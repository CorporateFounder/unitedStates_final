{"sender":"stExZb8ifLfnFoq4JJuTifpAcscegATH8znhwW26zyTa","customer":"LIBER16887e98f0e84969013fc56a015b49a00d9626f66691092d11e6f2101ce958f3","digitalDollar":0.0,"digitalStockBalance":0.0,"laws":{"packetLawName":"","laws":[],"hashLaw":""},"bonusForMiner":0.0,"voteEnum":"YES","sign":"MEUCICc7eHD0tVZ2owsq9CrpKtvSu8KMHyc336Q953Sj3HxtAiEA4hA6PNHZ1iMYpgUgfjUTkEifZa4fnMZWRr0x/dRpxQw="}
{"sender":"stExZb8ifLfnFoq4JJuTifpAcscegATH8znhwW26zyTa","customer":"LIBER16887e98f0e84969013fc56a015b49a00d9626f66691092d11e6f2101ce958f3","digitalDollar":0.0,"digitalStockBalance":0.0,"laws":{"packetLawName":"","laws":[],"hashLaw":""},"bonusForMiner":0.0,"voteEnum":"NO","sign":"MEYCIQC2tQGx5qYCXMHVa2uXDulD3xj0j4TABRTz8B36mzA14QIhAIK/HoUwyLe6hMOmcjgThkW1kJ9FsO761Cme1NCZ0fjb"}
{"sender":"stExZb8ifLfnFoq4JJuTifpAcscegATH8znhwW26zyTa","customer":"gjMoEkLZPwFKBbNKiFVHD3fSe2pwyHYbcGVD1W8WqR9B","digitalDollar":1.0,"digitalStockBalance":1.0,"laws":{"packetLawName":"","laws":[],"hashLaw":""},"bonusForMiner":1.0,"voteEnum":"YES","sign":"MEUCIQCUsxY8LNdcQJRr69YMyLkcinSmNvwTfKe3AwCHLe08jwIgQ6wU1eG81j11A4eyqnr6uh7r9N7t629ZS4rIhCHF924="}
{"sender":"stExZb8ifLfnFoq4JJuTifpAcscegATH8znhwW26zyTa","customer":"gjMoEkLZPwFKBbNKiFVHD3fSe2pwyHYbcGVD1W8WqR9B","digitalDollar":0.0,"digitalStockBalance":1.0,"laws":{"packetLawName":"","laws":[],"hashLaw":""},"bonusForMiner":0.0,"voteEnum":"NO","sign":"MEQCIBIhTRfjYFBkjWEflxZPcIQF1Qd756MuXe73F3lTK8QsAiA7XjJISvALZGY9Io++elpwLA30bh6zkxpm0UD9EeszpQ=="}
{"sender":"stExZb8ifLfnFoq4JJuTifpAcscegATH8znhwW26zyTa","customer":"gjMoEkLZPwFKBbNKiFVHD3fSe2pwyHYbcGVD1W8WqR9B","digitalDollar":5.0,"digitalStockBalance":2.0,"laws":{"packetLawName":"","laws":[],"hashLaw":""},"bonusForMiner":0.0,"voteEnum":"YES","sign":"MEYCIQCit/tHQ4ByUMdll/9nfeWGUztEcdyiTpxg6tcXVVVElgIhALG3RZGfGYMvOC71jBvcCCNWBFQ08wNCPvAHCbeubLZ4"}
{"sender":"stExZb8ifLfnFoq4JJuTifpAcscegATH8znhwW26zyTa","customer":"gjMoEkLZPwFKBbNKiFVHD3fSe2pwyHYbcGVD1W8WqR9B","digitalDollar":0.0,"digitalStockBalance":1.0,"laws":{"packetLawName":"","laws":[],"hashLaw":""},"bonusForMiner":5.0,"voteEnum":"NO","sign":"MEQCIHT3MH6YXkn2fmtXhkJ11IiBnpoILPzuqy02lXvip2IUAiBiVSyWeWrHyOWUTAwWi5BEBMS4pxzmyK4eQJ5Vvq+c0g=="}
{"sender":"stExZb8ifLfnFoq4JJuTifpAcscegATH8znhwW26zyTa","customer":"gjMoEkLZPwFKBbNKiFVHD3fSe2pwyHYbcGVD1W8WqR9B","digitalDollar":0.0,"digitalStockBalance":1.0,"laws":{"packetLawName":"","laws":[],"hashLaw":""},"bonusForMiner":0.0,"voteEnum":"NO","sign":"MEUCIQC6Y255qWYt36G71C2ICyHMxcsslPdVafL79x0t052qWAIgC6Cr9Q5R8WSBKNRzc3mqxuX6VvF4CpjX5BZulQtA2W0="}
{"sender":"stExZb8ifLfnFoq4JJuTifpAcscegATH8znhwW26zyTa","customer":"gjMoEkLZPwFKBbNKiFVHD3fSe2pwyHYbcGVD1W8WqR9B","digitalDollar":0.0,"digitalStockBalance":1.0,"laws":{"packetLawName":"","laws":[],"hashLaw":""},"bonusForMiner":15.0,"voteEnum":"NO","sign":"MEYCIQCAq1ocqSZ77n8kcpvO2UHUaSuF8CivtgY1HaLs/8X7vAIhAMn0RWdapi2UR74BTWDgNCSbEuGth6Lz6nZZ0AzMagDn"}
{"sender":"stExZb8ifLfnFoq4JJuTifpAcscegATH8znhwW26zyTa","customer":"LIBER489cd5a211fc67177e79a10a882120e3b3cb1cc90a053d40cd1ce4bda5f31f9a","digitalDollar":0.0,"digitalStockBalance":0.0,"laws":{"packetLawName":"","laws":[],"hashLaw":""},"bonusForMiner":0.0,"voteEnum":"NO","sign":"MEYCIQDS4sFvtRGXR65Hu0lhdzitpWOlZeglkNOAbNi7T/984wIhAL1uF0DWt33vqo2vi12hsJdP+gPiF2DoQ9exz9tirXS/"}
{"sender":"stExZb8ifLfnFoq4JJuTifpAcscegATH8znhwW26zyTa","customer":"LIBER38072b8b29e391554d90c407f2b7d17dba649c84c37cff46337d5b450b524d8a","digitalDollar":0.0,"digitalStockBalance":0.0,"laws":{"packetLawName":"","laws":[],"hashLaw":""},"bonusForMiner":0.0,"voteEnum":"NO","sign":"MEUCIDceiaLXyVReNB2UmMmQU41iaJvWAE/Dr99iIPTZZaTAAiEA0mRN+KezbrBFoC0x+lY49GjyrMYqxn6XbEz7Upcdd1I="}
{"sender":"stExZb8ifLfnFoq4JJuTifpAcscegATH8znhwW26zyTa","customer":"LIBER489cd5a211fc67177e79a10a882120e3b3cb1cc90a053d40cd1ce4bda5f31f9a","digitalDollar":0.0,"digitalStockBalance":0.0,"laws":{"packetLawName":"","laws":[],"hashLaw":""},"bonusForMiner":0.0,"voteEnum":"YES","sign":"MEQCIHv3WJ8vpfWpQRARt2lhU7ZiVqh6MnhrHN4CJN0HHPAZAiBUJ2aWL+RTbgBJg9hm3bXvc3EkchRxPFEj4T/5ADPIHQ=="}
{"sender":"stExZb8ifLfnFoq4JJuTifpAcscegATH8znhwW26zyTa","customer":"LIBER38072b8b29e391554d90c407f2b7d17dba649c84c37cff46337d5b450b524d8a","digitalDollar":0.0,"digitalStockBalance":0.0,"laws":{"packetLawName":"","laws":[],"hashLaw":""},"bonusForMiner":0.0,"voteEnum":"YES","sign":"MEUCIQDa+lbZKmRuDKgE+RL8hNzpwnjRaHJ/3Ne0q95662RkCwIgNTtzrgoCCGl4UoilNCGCHQn7GzIISdcx7NnQsVaE+YA="}
{"sender":"stExZb8ifLfnFoq4JJuTifpAcscegATH8znhwW26zyTa","customer":"LIBER489cd5a211fc67177e79a10a882120e3b3cb1cc90a053d40cd1ce4bda5f31f9a","digitalDollar":0.0,"digitalStockBalance":0.0,"laws":{"packetLawName":"","laws":[],"hashLaw":""},"bonusForMiner":0.0,"voteEnum":"NO","sign":"MEUCIQDfTtUc2L6Hx136oyuJhZyH/iQK1OAYb1rZ2/rJksv+PQIgXmJU+vdlFvr/MZVnI2gsXPJCrkZyM0A8eJuyQWQoHas="}
{"sender":"stExZb8ifLfnFoq4JJuTifpAcscegATH8znhwW26zyTa","customer":"LIBER38072b8b29e391554d90c407f2b7d17dba649c84c37cff46337d5b450b524d8a","digitalDollar":0.0,"digitalStockBalance":0.0,"laws":{"packetLawName":"","laws":[],"hashLaw":""},"bonusForMiner":0.0,"voteEnum":"YES","sign":"MEUCIHKmqq+sKZveQYeKbMyp8wYVfcIFKzopd7mU9W0AYaAbAiEAs20aBbIVkRse7pg8FmWm7shm6yo1jmVQwWXGkLpZG0c="}
{"sender":"stExZb8ifLfnFoq4JJuTifpAcscegATH8znhwW26zyTa","customer":"LIBER0018e1c46e0aa2af0852bfbd72d2743638cd2ca8158a1cba75a8433284ef5dbc","digitalDollar":0.0,"digitalStockBalance":0.0,"laws":{"packetLawName":"ORIGINAL_CHARTER_CURRENT_LAW_PACKAGE_NAME","laws":["POWERS_OF_THE_BOARD_OF_DIRECTORS Совет Директоров может утверждать счета, которые подали на должности из списка Directors (Назначает должность). Также Законы название пакетов начинаются с ADD_DIRECTOR, являются пакетами, которые содержать список новых директоров. Этот список должны управлять новыми линейками продукции.    Данные Законы может утверждать только Совет директоров и оттуда будет взять список законов, где  каждая строка которая начинается ADD_DIRECTOR, будет добавлена в список Directors в качестве новой должности. Список DIRECTORS которую можно подать.   Пакет, который начинается с BUDGET, является бюджетом и может его утвердить только Совет директоров Действующий бюджет может быть только один.              Совет директоров также утверждает стратегический план STRATEGIC_PLAN. Действующим может быть только  один стратегический план.                Совет директоров также участвует в утверждении законов (правил по которым должны действовать  все участники корпорации), а также участвует в утверждении внедрения поправок в устав AMENDMENT_TO_THE_CHARTER.              Совет имеет право устанавливать и собирать комиссию от продаж внутри платформ принадлежащих Корпорации Международного Торгового Союза, при условии что данная комиссия не будет выше двадцати процентов (20%). Все сборы должны быть направлены на расходы которые установлены бюджетом. Также источником дохода является продажа своих товаров и услуг, для этого есть Директора офисов которые избираются советом директоров и они должны реализовать продукцию Корпорации Международного Торгового Союза. ","HOW_LAWS_ARE_CHOSEN Ни один закон не имеет обратной силы. Ни один закон не должен нарушать действующий устав или противоречит  другим действующим законам. Если есть противотечение между несколькими законами из одного пакета законов, то действующим является тот который списке находится выше по индексу. Пример: пакет по продаже алкоголя  закон под индексом 3 противоречит закону из индекса 17, в даном случае закон под индексом три будет действующим, так как он более выше по статусу.             Если законы противоречат из разных пакетов, то действующим является тот пакет, который получил больше голосов от Совета акционеров, если есть паритет, то тот который получил больше голосов Совета Директоров, если и здесь  есть паритет то данный спор должен решить Верховный Судья, если он также не определил который из двух пакетов где законы противоречат друг другу является законы одно из пакетов более действующими, то в приоритете становиться   тот, который начал действовать раньше, отсчет определяется именно с последнего момента вступления в силу.              Все обычные законы являются действующими если за них проголосовали таким способом ONE_VOTE Совет Акционеров, Совет Директоров и возможно  Верховный Судья.   Чтобы закон был действующим он должен получить равно или больше 100 остатка голосов Совета Акционеров, равно или больше 15 остатка голосов Совета Директоров и Один голос Верховного Судьи, но если Верховный Судья не проголосовал или проголосовал против то можно обойти вето верховного судьи получив 200 и более остаток голосов Совета Акционеров и 30 и более остаток голосов Совета Директоров.             или если закон получил более 100 тысяч голосов остатка как описано VOTE_STOCK также является действующим, и будет действовать пока сохраняет больше сто тысяч голосов. Закон является действующим, пока он соответствует количеству голосов как описано выше. Каждый раз как кто-то теряет свою должность  также теряется все его голоса за все законы которые он проголосовал, но не теряются голоса полученные с помощью акций.","HOW_THE_BOARD_OF_DIRECTORS_IS_ELECTED Как избирается Совет Директоров.  Совет директоров состоит из 301 счетов BOARD_OF_DIRECTORS.  Каждый участник сети может подать на должность совета директоров, создав пакет закона, где  название пакета BOARD_OF_DIRECTORS и счет отправителя должен совпадать счетом который указан  в первой строке закона который содержится в списке данного пакета.  301 счет с наибольшим количеством остатка голосов получает должность.  Стоимость подачи на создание закона(должность) стоит пять цифровых долларов (5) в качестве вознаграждения добытчику.  Процесс голосования описан в VOTE_STOCK.","POWERS_OF_THE_BOARD_OF_SHAREHOLDERS Полномочия совета акционеров. Совет Акционеров Участвует в утверждении Законов (правил сети, которые должны соблюдать все участники данной Корпорации). Также Совет Акционеров участвует в утверждении поправок в устав Корпорации Международного Торгового Союза AMENDMENT_TO_THE_CHARTER. Совет Акционеров также может участвовать в голосовании при избрании кандидатов CORPORATE_COUNCIL_OF_REFEREES и BOARD_OF_DIRECTORS используя эти правила для голосования за кандидатов VOTE_STOCK.","HOW_SHAREHOLDERS_BOARD_IS_ELECTED OriginalCHARTER.HOW_SHAREHOLDERS_BOARD_IS_ELECTED: КАК ИЗБИРАЕТСЯ СОВЕТ АКЦИОНЕРОВ.  Совет Акционеров состоит из тысячи пятьсот счетов (1500) с наибольшим количеством акций, но учитываются только те счета от чьей активности не прошло больше года (Активностью считается майнинг или отправка денег, создание закона, отправка штрафов, Подача на должность и Создание новой должности). формула: текущий год - один год, и если счет был активен в этом диапазоне, он учитывается. Все счета сортируются по убыванию количества цифровых акций, и отбираются 1500 счетов с наибольшим количеством акций. Перерасчет происходит Каждый блок. Пример участка кода как избирается Совет Акционеров:  //определение совета акционеров     public static List<Account> findBoardOfShareholders(Map<String, Account> balances, List<Block> blocks, int limit) {         List<Block> minersHaveMoreStock = null;         if (blocks.size() > limit) {             minersHaveMoreStock = blocks.subList(blocks.size() - limit, blocks.size());         } else {             minersHaveMoreStock = blocks;         }         List<Account> boardAccounts = minersHaveMoreStock.stream().map(                         t -> new Account(t.getMinerAddress(), 0, 0))                 .collect(Collectors.toList());          for (Block block : minersHaveMoreStock) {             for (DtoTransaction dtoTransaction : block.getDtoTransactions()) {                 boardAccounts.add(new Account(dtoTransaction.getSender(), 0, 0));             }          }           CompareObject compareObject = new CompareObject();          List<Account> boardOfShareholders = balances.entrySet().stream()                 .filter(t -> boardAccounts.contains(t.getValue()))                 .map(t -> t.getValue()).collect(Collectors.toList());           boardOfShareholders = boardOfShareholders                 .stream()                 .filter(t -> !t.getAccount().startsWith(Seting.NAME_LAW_ADDRESS_START))                 .filter(t -> t.getDigitalStockBalance() > 0)                 .sorted(Comparator.comparing(Account::getDigitalStockBalance).reversed())                 .collect(Collectors.toList());          boardOfShareholders = boardOfShareholders                 .stream()                 .limit(Seting.BOARD_OF_SHAREHOLDERS)                 .collect(Collectors.toList());          return boardOfShareholders;     }","VOTE_STOCK Как с помощью акций происходит голосование. Все акции которым счет владеет, приравниваются такому же количеству голосов. каждый раз когда кто то делает транзакцию на счет, который является адресом пакета который начинается с LIBER он голосует за данный пакет. Учитываются только те голоса, с которых не прошло больше четырех лет. если транзакция была совершена VoteEnum.YES то данный счет получает голоса за по формуле yesV = количество голосов равные количеству акций отправителя. yesN = за сколько законов данный счет проголосовал с VoteEnum.YES resultYES = yesV / yesN). Пример: счет проголосовал за три счета которые начинаются с LIBER, на счету сто акций, значит сто голосов. 100 / 3 = 33.3 значит каждый счет получит по 33.3 голоса.              если транзакция была совершена с VoteEnum.NO то используется такая же формула, но учитываются теперь все счета за которые он проголосовал против пример тот же счет проголосовал за два счет против, у него те же сто акций. resultNO = noV / noN = 50 = 50 значит каждый счет за который он проголосовал, против получит 50 голосов против. дальше каждый счет подсчитывает и суммирует все отданные ему голоса ЗА (VoteEnum.YES) и ПРОТИВ (VoteEnum.NO). Потом используется данная формула remainder = resultYES - resultNO. сначала данные должности отбираются все счета которые получили больше или равно одного голосов остатка (0) remainder >= 1. Дальше все счета сортируются по убыванию remainder и оттуда отбираются то количество счетов на данные должности, сколько это оговорено в данной должности. Для Совета Директоров это 301 счет с наибольшим количеством остатка.              В любой момент можно изменить свой голос, но только на противоположный, что значит если вы проголосовали за кандидата YES то вы можете изменить только на NO и обратно. Количество раз сколько вы можете изменить свой голос не ограничено. С каждым блоком происходит перерасчет голосов, если вы теряете свои акции, ваши кандидаты также теряют свои голоса. Данная мера специально так реализовано чтобы избираемые должности были заинтересованы в том чтобы вы процветали. Таким способом избираются Только CORPORATE_COUNCIL_OF_REFEREES и BOARD_OF_DIRECTORS Учитывается только последняя транзакция отданная за каждый счет, если вы не обновляли свой голос, то по прошествии четырех лет он аннулируется. Для Утверждения Закона нужно 100 тысяч голосов.","CODE_VOTE_STOCK class CurrentLawVotes method: votesLaw  public double votesLaw(Map<String, Account> balances, Map<String, Integer> yesAverage, Map<String, Integer> noAverage) {      \t\tdouble yes = 0.0;                     double no = 0.0;                                                      for (String s : YES) {                                      int count = 1;                        count = yesAverage.get(s) > 0 ? yesAverage.get(s) : 1;                        yes += balances.get(s).getDigitalStockBalance() /count;                                  }                                for (String s : NO) {                         int count = 1;                         count = noAverage.get(s) > 0 ? noAverage.get(s) : 1;                        no += balances.get(s).getDigitalStockBalance() / count;                                 }                                              return yes - no;                 } ","POWERS_OF_THE_CABINET_OF_DIRECTORS Полномочия Кабинета Директоров.  Директорами кабинета, называются высшие директора которые являются директорами своих дивизионов.  Полномочия каждого директора должны быть описаны действующими законами. Но каждый директор должен управлять  только своим дивизионом (пример: MEDIA_DIRECTOR руководит сми и его полномочия распространяются только на сми). Координацией всех директоров должен руководить Генеральный Исполнительный Директор GENERAL_EXECUTIVE_DIRECTOR.  Совет Директоров, CORPORATE_COUNCIL_OF_REFEREES, HIGH_JUDGE, Совет Акционеров и GENERAL_EXECUTIVE_DIRECTOR могут быть как физическими лицами, так и юридическими лицами, но один счет будет учитываться как один голос. ","HOW_CABINET_DIRECTORS_ARE_CHOSEN Все Директора Кабинета, это высшие директора которые управляют своими дивизионами, избираются только Советом Директоров. Каждый участник сети может подать на должность высшего директора, создав закон, с названием пакета который совпадает с допустимыми должностями, где адрес отправителя данной транзакции должен совпадать с первой строкой из списка законов данного пакета.  Стоимость закона пять цифровых долларов в качестве вознаграждения добытчику.  Счет с наибольшим количеством голосов остатка получает данную должность.  Механизм голосования описан ONE_VOTE.  Чтобы быть избранным советом директоров, должность должна получить не меньше 15 голосов (остатка голосов).        \t\tПример участка кода как избирается должности class LawsController: method currentLaw:                           //позиции созданные советом директоров                     List<CurrentLawVotesEndBalance> createdByBoardOfDirectors = current.stream()                           .filter(t->t.getPackageName().startsWith(Seting.ADD_DIRECTOR))                           .filter(t->t.getVotesBoardOfDirectors() >= Seting.ORIGINAL_LIMIT_MIN_VOTE_BOARD_OF_DIRECTORS)                           .collect(Collectors.toList());                     //добавление позиций созданных советом директоров                    for (CurrentLawVotesEndBalance currentLawVotesEndBalance : createdByBoardOfDirectors) {                         directors.addAllByBoardOfDirectors(currentLawVotesEndBalance.getLaws());                     }                                  //позиции избираемые только советом директоров                     List<CurrentLawVotesEndBalance> electedByBoardOfDirectors = current.stream()                            .filter(t -> directors.isElectedByBoardOfDirectors(t.getPackageName()) || directors.isCabinets(t.getPackageName()))                            .filter(t -> t.getVotesBoardOfDirectors() >= Seting.ORIGINAL_LIMIT_MIN_VOTE_BOARD_OF_DIRECTORS)                            .sorted(Comparator.comparing(CurrentLawVotesEndBalance::getVotesBoardOfDirectors).reversed())                            .collect(Collectors.toList());","ONE_VOTE ОДИН ГОЛОС. Когда голосуют данные должности, учитывается как один счет = один голос  (CORPORATE_COUNCIL_OF_REFEREES-Совет Корпоративных Судей,  BOARD_OF_DIRECTORS-Совет Директоров, GENERAL_EXECUTIVE_DIRECTOR-Генеральный Исполнительный Директор, HIGH_JUDGE-Верховный Судья и Совет Акционеров).   Каждый счет который начинается с LIBER, учитывает все голоса ЗА (VoteEnum.YES) и ПРОТИВ (VoteEnum.NO) за него  дальше отнимается от ЗА - ПРОТИВ = если остатков выше порога, то он становиться действующим законом. Но если избирается должности,  то после сортируется от наибольшего к наименьшим и отбираются то количество наибольших, которое описано для данной должности.  Перерасчет голосов происходит каждый блок.               После голосования голос можно поменять только на противоположный.  Ограничений на количество сколько раз можно поменять свой голос нет. Учитываются только те голоса которые даны счетами  находящимися в своей должности, к примеру если счет перестал быть в Совете Директор, его голос как в качестве  Совета Директоров не учитывается, и не будет учитываться в голосовании. Все голоса действуют, пока счета  проголосовавшие находятся в своих должностях. Учитываются также только те голоса, от которых прошло не более  четырех лет, но каждый участник, может в любой момент времени обновить свой голос.  ","CODE_VOTE_ONE КОД class CurrentLawVotes: method voteGovernment             public int voteGovernment(                    Map<String, Account> balances,                       List<String> governments) {                        int yes = 0;                        int no = 0;                                List<String> addressGovernment = governments;                   for (String s : YES) {                         if (addressGovernment.contains(s)) {                             yes += Seting.VOTE_GOVERNMENT;                        }                                 }                     for (String s : NO) {                       if (addressGovernment.contains(s)) {                             no += Seting.VOTE_GOVERNMENT;                        }                     }                    return yes - no;                } ","MECHANISM_FOR_REDUCING_THE_NUMBER_OF_SHARES МЕХАНИЗМ СНИЖЕНИЯ КОЛИЧЕСТВА АКЦИЙ.  Ввод штрафов. Каждый раз когда один счет отправляет на другой счет цифровую акцию, но использует VoteEnum.NO, счет  цифровых акций получателя снижается на то количество которое отправил отправитель акций.  Пример счет А отправил на счет Б 100 цифровых акций с VoteEnum.NO, тогда счет А и счет Б оба теряют 100  цифровых акций.  Данная мера нужна чтобы был механизм снять с должности Совета акционеров и также позволяет снижать голоса  деструктивных счетов, так как количество голосов, равно количеству акций, при Избрании Совета Директоров и  при избрании CORPORATE_COUNCIL_OF_REFEREES.   Данный механизм действует только на цифровые акции и только в том случае, что отправитель отправил с знаком VoteEnum.NO.","WHO_HAS_THE_RIGHT_TO_CREATE_LAWS то имеет Права Создавать Законы. Создавать законы в криптовалюте Корпорации Международный Торговый Союз имеют права  все участники сети, которые имеют минимум пять цифровых долларов.  Для создания закона через механизм криптовалюты Корпорации Международного торгового Союза  Нужно внутри данной криптовалюты Создать объект класса Laws, где packetLawName - является названием пакета законов. List<String> laws - является списком законов, String hashLaw - является адресом данного пакета законов и начинается с LIBER.  Чтобы Закон попал в пул законов нужно создать транзакцию где получателем является hashLaw данного закона и вознаграждение  майнера равно пять цифровых доллара (5)  данной криптовалюты. После этого как закон попадет в блок, он окажется в пуле законов и за него можно будет голосовать.  Количество строк в пакете законов может быть столько, сколько понадобиться и нет никаких ограничений.","POWERS_OF_THE_CORPORATE_COUNCIL_OF_JUDGES ПОЛНОМОЧИЯ КОРПОРАТИВНОГО СОВЕТА СУДЕЙ. Утверждает Верховного судью. Участвует в голосовании внедрения поправок.            Судебная власть Корпорации Международного Торгового Союза принадлежит одному Верховному суду и таким нижестоящим судам, которые Корпорация Международный  Торговый Союз может время от времени издавать и учреждать.  Судьи как верховных, так и нижестоящих судов занимают свои должности, при хорошем поведении и в установленные сроки получают за свои услуги вознаграждение.  Вознаграждение должно даваться с бюджета, установленными законами. Судебная власть распространяется на все дела по закону и справедливости,  в том числе инициированные членами для оспаривания незаконного расходования средств,  возникающего в соответствии с настоящем Уставом, законами Корпорации Международного Торгового Союза и договорами,  заключенными или которые будут заключены в соответствии с их авторитетом. К спорам, в которых Международный Торговый Союз будут стороной к разногласиям между двумя или более участников сети.  Ни один суд не должен быть тайным, но правосудие должно вершиться открыто и бесплатно, полностью и безотлагательно,  и каждый человек должен иметь правовую защиту от вреда, причиненного жизни, свободе или имуществу. Верховный Суд CORPORATE_COUNCIL_OF_REFEREES и верховный судья HIGH_JUDGE.","HOW_THE_CORPORATE_BOARD_OF_JUDGES_IS_ELECTED КАК ИЗБИРАЮТСЯ КОРПОРАТИВНЫЙ СОВЕТ СУДЕЙ.              CORPORATE_COUNCIL_OF_REFEREES состоит из 55 счетов. Каждый участник сети может подать на должность CORPORATE_COUNCIL_OF_REFEREES, создав пакет закона, где название пакета CORPORATE_COUNCIL_OF_REFEREES и счет отправителя должен совпадать счетом который указан в первой строке закона который содержится в списке данного пакета 55 счет с наибольшим количеством остатка голосов получает должность.              Стоимость подачи на создание закона(должность) стоит пять цифровых долларов (5) в качестве вознаграждения добытчику. Процесс голосования описан в VOTE_STOCK.                            Пример участка кода: class LawsController: method currentLaw:               //минимальное значение количество положительных голосов для того чтобы закон действовал,                  //позиции избираемые акциями CORPORATE_COUNCIL_OF_REFEREES                    List<CurrentLawVotesEndBalance> electedByStockCorporateCouncilOfReferees = current.stream()                             .filter(t -> directors.isElectedByStocks(t.getPackageName()))                             .filter(t -> t.getPackageName().equals(NamePOSITION.CORPORATE_COUNCIL_OF_REFEREES.toString()))                             .filter(t -> t.getVotes() >= Seting.ORIGINAL_LIMIT_MIN_VOTE)                             .sorted(Comparator.comparing(CurrentLawVotesEndBalance::getVotes).reversed())                             .limit(directors.getDirector(NamePOSITION.CORPORATE_COUNCIL_OF_REFEREES.toString()).getCount())                             .collect(Collectors.toList());","HOW_THE_CHIEF_JUDGE_IS_CHOSEN КАК ИЗБИРАЕТСЯ ВЕРХОВНЫЙ СУДЬЯ HIGH_JUDGE. Верховный Судья избирается CORPORATE_COUNCIL_OF_REFEREES.  Каждый участник сети может подать на должность Верховного Судьи, создав закон, с названием пакета который совпадает с допустимым  должностью, где адрес отправителя данной транзакции должен совпадать с первой строкой из списка законов данного пакета.  стоимость закона пять цифровых долларов в качестве вознаграждения добытчику.   счет с наибольшим количеством голосов остатка получает данную должность. Механизм голосования описан ONE_VOTE.                           Пример кода как утверждается верховный судья. class LawsController: method currentLaw. Участок кода                //позиции избираемые советом корпоративных верховных судей                     List<CurrentLawVotesEndBalance> electedByCorporateCouncilOfReferees = current.stream()                             .filter(t -> directors.isElectedBYCorporateCouncilOfReferees(t.getPackageName()))                             .filter(t -> t.getVotesCorporateCouncilOfReferees() >= Seting.ORIGINAL_LIMIT_MIN_VOTE_CORPORATE_COUNCIL_OF_REFEREES)                             .sorted(Comparator.comparing(CurrentLawVotesEndBalance::getVotesCorporateCouncilOfReferees)).collect(Collectors.toList());","POWERS_OF_THE_CHIEF_JUDGE ПОЛНОМОЧИЯ ВЕРХОВНОГО СУДЬИ. Верховный судья участвует в утверждении законов, а также  может участвовать в решении споров внутри членов сети, как и CORPORATE_COUNCIL_OF_REFEREES,  но его голос выше чем голос CORPORATE_COUNCIL_OF_REFEREES.","HOW_IS_THE_PROCESS_OF_AMENDING_THE_CHARTER КАК ПРОИСХОДИТ ПРОЦЕСС ВНЕСЕНИЯ ПОПРАВОК В УСТАВ. Для внесения поправок, нужно создать закон с названием пакета AMENDMENT_TO_THE_CHARTER,  дальше за этот закон должны проголосовать методом описанным в VOTE_ONE Совет Акционеров и остаток голосов должен быть равен или выше 300 участников, также должны проголосовать Совет Директоров и остаток голосов должен быть 60 или больше,  также должны проголосовать корпоративные верховные судьи (CORPORATE_COUNCIL_OF_REFEREES) и остаток голосов должен быть равен или больше 5. Но поправки не должны касаться способа установления правил действующих законов, а также  избрания Совета Директоров, Совета Акционеров, Генерального Исполнительного Директора,  Совета Корпоративных Судей и Верховного Судьи. Поправки могут изменять код, если сохраняются правила избрания действующих должностей (включая правил голосования), законов и добычи денег (добыча цифровых долларов и цифровых акции), Ни одна поправка не должна наделять из выше перечисленных должностей большей властью. Также поправки не должны ущемлять Естественные Права Человека.              \t\t Пример кода. class LawsController: method currentLaw: участок кода утверждающий действующие поправки             //внедрение поправок в устав                     List<CurrentLawVotesEndBalance> chapter_amendment = current.stream()                             .filter(t -> !directors.contains(t.getPackageName()))                             .filter(t-> Seting.AMENDMENT_TO_THE_CHARTER.equals(t.getPackageName()))                             .filter(t->!directors.isCabinets(t.getPackageName()))                             .filter(t -> t.getVotesBoardOfShareholders() >= Seting.ORIGINAL_LIMIT_MINT_VOTE_BOARD_OF_SHAREHOLDERS_AMENDMENT)                             .filter(t -> t.getVotesBoardOfDirectors() >= Seting.ORIGINAL_LIMIT_MIN_VOTE_BOARD_OF_DIRECTORS_AMENDMENT)                             .filter(t -> t.getVotesCorporateCouncilOfReferees() >= Seting.ORIGINAL_LIMIT_MIN_VOTE_CORPORATE_COUNCIL_OF_REFEREES_AMENDMENT)                             .sorted(Comparator.comparing(CurrentLawVotesEndBalance::getVotesBoardOfDirectors).reversed()).collect(Collectors.toList());","HOW_THE_BUDGET_IS_APPROVED КАК УТВЕРЖДАЕТСЯ БЮДЖЕТ.  Действующий бюджет может быть только один. Бюджет утверждает только Совет Директоров.  Для утверждения бюджета нужно получить методом описанным в VOTE_ONE 15 и больше голосов.  Сам процесс происходит так: 1. Сначала отбираются все пакеты законов, где название пакета совпадает с BUDGET.  2. Дальше отбираются все пакеты которые остаток голосов получили 15 или больше.  3. Дальше все эти пакеты сортируются по убыванию, с наибольшим количеством голосов.  4. Дальше отбирается самый первый с наибольшим количеством голосов.                           Пример кода утверждающий бюджет. class LawsController: method: currentLaw.                 //бюджет утверждается только советом директоров.                     List<CurrentLawVotesEndBalance> budjet = current.stream()                             .filter(t-> !directors.contains(t.getPackageName()))                             .filter(t->Seting.BUDGET.equals(t.getPackageName()))                             .filter(t->!directors.isCabinets(t.getPackageName()))                             .filter(t-> t.getVotesBoardOfDirectors() >= Seting.ORIGINAL_LIMIT_MIN_VOTE_BOARD_OF_DIRECTORS)                             .sorted(Comparator.comparing(CurrentLawVotesEndBalance::getVotesBoardOfDirectors).reversed())                             .limit(1)                             .collect(Collectors.toList());","HOW_IS_THE_STRATEGIC Стратегический план утверждает Совет Директоров, стратегический план может быть действующим  только в единственном экземпляре. Чтобы Стратегический План был действующим, нужно остаток голосов  Совета Директоров 15 или больше. Способ голосования VOTE_ONE.               Совет Директоров в любой момент может отменить Стратегический План. Стратегический План действует  пока количество голосов 15 или больше. Стратегический План может включать в себя общее направление  Корпорации, а также что нужно реализовать.               Участок кода который показывает как утверждается Стратегический План.    \t\tclass LawsController: method currentLaw:                                  //план утверждается только палатой Советом Директоров                     List<CurrentLawVotesEndBalance> planFourYears = current.stream()                             .filter(t->!directors.contains(t.getPackageName()))                             .filter(t->Seting.STRATEGIC_PLAN.equals(t.getPackageName()))                             .filter(t->!directors.isCabinets(t.getPackageName()))                             .filter(t->t.getVotesBoardOfDirectors() >= Seting.ORIGINAL_LIMIT_MIN_VOTE_BOARD_OF_DIRECTORS)                             .sorted(Comparator.comparing(CurrentLawVotesEndBalance::getVotesBoardOfDirectors).reversed())                             .limit(1)                             .collect(Collectors.toList());","HOW_NEW_POSITIONS_ARE_ADDED Таким способом добавляются только высшее руководство, подчиненные каждого руководителя  нанимают без использования блокчейна, их может нанять сам директор, или иным способом как  описано действующими законами. Высшее руководство добавляется в список class Directors.  Все новые добавленные должности действуют пока их законы, которые создают, данные должности действуют.               Добавлять новые должности может только Совет директоров.  Каждый пакет законов который начинается с ADD_DIRECTOR, определяется как добавление должности. Список законов который находиться внутри данного пакета являются должностями если название в  строке начинается с ADD_DIRECTOR.              Пример: название пакета ADD_DIRECTOR_PACKAGE название первой третьей и четвертой строки ADD_DIRECTOR_FIRST ADD_DIRECTOR_THIRD  ADD_DIRECTOR_FOUR таким образом будет созданы три места для должности.               Но если строка начинается с ADD_DIRECTOR, то название должности должно быть большими  буквами и нижними подчеркиваниями, так же в одной строке должна быть только одна должность  и больше никаких слов.              Те строки, где нет добавления должности (ADD_DIRECTOR), используются для описания  полномочий добавленных должностей.               Чтобы новые должности были добавлены в список, Совет Директоров должен проголосовать методом  VOTE_ONE 15 или больше голосов.  После как новые должности будут созданы, каждый участник сети сможет подавать себя на данные должности.              class LawsController: method currentLaw:                                                //добавляет законы, которые создают новые должности директоров                     List<CurrentLawVotesEndBalance> addDirectors = current.stream()                            .filter(t->t.getPackageName().startsWith(Seting.ADD_DIRECTOR))                            .filter(t->t.getVotesBoardOfDirectors() >= Seting.ORIGINAL_LIMIT_MIN_VOTE_BOARD_OF_DIRECTORS)                            .collect(Collectors.toList());","PROPERTY_OF_THE_CORPORATION СОБСТВЕННОСТЬ КОРПОРАЦИИ. Вся собственность которая принадлежит Корпорации Международного Торгового Союза, не может быть продана без действующего закона,  где будет описан процесс продажи и по какой стоимости будет продана собственность. Счет основателя, и счета других участников не является счетом корпорации, Совет Директоров должен создать отдельный счет который будет бюджетом и управляться только членами действующих членов Совета Директоров.","INTERNET_STORE_DIRECTOR Директор интернет магазина Данный директор занимается разработкой, продвижением и руководством интернет магазина, в котором должны  продаваться товары за цифровой доллар или цифровые акции.  Детальные полномочия должны быть даны или через действующие законы или  выданы Генеральным исполнительным директором или Советом Директоров.  Название Магазина должен определить либо Совет Директоров или Генеральный Исполнительный Директор.","GENERAL_EXECUTIVE_DIRECTOR Генеральный Исполнительный директор Данный Директор координирует действия остальных высших директоров для реализации стратегического плана или  поставленных перед ним задач действующими законами.  Все полномочия должны быть ему выданы через действующие законы.  Это самая высокая должность избираемая Корпорацией и является по своей сути аналогом премьер-министра.","DIRECTOR_OF_THE_DIGITAL_EXCHANGE Директор Цифровой биржи Данный Директор занимается разработкой, продвижением и руководством интернет биржи. Полномочия должны быть выданы ему или действующими законами,  или Советом Директоров, или Генеральным Исполнительным Директором.","DIRECTOR_OF_DIGITAL_BANK Директор Цифрового  банка Данный Директор руководит интернет банком. Все полномочия должны быть выданы  или действующими законами, или Советом директоров, или Генеральным Исполнительным Директором.","DIRECTOR_OF_THE_COMMERCIAL_COURT Директор частного коммерческого суда  Должен обеспечивать руководство частным судам, все полномочия  должны быть Выданы или действующими законами, или Советом Директоров,  или Генеральным Исполнительным Директором.   В данных судах судьями могут быть как члены Совета Верховных Судей (CORPORATE_COUNCIL_OF_REFEREES) так и Верховный Судья, или ниже стоящие судьи избранные CORPORATE_COUNCIL_OF_REFEREES. ","MEDIA_DIRECTOR Директор СМИ Данный Директор руководит СМИ, все полномочия должны быть выданы действующими законами,  или, Советом Директоров или генеральным исполнительным Директором.              Данный Директор занимается руководством СМИ принадлежащих непосредственно Корпорации Международного Торгового Союза. ","DIRECTOR_OF_THE_DEVELOPMENT_OF_THE_IMPLEMENTATION_OF_CRYPTOCURRENCY_TECHNOLOGIES_OF_THE_INTERNATIONAL_TRADE_UNION_CORPORATION  Данный Директор руководит разработкой и внедрением нового кода в данную криптовалюту, все полномочия должны быть выданы только через  действующие законы, но также могут быть выданы или Советом Директоров, если действующие законы дали такие полномочия Совету Директоров.  Также ни одно изменение кода не должно противоречить действующему уставу или действующим законам, Также полномочия могут быть выданы Генеральным Исполнительным Директором, если генеральному исполнительному директору данные полномочия выданы действующим законами.","EXPLANATION_WHY_MONEY_DEMURAGE_IS_USED_HERE ОБЯСНЕНИЕ ПОЧЕМУ ЗДЕСЬ ИСПОЛЬЗУЕТСЯ  ДЕМЕРЕДЖ ДЕНЕГ Отрицательная ставка сейчас применяется во множестве стран, данная мера стимулирует держателей денег, когда цена чрезмерно завышена,  насыщать рынок деньгами. Количество добываемых денег за каждый блок составляет 200 цифровых долларов и 200 цифровых акций,  также 2% от каждой добычи вознаграждение основателю, что составляет 4 цифровых доллара и 4 цифровых Акций при каждой добыче блока.  Здесь используется как Теории Сильвио Гезеля, а также школы монетаризма в измененном виде.              У Сильвио Гезеля, отрицательная ставка составляла 1% в месяц, что просто убило бы экономику, при монетаризме рост, денежной массы должен был быть пропорционален росту ВВП, но так как в данной системе не получиться посчитать реальный рост ВВП, я установил фиксированный рост, также если денежный рост  будет равен ВВП, есть высокая вероятность Гиперинфляции, так как ВВП не всегда отражает реальный экономический рост.  Деньги должны быть твердые, чтобы бизнес мог прогнозировать свои долгосрочные вложения и от монетаризма, взята только та часть что  денежная масса должна расти линейно, но в целом здесь микс из разных экономических школ, включая Австрийскую экономическую школу.               При отрицательной ставке 0.1% каждые пол года для цифровых долларов и 0.2% для цифровых акций мы избегаем последствий тяжелого экономического кризиса для данной валюты.               Такой механизм создает коридор цен, где нижняя граница стоимости данных цифровых валют является общее количество выпущенных цифровых  долларов и цифровых акций, а верхняя граница является реальная стоимость. Так как только стоимость становиться выше реальной стоимости,  держателям выгодней становиться продавать цифровые доллары и цифровые акции, по завышенным ценам, тем самым насыщая рынок деньгами  и создавая коррекцию на рынке.               Основным источником монетарных кризисов, является быстрыми изменениями цен на товары и медленным изменением заработных плат.  Пример: Представим что стоимость валюты резко подорожало на 30%, держателям выгодней становиться не инвестировать деньги, так как  доходы от удерживания валюты, выше чем теперь уже оплачивать более дорогих сотрудников, из-за того деньги перестают  инвестироваться. Люди не дополучают заработные платы, что приводит к тому, что огромное количество товаров не реализуется,  и это приводит к тому, часть производителей банкротится и увольняют множество рабочих, что еще больше снижает заработную  плату у оставшихся, так как становиться профицитный рынок труда.         Что в свою очередь еще больше вызывает страх у держателей денег инвестировать и данный процесс продолжается до того момента,  пока стоимость денег не начинает сокращаться в связи с тем что общее количество производственных цепочек сократилось и также сократились товары.              Пример: Представим что у нас произошла инфляция и стоимость денег упала на 40% в течение месяца, стоимость товаров резко возрастает, но заработные платы не выросли, таким образом множество товаров не будут куплены, что приводит к закрытию производственных цепочек, что в свою очередь из-за избытка рабочих на рынке труда, снижает заработную плату, что также в свою очередь еще больше сокращает  количество проданных товаров. Первый случай Дефляционная спираль возникает из-за резкого сокращения денег на рынке, второй  случай стагфляция чаще возникает когда на рынок поступает резко избыточное количество денег.  И это оба явления две стороны одной медали, в одном случае мы получаем дефляционную спираль в другом стагфляцию.                         Чтобы не возникали такие кризисы, в данной криптовалюте деньги прирастают в одинаковом предсказуемом количестве.  204 (4 - вознаграждение основателю, 200 - вознаграждение добытчику) цифровых долларов и акций за блок, в сутках около 576 блоков. А отрицательная ставка корректирует стоимость монет каждые пол года.  Также запрещено использовать частичное банковское резервирование для данных монет, так как их количество растет линейно, и  не сможет покрыть долги возникшие из-за частичного банковского резервирования, в связи отсутствия с недостатком  наличности, так как при частичном банковском резервировании рост долгов будет намного выше, чем данный протокол будет создавать денег.   Также если увеличить денежную массу изменив настройки, и сделав прирост денежной массы значительно выше, может вызвать гиперинфляцию или  даже галопирующую инфляцию. Если нужно будет увеличить прирост денежной массы это должно происходить только через внесения поправок, сохраняя процент вознаграждения основателя в двух процентах. И добыча за блок не должна увеличиваться больше 5% в течение десяти лет, каждое следующее увеличение которое может вноситься должно проходить не менее десяти лет через поправки,  и не более 5% за блок от вознаграждения последнего блока. (Пример: если мы изменили через поправки, то добыча не должна быть выше 210 монет, но каждые следующие будет не больше пяти процентов от последнего.  Таким образом следующее увеличение внесенное через поправки составит 220.5 монет. Но Эту поправку внесут только через десять лет после первой поправки по изменению добычи)              При недостатке денежной массы, если не было изменено количество добываемых монет через поправку, можно добавить несколько  дополнительных нулей после запятой, таким образом это просто увеличит ценность монет, без увелечения общей выпущенной денежной массы.              Отрицательные ставки не должны быть выше 0.5% годовых и ниже 0.2% годовых. Отрицательные ставки можно изменять только через внесения поправок.","FREEDOM_OF_SPEECH Ни один орган данной корпорации или субъект не должен запрещать свободное исповедание  какой-либо религии; или ограничивать свободу слова, совести или печати или право людей мирно собираться или объединяться друг с другом, или не объединяться друг с другом, и  обращаться к руководству Корпорации Международного Торгового Союза и к данной корпорации с ходатайством об удовлетворении жалоб;  или нарушать право на плоды своего труда или право на мирную жизнь по своему выбору.  Свободы слова и совести включают свободу вносить вклад в политические кампании или кандидатуры на корпоративные должности и должны толковаться как  распространяющиеся в равной степени на любые средства коммуникации.","RIGHTS Естественные Права Все члены сети, должны соблюдать Естественные Права Человека и не нарушать их.  Также должно соблюдаться презумпция невиновности и каждый участник сети должен иметь права на честное независимое  судебное разбирательство.  Каждый участник имеет права на адвоката или быть самому себе адвокатом.              Корпорация Международный Торговый Союз не должна регулировать стоимость товаров и услуг участников сети, которые  продают через данную платформу. Также Корпорация не должна запрещать отдельные бренды на своей площадке, но может  запрещать продавать целые группы товаров, которые попадают по характеристикам описанных действующими законами, если  этот запрет не нарушает Естественные Права Человека. В качестве источника прав можно брать  в качестве прецедента Страны признанные демократическими странами.                Детальный список есть в Организации Объединенных Наций (ООН)              Право на жизнь Право на свободу и личную неприкосновенность Право на неприкосновенность частной жизни Право определять и указывать свою национальную принадлежность Право на пользование родным языком Право на свободу передвижения и выбора места пребывания и жительства Право на свободу совести              Свобода мысли и слова Свобода информации Право на создание общественных объединений Право на проведение публичных мероприятий Право на участие в управлении делами Корпорации Международного Торгового Союза Право на обращение в органы Корпорации Международного Торгового Союза и органы местного самоуправления. К числу естественных неотчуждаемых прав человека относят право на жизнь, свободу, безопасность, собственность, физическую и психическую неприкосновенность, достоинство личности, личную и семейную тайну и т. п.              Ни один действующий закон не должен интерпретироваться так, чтобы нарушать естественные права человека.  Корпоративный верховный суд может использовать прецеденты в качестве судебных решений, если эти решения не противоречат  действующему уставу и действующим законам. Корпоративный Верховный Суд может создавать прецеденты аналогичные странам с прецедентным правом, но применять можно если эти прецеденты не нарушают действующий устав или действующие законы Корпорации Международного Торгового Союза. ","POWERS_OF_THE_BOARD_OF_DIRECTORS The Board of Directors can approve invoices that have applied for positions on the Directors list. Also Laws package names start with ADD_DIRECTOR, are packages that contain a list of new directors. This list should drive new product lines.   These Laws can only be approved by the Board of Directors and from there they will take a list of laws where every line that starts with ADD_DIRECTOR will be added to the Directors list as a new line positions. List of DIRECTORS that can be filed.  A package that starts with BUDGET is a budget and can only be approved by the Board of Directors There can be only one current budget.              The Board of Directors also approves the STRATEGIC_PLAN. Only valid one strategic plan.              The board of directors also participates in the approval of laws (rules on which all members of the corporation), and also participates in the approval of the implementation of amendments to the charter AMENDMENT_TO_THE_CHARTER.              The Council has the right to set and collect a commission from sales within the platforms owned by the Corporation of the International Trade Union, provided that this commission will not exceed twenty percent (20%). All fees must be allocated to expenses that are established by the budget. Also, a source of income is the sale of their goods and services, for this there are Office Directors who are elected Board of Directors and they must sell the products of the Corporation of the International Trade Union.","HOW_LAWS_ARE_CHOSEN No laws are retroactive. No law shall violate the existing statute or be inconsistent with other applicable laws. If there is a contradiction between several laws from one set of laws, then the current one is the one that is higher in the index. Example: alcohol sales package the law under index 3 contradicts the law from index 17, in this case the law under index three will be valid, because he is higher in status.            If the laws contradict from different packages, then the package that received the most votes is valid. from the Board of Shareholders, if there is parity, then the one that received more votes from the Board of Directors, if here too there is parity, then the dispute must be decided by the Chief Justice, if he also did not determine which of the two packages where the laws contradict each other, if the laws of one of the packages are more effective, then the priority becomes the one that began to operate earlier, the countdown is determined precisely from the last moment of entry into force.             All ordinary laws are valid if they are voted in this way ONE_VOTE The Board of Shareholders, the Board of Directors and possibly Supreme Judge.  For a law to be valid, it must receive equal to or more than 100 of the remaining votes of the Board of Shareholders, equal to or greater than 15 remaining votes of the Board of Directors and One vote of the Chief Justice, but if the Chief Justice did not vote or voted against then it is possible to override the veto of the supreme judge by obtaining 200 or more of the remainder of the votes of the Board of Shareholders and 30 or more of the remainder of the votes of the Board of Directors.             or if the law received more than 100 thousand remainder votes as described by VOTE_STOCK is also in force, and will act while retaining more than one hundred thousand votes. A law is valid as long as it matches the number of votes as described above. Every time someone loses their position all his votes for all the laws he voted are also lost, but the votes received with the help of shares are not lost.","HOW_THE_BOARD_OF_DIRECTORS_IS_ELECTED How the Board of Directors is elected.  The Board of Directors consists of 301 BOARD_OF_DIRECTORS accounts. Each member of the network can apply for the position of the board of directors by creating a package of law, where the package name BOARD_OF_DIRECTORS and the sender's account must match the account specified in the first line of the law which is contained in the list of this package. The 301 account with the most remaining votes receives the position. The cost of filing for the creation of a law (position) is worth five digital dollars (5) as a reward to the earner. The voting process is described in VOTE_STOCK.","POWERS_OF_THE_BOARD_OF_SHAREHOLDERS Powers of the board of shareholders. The Council of Shareholders Participates in the approval of the Laws (network rules that all members of this Corporation must comply with). The Council of Shareholders also participates in the approval of amendments to the charter of the Corporation of the International Trade Union AMENDMENT_TO_THE_CHARTER. The Council of Shareholders can also participate in voting when electing candidates CORPORATE_COUNCIL_OF_REFEREES and BOARD_OF_DIRECTORS using these rules for voting for VOTE_STOCK candidates.","HOW_SHAREHOLDERS_BOARD_IS_ELECTED OriginalCHARTER.HOW_SHAREHOLDERS_BOARD_IS_ELECTED: HOW SHAREHOLDERS ARE ELECTED. The Board of Shareholders consists of one thousand five hundred accounts (1500) with the largest number of shares, but only those accounts are taken into account from whose activity more than a year has not passed (Activity is mining or sending money, creating a law, sending fines, Applying for a position and Creating a new position). formula: the current year is one year, and if the account was active in this range, it is taken into account. All accounts are sorted in descending order of the number of digital shares, and 1500 accounts with the most shares are selected. Recalculation occurs every block. An example of a section of code how the Board of Shareholders is elected:  //determining the board of shareholders      public static List<Account> findBoardOfShareholders(Map<String, Account> balances, List<Block> blocks, int limit) {          List<Block> minersHaveMoreStock = null;          if (blocks.size() > limit) {              minersHaveMoreStock = blocks.subList(blocks.size() - limit, blocks.size());          } else {              minersHaveMoreStock = blocks;          }          List<Account> boardAccounts = minersHaveMoreStock.stream().map(                          t -> new Account(t.getMinerAddress(), 0, 0))                  .collect(Collectors.toList());           for (Block block : minersHaveMoreStock) {              for (DtoTransaction dtoTransaction : block.getDtoTransactions()) {                  boardAccounts.add(new Account(dtoTransaction.getSender(), 0, 0));              }           }            CompareObject compareObject = new CompareObject();           List<Account> boardOfShareholders = balances.entrySet().stream()                  .filter(t -> boardAccounts.contains(t.getValue()))                  .map(t -> t.getValue()).collect(Collectors.toList());            boardOfShareholders = boardOfShareholders                  .stream()                  .filter(t -> !t.getAccount().startsWith(Seting.NAME_LAW_ADDRESS_START))                  .filter(t -> t.getDigitalStockBalance() > 0)                  .sorted(Comparator.comparing(Account::getDigitalStockBalance).reversed())                  .collect(Collectors.toList());           boardOfShareholders = boardOfShareholders                  .stream()                  .limit(Setting.BOARD_OF_SHAREHOLDERS)                  .collect(Collectors.toList());           return boardOfShareholders;      }","VOTE_STOCK How shares are voted. All shares held by the account are equal to the same number of votes. every time someone makes a transaction to an account that is the address of a batch that starts with LIBER, they vote for that batch. Only those votes from which no more than four years have passed are taken into account. if the transaction was made VoteEnum.YES then this account receives votes for according to the formula yesV = number of votes equal to the number of shares of the sender. yesN = how many laws this account voted for with VoteEnum.YES resultYES = yesV / yesN). Example: an account voted for three accounts that start with LIBER, there are 100 shares in the account, which means 100 votes. 100 / 3 = 33.3 means each account will receive 33.3 votes.              if the transaction was made with VoteEnum.NO then the same formula is used, but now all accounts for which he voted against are taken into account. example, the same account voted for two against, he has the same one hundred shares. resultNO = noV / noN = 50 = 50 means every bill he voted against will get 50 votes against. then each score counts and sums up all votes given to it FOR (VoteEnum.YES) and AGAINST (VoteEnum.NO). Then this formula is used remainder = resultYES - resultNO. first, these positions are selected all accounts that received more than or equal to one vote of the remainder (0) remainder >= 1. Then all accounts are sorted in descending order by remainder and from there the number of accounts for these positions is selected, as specified in this position. For the Board of Directors, this is the 301 accounts with the most balances.              At any time, you can change your vote, but only to the opposite, which means if you voted for a YES candidate, you can only change to NO and vice versa. The number of times you can change your voice is not limited. With each block there is a recalculation of votes, if you lose your shares, your candidates also lose their votes. This measure is specifically implemented so that the elected positions are interested in you to prosper. Only CORPORATE_COUNCIL_OF_REFEREES and BOARD_OF_DIRECTORS are elected in this way. Only the last transaction given for each account is taken into account, if you have not renewed your vote, then after four years it will be canceled. 100,000 votes are needed to approve the Law.","CODE_VOTE_STOCK class CurrentLawVotes method: votesLaw public double votesLaw(Map<String, Account> balances, Map<String, Integer> yesAverage, Map<String, Integer> noAverage) {       double yes = 0.0;                      double no = 0.0;                                                       for (String s : YES) {                                       int count = 1;                         count = yesAverage.get(s) > 0 ? yesAverage.get(s) : 1;                         yes += balances.get(s).getDigitalStockBalance() /count;                                   }                                 for (String s : NO) {                          int count = 1;                          count = noAverage.get(s) > 0 ? noAverage.get(s) : 1;                         no += balances.get(s).getDigitalStockBalance() / count;                                  }                                               return yes - no;                  }","POWERS_OF_THE_CABINET_OF_DIRECTORS Powers of the Cabinet of Directors. Cabinet directors are senior directors who are directors of their divisions. The powers of each director must be described by applicable law. But every director must manage only its own division (example: MEDIA_DIRECTOR manages the media and its powers apply only to the media). The coordination of all directors must be led by the General Executive Director GENERAL_EXECUTIVE_DIRECTOR.  Board of Directors, CORPORATE_COUNCIL_OF_REFEREES, HIGH_JUDGE, Board of Shareholders and GENERAL_EXECUTIVE_DIRECTOR can be either individuals and legal entities, but one account will be counted as one vote.","HOW_CABINET_DIRECTORS_ARE_CHOSEN All Cabinet Directors are the top directors who manage their divisions, elected only by the Board of Directors. Each member of the network can apply for the position of supreme director by creating a law with a package name that matches the allowed positions, where the address of the sender of this transaction must match the first line from the list of laws of this package. The cost of the law is five digital dollars as a reward to the earner. The account with the most remaining votes receives the position. The voting mechanism is described by ONE_VOTE. To be elected by the board of directors, a position must receive at least 15 votes (the remainder of the votes).        An example of a code section of how positions are elected class LawsController: method currentLaw:                            //positions created by the board of directors                      List<CurrentLawVotesEndBalance> createdByBoardOfDirectors = current.stream()                            .filter(t->t.getPackageName().startsWith(Seting.ADD_DIRECTOR))                            .filter(t->t.getVotesBoardOfDirectors() >= Seting.ORIGINAL_LIMIT_MIN_VOTE_BOARD_OF_DIRECTORS)                            .collect(Collectors.toList());                      //adding positions created by the board of directors                     for (CurrentLawVotesEndBalance currentLawVotesEndBalance : createdByBoardOfDirectors) {                          directors.addAllByBoardOfDirectors(currentLawVotesEndBalance.getLaws());                      }                                   //positions elected only by the board of directors                      List<CurrentLawVotesEndBalance> electedByBoardOfDirectors = current.stream()                             .filter(t -> directors.isElectedByBoardOfDirectors(t.getPackageName()) || directors.isCabinets(t.getPackageName()))                             .filter(t -> t.getVotesBoardOfDirectors() >= Seting.ORIGINAL_LIMIT_MIN_VOTE_BOARD_OF_DIRECTORS)                             .sorted(Comparator.comparing(CurrentLawVotesEndBalance::getVotesBoardOfDirectors).reversed())                             .collect(Collectors.toList());","ONE_VOTE ONE VOTE. When these positions are voted count as one score = one vote (CORPORATE_COUNCIL_OF_REFEREES-Council of Corporate Judges, BOARD_OF_DIRECTORS-Board of Directors, GENERAL_EXECUTIVE_DIRECTOR-General Executive Director, HIGH_JUDGE - Supreme Judge and Board of Shareholders).  Each score that starts with LIBER counts all votes FOR (VoteEnum.YES) and AGAINST (VoteEnum.NO) for it further deducted from FOR - AGAINST = if the balances are above the threshold, then it becomes the current law. But if a position is elected, then after that it is sorted from largest to smallest and the largest number that is described for this position is selected. Recalculation of votes occurs every block.              After voting, the vote can only be changed to the opposite one. There is no limit on the number of times you can change your voice. Only those votes that are given by accounts are taken into account in office, for example, if the account ceases to be on the Board of Directors, his vote as The Board of Directors does not, and will not, count in voting. All votes are valid until the bills voters are in their positions. Only those votes from which no more than four years, but each participant may at any time renew their vote.","CODE_VOTE_ONE CODE class CurrentLawVotes: method voteGovernment             public int voteGovernment(                    Map<String, Account> balances,                       List<String> governments) {                        int yes = 0;                        int no = 0;                                List<String> addressGovernment = governments;                   for (String s : YES) {                         if (addressGovernment.contains(s)) {                             yes += Seting.VOTE_GOVERNMENT;                        }                                 }                     for (String s : NO) {                       if (addressGovernment.contains(s)) {                             no += Seting.VOTE_GOVERNMENT;                        }                     }                    return yes - no;                } ","MECHANISM_FOR_REDUCING_THE_NUMBER_OF_SHARES Entering penalties. Every time one account sends a digital share to another account but uses VoteEnum.NO, the account recipient's digital shares are reduced by the amount sent by the share sender. Example account A sent to account B 100 digital shares with VoteEnum.NO, then account A and account B both lose 100 digital shares. This measure is needed so that there is a mechanism to dismiss the Board of Shareholders and also allows you to lower your votes destructive accounts, since the number of votes is equal to the number of shares in the Election of the Board of Directors and when electing CORPORATE_COUNCIL_OF_REFEREES.   This mechanism works only for digital shares and only if the sender sent with the sign VoteEnum.NO.","WHO_HAS_THE_RIGHT_TO_CREATE_LAWS then has the Right to Create Laws. Create Laws in Cryptocurrency International Trade Union Corporations Have the Rights all network members who have at least five digital dollars. To create law through the International Trade Union Corporation's cryptocurrency mechanism It is necessary to create an object of the Laws class inside this cryptocurrency, where packetLawName is the name of the law package. List<String> laws - is a list of laws, String hashLaw - is the address of this package of laws and starts with LIBER. For a law to be included in the pool of laws, you need to create a transaction where the recipient is the hashLaw of this law and the reward miner is equal to five digital dollars (5) of this cryptocurrency. After that, once the law gets into the block, it will be in the pool of laws and it will be possible to vote for it. The number of lines in a package of laws can be as many as needed and there are no restrictions.","POWERS_OF_THE_CORPORATE_COUNCIL_OF_JUDGES POWERS OF THE CORPORATE COUNCIL OF JUDGES. Approves the Chief Justice. Participates in the voting on the introduction of amendments.           The judicial power of the International Trade Union Corporation is vested in one Supreme Court and such inferior courts as the Corporation International The Merchant Union may issue and establish from time to time. Judges of both the supreme and inferior courts hold their offices, with good conduct and in due time receive remuneration for their services. Remuneration must be given from the budget established by laws. Judicial power extends to all cases of law and justice, including those initiated by members to challenge the misappropriation of funds, arising under these Articles, the laws of the International Trade Union Corporation and treaties, imprisoned or to be imprisoned according to their authority. Disputes in which the International Trade Union will be party to a dispute between two or more members of the network. No judgment shall be secret, but justice shall be administered openly and free of charge, completely and without delay, and every person shall have legal protection against injury to life, liberty, or property. Supreme Court CORPORATE_COUNCIL_OF_REFEREES and Chief Justice HIGH_JUDGE.","HOW_THE_CORPORATE_BOARD_OF_JUDGES_IS_ELECTED HOW THE CORPORATE BOARD OF JUDGES IS ELECTED.              CORPORATE_COUNCIL_OF_REFEREES consists of 55 accounts. Each network member can apply for the CORPORATE_COUNCIL_OF_REFEREES position, by creating a law package where the package name CORPORATE_COUNCIL_OF_REFEREES and the sender's account must match the account which is indicated in the first line of the law which is contained in the list of this package The 55th score with the most remaining votes wins the office.              The cost of filing for the creation of a law (position) is worth five digital dollars (5) as a reward to the earner. The voting process is described in VOTE_STOCK.                            Code snippet example: class LawsController: method currentLaw:               //minimum value for the number of positive votes for the law to be valid,                   //positions elected by shares CORPORATE_COUNCIL_OF_REFEREES                     List<CurrentLawVotesEndBalance> electedByStockCorporateCouncilOfReferees = current.stream()                              .filter(t -> directors.isElectedByStocks(t.getPackageName()))                              .filter(t -> t.getPackageName().equals(NamePOSITION.CORPORATE_COUNCIL_OF_REFEREES.toString()))                              .filter(t -> t.getVotes() >= Seting.ORIGINAL_LIMIT_MIN_VOTE)                              .sorted(Comparator.comparing(CurrentLawVotesEndBalance::getVotes).reversed())                              .limit(directors.getDirector(NamePOSITION.CORPORATE_COUNCIL_OF_REFEREES.toString()).getCount())                              .collect(Collectors.toList());","HOW_THE_CHIEF_JUDGE_IS_CHOSEN HOW HIGH_JUDGE IS CHOSEN. The Chief Justice is elected by CORPORATE_COUNCIL_OF_REFEREES. Each member of the network can apply for the position of Chief Justice by creating a law with a package name that matches the allowed position, where the address of the sender of this transaction must match the first line from the list of laws of this package. the cost of the law is five digital dollars as a reward to the earner. the score with the most remainder votes wins the position. The voting mechanism is described by ONE_VOTE.                           Sample code as stated by the supreme judge. class LawsController: method currentLaw. Code section                 //positions elected by the board of corporate chief judges                      List<CurrentLawVotesEndBalance> electedByCorporateCouncilOfReferees = current.stream()                              .filter(t -> directors.isElectedBYCorporateCouncilOfReferees(t.getPackageName()))                              .filter(t -> t.getVotesCorporateCouncilOfReferees() >= Seting.ORIGINAL_LIMIT_MIN_VOTE_CORPORATE_COUNCIL_OF_REFEREES)                              .sorted(Comparator.comparing(CurrentLawVotesEndBalance::getVotesCorporateCouncilOfReferees)).collect(Collectors.toList());","POWERS_OF_THE_CHIEF_JUDGE THE POWERS OF THE CHIP JUDGE. The Chief Justice participates in the approval of laws, as well as can participate in resolving disputes within network members, like CORPORATE_COUNCIL_OF_REFEREES, but his vote is higher than that of CORPORATE_COUNCIL_OF_REFEREES.","HOW_IS_THE_PROCESS_OF_AMENDING_THE_CHARTER HOW IS THE CHARTER AMENDING PROCESS. To amend, you need to create a law with the package name AMENDMENT_TO_THE_CHARTER, further this law must be voted by the method described in VOTE_ONE Board of Shareholders and the balance of votes must be equal to or greater than 300 members, the Board of Directors must also vote and the balance of votes must be 60 or more, corporate chief judges must also vote (CORPORATE_COUNCIL_OF_REFEREES) and The remainder of the votes must be equal to or greater than 5. But amendments should not concern the way in which the rules of existing laws are established, as well as election of the Board of Directors, Board of Shareholders, General Executive Director, Council of Corporate Judges and Chief Justice. Amendments can change the code if the rules are kept electing current positions (including voting rules), laws and money mining (mining digital dollars and digital stocks), No amendment should give any of the above positions more power. Also, the amendments must not infringe upon the Natural Rights of Man.             Code example. class LawsController: method currentLaw: section of code that approves current amendments              //introduction of amendments to the charter                      List<CurrentLawVotesEndBalance> chapter_amendment = current.stream()                              .filter(t -> !directors.contains(t.getPackageName()))                              .filter(t-> Seting.AMENDMENT_TO_THE_CHARTER.equals(t.getPackageName()))                              .filter(t->!directors.isCabinets(t.getPackageName()))                              .filter(t -> t.getVotesBoardOfShareholders() >= Seting.ORIGINAL_LIMIT_MINT_VOTE_BOARD_OF_SHAREHOLDERS_AMENDMENT)                              .filter(t -> t.getVotesBoardOfDirectors() >= Seting.ORIGINAL_LIMIT_MIN_VOTE_BOARD_OF_DIRECTORS_AMENDMENT)                              .filter(t -> t.getVotesCorporateCouncilOfReferees() >= Seting.ORIGINAL_LIMIT_MIN_VOTE_CORPORATE_COUNCIL_OF_REFEREES_AMENDMENT)                              .sorted(Comparator.comparing(CurrentLawVotesEndBalance::getVotesBoardOfDirectors).reversed()).collect(Collectors.toList());","HOW_THE_BUDGET_IS_APPROVED HOW THE BUDGET IS APPROVED. There can be only one current budget. The budget is approved only by the Board of Directors. To approve the budget, you need to get the method described in VOTE_ONE 15 or more votes. The process itself goes like this: 1. First, all packages of laws are selected, where the name of the package matches BUDGET. 2. Next, all packages are selected that have received 15 or more votes. 3. Then all these packages are sorted in descending order, with the most votes. 4. Then the very first one with the most votes is selected.                            Sample code for approving a budget. class LawsController: method: currentLaw.                 //the budget is approved only by the board of directors.                      List<CurrentLawVotesEndBalance> budjet = current.stream()                              .filter(t-> !directors.contains(t.getPackageName()))                              .filter(t->Seting.BUDGET.equals(t.getPackageName()))                              .filter(t->!directors.isCabinets(t.getPackageName()))                              .filter(t-> t.getVotesBoardOfDirectors() >= Seting.ORIGINAL_LIMIT_MIN_VOTE_BOARD_OF_DIRECTORS)                              .sorted(Comparator.comparing(CurrentLawVotesEndBalance::getVotesBoardOfDirectors).reversed())                              .limit(1)                              .collect(Collectors.toList());","HOW_IS_THE_STRATEGIC The strategic plan is approved by the Board of Directors, the strategic plan may be valid only in a single copy. For the Strategic Plan to be valid, a balance of votes is needed Board of Directors 15 or more. Voting method VOTE_ONE.              The Board of Directors may cancel the Strategic Plan at any time. Strategic Plan in effect while the number of votes is 15 or more. The Strategic Plan may include a general direction Corporations, as well as what needs to be implemented.              A section of code that shows how the Strategic Plan is being approved.    class LawsController: method currentLaw:                                  //the plan is approved only by the chamber Board of Directors                      List<CurrentLawVotesEndBalance> planFourYears = current.stream()                              .filter(t->!directors.contains(t.getPackageName()))                              .filter(t->Seting.STRATEGIC_PLAN.equals(t.getPackageName()))                              .filter(t->!directors.isCabinets(t.getPackageName()))                              .filter(t->t.getVotesBoardOfDirectors() >= Seting.ORIGINAL_LIMIT_MIN_VOTE_BOARD_OF_DIRECTORS)                              .sorted(Comparator.comparing(CurrentLawVotesEndBalance::getVotesBoardOfDirectors).reversed())                              .limit(1)                              .collect(Collectors.toList());","HOW_NEW_POSITIONS_ARE_ADDED This method adds only top management, reports of each manager are hired without using the blockchain, they can be hired by the director himself, or otherwise described by applicable law. The top management is added to the class Directors list. All newly added positions are valid as long as their laws that create these positions are in effect.              Only the Board of Directors can add new positions. Each package of laws that starts with ADD_DIRECTOR is defined as adding a position. The list of laws that are inside this package are positions if the title is in line starts with ADD_DIRECTOR.             Example: package name ADD_DIRECTOR_PACKAGE name of the first third and fourth line ADD_DIRECTOR_FIRST ADD_DIRECTOR_THIRD ADD_DIRECTOR_FOUR This will create three positions for the position.              But if the line starts with ADD_DIRECTOR, then the position name must be large letters and underscores, also there should be only one position in one line and no more words.              Those lines where there is no position added (ADD_DIRECTOR) are used to describe the powers of the added posts.              In order for new positions to be added to the list, the Board of Directors must vote by VOTE_ONE 15 or more votes. After new positions are created, each member of the network will be able to apply for these positions.              class LawsController: method currentLaw:                                                //adds laws that create new director positions                      List<CurrentLawVotesEndBalance> addDirectors = current.stream()                             .filter(t->t.getPackageName().startsWith(Seting.ADD_DIRECTOR))                             .filter(t->t.getVotesBoardOfDirectors() >= Seting.ORIGINAL_LIMIT_MIN_VOTE_BOARD_OF_DIRECTORS)                             .collect(Collectors.toList());","PROPERTY_OF_THE_CORPORATION PROPERTY OF A CORPORATION. All property owned by the International Trade Union Corporation, cannot be sold without a valid law, where the sale process will be described and at what price the property will be sold. The founder's account, and the accounts of other members are not corporate account, the Board of Directors must create a separate account which will be budgeted and managed only by members of the current members of the Board of Directors.","INTERNET_STORE_DIRECTOR Online store director This director is engaged in the development, promotion and management of an online store in which sell goods for a digital dollar or digital shares. Detailed powers must be given either through existing laws or issued by the CEO or the Board of Directors. The name of the Store must be determined by either the Board of Directors or the Chief Executive Officer.","GENERAL_EXECUTIVE_DIRECTOR General Executive Director This Director coordinates the actions of the other senior directors to implement the strategic plan or the tasks assigned to it by the laws in force. All powers must be given to him through existing laws. This is the highest position elected by the Corporation and is essentially the analogue of the prime minister.","DIRECTOR_OF_THE_DIGITAL_EXCHANGE Digital Exchange Director This Director is engaged in the development, promotion and management of the Internet exchange. The authority must be given to him or the laws in force, or the Board of Directors, or the Chief Executive Officer.","DIRECTOR_OF_DIGITAL_BANK Digital Bank Director This Director manages the Internet bank. All powers must be issued or applicable laws, or the Board of Directors, or the Chief Executive Officer.","DIRECTOR_OF_THE_COMMERCIAL_COURT Director of a private commercial court Must provide leadership to private courts, all powers must be issued either by applicable laws or by the Board of Directors, or General Executive Director.  In these courts, judges can be both members of the Council of Chief Justices (CORPORATE_COUNCIL_OF_REFEREES) so is the Chief Justice, or inferior judges elected by CORPORATE_COUNCIL_OF_REFEREES.","MEDIA_DIRECTOR Media director This Director directs the media, all powers must be issued by the laws in force, or, the Board of Directors or the CEO.              This Director is responsible for the management of media owned directly Corporations of the International Trade Union.","DIRECTOR_OF_THE_DEVELOPMENT_OF_THE_IMPLEMENTATION_OF_CRYPTOCURRENCY_TECHNOLOGIES_OF_THE_INTERNATIONAL_TRADE_UNION_CORPORATION This Director manages the development and implementation of new code in this cryptocurrency, all powers must be issued only through applicable laws, but may also be issued by either the Board of Directors if applicable laws have given such authority to the Board of Directors. Also, no code change should be contrary to the current charter or applicable laws. Also, powers can be issued by the Chief Executive Officer, if such authority is granted to the Chief Executive Officer by applicable law.","EXPLANATION_WHY_MONEY_DEMURAGE_IS_USED_HERE EXPLANATION WHY MONEY DEMURAGE IS USED HERE The negative rate is now applied in many countries, this measure stimulates money holders when the price is excessively high, saturate the market with money. The amount of money mined for each block is 200 digital dollars and 200 digital shares, also 2% of each mining reward to the founder, which is 4 digital dollars and 4 digital Shares for each block mining. Here it is used as the Theories of Silvio Gesell, as well as the school of monetarism in a modified form.              With Silvio Gezel, the negative rate was 1% per month, which would just kill the economy, under monetarism, the growth of the money supply had to be proportional to the growth of GDP, but since in this system fails to calculate the real GDP growth, I set a fixed growth, also if the monetary growth will equal GDP, there is a high probability of Hyperinflation, since GDP does not always reflect real economic growth. Money must be solid so that a business can predict its long-term investments and from monetarism, only the part that the money supply should grow linearly, but in general there is a mix of different economic schools, including the Austrian School of Economics.              With a negative rate of 0.1% every six months for digital dollars and 0.2% for digital stocks, we avoid the consequences of a severe economic crisis for this currency.              Such a mechanism creates a price corridor where the lower limit of the value of these digital currencies is the total number of issued digital currencies. dollars and digital stocks, and the upper limit is the real value. Since as soon as the value becomes higher than the real value, it becomes more profitable for holders to sell digital dollars and digital shares at inflated prices, thereby saturating the market with money and creating a correction in the market.              The main source of monetary crises is rapid changes in commodity prices and slow changes in wages. Example: Imagine that the value of the currency has risen sharply by 30%, it becomes more profitable for holders not to invest money, since income from holding currency, higher than now pay more expensive employees, because of the fact that the money stops invest. People do not receive wages, which leads to the fact that a huge number of goods are not sold, and this leads to the fact that some manufacturers go bankrupt and lay off many workers, which further reduces wages. wages from the rest, as the labor market becomes surplus.        Which, in turn, causes even more fear among money holders to invest, and this process continues until the moment when until the value of money starts to decline due to the fact that the total number of production chains has decreased and goods have also decreased.             Example: Let's imagine that we had inflation and the value of money fell by 40% within a month, the cost of goods increases sharply, but wages have not risen, so a lot of goods will not be bought, which leads to the closure of production chains, which, in turn, due to an excess of workers in the labor market, reduces wages, which also further reduces the number of goods sold. The first case A deflationary spiral occurs due to a sharp reduction in money in the market, the second stagflation occurs more often when a sharply excess amount of money enters the market. And these two phenomena are two sides of the same coin, in one case we get a deflationary spiral in the other stagflation.                         To avoid such crises, in this cryptocurrency, money grows in the same predictable amount. 204 (4 - founder reward, 200 - earner reward) digital dollars and shares per block, about 576 blocks per day. A negative rate adjusts the value of coins every six months. It is also forbidden to use fractional reserve banking for these coins, as their number grows linearly, and will not be able to cover the debts incurred due to fractional reserve banking, due to lack of cash, since with fractional reserve banking, the increase in debt will be much higher than this protocol will create money.  Also, if you increase the money supply by changing the settings, and making the money supply increase much higher, it can cause hyperinflation or even galloping inflation. If it is necessary to increase the growth of the money supply, this should only happen through amendments, keeping the founder's remuneration percentage at two percent. And mining per block should not increase more than 5% for ten years, each subsequent increase that may be made must pass at least ten years through amendments, and no more than 5% per block from the reward of the last block. (Example: if we change through amendments, then production should not be higher than 210 coins, but every next ie will not be more than five percent of the last. Thus, the next increase made through the amendments will be 220.5 coins. But this amendment will be introduced only in ten years after the first production adjustment)              With a lack of money supply, if the number of mined coins has not been changed through an amendment, you can add a few additional zeros after the decimal point, so it will simply increase the value of the coins, without increasing the total money supply.              Negative rates should not be higher than 0.5% per annum and lower than 0.2% per annum. Negative rates can only be changed through amendments.","FREEDOM_OF_SPEECH No body of this corporation or entity shall prohibit free practice any religion; or restrict freedom of speech, conscience or the press or the right of people to peacefully assemble or associate with one another, or not associate with one another, and apply to the management of the Corporation of the International Trade Union and to this corporation with a petition for satisfaction of complaints; or violate the right to the fruits of one's labor or the right to a peaceful life of one's choice. Freedoms of speech and conscience include the freedom to contribute to political campaigns or candidacy for corporate office and should be construed as extending equally to any means of communication.","RIGHTS Natural Rights All members of the network must respect the Natural Human Rights and not violate them. The presumption of innocence must also be respected and each member of the network must have the right to a fair and independent trial. Each participant has the right to a lawyer or to be his own lawyer.              The International Trade Union Corporation shall not regulate the cost of goods and services of network members that sell through this platform. Also, the Corporation should not ban individual brands on its site, but may prohibit the sale of entire groups of goods that fall within the characteristics described by applicable laws, if this prohibition does not violate Natural Human Rights. As a source of rights, you can take as a precedent Countries recognized as democratic countries.              A detailed list is at the United Nations (UN)              The right to live Right to liberty and security of person Right to privacy The right to determine and indicate one's nationality The right to use one's native language The right to freedom of movement and choice of place of stay and residence Right to freedom of conscience              Freedom of thought and speech Freedom of Information The right to form public associations The right to hold public events The right to participate in the management of the affairs of the Corporation of the International Trade Union The right to appeal to the bodies of the Corporation of the International Trade Union and local governments. Among the natural inalienable human rights include the right to life, freedom, security, property, physical and mental integrity, personal dignity, personal and family secrets, etc.              No existing law should be interpreted in such a way as to violate the natural rights of man. The corporate supreme court may use precedents as judgments, as long as these decisions do not contradict current charter and applicable laws. The Corporate Supreme Court can create precedents similar to countries with case law, but apply you can if these precedents do not violate the current charter or current laws of the Corporation of the International Trade Union.","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","",""],"hashLaw":"LIBER0018e1c46e0aa2af0852bfbd72d2743638cd2ca8158a1cba75a8433284ef5dbc"},"bonusForMiner":5.0,"voteEnum":"YES","sign":"MEUCIQCXYvIuacS68PHu5RSz3Ukqkk+C/hZVsBXZYTFo7VPTOgIgFzIgxCZx4QZR0ry144LDnm4ypwYegObZhf5ixYJuPRQ="}
{"sender":"stExZb8ifLfnFoq4JJuTifpAcscegATH8znhwW26zyTa","customer":"LIBER38072b8b29e391554d90c407f2b7d17dba649c84c37cff46337d5b450b524d8a","digitalDollar":0.0,"digitalStockBalance":0.0,"laws":{"packetLawName":"","laws":[],"hashLaw":""},"bonusForMiner":0.0,"voteEnum":"NO","sign":"MEQCIGZqKuYDRgZnLGKSArt3MBPP2GvF0Kgjeyoa3ef9QilRAiBOpxCkUOz1xdHSGjPCE11kZXKARKWLg8z4vBBmPUGJ0A=="}
{"sender":"stExZb8ifLfnFoq4JJuTifpAcscegATH8znhwW26zyTa","customer":"LIBER10406f42a16accf222cd8731cf51cbf18ea2c9a9a2517fcb5f17ac4f0c60974d","digitalDollar":0.0,"digitalStockBalance":0.0,"laws":{"packetLawName":"ORIGINAL_CHARTER_CURRENT_ALL_CODE","laws":["Код всех важных классов которые участвуют в программе. The code of all important classes that participate in the program.","package International_Trade_Union.config;   import International_Trade_Union.entity.blockchain.Blockchain; import International_Trade_Union.setings.Seting;  import java.io.IOException; import java.security.InvalidKeyException; import java.security.NoSuchAlgorithmException; import java.security.NoSuchProviderException; import java.security.SignatureException; import java.security.spec.InvalidKeySpecException;  public class BLockchainFactory {      public static Blockchain getBlockchain(BlockchainFactoryEnum factoryEnum) throws NoSuchAlgorithmException, InvalidKeySpecException, IOException, SignatureException, NoSuchProviderException, InvalidKeyException {         switch (factoryEnum){             case TEST:                 return new Blockchain(                         Seting.BLOCK_GENERATION_INTERVAL_TEST,                         Seting.DIFFICULTY_ADJUSTMENT_INTERVAL_TEST,                         Seting.INTERVAL_TARGET_TEST,                         Seting.ADDRESS_FOUNDER_TEST);              case ORIGINAL:                 return new Blockchain(                         Seting.BLOCK_GENERATION_INTERVAL,                         Seting.DIFFICULTY_ADJUSTMENT_INTERVAL,                         Seting.INTERVAL_TARGET,                         Seting.ADDRESS_FOUNDER                 );             default: return null;         }     } }","package International_Trade_Union.config;  public enum BlockchainFactoryEnum {     TEST,     ORIGINAL }","package International_Trade_Union.controllers;  import International_Trade_Union.entity.AddressUrl; import International_Trade_Union.entity.SubBlockchainEntity; import org.json.JSONException;  import org.springframework.http.MediaType; import International_Trade_Union.entity.DtoTransaction.DtoTransaction; import International_Trade_Union.entity.blockchain.Blockchain; import International_Trade_Union.entity.blockchain.block.Block; import International_Trade_Union.config.BLockchainFactory; import International_Trade_Union.config.BlockchainFactoryEnum; import International_Trade_Union.entity.EntityChain; import International_Trade_Union.model.Account; import International_Trade_Union.model.Mining; import International_Trade_Union.model.User; import International_Trade_Union.network.AllTransactions; import International_Trade_Union.setings.Seting; import International_Trade_Union.utils.*; import International_Trade_Union.vote.*; import org.springframework.http.HttpStatus; import org.springframework.http.ResponseEntity; import org.springframework.stereotype.Controller; import org.springframework.ui.Model; import org.springframework.util.Assert; import org.springframework.web.bind.annotation.*; import org.springframework.web.context.request.RequestAttributes; import org.springframework.web.context.request.RequestContextHolder; import org.springframework.web.context.request.ServletRequestAttributes;  import javax.servlet.http.HttpServletRequest; import java.io.IOException;  import java.security.*; import java.security.spec.InvalidKeySpecException;  import java.util.*; import java.util.stream.Collectors;  @Controller public class BasisController {     private static Blockchain blockchain;      private static Set<String> excludedAddresses = new HashSet<>();      public static HttpServletRequest getCurrentRequest() {         RequestAttributes requestAttributes = RequestContextHolder.getRequestAttributes();         if(requestAttributes == null)             return null;         Assert.state(requestAttributes != null, \"Could not find current request via RequestContextHolder\");         Assert.isInstanceOf(ServletRequestAttributes.class, requestAttributes);         HttpServletRequest servletRequest = ((ServletRequestAttributes) requestAttributes).getRequest();         Assert.state(servletRequest != null, \"Could not find current HttpServletRequest\");         return servletRequest;     }       public static Set<String> getExcludedAddresses() {         HttpServletRequest request = getCurrentRequest();         if(request == null)             return excludedAddresses;          String scheme = request.getScheme();         String serverName = request.getServerName();         int serverPort = request.getServerPort();         String contextPath = request.getContextPath();  // includes leading forward slash          String localaddress = scheme + \"://\" + serverName + \":\" + serverPort;          excludedAddresses.add(localaddress);         return excludedAddresses;     }      public static void setExcludedAddresses(Set<String> excludedAddresses) {         BasisController.excludedAddresses = excludedAddresses;     }      private static Set<String> nodes = new HashSet<>(); //    private static Nodes nodes = new Nodes();       public static void setNodes(Set<String> nodes) {         BasisController.nodes = nodes;     }      /**Возвращает список хостов*/     public static Set<String> getNodes() throws IOException, NoSuchAlgorithmException, InvalidKeySpecException, SignatureException, NoSuchProviderException, InvalidKeyException {          nodes = new HashSet<>();          Set<String> temporary = UtilsAllAddresses.readLineObject(Seting.ORIGINAL_POOL_URL_ADDRESS_FILE);           nodes.addAll(temporary);           nodes = nodes.stream()                 .filter(t -> !t.isBlank())                 .filter(t -> t.startsWith(\"\\\"\"))                 .collect(Collectors.toSet());         nodes = nodes.stream().map(t -> t.replaceAll(\"\\\"\", \"\")).collect(Collectors.toSet());         nodes.addAll(Seting.ORIGINAL_ADDRESSES);         return nodes;     }       /**Возвращяет действующий блокчейн*/     public static Blockchain getBlockchain() {         return blockchain;     }      public static synchronized void setBlockchain(Blockchain blockchain) {         BasisController.blockchain = blockchain;     }       static {         try {             blockchain = BLockchainFactory.getBlockchain(BlockchainFactoryEnum.ORIGINAL);         } catch (NoSuchAlgorithmException e) {             throw new RuntimeException(e);         } catch (InvalidKeySpecException e) {             throw new RuntimeException(e);         } catch (IOException e) {             throw new RuntimeException(e);         } catch (SignatureException e) {             throw new RuntimeException(e);         } catch (NoSuchProviderException e) {             throw new RuntimeException(e);         } catch (InvalidKeyException e) {             throw new RuntimeException(e);         }     }       public BasisController() {     }      //TODO если вы прервали mine, то перед следующим вызовом перезапустите сервер и вызовите /addBlock перед mine     //TODO if you interrupted mine, restart the server before next call and call /addBlock before mine     //TODO иначе будет расождение в файле балансов     //TODO otherwise there will be a discrepancy in the balance file        /**Стартует добычу, начинает майнинг*/     @GetMapping(\"/mine\")     public synchronized String mine(Model model) throws NoSuchAlgorithmException, InvalidKeySpecException, IOException, SignatureException, NoSuchProviderException, InvalidKeyException, JSONException, CloneNotSupportedException {         String text = \"\";         //нахождение адрессов         findAddresses();         sendAddress();          //собирает класс список балансов из файла расположенного по пути Seting.ORIGINAL_BALANCE_FILE         Map<String, Account> balances = SaveBalances.readLineObject(Seting.ORIGINAL_BALANCE_FILE);         //собирает объект блокчейн из файла         blockchain = Mining.getBlockchain(                 Seting.ORIGINAL_BLOCKCHAIN_FILE,                 BlockchainFactoryEnum.ORIGINAL);          //если блокчейн работает то продолжить         if (!blockchain.validatedBlockchain()) {             text = \"wrong chain: неправильный блокчейн, добыча прекращена\";             model.addAttribute(\"text\", text);             return \"wrong blockchain\";         }          //Прежде чем добыть новый блок сначала в сети ищет самый длинный блокчейн         resolve_conflicts();          //если размер блокчейна меньше или равно единице, сохранить в файл генезис блок         long index = blockchain.sizeBlockhain();         if (blockchain.sizeBlockhain() <= 1) {             //сохранение генезис блока             if (blockchain.sizeBlockhain() == 1) {                 UtilsBlock.saveBLock(blockchain.getBlock(0), Seting.ORIGINAL_BLOCKCHAIN_FILE);             }              //получить список балансов из файла             balances = Mining.getBalances(Seting.ORIGINAL_BALANCE_FILE, blockchain, balances);             //удалить старые файлы баланса             Mining.deleteFiles(Seting.ORIGINAL_BALANCE_FILE);             //сохранить балансы             SaveBalances.saveBalances(balances, Seting.ORIGINAL_BALANCE_FILE);          }         //скачать список балансов из файла         balances = SaveBalances.readLineObject(Seting.ORIGINAL_BALANCE_FILE);          //получить счет майнера         Account miner = balances.get(User.getUserAddress());         if (miner == null) {             //если в блокчейне не было баланса, то баланс равен нулю             miner = new Account(User.getUserAddress(), 0, 0);         }          //транзакции которые мы добавили в блок и теперь нужно удалить из файла, в папке resources/transactions         List<DtoTransaction> temporaryDtoList = AllTransactions.getInstance();          //раз в три для очищяет файлы в папке resources/sendedTransaction данная папка         //хранит уже добавленые в блокчейн транзации, чтобы повторно не добавлять в         //в блок уже добавленные транзакции         AllTransactions.clearAllSendedTransaction(index);         AllTransactions.clearUsedTransaction(AllTransactions.getInsanceSended());         System.out.println(\"BasisController: start mine:\");          //Сам процесс Майнинга         //DIFFICULTY_ADJUSTMENT_INTERVAL как часто происходит коррекция         //BLOCK_GENERATION_INTERVAL как часто должен находить блок         //temporaryDtoList добавляет транзакции в блок         Block block = Mining.miningDay(                 miner,                 blockchain,                 Seting.BLOCK_GENERATION_INTERVAL,                 Seting.DIFFICULTY_ADJUSTMENT_INTERVAL,                 temporaryDtoList,                 balances,                 index         );         System.out.println(\"BasisController: finish mine:\");         //save sended transaction         //сохранить уже добавленные в блок транзакции,         //чтобы избежать повторного добавления         AllTransactions.addSendedTransaction(temporaryDtoList);          //нужна для корректировки сложности         int diff = Seting.DIFFICULTY_ADJUSTMENT_INTERVAL;         //Тестирование блока         List<Block> testingValidationsBlock = null;          if (blockchain.sizeBlockhain() > diff) {              testingValidationsBlock = blockchain.subBlock(blockchain.sizeBlockhain() - diff, blockchain.sizeBlockhain());         } else {             testingValidationsBlock = blockchain.clone();         }         //проверяет последние 288 блоков на валидность.         if (testingValidationsBlock.size() > 1) {             boolean validationTesting = UtilsBlock.validationOneBlock(                     blockchain.genesisBlock().getFounderAddress(),                     testingValidationsBlock.get(testingValidationsBlock.size() - 1),                     block,                     Seting.BLOCK_GENERATION_INTERVAL,                     diff,                     testingValidationsBlock);              if (validationTesting == false) {                 System.out.println(\"wrong validation block: \" + validationTesting);                 System.out.println(\"index block: \" + block.getIndex());                 text = \"wrong validation\";             }             testingValidationsBlock.add(block.clone());         }          //добавляет последний блок в блокчейн         blockchain.addBlock(block);         //сохраняет последний блок в файл         UtilsBlock.saveBLock(block, Seting.ORIGINAL_BLOCKCHAIN_FILE);          //перерасчет балансов, подсчитывает какие изменения произошли в балансах         balances = Mining.getBalances(Seting.ORIGINAL_BALANCE_FILE, blockchain, balances);         Mining.deleteFiles(Seting.ORIGINAL_BALANCE_FILE);         //сохраняет в файл уже заново посчитанные балансы.         SaveBalances.saveBalances(balances, Seting.ORIGINAL_BALANCE_FILE);          //получает все созданные когда либо законы         Map<String, Laws> allLaws = UtilsLaws.getLaws(blockchain.getBlockchainList(), Seting.ORIGINAL_ALL_CORPORATION_LAWS_FILE);          //возвращает все законы с голосами проголосовавшими за них         List<LawEligibleForParliamentaryApproval> allLawsWithBalance = UtilsLaws.getCurrentLaws(allLaws, balances, Seting.ORIGINAL_ALL_CORPORATION_LAWS_WITH_BALANCE_FILE);         //удаление устаревних законов         Mining.deleteFiles(Seting.ORIGINAL_ALL_CORPORATION_LAWS_WITH_BALANCE_FILE);         //записывает все законы в файл с их голосами.         UtilsLaws.saveCurrentsLaws(allLawsWithBalance, Seting.ORIGINAL_ALL_CORPORATION_LAWS_WITH_BALANCE_FILE);          //отправляет блокчейн во внешние сервера         sendAllBlocksToStorage(blockchain.getBlockchainList());          text = \"success: блок успешно добыт\";         model.addAttribute(\"text\", text);         return \"redirect:/mining\";      }       /**Возвращает EntityChain который хранит в себе размер блокчейна и список блоков*/     @GetMapping(\"/chain\")     @ResponseBody     public EntityChain full_chain() throws IOException, NoSuchAlgorithmException, InvalidKeySpecException, SignatureException, NoSuchProviderException, InvalidKeyException {         blockchain = Mining.getBlockchain(                 Seting.ORIGINAL_BLOCKCHAIN_FILE,                 BlockchainFactoryEnum.ORIGINAL);         return new EntityChain(blockchain.sizeBlockhain(), blockchain.getBlockchainList());     }      /**возвращяет размер локального блокчейна*/     @GetMapping(\"/size\")     @ResponseBody     public Integer sizeBlockchain() throws IOException, NoSuchAlgorithmException, InvalidKeySpecException, SignatureException, NoSuchProviderException, InvalidKeyException {         blockchain = Mining.getBlockchain(                 Seting.ORIGINAL_BLOCKCHAIN_FILE,                 BlockchainFactoryEnum.ORIGINAL);         return blockchain.sizeBlockhain();     }       /**Возвращает список блоков ОТ до ДО,*/     @PostMapping(\"/sub-blocks\")     @ResponseBody     public List<Block> subBlocks(@RequestBody SubBlockchainEntity entity) throws IOException, NoSuchAlgorithmException, InvalidKeySpecException, SignatureException, NoSuchProviderException, InvalidKeyException {         blockchain = Mining.getBlockchain(                 Seting.ORIGINAL_BLOCKCHAIN_FILE,                 BlockchainFactoryEnum.ORIGINAL);         return blockchain.getBlockchainList().subList(entity.getStart(), entity.getFinish());     }      /**Возвращяет блок по индексу*/     @PostMapping(\"/block\")     @ResponseBody     public Block getBlock(@RequestBody Integer index) throws IOException, NoSuchAlgorithmException, InvalidKeySpecException, SignatureException, NoSuchProviderException, InvalidKeyException {         blockchain = Mining.getBlockchain(                 Seting.ORIGINAL_BLOCKCHAIN_FILE,                 BlockchainFactoryEnum.ORIGINAL);         return blockchain.getBlock(index);     }      //TODO нужно чтобы передавался каждый раз не весь блокчейн а часть, как реализованно в биткоин     //TODO is necessary so that not the entire blockchain is transmitted each time, but a part, as implemented in bitcoin     //TODO need to optimization because now not best      @RequestMapping(\"/resolving\")     public String resolving() throws JSONException, NoSuchAlgorithmException, InvalidKeySpecException, IOException, SignatureException, NoSuchProviderException, InvalidKeyException {         resolve_conflicts();         return \"redirect:/\";     }     /**соединяется к внешним хостам, и скачивает самый длинный блокчейн,      * если, локальный блокчейн, меньше других */     @GetMapping(\"/nodes/resolve\")     public synchronized void resolve_conflicts() throws NoSuchAlgorithmException, InvalidKeySpecException, IOException, SignatureException, NoSuchProviderException, InvalidKeyException, JSONException {         Blockchain temporaryBlockchain = BLockchainFactory.getBlockchain(BlockchainFactoryEnum.ORIGINAL);         Blockchain bigBlockchain = BLockchainFactory.getBlockchain(BlockchainFactoryEnum.ORIGINAL);         blockchain = Mining.getBlockchain(                 Seting.ORIGINAL_BLOCKCHAIN_FILE,                 BlockchainFactoryEnum.ORIGINAL);         int blocks_current_size = blockchain.sizeBlockhain();         long hashCountZeroTemporary = 0;         long hashCountZeroBigBlockchain = 0;         EntityChain entityChain = null;          long hashCountZeroAll = 0;         //count hash start with zero all         for (Block block : blockchain.getBlockchainList()) {             hashCountZeroAll += UtilsUse.hashCount(block.getHashBlock());         }          Set<String> nodesAll = getNodes(); //        nodesAll.addAll(Seting.ORIGINAL_ADDRESSES_BLOCKCHAIN_STORAGE);         System.out.println(\"BasisController: resolve: size: \" + getNodes().size());         for (String s : nodesAll) {             System.out.println(\"BasisController: resove: address: \" + s);             String temporaryjson = null;              if (BasisController.getExcludedAddresses().contains(s)) {                 System.out.println(\"its your address or excluded address: \" + s);                 continue;             }             try {                 if(s.contains(\"localhost\") || s.contains(\"127.0.0.1\"))                     continue;                 String address = s + \"/chain\";                 System.out.println(\"BasisController:resolve conflicts: address: \" + s + \"/size\");                 String sizeStr = UtilUrl.readJsonFromUrl(s + \"/size\");                 Integer size = Integer.valueOf(sizeStr);                 if (size > blocks_current_size) {                     System.out.println(\"size from address: \" + s + \" upper than: \" + size + \":blocks_current_size \" + blocks_current_size);                     //Test start algorithm                     SubBlockchainEntity subBlockchainEntity = new SubBlockchainEntity(blocks_current_size, size);                     String subBlockchainJson = UtilsJson.objToStringJson(subBlockchainEntity);                      List<Block> emptyList = new ArrayList<>();                       List<Block> subBlocks = UtilsJson.jsonToListBLock(UtilUrl.getObject(subBlockchainJson, s + \"/sub-blocks\"));                     emptyList.addAll(subBlocks);                     emptyList.addAll(blockchain.getBlockchainList());                      emptyList = emptyList.stream().sorted(Comparator.comparing(Block::getIndex)).collect(Collectors.toList());                     temporaryBlockchain.setBlockchainList(emptyList);                     if (!temporaryBlockchain.validatedBlockchain()) {                         System.out.println(\"first algorithm not worked\");                         emptyList = new ArrayList<>();                         emptyList.addAll(subBlocks);                         for (int i = blockchain.sizeBlockhain() - 1; i > 0; i--) {                             Block block = UtilsJson.jsonToBLock(UtilUrl.getObject(UtilsJson.objToStringJson(i), s + \"/block\"));                             if (!blockchain.getBlock(i).getHashBlock().equals(block.getHashBlock())) {                                 emptyList.add(block);                             } else {                                 emptyList.add(block);                                 emptyList.addAll(blockchain.getBlockchainList().subList(0, i));                                 emptyList = emptyList.stream().sorted(Comparator.comparing(Block::getIndex)).collect(Collectors.toList());                                 temporaryBlockchain.setBlockchainList(emptyList);                                 break;                             }                         }                     }                     if (!temporaryBlockchain.validatedBlockchain()) {                         System.out.println(\"second algorith not worked\");                         temporaryjson = UtilUrl.readJsonFromUrl(address);                         entityChain = UtilsJson.jsonToEntityChain(temporaryjson);                         temporaryBlockchain.setBlockchainList(                                 entityChain.getBlocks().stream().sorted(Comparator.comparing(Block::getIndex)).collect(Collectors.toList()));                     }                 } else {                     System.out.println(\"BasisController: resove: size less: \" + size + \" address: \" + address);                     continue;                 }             } catch (IOException e) {                 e.printStackTrace();                 System.out.println(\"BasisController: resolve_conflicts: Error: \" + s);                 continue;             }               if (temporaryBlockchain.validatedBlockchain()) {                 for (Block block : temporaryBlockchain.getBlockchainList()) {                     hashCountZeroTemporary += UtilsUse.hashCount(block.getHashBlock());                 }                  if (blocks_current_size < temporaryBlockchain.sizeBlockhain() && hashCountZeroAll < hashCountZeroTemporary) {                     blocks_current_size = temporaryBlockchain.sizeBlockhain();                     bigBlockchain = temporaryBlockchain;                     hashCountZeroBigBlockchain = hashCountZeroTemporary;                 }                 hashCountZeroTemporary = 0;             }          }           if (bigBlockchain.sizeBlockhain() > blockchain.sizeBlockhain() && hashCountZeroBigBlockchain > hashCountZeroAll) {              blockchain = bigBlockchain;             UtilsBlock.deleteFiles();             addBlock(bigBlockchain.getBlockchainList(), BLockchainFactory.getBlockchain(BlockchainFactoryEnum.ORIGINAL));             System.out.println(\"BasisController: resolve: bigblockchain size: \" + bigBlockchain.sizeBlockhain());          }      }       /**      * Перезаписывает весь список блоков, и делает перерасчет баланса, а также других данных      * таких как голоса, совет акционеров и т.д. заново записывает в файлы      */      public static void addBlock(List<Block> orignalBlocks, Blockchain blockchain) throws IOException, NoSuchAlgorithmException, SignatureException, InvalidKeySpecException, NoSuchProviderException, InvalidKeyException {          Map<String, Account> balances = new HashMap<>();         Blockchain temporaryForValidation = BLockchainFactory.getBlockchain(BlockchainFactoryEnum.ORIGINAL);         temporaryForValidation.setBlockchainList(orignalBlocks);         UtilsBlock.deleteFiles();         System.out.println(\"addBlock start\");         for (Block block : orignalBlocks) {             UtilsBlock.saveBLock(block, Seting.ORIGINAL_BLOCKCHAIN_FILE);         }          blockchain = Mining.getBlockchain(                 Seting.ORIGINAL_BLOCKCHAIN_FILE,                 BlockchainFactoryEnum.ORIGINAL);          //перерасчет после добычи         balances = UtilsBalance.calculateBalances(blockchain.getBlockchainList());         Mining.deleteFiles(Seting.ORIGINAL_BALANCE_FILE);         SaveBalances.saveBalances(balances, Seting.ORIGINAL_BALANCE_FILE);           //получение и отображение законов, а также сохранение новых законов         //и изменение действующих законов         Map<String, Laws> allLaws = UtilsLaws.getLaws(blockchain.getBlockchainList(), Seting.ORIGINAL_ALL_CORPORATION_LAWS_FILE);           //возвращает все законы с балансом         List<LawEligibleForParliamentaryApproval> allLawsWithBalance = UtilsLaws.getCurrentLaws(allLaws, balances, Seting.ORIGINAL_ALL_CORPORATION_LAWS_WITH_BALANCE_FILE);         //удаление устаревних законов         Mining.deleteFiles(Seting.ORIGINAL_ALL_CORPORATION_LAWS_WITH_BALANCE_FILE);         UtilsLaws.saveCurrentsLaws(allLawsWithBalance, Seting.ORIGINAL_ALL_CORPORATION_LAWS_WITH_BALANCE_FILE);          System.out.println(\"BasisController: addBlock: finish\");     }      /**Регистрирует новый внешний хост*/     @RequestMapping(method = RequestMethod.POST, value = \"/nodes/register\", consumes = MediaType.APPLICATION_JSON_VALUE)     public synchronized void register_node(@RequestBody AddressUrl urlAddrress) throws IOException, NoSuchAlgorithmException, InvalidKeySpecException, SignatureException, NoSuchProviderException, InvalidKeyException {           for (String s : BasisController.getNodes()) {             String original = s;             String url = s + \"/nodes/register\";              try {                 UtilUrl.sendPost(urlAddrress.getAddress(), url);                 sendAddress();               } catch (Exception e) {                 System.out.println(\"BasisController: register node: wrong node: \" + original);                 BasisController.getNodes().remove(original);                 continue;             }         }          Set<String> nodes = BasisController.getNodes();         nodes = nodes.stream()                 .map(t -> t.replaceAll(\"\\\"\", \"\"))                 .map(t -> t.replaceAll(\"\\\\\\\\\", \"\"))                 .collect(Collectors.toSet());         nodes.add(urlAddrress.getAddress());         BasisController.setNodes(nodes);          Mining.deleteFiles(Seting.ORIGINAL_POOL_URL_ADDRESS_FILE);         nodes.stream().forEach(t -> {             try {                 UtilsAllAddresses.saveAllAddresses(t, Seting.ORIGINAL_POOL_URL_ADDRESS_FILE);             } catch (IOException e) {                 throw new RuntimeException(e);             } catch (NoSuchAlgorithmException e) {                 throw new RuntimeException(e);             } catch (SignatureException e) {                 throw new RuntimeException(e);             } catch (InvalidKeySpecException e) {                 throw new RuntimeException(e);             } catch (NoSuchProviderException e) {                 throw new RuntimeException(e);             } catch (InvalidKeyException e) {                 throw new RuntimeException(e);             }         });      }      //TODO если происходить майнинг, то он возвращает false, пока не прекратиться майнинг.     //TODO if mining occurs, it returns false until mining stops.     /** выззывает метод addBlock который перезаписывает весь список блоков, и другие данные*/     @GetMapping(\"/addBlock\")     public boolean getBLock() throws IOException, NoSuchAlgorithmException, InvalidKeySpecException, SignatureException, NoSuchProviderException, InvalidKeyException {         blockchain = Mining.getBlockchain(                 Seting.ORIGINAL_BLOCKCHAIN_FILE,                 BlockchainFactoryEnum.ORIGINAL);         UtilsBlock.deleteFiles();         addBlock(blockchain.getBlockchainList(), BLockchainFactory.getBlockchain(BlockchainFactoryEnum.ORIGINAL));         return true;     }      /**Возвращяет список хостов, сохраненных на локальном сервере*/     @GetMapping(\"/getNodes\")     public Set<String> getAllNodes() throws IOException, NoSuchAlgorithmException, InvalidKeySpecException, SignatureException, NoSuchProviderException, InvalidKeyException {         Set<String> temporary = UtilsAllAddresses.readLineObject(Seting.ORIGINAL_POOL_URL_ADDRESS_FILE);         nodes.addAll(temporary);         nodes.addAll(Seting.ORIGINAL_ADDRESSES);         nodes = nodes.stream().filter(t -> t.startsWith(\"\\\"\"))                 .collect(Collectors.toSet());         return nodes;     }      /**подключается к другим узлам и у них берет их списки хостов, которые храняться у них,      *  и сохраняет эти списки у себя*/     @GetMapping(\"/findAddresses\")     public void findAddresses() throws IOException, NoSuchAlgorithmException, InvalidKeySpecException, SignatureException, NoSuchProviderException, InvalidKeyException {         for (String s : Seting.ORIGINAL_ADDRESSES) {             Set<String> addressesSet = new HashSet<>();             try {                 String addresses = UtilUrl.readJsonFromUrl(s + \"/getDiscoveryAddresses\");                 addressesSet = UtilsJson.jsonToSetAddresses(addresses);             } catch (IOException e) {                 System.out.println(\"BasisController: findAddress: error\");                 continue;             } catch (JSONException e) {                 throw new RuntimeException(e);             }              for (String s1 : addressesSet) {                  register_node(new AddressUrl(s1));             }          }      }      /**Запускает автоматический цикл майнинга, цикл будет идти 2000 шагов*/     @GetMapping(\"/moreMining\")     public void moreMining() throws JSONException, IOException {         for (int i = 1; i < 2000; i++) {             System.out.println(\"block generate i: \" + i);             UtilUrl.readJsonFromUrl(\"http://localhost:8082/mine\");           }     }       /**Отправляет свой список хостов, другим узлам, и пытается автоматически регистрировать у них*/     public static void sendAddress() throws IOException, NoSuchAlgorithmException, InvalidKeySpecException, SignatureException, NoSuchProviderException, InvalidKeyException {         //лист временный для отправки аддресов          for (String s : Seting.ORIGINAL_ADDRESSES) {              String original = s;             String url = s + \"/nodes/register\";              if (BasisController.getExcludedAddresses().contains(url)) {                 System.out.println(\"MainController: its your address or excluded address: \" + url);                 continue;             }             try {                 for (String s1 : BasisController.getNodes()) {                       AddressUrl addressUrl = new AddressUrl(s1);                     String json = UtilsJson.objToStringJson(addressUrl);                     UtilUrl.sendPost(json, url);                 }             } catch (Exception e) {                 System.out.println(\"BasisController: sendAddress: wronge node: \" + original);                  continue;             }           }     }      //должен отправлять блокчейн в хранилище блокчейна     /**Отправляет список блоков в центральные хранилища (пример: http://194.87.236.238:80)*/     public static void sendAllBlocksToStorage(List<Block> blocks) throws IOException, NoSuchAlgorithmException, InvalidKeySpecException, SignatureException, NoSuchProviderException, InvalidKeyException {         String jsonDto;         System.out.println(\"BasisController: sendAllBlocksToStorage: start: \");         try {             jsonDto = UtilsJson.objToStringJson(blocks);         } catch (IOException e) {             throw new RuntimeException(e);         }         int blocks_current_size = blocks.size();         //отправка блокчейна на хранилище блокчейна         System.out.println(\"BasisController: sendAllBlocksToStorage: \");         getNodes().stream().forEach(System.out::println);         for (String s : getNodes()) {               if (BasisController.getExcludedAddresses().contains(s)) {                 System.out.println(\"its your address or excluded address: \" + s);                 continue;             }              try {                 System.out.println(\"BasisController:resolve conflicts: address: \" + s + \"/size\");                 String sizeStr = UtilUrl.readJsonFromUrl(s + \"/size\");                 Integer size =  0;                 if(Integer.valueOf(sizeStr) > 0)                     size = Integer.valueOf(sizeStr);                 System.out.println(\"BasisController: send size: \" + size);                 List<Block> fromToTempBlock = blocks.subList(size, blocks.size());                 String jsonFromTo = UtilsJson.objToStringJson(fromToTempBlock);                 //если блокчейн текущей больше чем в хранилище, то                 //отправить текущий блокчейн отправить в хранилище                 if (size < blocks_current_size) {                     int response = 0;                     //Test start algorithm                     String originalF = s;                     String urlFrom = s + \"/nodes/resolve_from_to_block\";                     try {                         response = UtilUrl.sendPost(jsonFromTo, urlFrom);                     }catch (Exception e){                         System.out.println(\"exception discover: \" + originalF);                         continue;                     }                      System.out.println(\"BasisController: sendAllBlocksStorage: response: \" + response);                      if(response != 0){                         System.out.println(\"BasisController: sendAllBlocks: need change all: \" + response);                         //Test start algorithm                         String original = s;                         String url = s + \"/nodes/resolve_all_blocks\";                         try {                             UtilUrl.sendPost(jsonDto, url);                          }catch (Exception e){                             System.out.println(\"exception discover: \" + original);                             continue;                          }                     }                  }              } catch (JSONException e) {                 e.printStackTrace();                 continue;              } catch (IOException e) {                 e.printStackTrace();                 continue;             }          }      } }","package International_Trade_Union.controllers;  import International_Trade_Union.config.BlockchainFactoryEnum; import International_Trade_Union.entity.blockchain.Blockchain; import International_Trade_Union.model.Mining; import International_Trade_Union.setings.Seting; import org.springframework.web.bind.annotation.GetMapping; import org.springframework.web.bind.annotation.RestController;  import java.io.IOException; import java.security.InvalidKeyException; import java.security.NoSuchAlgorithmException; import java.security.NoSuchProviderException; import java.security.SignatureException; import java.security.spec.InvalidKeySpecException;  @RestController public class BlockchainCheckController {      //TODO во время майнинга, если майнинг не остановлен, он почему то возвращает false, но после остановки true. Нужно исправить.     //TODO during mining, if mining is not stopped, for some reason it returns false, but after stopping it returns true. Need to fix.     //TODO worked after restart server, get true.     //TODO ошибка возникает если прервать mine,     //TODO error occurs if mine is interrupted,      /**Проверяет целостность блокчейна*/     @GetMapping(\"/checkValidation\")     public boolean checkValidation() throws IOException, NoSuchAlgorithmException, SignatureException, InvalidKeySpecException, NoSuchProviderException, InvalidKeyException {         try{             Blockchain blockchain = Mining.getBlockchain(                     Seting.ORIGINAL_BLOCKCHAIN_FILE,                     BlockchainFactoryEnum.ORIGINAL);             System.out.println(\"BlockchainCheckController: checkValidation: size: \" + blockchain.sizeBlockhain());             boolean check = blockchain.validatedBlockchain();             System.out.println(\"check: \" + check);             return check;}         catch (IOException e){             e.printStackTrace();             return false;         }     } }","package International_Trade_Union.controllers;  import International_Trade_Union.config.BlockchainFactoryEnum; import International_Trade_Union.entity.blockchain.Blockchain; import International_Trade_Union.governments.UtilsGovernment; import International_Trade_Union.model.Mining; import International_Trade_Union.utils.SaveBalances; import org.springframework.stereotype.Controller; import org.springframework.ui.Model; import org.springframework.web.bind.annotation.GetMapping; import International_Trade_Union.model.Account; import International_Trade_Union.setings.Seting;  import java.io.IOException; import java.security.InvalidKeyException; import java.security.NoSuchAlgorithmException; import java.security.NoSuchProviderException; import java.security.SignatureException; import java.security.spec.InvalidKeySpecException; import java.util.ArrayList; import java.util.HashMap; import java.util.List; import java.util.Map; import java.util.stream.Collectors;  @Controller public class BoardOfShareholdersController {      /**отображает список Совета Акционеров, отображается в браузере*/     @GetMapping(\"board-of-shareholders\")     public String boardOfShareHolders(Model model) throws NoSuchAlgorithmException, InvalidKeySpecException, IOException, SignatureException, NoSuchProviderException, InvalidKeyException {          Blockchain blockchain = Mining.getBlockchain(                 Seting.ORIGINAL_BLOCKCHAIN_FILE,                 BlockchainFactoryEnum.ORIGINAL);          //Получение баланса         Map<String, Account> balances = new HashMap<>();          balances = SaveBalances.readLineObject(Seting.ORIGINAL_BALANCE_FILE);         List<Account> boardOfShareholders = new ArrayList<>();          boardOfShareholders = UtilsGovernment.findBoardOfShareholders(balances, blockchain.getBlockchainList(), Seting.BOARDS_BLOCK);           model.addAttribute(\"title\", \"Совет акционеров количество: \" + boardOfShareholders.size());         model.addAttribute(\"boardOfShareholders\", boardOfShareholders);         return \"board-of-shareholders\";     }   }","package International_Trade_Union.controllers;  import International_Trade_Union.originalCorporateCharter.OriginalCHARTER; import International_Trade_Union.originalCorporateCharter.OriginalPreamble; import org.springframework.stereotype.Controller; import org.springframework.ui.Model; import org.springframework.web.bind.annotation.GetMapping;  import java.io.IOException; import java.security.InvalidKeyException; import java.security.NoSuchAlgorithmException; import java.security.NoSuchProviderException; import java.security.SignatureException; import java.security.spec.InvalidKeySpecException; import java.util.ArrayList; import java.util.List;  @Controller public class ConstitutionController {      /**Отображает устав в браузере*/     @GetMapping(\"corporate-charter\")     public String constutionRus(Model model) throws NoSuchAlgorithmException, InvalidKeySpecException, IOException, SignatureException, NoSuchProviderException, InvalidKeyException {          model.addAttribute(\"title\", \"corporate charter-корпоративный устав\");         List<String> rus = charterRusList();         List<String> eng = charterEngList();               model.addAttribute(\"rus\", rus);         model.addAttribute(\"eng\", eng);         return \"corporate-charter\";     }      public static String charterRus (){         String string = \"\";         for (String s : charterRusList()) {             string = s + \"\\n\";         }         return string;     }      public static String charterEng(){         String string = \"\";         for (String s : charterEngList()) {             string = s + \"\\n\";         }         return string;     }       public static List<String> charterRusList(){         List<String> rus = new ArrayList<>();           rus.add(\"OriginalPreamble.ARTICLE_0\\n\"+ OriginalPreamble.ARTICLE_0);         rus.add(\"OriginalCHARTER.POWERS_OF_THE_BOARD_OF_DIRECTORS:\\n\"+ OriginalCHARTER.POWERS_OF_THE_BOARD_OF_DIRECTORS);         rus.add(\"OriginalCHARTER.HOW_LAWS_ARE_CHOSEN:\\n\"+ OriginalCHARTER.HOW_LAWS_ARE_CHOSEN);         rus.add(\"OriginalCHARTER.HOW_THE_BOARD_OF_DIRECTORS_IS_ELECTED:\\n\"+ OriginalCHARTER.HOW_THE_BOARD_OF_DIRECTORS_IS_ELECTED);         rus.add(\"OriginalCHARTER.POWERS_OF_THE_BOARD_OF_SHAREHOLDERS:\\n\"+ OriginalCHARTER.POWERS_OF_THE_BOARD_OF_SHAREHOLDERS);         rus.add(\"OriginalCHARTER.HOW_SHAREHOLDERS_BOARD_IS_ELECTED:\\n\"+ OriginalCHARTER.HOW_SHAREHOLDERS_BOARD_IS_ELECTED);         rus.add(\"OriginalCHARTER.VOTE_STOCK:\\n\"+ OriginalCHARTER.VOTE_STOCK);         rus.add(\"OriginalCHARTER.CODE_VOTE_STOCK:\\n\"+ OriginalCHARTER.CODE_VOTE_STOCK);         rus.add(\"OriginalCHARTER.POWERS_OF_DIRECTORS_IN_THE_OFFICE:\\n\"+ OriginalCHARTER.POWERS_OF_THE_CABINET_OF_DIRECTORS);         rus.add(\"OriginalCHARTER.HOW_OFFICE_DIRECTORS_ARE_CHOSEN:\\n\"+ OriginalCHARTER.HOW_CABINET_DIRECTORS_ARE_CHOSEN);         rus.add(\"OriginalCHARTER.ONE_VOTE:\\n\"+ OriginalCHARTER.ONE_VOTE);         rus.add(\"OriginalCHARTER.CODE_VOTE_ONE:\\n\"+ OriginalCHARTER.CODE_VOTE_ONE);         rus.add(\"OriginalCHARTER.MECHANISM_FOR_REDUCING_THE_NUMBER_OF_SHARES:\\n\"+ OriginalCHARTER.MECHANISM_FOR_REDUCING_THE_NUMBER_OF_SHARES);         rus.add(\"OriginalCHARTER.WHO_HAS_THE_RIGHT_TO_CREATE_LAWS:\\n\"+ OriginalCHARTER.WHO_HAS_THE_RIGHT_TO_CREATE_LAWS);         rus.add(\"OriginalCHARTER.POWERS_OF_THE_CORPORATE_COUNCIL_OF_JUDGES:\\n\"+ OriginalCHARTER.POWERS_OF_THE_CORPORATE_COUNCIL_OF_JUDGES);         rus.add(\"OriginalCHARTER.HOW_THE_CORPORATE_BOARD_OF_JUDGES_IS_ELECTED:\\n\"+ OriginalCHARTER.HOW_THE_CORPORATE_BOARD_OF_JUDGES_IS_ELECTED);         rus.add(\"OriginalCHARTER.HOW_THE_CHIEF_JUDGE_IS_CHOSEN:\\n\"+ OriginalCHARTER.HOW_THE_CHIEF_JUDGE_IS_CHOSEN);         rus.add(\"OriginalCHARTER.POWERS_OF_THE_CHIEF_JUDGE:\\n\"+ OriginalCHARTER.POWERS_OF_THE_CHIEF_JUDGE);         rus.add(\"OriginalCHARTER.HOW_IS_THE_PROCESS_OF_AMENDING_THE_CHARTER:\\n\"+ OriginalCHARTER.HOW_IS_THE_PROCESS_OF_AMENDING_THE_CHARTER);         rus.add(\"OriginalCHARTER.HOW_THE_BUDGET_IS_APPROVED:\\n\"+ OriginalCHARTER.HOW_THE_BUDGET_IS_APPROVED);         rus.add(\"OriginalCHARTER.HOW_IS_THE_STRATEGIC:\\n\"+ OriginalCHARTER.HOW_IS_THE_STRATEGIC);         rus.add(\"OriginalCHARTER.HOW_NEW_POSITIONS_ARE_ADDED:\\n\"+ OriginalCHARTER.HOW_NEW_POSITIONS_ARE_ADDED);         rus.add(\"OriginalCHARTER.PROPERTY_OF_THE_CORPORATION:\\n\"+ OriginalCHARTER.PROPERTY_OF_THE_CORPORATION);         rus.add(\"OriginalCHARTER.INTERNET_STORE_DIRECTOR:\\n\"+ OriginalCHARTER.INTERNET_STORE_DIRECTOR);         rus.add(\"OriginalCHARTER.GENERAL_EXECUTIVE_DIRECTOR:\\n\"+ OriginalCHARTER.GENERAL_EXECUTIVE_DIRECTOR);         rus.add(\"OriginalCHARTER.DIRECTOR_OF_THE_DIGITAL_EXCHANGE:\\n\"+ OriginalCHARTER.DIRECTOR_OF_THE_DIGITAL_EXCHANGE);         rus.add(\"OriginalCHARTER.DIRECTOR_OF_DIGITAL_BANK:\\n\"+ OriginalCHARTER.DIRECTOR_OF_DIGITAL_BANK);         rus.add(\"OriginalCHARTER.DIRECTOR_OF_THE_COMMERCIAL_COURT:\\n\"+ OriginalCHARTER.DIRECTOR_OF_THE_COMMERCIAL_COURT);         rus.add(\"OriginalCHARTER.MEDIA_DIRECTOR:\\n\"+ OriginalCHARTER.MEDIA_DIRECTOR);         rus.add(\"OriginalCHARTER.DIRECTOR_OF_THE_DEVELOPMENT_OF_THE_IMPLEMENTATION_OF_CRYPTOCURRENCY_TECHNOLOGIES_OF_THE_INTERNATIONAL_TRADE_UNION_CORPORATION:\\n\"+ OriginalCHARTER.DIRECTOR_OF_THE_DEVELOPMENT_OF_THE_IMPLEMENTATION_OF_CRYPTOCURRENCY_TECHNOLOGIES_OF_THE_INTERNATIONAL_TRADE_UNION_CORPORATION);         rus.add(\"OriginalCHARTER.EXPLANATION_WHY_MONEY_DEMURAGE_IS_USED_HERE:\\n\"+ OriginalCHARTER.EXPLANATION_WHY_MONEY_DEMURAGE_IS_USED_HERE);         rus.add(\"OriginalCHARTER.FREEDOM_OF_SPEECH:\\n\"+ OriginalCHARTER.FREEDOM_OF_SPEECH);         rus.add(\"OriginalCHARTER.RIGHTS:\\n\"+ OriginalCHARTER.RIGHTS);         return rus;     }       public static List<String> charterEngList(){         List<String> eng = new ArrayList<>();         eng.add(\"OriginalPreamble.ARTICLE_0\\n\"+ OriginalPreamble.ARTICLE_0);         eng.add(\"OriginalCHARTER.POWERS_OF_THE_BOARD_OF_DIRECTORS:\\n\"+ OriginalCHARTER.POWERS_OF_THE_BOARD_OF_DIRECTORS);         eng.add(\"OriginalCHARTER.HOW_LAWS_ARE_CHOSEN:\\n\"+ OriginalCHARTER.HOW_LAWS_ARE_CHOSEN);         eng.add(\"OriginalCHARTER.HOW_THE_BOARD_OF_DIRECTORS_IS_ELECTED:\\n\"+ OriginalCHARTER.HOW_THE_BOARD_OF_DIRECTORS_IS_ELECTED);         eng.add(\"OriginalCHARTER.POWERS_OF_THE_BOARD_OF_SHAREHOLDERS:\\n\"+ OriginalCHARTER.POWERS_OF_THE_BOARD_OF_SHAREHOLDERS);         eng.add(\"OriginalCHARTER.HOW_SHAREHOLDERS_BOARD_IS_ELECTED:\\n\"+ OriginalCHARTER.HOW_SHAREHOLDERS_BOARD_IS_ELECTED);         eng.add(\"OriginalCHARTER.VOTE_STOCK:\\n\"+ OriginalCHARTER.VOTE_STOCK);         eng.add(\"OriginalCHARTER.CODE_VOTE_STOCK:\\n\"+ OriginalCHARTER.CODE_VOTE_STOCK);         eng.add(\"OriginalCHARTER.POWERS_OF_DIRECTORS_IN_THE_OFFICE:\\n\"+ OriginalCHARTER.POWERS_OF_THE_CABINET_OF_DIRECTORS);         eng.add(\"OriginalCHARTER.HOW_OFFICE_DIRECTORS_ARE_CHOSEN:\\n\"+ OriginalCHARTER.HOW_CABINET_DIRECTORS_ARE_CHOSEN);         eng.add(\"OriginalCHARTER.ONE_VOTE:\\n\"+ OriginalCHARTER.ONE_VOTE);         eng.add(\"OriginalCHARTER.CODE_VOTE_ONE:\\n\"+ OriginalCHARTER.CODE_VOTE_ONE);         eng.add(\"OriginalCHARTER.MECHANISM_FOR_REDUCING_THE_NUMBER_OF_SHARES:\\n\"+ OriginalCHARTER.MECHANISM_FOR_REDUCING_THE_NUMBER_OF_SHARES);         eng.add(\"OriginalCHARTER.WHO_HAS_THE_RIGHT_TO_CREATE_LAWS:\\n\"+ OriginalCHARTER.WHO_HAS_THE_RIGHT_TO_CREATE_LAWS);         eng.add(\"OriginalCHARTER.POWERS_OF_THE_CORPORATE_COUNCIL_OF_JUDGES:\\n\"+ OriginalCHARTER.POWERS_OF_THE_CORPORATE_COUNCIL_OF_JUDGES);         eng.add(\"OriginalCHARTER.HOW_THE_CORPORATE_BOARD_OF_JUDGES_IS_ELECTED:\\n\"+ OriginalCHARTER.HOW_THE_CORPORATE_BOARD_OF_JUDGES_IS_ELECTED);         eng.add(\"OriginalCHARTER.HOW_THE_CHIEF_JUDGE_IS_CHOSEN:\\n\"+ OriginalCHARTER.HOW_THE_CHIEF_JUDGE_IS_CHOSEN);         eng.add(\"OriginalCHARTER.POWERS_OF_THE_CHIEF_JUDGE:\\n\"+ OriginalCHARTER.POWERS_OF_THE_CHIEF_JUDGE);         eng.add(\"OriginalCHARTER.HOW_IS_THE_PROCESS_OF_AMENDING_THE_CHARTER:\\n\"+ OriginalCHARTER.HOW_IS_THE_PROCESS_OF_AMENDING_THE_CHARTER);         eng.add(\"OriginalCHARTER.HOW_THE_BUDGET_IS_APPROVED:\\n\"+ OriginalCHARTER.HOW_THE_BUDGET_IS_APPROVED);         eng.add(\"OriginalCHARTER.HOW_IS_THE_STRATEGIC:\\n\"+ OriginalCHARTER.HOW_IS_THE_STRATEGIC);         eng.add(\"OriginalCHARTER.HOW_NEW_POSITIONS_ARE_ADDED:\\n\"+ OriginalCHARTER.HOW_NEW_POSITIONS_ARE_ADDED);         eng.add(\"OriginalCHARTER.PROPERTY_OF_THE_CORPORATION:\\n\"+ OriginalCHARTER.PROPERTY_OF_THE_CORPORATION);         eng.add(\"OriginalCHARTER.INTERNET_STORE_DIRECTOR:\\n\"+ OriginalCHARTER.INTERNET_STORE_DIRECTOR);         eng.add(\"OriginalCHARTER.GENERAL_EXECUTIVE_DIRECTOR:\\n\"+ OriginalCHARTER.GENERAL_EXECUTIVE_DIRECTOR);         eng.add(\"OriginalCHARTER.DIRECTOR_OF_THE_DIGITAL_EXCHANGE:\\n\"+ OriginalCHARTER.DIRECTOR_OF_THE_DIGITAL_EXCHANGE);         eng.add(\"OriginalCHARTER.DIRECTOR_OF_DIGITAL_BANK:\\n\"+ OriginalCHARTER.DIRECTOR_OF_DIGITAL_BANK);         eng.add(\"OriginalCHARTER.DIRECTOR_OF_THE_COMMERCIAL_COURT:\\n\"+ OriginalCHARTER.DIRECTOR_OF_THE_COMMERCIAL_COURT);         eng.add(\"OriginalCHARTER.MEDIA_DIRECTOR:\\n\"+ OriginalCHARTER.MEDIA_DIRECTOR);         eng.add(\"OriginalCHARTER.DIRECTOR_OF_THE_DEVELOPMENT_OF_THE_IMPLEMENTATION_OF_CRYPTOCURRENCY_TECHNOLOGIES_OF_THE_INTERNATIONAL_TRADE_UNION_CORPORATION:\\n\"+ OriginalCHARTER.DIRECTOR_OF_THE_DEVELOPMENT_OF_THE_IMPLEMENTATION_OF_CRYPTOCURRENCY_TECHNOLOGIES_OF_THE_INTERNATIONAL_TRADE_UNION_CORPORATION);         eng.add(\"OriginalCHARTER.EXPLANATION_WHY_MONEY_DEMURAGE_IS_USED_HERE:\\n\"+ OriginalCHARTER.EXPLANATION_WHY_MONEY_DEMURAGE_IS_USED_HERE);         eng.add(\"OriginalCHARTER.FREEDOM_OF_SPEECH:\\n\"+ OriginalCHARTER.FREEDOM_OF_SPEECH);         eng.add(\"OriginalCHARTER.RIGHTS:\\n\"+ OriginalCHARTER.RIGHTS);           return eng;     } }","package International_Trade_Union.controllers;  import org.springframework.stereotype.Controller; import org.springframework.ui.Model; import org.springframework.web.bind.annotation.GetMapping; import org.springframework.web.bind.annotation.PostMapping; import org.springframework.web.servlet.mvc.support.RedirectAttributes; import International_Trade_Union.model.CreateAccount;  import java.security.InvalidAlgorithmParameterException; import java.security.NoSuchAlgorithmException; import java.security.NoSuchProviderException; import java.security.spec.InvalidKeySpecException; import java.util.Map;  @Controller public class CreateAccountController {       /**Позвалояет создавать счет, отображается в браузере*/     @GetMapping(\"create-account\")     public String createAccount(Model model) throws InvalidAlgorithmParameterException, NoSuchAlgorithmException, InvalidKeySpecException, NoSuchProviderException {         model.addAttribute(\"title\", \"create minerAccount\");         Map<String, String> newAccount = CreateAccount.create();          model.addAttribute(\"login\", newAccount.get(\"pubKey\"));         model.addAttribute(\"password\", newAccount.get(\"privKey\"));         return \"create-account\";     }       @PostMapping(\"create-account\")     public String createNewAccount(RedirectAttributes redirectAttrs) throws InvalidAlgorithmParameterException, NoSuchAlgorithmException, InvalidKeySpecException, NoSuchProviderException {         redirectAttrs.addFlashAttribute(\"title\", \"create minerAccount\");         Map<String, String> newAccount = CreateAccount.create();          redirectAttrs.addFlashAttribute(\"login\", newAccount.get(\"pubKey\"));         redirectAttrs.addFlashAttribute(\"password\", newAccount.get(\"privKey\"));          return \"redirect:/create-account\";     }  //    @PostMapping(\"save-creating-minerAccount\") //    public String saveNewAccount(Model model, @RequestParam String changeAddress){ //        User.setUserAddress(changeAddress); //        return \"redirect:/\"; //    }    }","package International_Trade_Union.controllers;  import International_Trade_Union.config.BlockchainFactoryEnum; import International_Trade_Union.entity.DtoTransaction.DtoTransaction; import International_Trade_Union.entity.blockchain.Blockchain; import International_Trade_Union.governments.Director; import International_Trade_Union.governments.Directors; import International_Trade_Union.governments.NamePOSITION; import International_Trade_Union.model.FIndPositonHelperData; import International_Trade_Union.model.Mining; import International_Trade_Union.network.AllTransactions; import International_Trade_Union.utils.base.Base; import International_Trade_Union.utils.base.Base58; import org.springframework.stereotype.Controller; import org.springframework.ui.Model; import org.springframework.web.bind.annotation.GetMapping; import International_Trade_Union.governments.UtilsGovernment; import International_Trade_Union.model.Account; import International_Trade_Union.setings.Seting; import International_Trade_Union.utils.*; import International_Trade_Union.vote.*; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RequestMethod; import org.springframework.web.bind.annotation.RequestParam; import org.springframework.web.servlet.mvc.support.RedirectAttributes;  import java.io.IOException; import java.security.*; import java.security.spec.InvalidKeySpecException; import java.util.*; import java.util.stream.Collectors;  @Controller public class GovernmentController {      //TODO если происходит майнинг почему то происходят ошибки, и если вызвать данный метод, то может     //TODO прерываться сам процесс майнинга     //TODO if mining occurs for some reason, errors are observed, and this method appears, then it can     //TODO interrupt the mining process itself      /**Отображает в браузере список действующих должностей*/     @GetMapping(\"/governments\")     public String corporateSeniorpositions(Model model) throws NoSuchAlgorithmException, InvalidKeySpecException, IOException, SignatureException, NoSuchProviderException, InvalidKeyException {         Blockchain blockchain = Mining.getBlockchain(                 Seting.ORIGINAL_BLOCKCHAIN_FILE,                 BlockchainFactoryEnum.ORIGINAL);          //за сколько времени занимает подсчет         Date start = new Date();         //Получение баланса         Map<String, Account> balances = new HashMap<>();          balances = SaveBalances.readLineObject(Seting.ORIGINAL_BALANCE_FILE);          //Нахождение должности         List<LawEligibleForParliamentaryApproval> allGovernment =                 UtilsLaws.readLineCurrentLaws(Seting.ORIGINAL_ALL_CORPORATION_LAWS_WITH_BALANCE_FILE);          //список должностей         Map<Director, List<LawEligibleForParliamentaryApproval>> positionsListMap = new HashMap<>();          Directors directors = new Directors();         //добавление всех должностей         for (Director higherSpecialPositions : directors.getDirectors()) {             positionsListMap.put(higherSpecialPositions, UtilsLaws.getPossions(allGovernment, higherSpecialPositions));         }          //список акционеров         List<Account> BoardOfShareholders = UtilsGovernment.findBoardOfShareholders(balances, blockchain.getBlockchainList(), Seting.BOARDS_BLOCK);          //список законов с голосами         Map<String, List<CurrentLawVotesEndBalance>> curentLawVotesEndBalance = new HashMap<>();          //TODO доработать оптимизацию         //TODO избавиться от find position в данном методе         Map<Director, FIndPositonHelperData> fIndPositonHelperDataMap = new HashMap<>();         for (Director higherSpecialPositions : directors.getDirectors()) {             if(higherSpecialPositions.isElectedByCEO()){                 fIndPositonHelperDataMap.put(higherSpecialPositions,                         new FIndPositonHelperData(higherSpecialPositions, false, false, true, false, false));             }             else if(higherSpecialPositions.isElectedByBoardOfDirectors()){                 fIndPositonHelperDataMap.put(higherSpecialPositions,                         new FIndPositonHelperData(higherSpecialPositions, false, false, false, true, false));             }             else if(higherSpecialPositions.isElectedByCorporateCouncilOfReferees()){                 fIndPositonHelperDataMap.put(higherSpecialPositions,                         new FIndPositonHelperData(higherSpecialPositions, false, false, false, false, true));             }             else {                 fIndPositonHelperDataMap.put(higherSpecialPositions,                         new FIndPositonHelperData(higherSpecialPositions, true, true, false ,false, false));              }          }          List<CurrentLawVotesEndBalance> current = UtilsGovernment.filtersVotes(                 allGovernment,                 balances,                 BoardOfShareholders,                 blockchain.getBlockchainList(),                 Seting.LAW_YEAR_VOTE);            //минимальное значение количество положительных голосов для того чтобы закон действовал,         //позиции избираемые акциями в совет директоров         List<CurrentLawVotesEndBalance> electedByStockBoardOfDirectors = current.stream()                 .filter(t -> directors.isElectedByStocks(t.getPackageName()))                 .filter(t -> t.getPackageName().equals(NamePOSITION.BOARD_OF_DIRECTORS.toString()))                 .filter(t -> t.getVotes() >= Seting.ORIGINAL_LIMIT_MIN_VOTE)                 .sorted(Comparator.comparing(CurrentLawVotesEndBalance::getVotes).reversed())                 .limit(directors.getDirector(NamePOSITION.BOARD_OF_DIRECTORS.toString()).getCount())                 .collect(Collectors.toList());           //минимальное значение количество положительных голосов для того чтобы закон действовал,         //позиции избираемые акциями electedByStockCorporateCouncilOfReferees         List<CurrentLawVotesEndBalance> electedByStockCorporateCouncilOfReferees = current.stream()                 .filter(t -> directors.isElectedByStocks(t.getPackageName()))                 .filter(t -> t.getPackageName().equals(NamePOSITION.CORPORATE_COUNCIL_OF_REFEREES.toString()))                 .filter(t -> t.getVotes() >= Seting.ORIGINAL_LIMIT_MIN_VOTE)                 .sorted(Comparator.comparing(CurrentLawVotesEndBalance::getVotes).reversed())                 .limit(directors.getDirector(NamePOSITION.CORPORATE_COUNCIL_OF_REFEREES.toString()).getCount())                 .collect(Collectors.toList());            //позиции созданные советом директоров         List<CurrentLawVotesEndBalance> createdByBoardOfDirectors = current.stream()                 .filter(t->t.getPackageName().startsWith(Seting.ADD_DIRECTOR))                 .filter(t->t.getVotesBoardOfDirectors() >= Seting.ORIGINAL_LIMIT_MIN_VOTE_BOARD_OF_DIRECTORS)                 .collect(Collectors.toList());         //добавление позиций созданных советом директоров         for (CurrentLawVotesEndBalance currentLawVotesEndBalance : createdByBoardOfDirectors) {             directors.addAllByBoardOfDirectors(currentLawVotesEndBalance.getLaws());         }          //позиции избираемые  только советом директоров в кабинет директоров         List<CurrentLawVotesEndBalance> electedByBoardOfDirectors = current.stream()                 .filter(t -> directors.isElectedByBoardOfDirectors(t.getPackageName()))                 .filter(t -> t.getVotesBoardOfDirectors() >= Seting.ORIGINAL_LIMIT_MIN_VOTE_BOARD_OF_DIRECTORS)                 .sorted(Comparator.comparing(CurrentLawVotesEndBalance::getVotesBoardOfDirectors).reversed())                 .collect(Collectors.toList());          List<CurrentLawVotesEndBalance> addDirectors = current.stream()                         .filter(t->directors.isCabinets(t.getPackageName()))                                 .filter(t->t.getVotesBoardOfDirectors() >= Seting.ORIGINAL_LIMIT_MIN_VOTE_BOARD_OF_DIRECTORS)                                         .collect(Collectors.toList());          System.out.println(\"***************************************\");         System.out.println(\"GovernmentController: corporateSeniorpositions: elected by Board of Directors;\");         electedByBoardOfDirectors.stream().forEach(System.out::println);         System.out.println(\"***************************************\");          //групируем по списку         Map<String, List<CurrentLawVotesEndBalance>> group = electedByBoardOfDirectors.stream()                 .collect(Collectors.groupingBy(CurrentLawVotesEndBalance::getPackageName));          Map<Director, List<CurrentLawVotesEndBalance>> original_group = new HashMap<>();          //оставляем то количество которое описано в данной должности         for (Map.Entry<String, List<CurrentLawVotesEndBalance>> stringListEntry : group.entrySet()) {             List<CurrentLawVotesEndBalance> temporary = stringListEntry.getValue();             temporary = temporary.stream()                     .sorted(Comparator.comparing(CurrentLawVotesEndBalance::getVotesBoardOfDirectors))                     .limit(directors.getDirector(stringListEntry.getKey()).getCount())                     .collect(Collectors.toList());             original_group.put(directors.getDirector(stringListEntry.getKey()), temporary);         }          //позиции избираемые палатой верховных судей         List<CurrentLawVotesEndBalance> electedByChamberOfSupremeJudges = current.stream()                 .filter(t -> directors.isElectedBYCorporateCouncilOfReferees(t.getPackageName()))                 .filter(t -> t.getVotesCorporateCouncilOfReferees() >= Seting.ORIGINAL_LIMIT_MIN_VOTE_CORPORATE_COUNCIL_OF_REFEREES)                 .sorted(Comparator.comparing(CurrentLawVotesEndBalance::getVotesCorporateCouncilOfReferees)).collect(Collectors.toList());            //избираемые премьер министром         List<CurrentLawVotesEndBalance> GENERAL_EXECUTIVE_DIRECTOR = electedByBoardOfDirectors.stream()                 .filter(t -> directors.isElectedCEO(t.getPackageName()))                 .filter(t -> NamePOSITION.GENERAL_EXECUTIVE_DIRECTOR.toString().equals(t.getPackageName()))                 .filter(t -> t.getVoteGeneralExecutiveDirector() >= Seting.ORIGINAL_LIMIT_MIN_VOTE_GENERAL_EXECUTIVE_DIRECTOR)                 .sorted(Comparator.comparing(CurrentLawVotesEndBalance::getVoteGeneralExecutiveDirector))                 .collect(Collectors.toList());          //избираемые верховным судьей         List<CurrentLawVotesEndBalance> electedByHightJudge = electedByChamberOfSupremeJudges.stream()                 .filter(t -> directors.isElectedBYCorporateCouncilOfReferees(t.getPackageName()))                 .filter(t -> t.getVoteHightJudge() >= Seting.ORIGINAL_LIMIT_MIN_VOTE_HIGHT_JUDGE)                 .collect(Collectors.toList());          curentLawVotesEndBalance.put(\"elected by GENERAL_EXECUTIVE_DIRECTOR: \", GENERAL_EXECUTIVE_DIRECTOR);         curentLawVotesEndBalance.put(\"elected by hight judge: \", electedByHightJudge);         curentLawVotesEndBalance.put(NamePOSITION.BOARD_OF_DIRECTORS.toString(), electedByStockBoardOfDirectors);         curentLawVotesEndBalance.put(NamePOSITION.CORPORATE_COUNCIL_OF_REFEREES.toString(), electedByStockCorporateCouncilOfReferees);         curentLawVotesEndBalance.put(NamePOSITION.HIGH_JUDGE.toString(), electedByChamberOfSupremeJudges);          for (Map.Entry<Director, List<CurrentLawVotesEndBalance>> higherSpecialPositionsListMap : original_group.entrySet()) {             curentLawVotesEndBalance.put(higherSpecialPositionsListMap.getKey().toString(), higherSpecialPositionsListMap.getValue());         }           Date finish = new Date();         System.out.println(\"given time: \" + new Date(finish.getTime() - start.getTime()));          model.addAttribute(\"show\", curentLawVotesEndBalance);          model.addAttribute(\"title\", \"current guidance\");          return \"/governments\";     }      @GetMapping(\"/create-position\")     public String createPositionShow(Model model) throws IOException, NoSuchAlgorithmException, InvalidKeySpecException, SignatureException, NoSuchProviderException, InvalidKeyException {         Blockchain blockchain = Mining.getBlockchain(                 Seting.ORIGINAL_BLOCKCHAIN_FILE,                 BlockchainFactoryEnum.ORIGINAL);         Map<String, Account> balances = new HashMap<>();         //считывать баланс         balances = SaveBalances.readLineObject(Seting.ORIGINAL_BALANCE_FILE);          Directors directors = new Directors();          List<LawEligibleForParliamentaryApproval> lawEligibleForParliamentaryApprovals =                 UtilsLaws.readLineCurrentLaws(Seting.ORIGINAL_ALL_CORPORATION_LAWS_WITH_BALANCE_FILE);           List<Account> boardOfShareholders = UtilsGovernment.findBoardOfShareholders(balances, blockchain.getBlockchainList(), Seting.BOARDS_BLOCK);          List<CurrentLawVotesEndBalance> current = UtilsGovernment.filtersVotes(                 lawEligibleForParliamentaryApprovals,                 balances,                 boardOfShareholders,                 blockchain.getBlockchainList(),                 Seting.LAW_YEAR_VOTE);           List<String> positions = directors.getDirectors().stream().map(t->t.getName()).collect(Collectors.toList());         //позиции созданные советом директоров          List<CurrentLawVotesEndBalance> createdByBoardOfDirectors = current.stream()                 .filter(t->t.getPackageName().startsWith(Seting.ADD_DIRECTOR))                 .filter(t->t.getVotesBoardOfDirectors() >= Seting.ORIGINAL_LIMIT_MIN_VOTE_BOARD_OF_DIRECTORS)                 .collect(Collectors.toList());         //добавление позиций созданных советом директоров         for (CurrentLawVotesEndBalance currentLawVotesEndBalance : createdByBoardOfDirectors) {             directors.addAllByBoardOfDirectors(currentLawVotesEndBalance.getLaws());         }           positions.addAll(directors.getNames());         positions = positions.stream().distinct().collect(Collectors.toList());         model.addAttribute(\"positions\", positions);         return \"create-position\";     }      /**Отображается в браузере, позволяет создавать новые должности*/     @RequestMapping(value = \"/create-position\", method = RequestMethod.POST, params = \"action=/send\")     public String createLaw(Model model,                             @RequestParam String sender,                             @RequestParam String reward,                             @RequestParam String nameLaw,                             @RequestParam String[] laws,                             @RequestParam String password,                             RedirectAttributes redirectAttrs) throws IOException, NoSuchAlgorithmException, SignatureException, NoSuchProviderException, InvalidKeyException, InvalidKeySpecException {           Laws law = new Laws(nameLaw, Arrays.asList(laws));         Base base = new Base58();          Double rewardD = Double.parseDouble(reward);           DtoTransaction dtoTransaction = new DtoTransaction(                 sender,                 law.getHashLaw(),                 0.0,                 0.0,                 law,                 rewardD,                 VoteEnum.valueOf(\"YES\"));         PrivateKey privateKey = UtilsSecurity.privateBytToPrivateKey(base.decode(password));         byte[] sign = UtilsSecurity.sign(privateKey, dtoTransaction.toSign());          redirectAttrs.addFlashAttribute(\"title\", \"sending result!!!\");         redirectAttrs.addFlashAttribute(\"sender\", sender);          redirectAttrs.addFlashAttribute(\"recipient\", law.getHashLaw());         redirectAttrs.addFlashAttribute(\"dollar\", 0.0);         redirectAttrs.addFlashAttribute(\"stock\", 0.0);         redirectAttrs.addFlashAttribute(\"reward\", rewardD);         redirectAttrs.addFlashAttribute(\"vote\", \"YES\");         dtoTransaction.setSign(sign);          if (dtoTransaction.verify() && UtilsGovernment.checkPostionSenderEqualsLaw(sender, law)) {             redirectAttrs.addFlashAttribute(\"sending\", \"success\");             AllTransactions.addTransaction(dtoTransaction);             String jsonDto = UtilsJson.objToStringJson(dtoTransaction);              for (String s : Seting.ORIGINAL_ADDRESSES) {                 String original = s;                 String url = s + \"/addTransaction\";                 if (BasisController.getExcludedAddresses().contains(url)) {                     System.out.println(\"its your address or excluded address: \" + url);                     continue;                 }                 try {                     UtilUrl.sendPost(jsonDto, url);                  } catch (Exception e) {                     System.out.println(\"exception discovery: \" + original);                  }             }         } else             redirectAttrs.addFlashAttribute(\"sending\", \"wrong transaction\");          return \"redirect:/result-sending\";      } }","package International_Trade_Union.controllers;  import International_Trade_Union.config.BLockchainFactory; import International_Trade_Union.config.BlockchainFactoryEnum; import International_Trade_Union.entity.blockchain.Blockchain; import International_Trade_Union.entity.blockchain.block.Block; import International_Trade_Union.governments.Director; import International_Trade_Union.governments.Directors; import International_Trade_Union.governments.NamePOSITION; import International_Trade_Union.model.FIndPositonHelperData; import International_Trade_Union.model.Mining; import org.springframework.stereotype.Controller; import org.springframework.ui.Model; import org.springframework.web.bind.annotation.*; import org.springframework.web.servlet.mvc.support.RedirectAttributes; import International_Trade_Union.entity.DtoTransaction.DtoTransaction; import International_Trade_Union.governments.UtilsGovernment; import International_Trade_Union.model.Account; import International_Trade_Union.network.AllTransactions; import International_Trade_Union.setings.Seting; import International_Trade_Union.utils.*; import International_Trade_Union.utils.base.Base; import International_Trade_Union.utils.base.Base58; import International_Trade_Union.vote.*;  import java.io.IOException; import java.security.*; import java.security.spec.InvalidKeySpecException; import java.util.*; import java.util.stream.Collectors;   @Controller public class LawsController {       @GetMapping(\"detail-laws\")     public String details(Model model) {         return \"detail-laws\";     }      //TODO реализовать голосвание       /**Отображается в браузере, позволяет увидеть содержимое пакета законов, список действующих законов*/     @GetMapping(\"/detail-laws-current/{addressLaw}\")     public String lawsDetail(@PathVariable(value = \"addressLaw\") String addressLaw, RedirectAttributes redirectAttrs) throws NoSuchAlgorithmException, InvalidKeySpecException, IOException, SignatureException, NoSuchProviderException, InvalidKeyException {         System.out.println(\"LawsController detail-laws-current/{addressLaw}: \" + addressLaw);         redirectAttrs.addAttribute(\"title\", \"detail laws\");         //Seting.ORIGINAL_CURRENT_FEDERAL_LAWS_FILE         List<LawEligibleForParliamentaryApproval> lawEligibleForParliamentaryApprovals =                 UtilsLaws.readLineCurrentLaws(Seting.ORIGINAL_ALL_CORPORATION_LAWS_WITH_BALANCE_FILE);          List<String> currntLaws = new ArrayList<>();         for (LawEligibleForParliamentaryApproval lawEligibleForParliamentaryApproval : lawEligibleForParliamentaryApprovals) {             int i = 0;             if (lawEligibleForParliamentaryApproval.getLaws().getHashLaw().equals(addressLaw)) {                  for (String str : lawEligibleForParliamentaryApproval.getLaws().getLaws()) {                      currntLaws.add(\"\" + i + \": \" + str);                     ++i;                 }              }         }          currntLaws.forEach(System.out::println);         redirectAttrs.addFlashAttribute(\"laws\", currntLaws);         return \"redirect:/detail-laws\";     }      /**Отображается в браузере, показывает содержимое пакета законов, из  списка всех законов*/     @GetMapping(\"/detail-laws-all/{addressLaw}\")     public String lawsDetailAll(@PathVariable(value = \"addressLaw\") String addressLaw, RedirectAttributes redirectAttrs) throws NoSuchAlgorithmException, InvalidKeySpecException, IOException, SignatureException, NoSuchProviderException, InvalidKeyException {         System.out.println(\"LawsController /detail-laws-all/{addressLaw}: \" + addressLaw);         redirectAttrs.addAttribute(\"title\", \"detail laws\");         //ORIGINAL_ALL_CORPORATION_LAWS_FILE         List<Laws> laws = UtilsLaws.readLineLaws(Seting.ORIGINAL_ALL_CORPORATION_LAWS_FILE);         List<String> allLaws = new ArrayList<>();         for (Laws laws1 : laws) {             int i = 0;             if (laws1.getHashLaw().equals(addressLaw)) {                  for (String s : laws1.getLaws()) {                     allLaws.add(\"\" + i + \": \" + s);                     ++i;                 }              }         }          redirectAttrs.addFlashAttribute(\"laws\", allLaws);         return \"redirect:/detail-laws\";     }       @GetMapping(\"/sanction\")     public String sanction(Model model){         return \"/sanction\";     }      @PostMapping(\"/sanction\")     public String sanction(             @RequestParam             String sender,             String recipient,             Double stock,             Double reward,             String password,             RedirectAttributes redirectAttrs      ) throws IOException, NoSuchAlgorithmException, SignatureException, InvalidKeySpecException, NoSuchProviderException, InvalidKeyException {         Base base = new Base58();          Laws laws =  new Laws();         laws.setLaws(new ArrayList<>());         laws.setHashLaw(\"\");         laws.setPacketLawName(\"\");         DtoTransaction dtoTransaction = new DtoTransaction(                 sender,                 recipient,                 0.0,                 stock,                 laws,                 reward,                 VoteEnum.NO);         PrivateKey privateKey = UtilsSecurity.privateBytToPrivateKey(base.decode(password));         byte[] sign = UtilsSecurity.sign(privateKey, dtoTransaction.toSign());         System.out.println(\"Main Controller: new transaction: vote: \" + VoteEnum.NO);         redirectAttrs.addFlashAttribute(\"title\", \"sending result!!!\");         redirectAttrs.addFlashAttribute(\"sender\", sender);         redirectAttrs.addFlashAttribute(\"recipient\", recipient);         redirectAttrs.addFlashAttribute(\"dollar\", 0.0);         redirectAttrs.addFlashAttribute(\"stock\", stock);         redirectAttrs.addFlashAttribute(\"reward\", reward);         redirectAttrs.addFlashAttribute(\"vote\", VoteEnum.NO);         dtoTransaction.setSign(sign);         Directors directors = new Directors();         if(dtoTransaction.verify()){              //если в названия закона совпадает с корпоративными должностями, то закон является действительным только когда             //отправитель совпадает с законом             List<String> corporateSeniorPositions = directors.getDirectors().stream()                     .map(t->t.getName()).collect(Collectors.toList());             System.out.println(\"LawsController: create_law: \" + laws.getPacketLawName() + \"contains: \" + corporateSeniorPositions.contains(laws.getPacketLawName()));             if(corporateSeniorPositions.contains(laws.getPacketLawName()) && !UtilsGovernment.checkPostionSenderEqualsLaw(sender, laws)){                 redirectAttrs.addFlashAttribute(\"sending\", \"wrong transaction: Position to be equals whith send\");                 return \"redirect:/result-sending\";             }             redirectAttrs.addFlashAttribute(\"sending\", \"success\");             System.out.println(\"dto MainController: \" + dtoTransaction);              AllTransactions.addTransaction(dtoTransaction);             String jsonDto = UtilsJson.objToStringJson(dtoTransaction);             for (String s : Seting.ORIGINAL_ADDRESSES) {                  String original = s;                 String url = s +\"/addTransaction\";                 //если адресс совпадает с внутреним хостом, то не отправляет самому себе                 if(BasisController.getExcludedAddresses().contains(url)){                     System.out.println(\"MainController: its your address or excluded address: \" + url);                     continue;                 }                 try {                     //отправка в сеть                     UtilUrl.sendPost(jsonDto, url);                  }catch (Exception e){                     System.out.println(\"exception discover: \" + original);                  }             }            }          else             redirectAttrs.addFlashAttribute(\"sending\", \"wrong transaction\");         return \"redirect:/result-sending\";     }     /**Голосование учитывает голоса как акций, так и голоса избраных представителей*/     @GetMapping(\"/voting\")     public String lawVoting(){         return \"/voting\";     }     @PostMapping(\"/voting\")     public String lawVoting(             @RequestParam             String sender,             String recipient,             Double reward,             String vote,             String password,             RedirectAttributes redirectAttrs      ) throws IOException, NoSuchAlgorithmException, SignatureException, InvalidKeySpecException, NoSuchProviderException, InvalidKeyException {         Base base = new Base58();         vote = vote.toUpperCase(Locale.ROOT);         Laws laws =  new Laws();         laws.setLaws(new ArrayList<>());         laws.setHashLaw(\"\");         laws.setPacketLawName(\"\");         System.out.println(\"LawController: Voting: \" + VoteEnum.valueOf(vote));         DtoTransaction dtoTransaction = new DtoTransaction(                 sender,                 recipient,                 0.0,                 0.0,                 laws,                 reward,                 VoteEnum.valueOf(vote));         PrivateKey privateKey = UtilsSecurity.privateBytToPrivateKey(base.decode(password));         byte[] sign = UtilsSecurity.sign(privateKey, dtoTransaction.toSign());         System.out.println(\"Main Controller: new transaction: vote: \" + vote);         redirectAttrs.addFlashAttribute(\"title\", \"sending result!!!\");         redirectAttrs.addFlashAttribute(\"sender\", sender);         redirectAttrs.addFlashAttribute(\"recipient\", recipient);         redirectAttrs.addFlashAttribute(\"dollar\", 0.0);         redirectAttrs.addFlashAttribute(\"stock\", 0.0);         redirectAttrs.addFlashAttribute(\"reward\", reward);         redirectAttrs.addFlashAttribute(\"vote\", vote);         dtoTransaction.setSign(sign);         Directors directors = new Directors();         if(dtoTransaction.verify()){              //если в названия закона совпадает с корпоративными должностями, то закон является действительным только когда             //отправитель совпадает с законом             List<String> corporateSeniorPositions = directors.getDirectors().stream()                     .map(t->t.getName()).collect(Collectors.toList());             System.out.println(\"LawsController: create_law: \" + laws.getPacketLawName() + \"contains: \" + corporateSeniorPositions.contains(laws.getPacketLawName()));             if(corporateSeniorPositions.contains(laws.getPacketLawName()) && !UtilsGovernment.checkPostionSenderEqualsLaw(sender, laws)){                 redirectAttrs.addFlashAttribute(\"sending\", \"wrong transaction: Position to be equals whith send\");                 return \"redirect:/result-sending\";             }             redirectAttrs.addFlashAttribute(\"sending\", \"success\");             System.out.println(\"dto MainController: \" + dtoTransaction);              AllTransactions.addTransaction(dtoTransaction);             String jsonDto = UtilsJson.objToStringJson(dtoTransaction);             for (String s : Seting.ORIGINAL_ADDRESSES) {                  String original = s;                 String url = s +\"/addTransaction\";                 //если адресс совпадает с внутреним хостом, то не отправляет самому себе                 if(BasisController.getExcludedAddresses().contains(url)){                     System.out.println(\"MainController: its your address or excluded address: \" + url);                     continue;                 }                 try {                     //отправка в сеть                     UtilUrl.sendPost(jsonDto, url);                  }catch (Exception e){                     System.out.println(\"exception discover: \" + original);                  }             }            }          else             redirectAttrs.addFlashAttribute(\"sending\", \"wrong transaction\");         return \"redirect:/result-sending\";     }     /**Отображается в браузере, список все действующих законов*/     @GetMapping(\"/current-laws\")     public String currentLaw(Model model) throws IOException, NoSuchAlgorithmException, InvalidKeySpecException, SignatureException, NoSuchProviderException, InvalidKeyException, CloneNotSupportedException {         Directors directors = new Directors();         Blockchain blockchain = Mining.getBlockchain(                 Seting.ORIGINAL_BLOCKCHAIN_FILE,                 BlockchainFactoryEnum.ORIGINAL);          Map<String, Account> balances = new HashMap<>();         //считывать баланс         balances = SaveBalances.readLineObject(Seting.ORIGINAL_BALANCE_FILE);          List<LawEligibleForParliamentaryApproval> lawEligibleForParliamentaryApprovals =                 UtilsLaws.readLineCurrentLaws(Seting.ORIGINAL_ALL_CORPORATION_LAWS_WITH_BALANCE_FILE);          //получить совет акционеров из файла         List<Account> boardOfShareholders = UtilsGovernment.findBoardOfShareholders(balances, blockchain.getBlockchainList(), Seting.BOARDS_BLOCK);           //TODO доработать оптимизацию         //TODO избавиться от find position в данном методе         //отфильтровать по типам голосов         Map<Director, FIndPositonHelperData> fIndPositonHelperDataMap = new HashMap<>();         for (Director higherSpecialPositions : directors.getDirectors()) {             if (higherSpecialPositions.isElectedByCEO()) {                 fIndPositonHelperDataMap.put(higherSpecialPositions,                         new FIndPositonHelperData(higherSpecialPositions, false, false, true, false, false));             } else if (higherSpecialPositions.isElectedByBoardOfDirectors()) {                 fIndPositonHelperDataMap.put(higherSpecialPositions,                         new FIndPositonHelperData(higherSpecialPositions, false, false, false, true, false));             } else if (higherSpecialPositions.isElectedByCorporateCouncilOfReferees()) {                 fIndPositonHelperDataMap.put(higherSpecialPositions,                         new FIndPositonHelperData(higherSpecialPositions, false, false, false, false, true));             } else {                 fIndPositonHelperDataMap.put(higherSpecialPositions,                         new FIndPositonHelperData(higherSpecialPositions, true, true, false, false, false));              }          }         //подсчитать голоса за все проголосованные заканы         List<CurrentLawVotesEndBalance> current = UtilsGovernment.filtersVotes(                 lawEligibleForParliamentaryApprovals,                 balances,                 boardOfShareholders,                 blockchain.getBlockchainList(),                 Seting.LAW_YEAR_VOTE);             //минимальное значение количество положительных голосов для того чтобы закон действовал,         //позиции избираемые акциями совета директоров         List<CurrentLawVotesEndBalance> electedByStockBoardOfDirectors = current.stream()                 .filter(t -> directors.isElectedByStocks(t.getPackageName()))                 .filter(t -> t.getPackageName().equals(NamePOSITION.BOARD_OF_DIRECTORS.toString()))                 .filter(t -> t.getVotes() >= Seting.ORIGINAL_LIMIT_MIN_VOTE)                 .sorted(Comparator.comparing(CurrentLawVotesEndBalance::getVotes).reversed())                 .limit(directors.getDirector(NamePOSITION.BOARD_OF_DIRECTORS.toString()).getCount())                 .collect(Collectors.toList());           //минимальное значение количество положительных голосов для того чтобы закон действовал,         //позиции избираемые акциями CORPORATE_COUNCIL_OF_REFEREES         List<CurrentLawVotesEndBalance> electedByStockCorporateCouncilOfReferees = current.stream()                 .filter(t -> directors.isElectedByStocks(t.getPackageName()))                 .filter(t -> t.getPackageName().equals(NamePOSITION.CORPORATE_COUNCIL_OF_REFEREES.toString()))                 .filter(t -> t.getVotes() >= Seting.ORIGINAL_LIMIT_MIN_VOTE)                 .sorted(Comparator.comparing(CurrentLawVotesEndBalance::getVotes).reversed())                 .limit(directors.getDirector(NamePOSITION.CORPORATE_COUNCIL_OF_REFEREES.toString()).getCount())                 .collect(Collectors.toList());            //позиции созданные советом директоров         List<CurrentLawVotesEndBalance> createdByBoardOfDirectors = current.stream()                 .filter(t->t.getPackageName().startsWith(Seting.ADD_DIRECTOR))                 .filter(t->t.getVotesBoardOfDirectors() >= Seting.ORIGINAL_LIMIT_MIN_VOTE_BOARD_OF_DIRECTORS)                 .collect(Collectors.toList());         //добавление позиций созданных советом директоров         for (CurrentLawVotesEndBalance currentLawVotesEndBalance : createdByBoardOfDirectors) {             directors.addAllByBoardOfDirectors(currentLawVotesEndBalance.getLaws());         }          //позиции избираемые только советом директоров         List<CurrentLawVotesEndBalance> electedByBoardOfDirectors = current.stream()                 .filter(t -> directors.isElectedByBoardOfDirectors(t.getPackageName()) || directors.isCabinets(t.getPackageName()))                 .filter(t -> t.getVotesBoardOfDirectors() >= Seting.ORIGINAL_LIMIT_MIN_VOTE_BOARD_OF_DIRECTORS)                 .sorted(Comparator.comparing(CurrentLawVotesEndBalance::getVotesBoardOfDirectors).reversed())                 .collect(Collectors.toList());           //групируем по списку         Map<String, List<CurrentLawVotesEndBalance>> group = electedByBoardOfDirectors.stream()                 .collect(Collectors.groupingBy(CurrentLawVotesEndBalance::getPackageName));          Map<Director, List<CurrentLawVotesEndBalance>> original_group = new HashMap<>();          //оставляем то количество которое описано в данной должности         for (Map.Entry<String, List<CurrentLawVotesEndBalance>> stringListEntry : group.entrySet()) {             List<CurrentLawVotesEndBalance> temporary = stringListEntry.getValue();             temporary = temporary.stream()                     .sorted(Comparator.comparing(CurrentLawVotesEndBalance::getVotesBoardOfDirectors))                     .limit(directors.getDirector(stringListEntry.getKey()).getCount())                     .collect(Collectors.toList());             original_group.put(directors.getDirector(stringListEntry.getKey()), temporary);         }            //позиции избираемые советом корпоративных верховных судей         List<CurrentLawVotesEndBalance> electedByCorporateCouncilOfReferees = current.stream()                 .filter(t -> directors.isElectedBYCorporateCouncilOfReferees(t.getPackageName()))                 .filter(t -> t.getVotesCorporateCouncilOfReferees() >= Seting.ORIGINAL_LIMIT_MIN_VOTE_CORPORATE_COUNCIL_OF_REFEREES)                 .sorted(Comparator.comparing(CurrentLawVotesEndBalance::getVotesCorporateCouncilOfReferees)).collect(Collectors.toList());           //избираемые GENERAL_EXECUTIVE_DIRECTOR         List<CurrentLawVotesEndBalance> electedByGeneralExecutiveDirector = electedByBoardOfDirectors.stream()                 .filter(t -> directors.isElectedCEO(t.getPackageName()))                 .filter(t -> NamePOSITION.GENERAL_EXECUTIVE_DIRECTOR.toString().equals(t.getPackageName()))                 .filter(t -> t.getVoteGeneralExecutiveDirector() >= Seting.ORIGINAL_LIMIT_MIN_VOTE_GENERAL_EXECUTIVE_DIRECTOR)                 .sorted(Comparator.comparing(CurrentLawVotesEndBalance::getVoteGeneralExecutiveDirector))                 .collect(Collectors.toList());          //голос верховного судьи         List<CurrentLawVotesEndBalance> electedByHightJudge = electedByCorporateCouncilOfReferees.stream()                 .filter(t -> directors.isElectedBYCorporateCouncilOfReferees(t.getPackageName()))                 .filter(t -> t.getVoteHightJudge() >= Seting.ORIGINAL_LIMIT_MIN_VOTE_HIGHT_JUDGE)                 .collect(Collectors.toList());          //ЗАКОНЫ КОТОРЫЕ БЫЛИ ОДОБРЕНЫ ЧЕРЕЗ ПРЯМОЕ ГОЛОСОВАНИЕ         List<CurrentLawVotesEndBalance> allVotes = current.stream()                 .filter(t->!directors.contains(t.getPackageName()))                 .filter(t->!Seting.AMENDMENT_TO_THE_CHARTER.equals(t.getPackageName()))                 .filter(t->!directors.isCabinets(t.getPackageName()))                 .filter(t->!Seting.ORIGINAL_CHARTER_CURRENT_LAW_PACKAGE_NAME.equals(t.getPackageName()))                 .filter(t->!Seting.ORIGINAL_CHARTER_CURRENT_ALL_CODE.equals(t.getPackageName()))                 .filter(t->t.getVotes() > Seting.ALL_STOCK_VOTE)                 .collect(Collectors.toList());          //законы которые получили не достаточно голосов которые могут пройти только если верховный судья одобрет         List<CurrentLawVotesEndBalance> notEnoughVotes = current.stream()                 .filter(t -> !directors.contains(t.getPackageName()))                 .filter(t->!Seting.AMENDMENT_TO_THE_CHARTER.equals(t.getPackageName()))                 .filter(t->!directors.isCabinets(t.getPackageName()))                 .filter(t -> !Seting.ORIGINAL_CHARTER_CURRENT_LAW_PACKAGE_NAME.equals(t.getPackageName()))                 .filter(t->!Seting.ORIGINAL_CHARTER_CURRENT_ALL_CODE.equals(t.getPackageName()))                 .filter(t -> t.getVotesBoardOfShareholders() >= Seting.ORIGINAL_LIMIT_MIN_VOTE_BOARD_OF_SHAREHOLDERS)                 .filter(t -> t.getVotesBoardOfDirectors() >= Seting.ORIGINAL_LIMIT_MIN_VOTE_BOARD_OF_DIRECTORS)                 .filter(t -> t.getVoteHightJudge() >= Seting.ORIGINAL_LIMIT_MIN_VOTE_HIGHT_JUDGE)                 .sorted(Comparator.comparing(CurrentLawVotesEndBalance::getVotes).reversed()).collect(Collectors.toList());           //законы которые получили достаточно голосов и не требуют одобрения верховного судьи         List<CurrentLawVotesEndBalance> powerfulVotes = current.stream()                 .filter(t -> !directors.contains(t.getPackageName()))                 .filter(t-> !Seting.AMENDMENT_TO_THE_CHARTER.equals(t.getPackageName()))                 .filter(t-> !directors.isCabinets(t.getPackageName()))                 .filter(t -> !Seting.ORIGINAL_CHARTER_CURRENT_LAW_PACKAGE_NAME.equals(t.getPackageName()))                 .filter(t->!Seting.ORIGINAL_CHARTER_CURRENT_ALL_CODE.equals(t.getPackageName()))                 .filter(t -> t.getVotesBoardOfShareholders() >= (Seting.ORIGINAL_LIMIT_MIN_VOTE_BOARD_OF_SHAREHOLDERS * Seting.POWERFUL_VOTE))                 .filter(t -> t.getVotesBoardOfDirectors() >= (Seting.ORIGINAL_LIMIT_MIN_VOTE_BOARD_OF_DIRECTORS * Seting.POWERFUL_VOTE))                 .sorted(Comparator.comparing(CurrentLawVotesEndBalance::getVotes).reversed()).collect(Collectors.toList());          //удаление совпадающих голосов         notEnoughVotes.addAll(powerfulVotes);         notEnoughVotes = notEnoughVotes.stream().distinct().collect(Collectors.toList());          //внедрение поправок в устав         List<CurrentLawVotesEndBalance> chapter_amendment = current.stream()                 .filter(t -> !directors.contains(t.getPackageName()))                 .filter(t-> Seting.AMENDMENT_TO_THE_CHARTER.equals(t.getPackageName()))                 .filter(t->!directors.isCabinets(t.getPackageName()))                 .filter(t -> t.getVotesBoardOfShareholders() >= Seting.ORIGINAL_LIMIT_MINT_VOTE_BOARD_OF_SHAREHOLDERS_AMENDMENT)                 .filter(t -> t.getVotesBoardOfDirectors() >= Seting.ORIGINAL_LIMIT_MIN_VOTE_BOARD_OF_DIRECTORS_AMENDMENT)                 .filter(t -> t.getVotesCorporateCouncilOfReferees() >= Seting.ORIGINAL_LIMIT_MIN_VOTE_CORPORATE_COUNCIL_OF_REFEREES_AMENDMENT)                 .sorted(Comparator.comparing(CurrentLawVotesEndBalance::getVotesBoardOfDirectors).reversed()).collect(Collectors.toList());          //бюджет утверждается только советом директоров.         List<CurrentLawVotesEndBalance> budjet = current.stream()                 .filter(t-> !directors.contains(t.getPackageName()))                 .filter(t->Seting.BUDGET.equals(t.getPackageName()))                 .filter(t->!directors.isCabinets(t.getPackageName()))                 .filter(t-> t.getVotesBoardOfDirectors() >= Seting.ORIGINAL_LIMIT_MIN_VOTE_BOARD_OF_DIRECTORS)                 .sorted(Comparator.comparing(CurrentLawVotesEndBalance::getVotesBoardOfDirectors).reversed())                 .limit(1)                 .collect(Collectors.toList());           //добавляет законы, которые создают новые должности директоров         List<CurrentLawVotesEndBalance> addDirectors = current.stream()                 .filter(t->t.getPackageName().startsWith(Seting.ADD_DIRECTOR))                 .filter(t->t.getVotesBoardOfDirectors() >= Seting.ORIGINAL_LIMIT_MIN_VOTE_BOARD_OF_DIRECTORS)                 .collect(Collectors.toList());          //план утверждается только палатой Советом Директоров         List<CurrentLawVotesEndBalance> planFourYears = current.stream()                 .filter(t->!directors.contains(t.getPackageName()))                 .filter(t->Seting.STRATEGIC_PLAN.equals(t.getPackageName()))                 .filter(t->!directors.isCabinets(t.getPackageName()))                 .filter(t->t.getVotesBoardOfDirectors() >= Seting.ORIGINAL_LIMIT_MIN_VOTE_BOARD_OF_DIRECTORS)                 .sorted(Comparator.comparing(CurrentLawVotesEndBalance::getVotesBoardOfDirectors).reversed())                 .limit(1)                 .collect(Collectors.toList());           //устав всегда действующий он подписан основателем         List<CurrentLawVotesEndBalance> CHARTER_ORIGINAL = current.stream()                 .filter(t -> !directors.contains(t.getPackageName()) && Seting.ORIGINAL_CHARTER_CURRENT_LAW_PACKAGE_NAME.equals(t.getPackageName()))                 .filter(t->!directors.isCabinets(t.getPackageName()))                 .filter(t->t.getFounderVote()>=1)                 .sorted(Comparator.comparing(CurrentLawVotesEndBalance::getVotes).reversed())                 .limit(1)                 .collect(Collectors.toList());          //ИСХОДНЫЙ КОД СОЗДАННЫЙ ОСНОВАТЕЛЕМ         List<CurrentLawVotesEndBalance> CHARTER_ORIGINAL_CODE = current.stream()                 .filter(t -> !directors.contains(t.getPackageName()) && Seting.ORIGINAL_CHARTER_CURRENT_ALL_CODE.equals(t.getPackageName()))                 .filter(t->!directors.isCabinets(t.getPackageName()))                 .filter(t->t.getFounderVote()>=1)                 .sorted(Comparator.comparing(CurrentLawVotesEndBalance::getVotes).reversed())                 .limit(1)                 .collect(Collectors.toList());           int startBlock = 22820;         int finishBlock = 22830;         if(blockchain.sizeBlockhain() > finishBlock){             List<Block> blocksCharter = blockchain.subBlock(startBlock, finishBlock);             //учитывает отрезок блоков для выяснения подлиности устава             List<CurrentLawVotesEndBalance> charterBlocks = UtilsGovernment.filtersVotes(                     lawEligibleForParliamentaryApprovals,                     balances,                     boardOfShareholders,                     blocksCharter,                     Seting.LAW_YEAR_VOTE             );             List<CurrentLawVotesEndBalance> charterCheckBlock = charterBlocks.stream()                     .filter(t -> !directors.contains(t.getPackageName()) && Seting.ORIGINAL_CHARTER_CURRENT_LAW_PACKAGE_NAME.equals(t.getPackageName()))                     .filter(t->!directors.isCabinets(t.getPackageName()))                     .filter(t->t.getFounderVote()>=1)                     .sorted(Comparator.comparing(CurrentLawVotesEndBalance::getVotes).reversed())                     .limit(1)                     .collect(Collectors.toList());              CHARTER_ORIGINAL.addAll(charterCheckBlock);               List<CurrentLawVotesEndBalance> charterOriginalCode = charterBlocks.stream()                     .filter(t -> !directors.contains(t.getPackageName()) && Seting.ORIGINAL_CHARTER_CURRENT_ALL_CODE.equals(t.getPackageName()))                     .filter(t->!directors.isCabinets(t.getPackageName()))                     .filter(t->t.getFounderVote()>=1)                     .sorted(Comparator.comparing(CurrentLawVotesEndBalance::getVotes).reversed())                     .limit(1)                     .collect(Collectors.toList());              CHARTER_ORIGINAL_CODE.addAll(charterOriginalCode);         }           for (Map.Entry<Director, List<CurrentLawVotesEndBalance>> higherSpecialPositionsListMap : original_group.entrySet()) {             current.addAll(higherSpecialPositionsListMap.getValue());         }           current = new ArrayList<>();         current.addAll(addDirectors);         current.addAll(allVotes);         current.addAll(budjet);         current.addAll(planFourYears);         current.addAll(electedByStockBoardOfDirectors);         current.addAll(electedByStockCorporateCouncilOfReferees);         current.addAll(electedByBoardOfDirectors);         current.addAll(electedByCorporateCouncilOfReferees);         current.addAll(electedByGeneralExecutiveDirector);         current.addAll(electedByHightJudge);         current.addAll(notEnoughVotes);         current.addAll(CHARTER_ORIGINAL);         current.addAll(CHARTER_ORIGINAL_CODE);         current.addAll(chapter_amendment);         current = current.stream()                 .filter(UtilsUse.distinctByKey(CurrentLawVotesEndBalance::getAddressLaw))                 .collect(Collectors.toList());         System.out.println(\"notEnoughVotes: \" + notEnoughVotes);          model.addAttribute(\"title\", \"Как принимаются действующие законы, описано в уставе.\" +                 \" \");         model.addAttribute(\"currentLaw\", current);         return \"current-laws\";     }      /**Отображается в браузере, список всех пакета законов*/     @GetMapping(\"/all-laws\")     public String allLaws(Model model) throws IOException, NoSuchAlgorithmException, InvalidKeySpecException, SignatureException, NoSuchProviderException, InvalidKeyException {         Blockchain blockchain = Mining.getBlockchain(                 Seting.ORIGINAL_BLOCKCHAIN_FILE,                 BlockchainFactoryEnum.ORIGINAL);          Map<String, Account> balances = new HashMap<>();         balances = SaveBalances.readLineObject(Seting.ORIGINAL_BALANCE_FILE);           List<Account> boardOfShareholders = UtilsGovernment.findBoardOfShareholders(balances, blockchain.getBlockchainList(), Seting.BOARDS_BLOCK);           List<LawEligibleForParliamentaryApproval> lawEligibleForParliamentaryApprovals =                 UtilsLaws.readLineCurrentLaws(Seting.ORIGINAL_ALL_CORPORATION_LAWS_WITH_BALANCE_FILE);         //данные для отображения           Directors directors = new Directors();         //TODO доработать оптимизацию         //TODO избавиться от find position в данном методе         //TODO доработать оптимизацию         //TODO избавиться от find position в данном методе         Map<Director, FIndPositonHelperData> fIndPositonHelperDataMap = new HashMap<>();         for (Director higherSpecialPositions : directors.getDirectors()) {             if (higherSpecialPositions.isElectedByCEO()) {                 fIndPositonHelperDataMap.put(higherSpecialPositions,                         new FIndPositonHelperData(higherSpecialPositions, false, false, true, false, false));             } else if (higherSpecialPositions.isElectedByBoardOfDirectors()) {                 fIndPositonHelperDataMap.put(higherSpecialPositions,                         new FIndPositonHelperData(higherSpecialPositions, false, false, false, true, false));             } else if (higherSpecialPositions.isElectedByCorporateCouncilOfReferees()) {                 fIndPositonHelperDataMap.put(higherSpecialPositions,                         new FIndPositonHelperData(higherSpecialPositions, false, false, false, false, true));             } else if (higherSpecialPositions.isElectedByStocks()) {                 fIndPositonHelperDataMap.put(higherSpecialPositions,                         new FIndPositonHelperData(higherSpecialPositions, true, true, false, false, false));              }          }           List<CurrentLawVotesEndBalance> current = UtilsGovernment.filtersVotes(                 lawEligibleForParliamentaryApprovals,                 balances,                 boardOfShareholders,                 blockchain.getBlockchainList(),                 Seting.LAW_YEAR_VOTE);           current = current.stream().distinct().collect(Collectors.toList());          current = current.stream().sorted(Comparator.comparing(CurrentLawVotesEndBalance::getVotes).reversed()).collect(Collectors.toList());         model.addAttribute(\"allLaws\", current);         return \"all-laws\";     }       /**Создать новую должность*/     @GetMapping(\"/add_position\")     public String addPostion(Model model){         model.addAttribute(\"title\", \"Создание новой должности\");         return \"add_position\";     }      @PostMapping(\"/add_position\")     public String addPosition( @RequestParam String sender,                                @RequestParam String reward,                                @RequestParam String nameLaw,                                @RequestParam String[] laws,                                @RequestParam String password,                                RedirectAttributes redirectAttrs) throws IOException, NoSuchAlgorithmException, SignatureException, InvalidKeySpecException, NoSuchProviderException, InvalidKeyException {          nameLaw = Seting.ADD_DIRECTOR + nameLaw;         String[] lawsAdd = new String[laws.length];         for (int i = 0; i < laws.length; i++) {             lawsAdd[i] = Seting.ADD_DIRECTOR + laws[i];         }         laws = lawsAdd;          Laws law = new Laws(nameLaw, Arrays.asList(laws));         Base base = new Base58();          Double rewardD = Double.parseDouble(reward);           DtoTransaction dtoTransaction = new DtoTransaction(                 sender,                 law.getHashLaw(),                 0.0,                 0.0,                 law,                 rewardD,                 VoteEnum.valueOf(\"YES\"));         PrivateKey privateKey = UtilsSecurity.privateBytToPrivateKey(base.decode(password));         byte[] sign = UtilsSecurity.sign(privateKey, dtoTransaction.toSign());          redirectAttrs.addFlashAttribute(\"title\", \"sending result!!!\");         redirectAttrs.addFlashAttribute(\"sender\", sender);          redirectAttrs.addFlashAttribute(\"recipient\", law.getHashLaw());         redirectAttrs.addFlashAttribute(\"dollar\", 0.0);         redirectAttrs.addFlashAttribute(\"stock\", 0.0);         redirectAttrs.addFlashAttribute(\"reward\", rewardD);         redirectAttrs.addFlashAttribute(\"vote\", \"YES\");         dtoTransaction.setSign(sign);          Directors directors = new Directors();         if (dtoTransaction.verify()) {              //если в названия закона совпадает с корпоративными должностями, то закон является действительным только когда             //отправитель совпадает с законом             List<Director> enumPosition = directors.getDirectors();             List<String> corporateSeniorPositions = enumPosition.stream()                     .map(t->t.getName())                     .collect(Collectors.toList());              if (corporateSeniorPositions.contains(law.getPacketLawName()) && !UtilsGovernment.checkPostionSenderEqualsLaw(sender, law)) {                 redirectAttrs.addFlashAttribute(\"sending\", \"wrong transaction: Position to be equals whith send\");                 return \"redirect:/result-sending\";             }              redirectAttrs.addFlashAttribute(\"sending\", \"success\");             AllTransactions.addTransaction(dtoTransaction);             String jsonDto = UtilsJson.objToStringJson(dtoTransaction);              for (String s : Seting.ORIGINAL_ADDRESSES) {                 String original = s;                 String url = s + \"/addTransaction\";                 if (BasisController.getExcludedAddresses().contains(url)) {                     System.out.println(\"its your address or excluded address: \" + url);                     continue;                 }                 try {                     UtilUrl.sendPost(jsonDto, url);                  } catch (Exception e) {                     System.out.println(\"exception discovery: \" + original);                  }             }         } else             redirectAttrs.addFlashAttribute(\"sending\", \"wrong transaction\");          return \"redirect:/result-sending\";      }      /**Отображается в браузере, позволяет создать новый пакет законов*/     @GetMapping(\"/create-law\")     public String createLawsShow(Model model) {         return \"create-law\";     }       @RequestMapping(value = \"/create-law\", method = RequestMethod.POST, params = \"action=/send\")     public String createLaw(Model model,                             @RequestParam String sender,                             @RequestParam String reward,                             @RequestParam String nameLaw,                             @RequestParam String[] laws,                             @RequestParam String password,                             RedirectAttributes redirectAttrs) throws IOException, NoSuchAlgorithmException, SignatureException, NoSuchProviderException, InvalidKeyException, InvalidKeySpecException {           Laws law = new Laws(nameLaw, Arrays.asList(laws));         Base base = new Base58();          Double rewardD = Double.parseDouble(reward);           DtoTransaction dtoTransaction = new DtoTransaction(                 sender,                 law.getHashLaw(),                 0.0,                 0.0,                 law,                 rewardD,                 VoteEnum.valueOf(\"YES\"));         PrivateKey privateKey = UtilsSecurity.privateBytToPrivateKey(base.decode(password));         byte[] sign = UtilsSecurity.sign(privateKey, dtoTransaction.toSign());          redirectAttrs.addFlashAttribute(\"title\", \"sending result!!!\");         redirectAttrs.addFlashAttribute(\"sender\", sender);          redirectAttrs.addFlashAttribute(\"recipient\", law.getHashLaw());         redirectAttrs.addFlashAttribute(\"dollar\", 0.0);         redirectAttrs.addFlashAttribute(\"stock\", 0.0);         redirectAttrs.addFlashAttribute(\"reward\", rewardD);         redirectAttrs.addFlashAttribute(\"vote\", \"YES\");         dtoTransaction.setSign(sign);          Directors directors = new Directors();         if (dtoTransaction.verify()) {              //если в названия закона совпадает с корпоративными должностями, то закон является действительным только когда             //отправитель совпадает с законом             List<Director> enumPosition = directors.getDirectors();             List<String> corporateSeniorPositions = enumPosition.stream()                     .map(t->t.getName())                     .collect(Collectors.toList());              if (corporateSeniorPositions.contains(law.getPacketLawName()) && !UtilsGovernment.checkPostionSenderEqualsLaw(sender, law)) {                 redirectAttrs.addFlashAttribute(\"sending\", \"wrong transaction: Position to be equals whith send\");                 return \"redirect:/result-sending\";             }              redirectAttrs.addFlashAttribute(\"sending\", \"success\");             AllTransactions.addTransaction(dtoTransaction);             String jsonDto = UtilsJson.objToStringJson(dtoTransaction);              for (String s : Seting.ORIGINAL_ADDRESSES) {                 String original = s;                 String url = s + \"/addTransaction\";                 if (BasisController.getExcludedAddresses().contains(url)) {                     System.out.println(\"its your address or excluded address: \" + url);                     continue;                 }                 try {                     UtilUrl.sendPost(jsonDto, url);                  } catch (Exception e) {                     System.out.println(\"exception discovery: \" + original);                  }             }         } else             redirectAttrs.addFlashAttribute(\"sending\", \"wrong transaction\");          return \"redirect:/result-sending\";      }  }","package International_Trade_Union.controllers;  import International_Trade_Union.about_us_engDraft.AboutUsEngDraft; import International_Trade_Union.governments.Director; import International_Trade_Union.governments.Directors; import International_Trade_Union.governments.UtilsGovernment; import International_Trade_Union.originalCorporateCharter.OriginalPreamble; import International_Trade_Union.originalCorporateCharter.OriginalPreambleEng;  import org.json.JSONException; import org.springframework.http.HttpStatus; import org.springframework.http.ResponseEntity; import org.springframework.stereotype.Controller; import org.springframework.ui.Model; import org.springframework.web.bind.annotation.GetMapping; import org.springframework.web.bind.annotation.PostMapping; import org.springframework.web.bind.annotation.RequestParam; import org.springframework.web.servlet.mvc.support.RedirectAttributes; import International_Trade_Union.entity.DtoTransaction.DtoTransaction; import International_Trade_Union.model.Account; import International_Trade_Union.model.User; import International_Trade_Union.network.AllTransactions; import International_Trade_Union.setings.Seting; import International_Trade_Union.utils.*; import International_Trade_Union.utils.base.Base; import International_Trade_Union.utils.base.Base58; import International_Trade_Union.vote.Laws; import International_Trade_Union.vote.VoteEnum;   import java.io.IOException; import java.net.http.WebSocket; import java.security.*; import java.security.spec.InvalidKeySpecException; import java.util.*; import java.util.stream.Collectors;  @Controller public class MainController {      @GetMapping(\"/\")     public String home(Model model) throws IOException, NoSuchAlgorithmException, InvalidKeySpecException, SignatureException, NoSuchProviderException, InvalidKeyException {           model.addAttribute(\"title\", \"Corporation International Trade Union.\");         Map<String, Account> balances = new HashMap<>();          //догрузить блокчейн //        List<Block> blocks = UtilsBlock.readLineObject(Seting.ORIGINAL_BLOCKCHAIN_FILE); //        balances = UtilsBalance.calculateBalances(blocks);         balances = SaveBalances.readLineObject(Seting.ORIGINAL_BALANCE_FILE);           Account account = UtilsBalance.getBalance(User.getUserAddress(), balances);         model.addAttribute(\"account\", account);          return \"home\";     }       @PostMapping(\"/setMinner\")     public String setMinnerAddress(@RequestParam(value = \"setMinner\") String setMinner, RedirectAttributes redirectAttrs){         System.out.println(\"MainController:  \" + setMinner);         UtilsFileSaveRead.save(setMinner, Seting.ORIGINAL_ACCOUNT, false);         return \"redirect:/home\";     }        @GetMapping(\"about\")     public String aboutUs(Model model){         model.addAttribute(\"title\", \"ABOUT US\");         model.addAttribute(\"eng\", OriginalPreambleEng.ARTICLE_0);         model.addAttribute(\"rus\", OriginalPreamble.ARTICLE_0);         return \"about\";     }     @GetMapping(\"result-sending\")     public String resultSending(Model model){          return \"result-sending\";     }      @PostMapping(\"/\")     public String new_transaction(             @RequestParam  String sender,             @RequestParam  String recipient,                                    Double dollar,                                    Double stock,                                    Double reward,                                    @RequestParam  String password,                                   RedirectAttributes redirectAttrs) throws IOException, NoSuchAlgorithmException, SignatureException, InvalidKeySpecException, NoSuchProviderException, InvalidKeyException {         Base base = new Base58();          Laws laws =  new Laws();         laws.setLaws(new ArrayList<>());         laws.setHashLaw(\"\");         laws.setPacketLawName(\"\");         DtoTransaction dtoTransaction = new DtoTransaction(                 sender,                 recipient,                 dollar,                 stock,                 laws,                 reward,                 VoteEnum.YES);         PrivateKey privateKey = UtilsSecurity.privateBytToPrivateKey(base.decode(password));         byte[] sign = UtilsSecurity.sign(privateKey, dtoTransaction.toSign());         System.out.println(\"Main Controller: new transaction: vote: \" +VoteEnum.YES);         redirectAttrs.addFlashAttribute(\"title\", \"sending result!!!\");         redirectAttrs.addFlashAttribute(\"sender\", sender);         redirectAttrs.addFlashAttribute(\"recipient\", recipient);         redirectAttrs.addFlashAttribute(\"dollar\", dollar);         redirectAttrs.addFlashAttribute(\"stock\", stock);         redirectAttrs.addFlashAttribute(\"reward\", reward);         redirectAttrs.addFlashAttribute(\"vote\", VoteEnum.YES);         dtoTransaction.setSign(sign);         Directors directors = new Directors();         if(dtoTransaction.verify()){              //если в названия закона совпадает с корпоративными должностями, то закон является действительным только когда             //отправитель совпадает с законом             List<String> corporateSeniorPositions = directors.getDirectors().stream()                     .map(t->t.getName()).collect(Collectors.toList());             System.out.println(\"LawsController: create_law: \" + laws.getPacketLawName() + \"contains: \" + corporateSeniorPositions.contains(laws.getPacketLawName()));             if(corporateSeniorPositions.contains(laws.getPacketLawName()) && !UtilsGovernment.checkPostionSenderEqualsLaw(sender, laws)){                 redirectAttrs.addFlashAttribute(\"sending\", \"wrong transaction: Position to be equals whith send\");                 return \"redirect:/result-sending\";             }             redirectAttrs.addFlashAttribute(\"sending\", \"success\");             System.out.println(\"dto MainController: \" + dtoTransaction);              AllTransactions.addTransaction(dtoTransaction);             String jsonDto = UtilsJson.objToStringJson(dtoTransaction);             for (String s : Seting.ORIGINAL_ADDRESSES) {                  String original = s;                 String url = s +\"/addTransaction\";                 //если адресс совпадает с внутреним хостом, то не отправляет самому себе                 if(BasisController.getExcludedAddresses().contains(url)){                     System.out.println(\"MainController: its your address or excluded address: \" + url);                     continue;                 }                 try {                     //отправка в сеть                     UtilUrl.sendPost(jsonDto, url);                  }catch (Exception e){                     System.out.println(\"exception discover: \" + original);                  }             }            }          else             redirectAttrs.addFlashAttribute(\"sending\", \"wrong transaction\");         return \"redirect:/result-sending\";     }       @GetMapping(\"/seting\")     public String seting(Model model){         model.addAttribute(\"title\", \"Настройки\");         return \"seting\";     }   }","package International_Trade_Union.controllers;  import International_Trade_Union.config.BLockchainFactory; import International_Trade_Union.config.BlockchainFactoryEnum; import International_Trade_Union.entity.blockchain.Blockchain; import International_Trade_Union.model.Account; import International_Trade_Union.model.User; import International_Trade_Union.setings.Seting; import International_Trade_Union.utils.SaveBalances; import International_Trade_Union.utils.UtilsBalance; import org.springframework.stereotype.Controller; import org.springframework.ui.Model; import org.springframework.web.bind.annotation.GetMapping; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RestController;  import java.io.IOException; import java.security.InvalidKeyException; import java.security.NoSuchAlgorithmException; import java.security.NoSuchProviderException; import java.security.SignatureException; import java.security.spec.InvalidKeySpecException; import java.util.HashMap; import java.util.Map;  @Controller public class MineController {     private static Blockchain blockchain;     static {         try {             blockchain = BLockchainFactory.getBlockchain(BlockchainFactoryEnum.ORIGINAL);         } catch (NoSuchAlgorithmException e) {             throw new RuntimeException(e);         } catch (InvalidKeySpecException e) {             throw new RuntimeException(e);         } catch (IOException e) {             throw new RuntimeException(e);         } catch (SignatureException e) {             throw new RuntimeException(e);         } catch (NoSuchProviderException e) {             throw new RuntimeException(e);         } catch (InvalidKeyException e) {             throw new RuntimeException(e);         }     }      @RequestMapping(\"/mining\")     public String miming(Model model) throws IOException, NoSuchAlgorithmException, InvalidKeySpecException, SignatureException, NoSuchProviderException, InvalidKeyException {         model.addAttribute(\"title\", \"Corporation International Trade Union.\");          return \"mining\";     }    }","package International_Trade_Union.controllers;  import International_Trade_Union.entity.DtoTransaction.DtoTransaction; import International_Trade_Union.network.AllTransactions; import org.springframework.http.MediaType; import org.springframework.web.bind.annotation.RequestBody; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RequestMethod; import org.springframework.web.bind.annotation.RestController;  import java.io.IOException; import java.security.InvalidKeyException; import java.security.NoSuchAlgorithmException; import java.security.NoSuchProviderException; import java.security.SignatureException; import java.security.spec.InvalidKeySpecException;  @RestController public class TransactionController {     @RequestMapping(method = RequestMethod.POST, value = \"/addTransaction\", consumes = MediaType.APPLICATION_JSON_VALUE)     public  void add(@RequestBody DtoTransaction data) throws IOException, NoSuchAlgorithmException, SignatureException, InvalidKeySpecException, NoSuchProviderException, InvalidKeyException {         System.out.println(\"add transaction: \" + data);         AllTransactions.getInstance();         AllTransactions.addTransaction(data);         System.out.println(\"TransactionController: add: \" + AllTransactions.getInstance().size());     }  }","package International_Trade_Union.entity.blockchain.block;  import International_Trade_Union.entity.DtoTransaction.DtoTransaction; import International_Trade_Union.exception.NotValidTransactionException; import International_Trade_Union.utils.UtilsJson; import International_Trade_Union.utils.UtilsUse; import com.fasterxml.jackson.annotation.JsonAutoDetect;  import lombok.Data;  import java.io.IOException; import java.security.InvalidKeyException; import java.security.NoSuchAlgorithmException; import java.security.NoSuchProviderException; import java.security.SignatureException; import java.security.spec.InvalidKeySpecException; import java.sql.Timestamp; import java.util.List; import java.util.Objects;  @JsonAutoDetect @Data public final class Block implements Cloneable {     private List<DtoTransaction> dtoTransactions;     private String previousHash;     private String minerAddress;     private String founderAddress;     private long randomNumberProof;     private double minerRewards;     private int hashCompexity;     private Timestamp timestamp;     private long index;     private String hashBlock;      public Block(List<DtoTransaction> dtoTransactions,  String previousHex, String minerAddress, String founderAddress, int hashCompexity, long index) throws IOException, NoSuchAlgorithmException, SignatureException, NoSuchProviderException, InvalidKeyException, InvalidKeySpecException {         this.dtoTransactions = dtoTransactions;         this.previousHash = previousHex;         this.minerAddress = minerAddress;         this.minerRewards = miningRewardsCount();         this.hashCompexity = hashCompexity;         this.founderAddress = founderAddress;         this.timestamp = new Timestamp(System.currentTimeMillis());         this.index = index;         this.hashBlock = findHash(hashCompexity);      }      public Block(List<DtoTransaction> dtoTransactions, String previousHash, String minerAddress, String founderAddress, long randomNumberProof, double minerRewards, int hashCompexity, Timestamp timestamp, long index, String hashBlock) {         this.dtoTransactions = dtoTransactions;         this.previousHash = previousHash;         this.minerAddress = minerAddress;         this.founderAddress = founderAddress;         this.randomNumberProof = randomNumberProof;         this.minerRewards = minerRewards;         this.hashCompexity = hashCompexity;         this.timestamp = timestamp;         this.index = index;         this.hashBlock = hashBlock;     }      @JsonAutoDetect     @Data     private class BlockForHash{         private List<DtoTransaction> transactions;         private String previousHash;         private String minerAddress;         private String founderAddress;         private long randomNumberProof;         private double minerRewards;         private int hashCompexity;         private Timestamp timestamp;         private long index;           public BlockForHash() {         }           public BlockForHash(List<DtoTransaction> transactions,                             String previousHash,                             String minerAddress,                             String founderAddress,                             long randomNumberProof,                             double minerRewards,                             int hashCompexity,                             Timestamp timestamp,                             long index) {             this.transactions = transactions;             this.previousHash = previousHash;             this.minerAddress = minerAddress;             this.founderAddress = founderAddress;             this.randomNumberProof = randomNumberProof;             this.minerRewards = minerRewards;             this.hashCompexity = hashCompexity;             this.timestamp = timestamp;             this.index = index;          }          public String hashForTransaction() throws IOException {             return UtilsUse.sha256hash(jsonString());         }          public String jsonString() throws IOException {             return UtilsJson.objToStringJson(this);         }     }      public Block() {     }      public String hashForBlockchain()             throws             IOException{         return this.hashBlock;     }       public boolean verifyesTransSign() throws IOException, NoSuchAlgorithmException, SignatureException, NoSuchProviderException, InvalidKeyException, InvalidKeySpecException {         for (DtoTransaction dtoTransaction : dtoTransactions) {             if(!dtoTransaction.verify())                 return false;         }         return true;     }      private double miningRewardsCount(){         double rewards = 0.0;         for (DtoTransaction dtoTransaction : dtoTransactions) {              rewards += dtoTransaction.getBonusForMiner();         }          return rewards;     }      public String jsonString() throws IOException {         return UtilsJson.objToStringJson(this);     }     //TODO     public String findHash(int hashCoplexity) throws IOException, NoSuchAlgorithmException, SignatureException, NoSuchProviderException, InvalidKeyException, InvalidKeySpecException {         if (!verifyesTransSign()){             throw new NotValidTransactionException();         }          this.randomNumberProof = 0;         String hash = \"\";         while (true){             this.randomNumberProof++;             BlockForHash block = new BlockForHash(this.dtoTransactions,                     this.previousHash, this.minerAddress, this.founderAddress,                     this.randomNumberProof, this.minerRewards, this.hashCompexity, this.timestamp, this.index);             hash = block.hashForTransaction();             if(UtilsUse.hashComplexity(hash.substring(0, hashCoplexity), hashCoplexity))             {                 break;             }          }         return hash;     }      @Override     public boolean equals(Object o) {           if (this == o) return true;         if (!(o instanceof Block)) return false;         Block block = (Block) o;         return getRandomNumberProof() == block.getRandomNumberProof() && Double.compare(block.getMinerRewards(), getMinerRewards()) == 0 && getHashCompexity() == block.getHashCompexity() && getIndex() == block.getIndex() && Objects.equals(getDtoTransactions(), block.getDtoTransactions()) && Objects.equals(getPreviousHash(), block.getPreviousHash()) && Objects.equals(getMinerAddress(), block.getMinerAddress()) && Objects.equals(getFounderAddress(), block.getFounderAddress()) && Objects.equals(getTimestamp(), block.getTimestamp()) && Objects.equals(getHashBlock(), block.getHashBlock());     }      @Override     public int hashCode() {         return Objects.hash(getDtoTransactions(), getPreviousHash(), getMinerAddress(), getFounderAddress(), getRandomNumberProof(), getMinerRewards(), getHashCompexity(), getTimestamp(), getIndex(), getHashBlock());     }      @Override     public Block clone() throws CloneNotSupportedException {         return new Block(this.dtoTransactions, this.previousHash, this.minerAddress, this.founderAddress,                 this.randomNumberProof, this.minerRewards, this.hashCompexity, this.timestamp, this.index,                 this.hashBlock);     } }","package International_Trade_Union.entity.blockchain;  import International_Trade_Union.entity.DtoTransaction.DtoTransaction; import International_Trade_Union.entity.blockchain.block.Block; import International_Trade_Union.setings.Seting; import International_Trade_Union.utils.UtilsBlock; import International_Trade_Union.utils.UtilsJson; import International_Trade_Union.utils.UtilsSecurity; import International_Trade_Union.utils.UtilsUse; import International_Trade_Union.utils.base.Base; import International_Trade_Union.utils.base.Base58; import International_Trade_Union.vote.Laws; import International_Trade_Union.vote.VoteEnum; import com.fasterxml.jackson.annotation.JsonAutoDetect;  import lombok.Data;  import java.io.IOException; import java.security.*; import java.security.spec.InvalidKeySpecException; import java.util.ArrayList; import java.util.List; import java.util.Objects;   @JsonAutoDetect @Data public class Blockchain implements Cloneable{     private List<Block> blockchainList;     //как часто должно создаваться блок в миллисекундах 1000 миллисекунд = 1 секунд     private long BLOCK_GENERATION_INTERVAL;     //каждые сколько блоков должен происходить перерасчет сложности     private int DIFFICULTY_ADJUSTMENT_INTERVAL;     //блок действителен, если значение блока меньше данного занчения в миллисекунда     private long INTERVAL_TARGET;     private String ADDRESS_FOUNDER;     public int sizeBlockhain(){          return blockchainList.size();     }      public void setBlockchainList(List<Block> blockchainList) throws IOException, NoSuchAlgorithmException, InvalidKeySpecException, SignatureException, NoSuchProviderException, InvalidKeyException {         this.blockchainList = blockchainList;      }      public Blockchain(long BLOCK_GENERATION_INTERVAL, int DIFFICULTY_ADJUSTMENT_INTERVAL, long INTERVAL_TARGET, String ADDRESS_FOUNDER) throws NoSuchAlgorithmException, InvalidKeySpecException, NoSuchProviderException, IOException, SignatureException, InvalidKeyException {         this(new ArrayList<>(), BLOCK_GENERATION_INTERVAL, DIFFICULTY_ADJUSTMENT_INTERVAL, INTERVAL_TARGET, ADDRESS_FOUNDER);      }     public Blockchain(List<Block> blockchainList, long BLOCK_GENERATION_INTERVAL, int DIFFICULTY_ADJUSTMENT_INTERVAL, long INTERVAL_TARGET,String ADDRESS_FOUNDER) throws IOException, NoSuchAlgorithmException, InvalidKeySpecException, SignatureException, NoSuchProviderException, InvalidKeyException {         this.blockchainList = blockchainList;         this.BLOCK_GENERATION_INTERVAL = BLOCK_GENERATION_INTERVAL;         this.DIFFICULTY_ADJUSTMENT_INTERVAL = DIFFICULTY_ADJUSTMENT_INTERVAL;         this.INTERVAL_TARGET = INTERVAL_TARGET;         this.ADDRESS_FOUNDER = ADDRESS_FOUNDER;         Block block = genesisBlock();         addBlock(block);     }      public void addBlock(Block newBlock) throws IOException, NoSuchAlgorithmException, SignatureException, InvalidKeySpecException, NoSuchProviderException, InvalidKeyException { //        if(blockchainList.size() > 2){ //            boolean time = UtilsBlock.isValidTimestamp(blockchainList.get(blockchainList.size()-1), newBlock, INTERVAL_TARGET); //            if(!time){ //                System.out.println(\"time out block add \" + time); //               return; //            } //        }         blockchainList.add(newBlock);       }      public Block genesisBlock() throws IOException, NoSuchAlgorithmException, InvalidKeySpecException, NoSuchProviderException, SignatureException, InvalidKeyException {         Base base = new Base58();         //dto sign         //pub byte keys         //transactions         List<DtoTransaction> transactions = new ArrayList<>();          DtoTransaction gold = new DtoTransaction(Seting.BASIS_ADDRESS, ADDRESS_FOUNDER,                 Seting.FOUNDERS_REMUNERATION_DIGITAL_DOLLAR, Seting.FOUNDERS_REMNUNERATION_DIGITAL_STOCK, new Laws(), 0.0, VoteEnum.YES);         PrivateKey privateKey = UtilsSecurity.privateBytToPrivateKey(base.decode(Seting.BASIS_PASSWORD));         byte[] signGold = UtilsSecurity.sign(privateKey, gold.toSign());         gold.setSign(signGold);         transactions.add(gold);          String genesisHash = genesisPrevHash();         Block block = new Block(transactions,  genesisHash, ADDRESS_FOUNDER, ADDRESS_FOUNDER,  Seting.HASH_COMPLEXITY_GENESIS, blockchainList.size());         return block;     }        public String genesisPrevHash() throws IOException {         return UtilsUse.hashComplexityStr(Seting.CORPORATE_CHARTER_DRAFT, Seting.HASH_COMPLEXITY_GENESIS);     }      public String getHashBlock(int index) throws IOException {         return blockchainList.get(index).hashForBlockchain();     }     public Block getBlock(int index){         return blockchainList.get(index);     }        public boolean validatedBlockchain() throws IOException, NoSuchAlgorithmException, SignatureException, InvalidKeySpecException, NoSuchProviderException, InvalidKeyException {        return UtilsBlock.validation(blockchainList, BLOCK_GENERATION_INTERVAL, DIFFICULTY_ADJUSTMENT_INTERVAL);     }      public String jsonString() throws IOException {         return UtilsJson.objToStringJson(blockchainList);     }     @Override     public boolean equals(Object o) {         if (this == o) return true;         if (!(o instanceof Blockchain)) return false;         Blockchain that = (Blockchain) o;         return getBlockchainList().equals(that.getBlockchainList());     }      @Override     public int hashCode() {         return Objects.hash(getBlockchainList());     }      public  List<Block> subBlock(int startIndex, int finishIndex) throws CloneNotSupportedException {         List<Block> temporary = this.getBlockchainList().subList(startIndex, finishIndex);         List<Block> result = new ArrayList<>();         for (Block block : temporary) {             result.add(block.clone());         }         return result;     }       @Override     public List<Block> clone() throws CloneNotSupportedException {         List<Block> result = new ArrayList<>();         for (Block block : blockchainList) {             result.add(block.clone());         }         return result;      } }","package International_Trade_Union.entity.DtoTransaction;  import org.bouncycastle.jcajce.provider.asymmetric.ec.BCECPublicKey; import International_Trade_Union.setings.Seting; import International_Trade_Union.utils.UtilsJson; import International_Trade_Union.utils.UtilsSecurity; import International_Trade_Union.utils.UtilsUse; import International_Trade_Union.utils.base.Base; import International_Trade_Union.utils.base.Base58; import International_Trade_Union.vote.Laws; import International_Trade_Union.vote.VoteEnum; import com.fasterxml.jackson.annotation.JsonAutoDetect;  import lombok.Data;   import java.io.IOException; import java.security.*; import java.security.spec.InvalidKeySpecException; import java.util.Arrays; import java.util.Objects;   @JsonAutoDetect @Data public class DtoTransaction {     private String sender;     private String customer;     private double digitalDollar;     private double digitalStockBalance;     private Laws laws;     private double bonusForMiner;     private VoteEnum voteEnum;     private byte[] sign;        public DtoTransaction(String sender, String customer, double digitalDollar, double digitalStockBalance, Laws laws, double bonusForMiner, VoteEnum voteEnum) {         this.sender = sender;         this.customer = customer;         this.digitalDollar = digitalDollar;         this.digitalStockBalance = digitalStockBalance;         this.laws = laws;         this.bonusForMiner = bonusForMiner;         this.voteEnum = voteEnum;     }      public DtoTransaction() {     }      //TODO возможно стоит перевести проверку подписи в отдельный utils, под вопросом!!     public boolean verify() throws IOException, NoSuchAlgorithmException, SignatureException, NoSuchProviderException, InvalidKeyException, InvalidKeySpecException {         Base base = new Base58();         byte[] pub = base.decode(sender);         BCECPublicKey publicKey = (BCECPublicKey) UtilsSecurity.decodeKey(pub); //        PublicKey publicKey = UtilsSecurity.publicByteToPublicKey(pub);         String sha = sender + customer + digitalDollar + digitalStockBalance + laws + bonusForMiner;         sha = UtilsUse.sha256hash(sha);         if(sender.isBlank() || customer.isBlank() || digitalDollar < 0 || digitalStockBalance < 0 || bonusForMiner < 0 || laws == null){             System.out.println(\"wrong dto transaction sender or customer blank? or dollar, reputation or reward less then 0\");             return false;         }         if(Seting.BASIS_ADDRESS.equals(publicKey))             return true;         return UtilsSecurity.verify(sha, sign, publicKey);     }      public String toSign(){         String sha = sender + customer + digitalDollar + digitalStockBalance + laws + bonusForMiner;         return UtilsUse.sha256hash(sha);     }  //    public String hashForBlock() throws IOException { //        return UtilsUse.sha256hash(jsonString()); //    }      public String jsonString() throws IOException {         return UtilsJson.objToStringJson(this);     }      @Override     public boolean equals(Object o) {         if (this == o) return true;         if (!(o instanceof DtoTransaction)) return false;         DtoTransaction that = (DtoTransaction) o;         return Double.compare(that.getDigitalDollar(), getDigitalDollar()) == 0 && Double.compare(that.getDigitalStockBalance(), getDigitalStockBalance()) == 0 && Double.compare(that.getBonusForMiner(), getBonusForMiner()) == 0 && getSender().equals(that.getSender()) && getCustomer().equals(that.getCustomer()) && getLaws().equals(that.getLaws()) && getVoteEnum() == that.getVoteEnum() && Arrays.equals(getSign(), that.getSign());     }      @Override     public int hashCode() {         int result = Objects.hash(getSender(), getCustomer(), getDigitalDollar(), getDigitalStockBalance(), getLaws(), getBonusForMiner(), getVoteEnum());         result = 31 * result + Arrays.hashCode(getSign());         return result;     } }","package International_Trade_Union.entity;   import lombok.Data; import International_Trade_Union.entity.blockchain.block.Block;  import java.util.List;  @Data public class EntityChain {      private int size;     private List<Block> blocks;      public EntityChain() {     }      public EntityChain(int sizeBlockhain, List<Block> blockchainList) {         this.size = sizeBlockhain;         this.blocks = blockchainList;     } }","package International_Trade_Union.entity;   import lombok.Data; import International_Trade_Union.entity.blockchain.Blockchain; import International_Trade_Union.entity.blockchain.block.Block; import International_Trade_Union.model.Account;  import java.util.List; import java.util.Map;  @Data public class ResultMiningData {     private Map<String, Account> balance;     private Blockchain blockchain;     private Block miningBlock;     private List<Block> lastBlock;     private Account governments;  }","package International_Trade_Union.entity;  import lombok.Data;  @Data public class SubBlockchainEntity {     private int start;     private int finish;      public SubBlockchainEntity(int start, int finish) {         this.start = start;         this.finish = finish;     }      public SubBlockchainEntity() {     } }","package International_Trade_Union.exception;  import java.io.IOException;  public class NotValidTransactionException extends IOException { }","package International_Trade_Union.governments;   import International_Trade_Union.model.Account;  public class CompareObject {      public int compare(Account o1, Account o2) {         double x1 = o1.getDigitalStockBalance();         double x2 = o2.getDigitalStockBalance();         int power = Double.compare(x1, x2);         if (power != 0)             return power;         double gold1 = o1.getDigitalDollarBalance();         double gold2 = o2.getDigitalDollarBalance();         int gold = Double.compare(gold1, gold2);         if(gold != 0)             return gold;         double first = x1 + gold1;         double second = x2 + gold2;         return Double.compare(first, second);     }      @Override     public boolean equals(Object obj) {         return false;     } }","package International_Trade_Union.governments;  import lombok.AllArgsConstructor; import lombok.Data; import lombok.NoArgsConstructor;  import java.util.Arrays; import java.util.List; import java.util.Locale; import java.util.Objects; import java.util.stream.Collectors;  @Data @NoArgsConstructor @AllArgsConstructor public class Director {     //количество юридических или физических лиц в данной должности     //количество юридических или физических лиц в данной должности     private String name;     private  int count;      private boolean electedByCEO;     private boolean electedByBoardOfDirectors;       private boolean electedByCorporateCouncilOfReferees;     private boolean electedByStocks;     private boolean officeOfDirectors;       @Override     public boolean equals(Object o) {         if (this == o) return true;         if (!(o instanceof Director)) return false;         Director director = (Director) o;         return getName().equals(director.getName());     }      @Override     public int hashCode() {         return Objects.hash(getName());     }      public boolean isAppointedByTheGovernment(){         if(electedByCEO || electedByBoardOfDirectors || electedByCorporateCouncilOfReferees)             return true;         else return false;     }     public int getCount() {         return count;     }     }","package International_Trade_Union.governments;  import International_Trade_Union.setings.Seting; import International_Trade_Union.utils.UtilsUse; import lombok.Data;  import java.util.ArrayList; import java.util.List; import java.util.Locale; import java.util.stream.Collectors;  @Data  public class Directors {     public Directors() {          directors = new ArrayList<>();         Director CORPORATE_COUNCIL_OF_REFEREES = new Director(\"CORPORATE_COUNCIL_OF_REFEREES\", 55, false, false, false, true, false);         Director BOARD_OF_DIRECTORS = new Director(\"BOARD_OF_DIRECTORS\", 301, false, false, false, true, false);          Director GENERAL_EXECUTIVE_DIRECTOR = new Director(\"GENERAL_EXECUTIVE_DIRECTOR\", 1, false, true, false, false, true);         Director HIGH_JUDGE = new Director(\"HIGH_JUDGE\",1, false, false, true, false, false);          Director INTERNET_STORE_DIRECTOR = new Director(\"INTERNET_STORE_DIRECTOR\",1, false, true, false, false, true);         Director DIRECTOR_OF_THE_DIGITAL_EXCHANGE = new Director(\"DIRECTOR_OF_THE_DIGITAL_EXCHANGE\",1, false, true, false, false, true);         Director DIRECTOR_OF_DIGITAL_BANK = new Director(\"DIRECTOR_OF_DIGITAL_BANK\",1, false, true, false, false, true);         Director DIRECTOR_OF_THE_COMMERCIAL_COURT = new Director(\"DIRECTOR_OF_THE_COMMERCIAL_COURT\",1, false, true, false, false, true);         Director MEDIA_DIRECTOR = new Director(\"MEDIA_DIRECTOR\",1, false, true, false, false, true);         Director DIRECTOR_OF_THE_DEVELOPMENT_OF_THE_IMPLEMENTATION_OF_CRYPTOCURRENCY_TECHNOLOGIES_OF_THE_INTERNATIONAL_TRADE_UNION_CORPORATION = new Director(\"DIRECTOR_OF_THE_DEVELOPMENT_OF_THE_IMPLEMENTATION_OF_CRYPTOCURRENCY_TECHNOLOGIES_OF_THE_INTERNATIONAL_TRADE_UNION_CORPORATION\",1, false, true, false, false, true);          directors.add(CORPORATE_COUNCIL_OF_REFEREES);         directors.add(BOARD_OF_DIRECTORS);          directors.add(GENERAL_EXECUTIVE_DIRECTOR);         directors.add(HIGH_JUDGE);          directors.add(INTERNET_STORE_DIRECTOR);         directors.add(DIRECTOR_OF_THE_DIGITAL_EXCHANGE);         directors.add(DIRECTOR_OF_DIGITAL_BANK);         directors.add(DIRECTOR_OF_THE_COMMERCIAL_COURT);         directors.add(MEDIA_DIRECTOR);         directors.add(DIRECTOR_OF_THE_DEVELOPMENT_OF_THE_IMPLEMENTATION_OF_CRYPTOCURRENCY_TECHNOLOGIES_OF_THE_INTERNATIONAL_TRADE_UNION_CORPORATION);     }       public Director getDirector(String str){        List<Director> director = directors                .stream()                .filter(t->t.getName().equals(str))                .collect(Collectors.toList());        return director.get(0);      }     private List<Director> directors;      public boolean contains(String str) {         str = str.toUpperCase();         directors = directors.stream().filter(UtilsUse.distinctByKey(Director::getName)).collect(Collectors.toList());         List<String> strings = directors.stream().map(t->t.getName()).collect(Collectors.toList());        return strings.contains(str);     }      public boolean isCabinets(String str) {         List<String> list = directors.stream()                 .filter(t->t.isOfficeOfDirectors())                 .filter(UtilsUse.distinctByKey(Director::getName))                 .map(t->t.getName())                 .collect(Collectors.toList());         return list.contains(str.toUpperCase(Locale.ROOT));     }       //должности которые добавляются только советом директоров     public void addByBoardOfDirectors(String str) {         if (str.startsWith(Seting.ADD_DIRECTOR)) {             Director director = new Director(str, 1, false, true, false, false, true);             directors.add(director);             directors = directors.stream().filter(UtilsUse.distinctByKey(Director::getName)).collect(Collectors.toList());         }      }      public void addAllByBoardOfDirectors(List<String> strings) {         strings = strings.stream()                 .filter(t -> t.startsWith(Seting.ADD_DIRECTOR))                 .distinct()                 .collect(Collectors.toList());         for (String s : strings) {             Director director = new Director(s, 1, false, true, false, false, true);             directors.add(director);         }         directors = directors.stream().filter(UtilsUse.distinctByKey(Director::getName)).collect(Collectors.toList());      }       public List<String> getNames() {         return directors.stream().map(t -> t.getName()).collect(Collectors.toList());     }       public  boolean isElectedByStocks(String str){         List<String> list = directors.stream()                 .filter(t->t.isElectedByStocks())                 .map(t->t.getName())                 .collect(Collectors.toList());          return list.contains(str.toUpperCase(Locale.ROOT));     }     public boolean isElectedCEO(String str){         List<String> list = directors.stream()                 .filter(t->t.isElectedByCEO())                 .map(t->t.getName())                 .collect(Collectors.toList());          return list.contains(str.toUpperCase(Locale.ROOT));     }      public  boolean isElectedByBoardOfDirectors(String  str){         List<String> list = directors.stream()                 .filter(t->t.isElectedByBoardOfDirectors())                 .map(t->t.getName())                 .collect(Collectors.toList());          return list.contains(str.toUpperCase(Locale.ROOT));     }      public boolean isElectedBYCorporateCouncilOfReferees(String  str){         List<String> list = directors.stream()                 .filter(t->t.isElectedByCorporateCouncilOfReferees())                 .map(t->t.getName())                 .collect(Collectors.toList());          return list.contains(str.toUpperCase(Locale.ROOT));     }      public boolean isofficeOfDirectors(String str){         List<String> list = directors.stream()                 .filter(t->t.isOfficeOfDirectors())                 .map(t->t.getName())                 .collect(Collectors.toList());          return list.contains(str.toUpperCase(Locale.ROOT));     } }","package International_Trade_Union.governments;  public enum NamePOSITION {     BOARD_OF_DIRECTORS,     CORPORATE_COUNCIL_OF_REFEREES,     GENERAL_EXECUTIVE_DIRECTOR,     HIGH_JUDGE }","package International_Trade_Union.governments;   import International_Trade_Union.entity.DtoTransaction.DtoTransaction; import International_Trade_Union.entity.blockchain.block.Block; import International_Trade_Union.model.Account; import International_Trade_Union.setings.Seting; import International_Trade_Union.vote.*;  import java.io.IOException; import java.security.InvalidKeyException; import java.security.NoSuchAlgorithmException; import java.security.NoSuchProviderException; import java.security.SignatureException; import java.security.spec.InvalidKeySpecException; import java.util.*; import java.util.stream.Collectors;  public class UtilsGovernment {      //для корпоративных позиций, адресс отправителя должен совпадать с первой строкой закона     public static boolean checkPostionSenderEqualsLaw(String addressSender, Laws laws) {         Directors directors = new Directors();         List<Director> enumPosition = directors.getDirectors();         List<String> corporateSeniorPositions = enumPosition.stream().map(t->t.getName()).collect(Collectors.toList());         if (corporateSeniorPositions.contains(laws.getPacketLawName())) {             if (laws.getLaws().get(0) != null && addressSender.equals(laws.getLaws().get(0))) {                 System.out.println(\"UtilsBogernment: checkPostionSenderEqualsLaw: \" + laws.getLaws().get(0) + \" true:\");                 return true;             } else {                 System.out.println(\"UtilsBogernment: checkPostionSenderEqualsLaw: \" + laws.getLaws().get(0) + \" false:\");                 return false;             }         }         System.out.println(\"UtilsBogernment: checkPostionSenderEqualsLaw: \" + laws.getLaws().get(0) + \" not position:\");         return true;     }       //определение совета акционеров     public static List<Account> findBoardOfShareholders(Map<String, Account> balances, List<Block> blocks, int limit) {         List<Block> minersHaveMoreStock = null;         if (blocks.size() > limit) {             minersHaveMoreStock = blocks.subList(blocks.size() - limit, blocks.size());         } else {             minersHaveMoreStock = blocks;         }         List<Account> boardAccounts = minersHaveMoreStock.stream().map(                         t -> new Account(t.getMinerAddress(), 0, 0))                 .collect(Collectors.toList());          for (Block block : minersHaveMoreStock) {             for (DtoTransaction dtoTransaction : block.getDtoTransactions()) {                 boardAccounts.add(new Account(dtoTransaction.getSender(), 0, 0));             }          }           CompareObject compareObject = new CompareObject();          List<Account> boardOfShareholders = balances.entrySet().stream()                 .filter(t -> boardAccounts.contains(t.getValue()))                 .map(t -> t.getValue()).collect(Collectors.toList());           boardOfShareholders = boardOfShareholders                 .stream()                 .filter(t -> !t.getAccount().startsWith(Seting.NAME_LAW_ADDRESS_START))                 .filter(t -> t.getDigitalStockBalance() > 0)                 .sorted(Comparator.comparing(Account::getDigitalStockBalance).reversed())                 .collect(Collectors.toList());          boardOfShareholders = boardOfShareholders                 .stream()                 .limit(Seting.BOARD_OF_SHAREHOLDERS)                 .collect(Collectors.toList());          return boardOfShareholders;     }       public static List<CurrentLawVotesEndBalance> filtersVotes(             List<LawEligibleForParliamentaryApproval> approvalList,             Map<String, Account> balances,             List<Account> BoardOfShareholders,             List<Block> blocks,             int limitBlocks     ) throws IOException, NoSuchAlgorithmException, SignatureException, InvalidKeySpecException, NoSuchProviderException, InvalidKeyException {         //действующие законы чьи голоса больше ORIGINAL_LIMIT_MIN_VOTE         List<CurrentLawVotesEndBalance> current = new ArrayList<>();         Map<String, CurrentLawVotes> votesMap = null;         List<Account> accounts = balances.entrySet().stream().map(t -> t.getValue()).collect(Collectors.toList());         if (blocks.size() > limitBlocks) {             votesMap = UtilsCurrentLaw.calculateVotes(accounts, blocks.subList(blocks.size() - limitBlocks, blocks.size()));         } else {             votesMap = UtilsCurrentLaw.calculateVotes(accounts, blocks);         }          //подсчитать средннее количество раз сколько он проголосовал за         Map<String, Integer> yesAverage = UtilsCurrentLaw.calculateAverageVotesYes(votesMap);         //подсчитать среднее количество раз сколько он проголосовал против         Map<String, Integer> noAverage = UtilsCurrentLaw.calculateAverageVotesNo(votesMap);           //подсчитываем голоса для для обычных законов и законов позиций         for (LawEligibleForParliamentaryApproval lawEligibleForParliamentaryApproval : approvalList) {             if (votesMap.containsKey(lawEligibleForParliamentaryApproval.getLaws().getHashLaw())) {                 String address = lawEligibleForParliamentaryApproval.getLaws().getHashLaw();                 String packageName = lawEligibleForParliamentaryApproval.getLaws().getPacketLawName();                 List<String> laws = lawEligibleForParliamentaryApproval.getLaws().getLaws();                 double vote = 0;                 int supremeVotes = 0;                 int boafdOfShareholderVotes = 0;                 int houseOfRepresentativiesVotes = 0;                 int primeMinisterVotes = 0;                 int hightJudgesVotes = 0;                 int founderVote = 0;                  //для законов подсчитываем специальные голоса                 vote = votesMap.get(lawEligibleForParliamentaryApproval.getLaws().getHashLaw()).votesLaw(balances, yesAverage, noAverage);                 List<String> boardOfShareholdersAddress = BoardOfShareholders.stream().map(t -> t.getAccount()).collect(Collectors.toList());                 boafdOfShareholderVotes = votesMap.get(lawEligibleForParliamentaryApproval.getLaws().getHashLaw()).voteGovernment(balances, boardOfShareholdersAddress);                  List<String> founder = List.of(Seting.ADDRESS_FOUNDER);                 founderVote = votesMap.get(lawEligibleForParliamentaryApproval.getLaws().getHashLaw()).voteGovernment(balances, founder);                 CurrentLawVotesEndBalance currentLawVotesEndBalance = new CurrentLawVotesEndBalance(                         address,                         packageName,                         vote,                         supremeVotes,                         houseOfRepresentativiesVotes,                         boafdOfShareholderVotes,                         primeMinisterVotes,                         hightJudgesVotes,                         founderVote,                         laws);                 current.add(currentLawVotesEndBalance);              }         }          List<String> houseOfRepresentativies = new ArrayList<>();         List<String> chamberOfSumpremeJudges = new ArrayList<>();          for (CurrentLawVotesEndBalance currentLawVotesEndBalance: current) {             if(currentLawVotesEndBalance.getPackageName().equals(NamePOSITION.BOARD_OF_DIRECTORS.toString())){                 if(currentLawVotesEndBalance.getVotes() >= Seting.ORIGINAL_LIMIT_MIN_VOTE){                      houseOfRepresentativies.add(currentLawVotesEndBalance.getLaws().get(0));                 }              }             if(currentLawVotesEndBalance.getPackageName().equals(NamePOSITION.CORPORATE_COUNCIL_OF_REFEREES.toString())){                 if(currentLawVotesEndBalance.getVotes() >= Seting.ORIGINAL_LIMIT_MIN_VOTE){                     chamberOfSumpremeJudges.add(currentLawVotesEndBalance.getLaws().get(0));                 }              }         }            for (CurrentLawVotesEndBalance currentLawVotesEndBalance : current) {             if(votesMap.containsKey(currentLawVotesEndBalance.getAddressLaw())){                   double vote = votesMap.get(currentLawVotesEndBalance.getAddressLaw()).votesLaw(balances, yesAverage, noAverage);                 int supremeVotes  = votesMap.get(currentLawVotesEndBalance.getAddressLaw()).voteGovernment(balances, chamberOfSumpremeJudges);                 int houseOfRepresentativiesVotes = votesMap.get(currentLawVotesEndBalance.getAddressLaw()).voteGovernment(balances, houseOfRepresentativies);                  currentLawVotesEndBalance.setVotes(vote);                 currentLawVotesEndBalance.setVotesBoardOfDirectors(houseOfRepresentativiesVotes);                 currentLawVotesEndBalance.setVotesCorporateCouncilOfReferees(supremeVotes);             }          }          List<String> primeMinister = new ArrayList<>();         List<String> hightJudge = new ArrayList<>();         for (CurrentLawVotesEndBalance currentLawVotesEndBalance : current) {             if(currentLawVotesEndBalance.getPackageName().equals(NamePOSITION.GENERAL_EXECUTIVE_DIRECTOR.toString())){                 if(currentLawVotesEndBalance.getVotesBoardOfDirectors() >= Seting.ORIGINAL_LIMIT_MIN_VOTE_BOARD_OF_DIRECTORS){                     primeMinister.add(currentLawVotesEndBalance.getLaws().get(0));                 }             }              if(currentLawVotesEndBalance.getPackageName().equals(NamePOSITION.HIGH_JUDGE.toString())){                 if(currentLawVotesEndBalance.getVotesCorporateCouncilOfReferees() >= Seting.ORIGINAL_LIMIT_MIN_VOTE_CORPORATE_COUNCIL_OF_REFEREES){                     hightJudge.add(currentLawVotesEndBalance.getLaws().get(0));                 }             }         }         for (CurrentLawVotesEndBalance currentLawVotesEndBalance : current) {             if(votesMap.containsKey(currentLawVotesEndBalance.getAddressLaw())){                 int primeMinisterVotes = votesMap.get(currentLawVotesEndBalance.getAddressLaw()).voteGovernment(balances, primeMinister);                 int hightJudgeVotes = votesMap.get(currentLawVotesEndBalance.getAddressLaw()).voteGovernment(balances, hightJudge);                  currentLawVotesEndBalance.setVoteGeneralExecutiveDirector(primeMinisterVotes);                 currentLawVotesEndBalance.setVoteHightJudge(hightJudgeVotes);             }          }           return current;      }          //без учета палаты представителей     public static List<CurrentLawVotesEndBalance> filters(List<LawEligibleForParliamentaryApproval> approvalList, Map<String, Account> balances,                                                           List<Account> BoardOfShareholders, List<Block> blocks, int limitBlocks) throws IOException, NoSuchAlgorithmException, InvalidKeySpecException, SignatureException, NoSuchProviderException, InvalidKeyException {         //действующие законы чьи голоса больше ORIGINAL_LIMIT_MIN_VOTE         List<CurrentLawVotesEndBalance> current = new ArrayList<>();         Map<String, CurrentLawVotes> votesMap = null;         List<Account> accounts = balances.entrySet().stream().map(t -> t.getValue()).collect(Collectors.toList());         if (blocks.size() > limitBlocks) {             votesMap = UtilsCurrentLaw.calculateVotes(accounts, blocks.subList(blocks.size() - limitBlocks, blocks.size()));         } else {             votesMap = UtilsCurrentLaw.calculateVotes(accounts, blocks);         }          //подсчитать средннее количество раз сколько он проголосовал за         Map<String, Integer> yesAverage = UtilsCurrentLaw.calculateAverageVotesYes(votesMap);         //подсчитать среднее количество раз сколько он проголосовал против         Map<String, Integer> noAverage = UtilsCurrentLaw.calculateAverageVotesNo(votesMap);          for (LawEligibleForParliamentaryApproval lawEligibleForParliamentaryApproval : approvalList) {             if (votesMap.containsKey(lawEligibleForParliamentaryApproval.getLaws().getHashLaw())) {                 String address = lawEligibleForParliamentaryApproval.getLaws().getHashLaw();                 String packageName = lawEligibleForParliamentaryApproval.getLaws().getPacketLawName();                 List<String> laws = lawEligibleForParliamentaryApproval.getLaws().getLaws();                 double vote = votesMap.get(lawEligibleForParliamentaryApproval.getLaws().getHashLaw()).votes(balances, yesAverage, noAverage);                  CurrentLawVotesEndBalance currentLawVotesEndBalance = new CurrentLawVotesEndBalance(address, packageName, vote, 0, 0, 0, 0, 0, 0,  laws);                 current.add(currentLawVotesEndBalance);              }         }         return current;     }   }","package International_Trade_Union.model;   import lombok.Data; import International_Trade_Union.entity.DtoTransaction.DtoTransaction; import International_Trade_Union.utils.UtilsSecurity; import International_Trade_Union.utils.base.Base; import International_Trade_Union.utils.base.Base58; import International_Trade_Union.vote.Laws; import International_Trade_Union.vote.VoteEnum;  import java.io.IOException; import java.security.*; import java.security.spec.InvalidKeySpecException; import java.util.Objects;   @Data public class Account {     private String account;     private double digitalDollarBalance;     private double digitalStockBalance;       public Account(String account, double digitalDollarBalance) {         this(account, digitalDollarBalance, 0.0);      }      public Account(String account, double digitalDollarBalance, double digitalStockBalance) {         this.account = account;         this.digitalDollarBalance = digitalDollarBalance;         this.digitalStockBalance = digitalStockBalance;     }      public Account() {     }      @Override     public boolean equals(Object o) {         if (this == o) return true;         if (!(o instanceof Account)) return false;         Account account1 = (Account) o;         return getAccount().equals(account1.getAccount());     }      @Override     public int hashCode() {         return Objects.hash(getAccount());     }      private DtoTransaction sendMoney(String recipient, String privatekey, double digitalDollar, double digitalStock, Laws laws, double minerRewards, VoteEnum voteEnum) throws NoSuchAlgorithmException, InvalidKeySpecException, NoSuchProviderException, SignatureException, IOException, InvalidKeyException {          DtoTransaction transaction = null;         if (account.equals(recipient)){             System.out.println(\"sender %s, recipient %s cannot be equals! Error!\".format(account,recipient));             return transaction;         }              if(digitalDollarBalance < digitalDollar + minerRewards  ){                 System.out.println(\"sender don't have digitalDollar\");                 return transaction;             }             if(digitalStockBalance < digitalStock){                 System.out.println(\"sender don't have digitalReputation\");                 return transaction;             }             else{                 Base base = new Base58();                 PrivateKey privateKey = UtilsSecurity.privateBytToPrivateKey(base.decode(privatekey));                  transaction = new DtoTransaction(this.getAccount(), recipient, digitalDollar, digitalStock, laws, minerRewards, voteEnum);                 byte[] signGold = UtilsSecurity.sign(privateKey, transaction.toSign());                 transaction.setSign(signGold);             }         return transaction;     }  //      recipient - получатель //      gold сумма отправки, last Block - это послдний блок.     public DtoTransaction send(String recipient, String privateKey, double digitalDollar, double digitalReputation, Laws laws,  double minerRewards, VoteEnum voteEnum) throws NoSuchAlgorithmException, InvalidKeySpecException, SignatureException, IOException, NoSuchProviderException, InvalidKeyException {          return sendMoney(recipient,privateKey, digitalDollar, digitalReputation, laws, minerRewards, voteEnum);     }      }","package International_Trade_Union.model;  import International_Trade_Union.utils.UtilsSecurity; import International_Trade_Union.utils.base.Base; import International_Trade_Union.utils.base.Base58;  import java.security.InvalidAlgorithmParameterException; import java.security.NoSuchAlgorithmException; import java.security.NoSuchProviderException; import java.security.spec.InvalidKeySpecException; import java.util.HashMap; import java.util.Map;  public class CreateAccount {     public static Map<String, String> create() throws InvalidAlgorithmParameterException, NoSuchAlgorithmException, InvalidKeySpecException, NoSuchProviderException {         Map<String, String> create = new HashMap<>();         Base base = new Base58();         Keys keyPair = UtilsSecurity.generateKeyPair();         String pubkey = keyPair.getPubkey();         String privKey = keyPair.getPrivkey();         System.out.println(\"pubkey: \" + pubkey);         System.out.println(\"privKey: \" + privKey);         create.put(\"pubKey\", pubkey);         create.put(\"privKey\", privKey);         return create;     } }","package International_Trade_Union.model;  import International_Trade_Union.governments.Director; import lombok.AllArgsConstructor; import lombok.Data; import lombok.NoArgsConstructor;  @Data @AllArgsConstructor @NoArgsConstructor public class FIndPositonHelperData {     Director addressPosition;     boolean withLimited;     boolean electedWithStock;     boolean electedWithPrimeMinister;     boolean electedWithHousOfRepresentativies;     boolean electedWithChamberOfHightJudjes;  }","package International_Trade_Union.model;  import lombok.Data;  @Data public class Keys {     private String pubkey;     private String privkey;      public Keys(String pubkey, String privkey) {         this.pubkey = pubkey;         this.privkey = privkey;     } }","package International_Trade_Union.model;    import International_Trade_Union.config.BLockchainFactory; import International_Trade_Union.config.BlockchainFactoryEnum; import International_Trade_Union.entity.DtoTransaction.DtoTransaction; import International_Trade_Union.entity.blockchain.Blockchain; import International_Trade_Union.entity.blockchain.block.Block; import International_Trade_Union.governments.Director; import International_Trade_Union.governments.Directors; import International_Trade_Union.governments.UtilsGovernment; import International_Trade_Union.setings.Seting; import International_Trade_Union.utils.base.Base; import International_Trade_Union.utils.base.Base58; import International_Trade_Union.vote.Laws; import International_Trade_Union.vote.VoteEnum; import International_Trade_Union.utils.*;  import java.io.File; import java.io.IOException; import java.security.*; import java.security.spec.InvalidKeySpecException; import java.util.*; import java.util.stream.Collectors;  public class Mining {      public static Blockchain getBlockchain(String filename, BlockchainFactoryEnum factoryEnum) throws IOException, NoSuchAlgorithmException, InvalidKeySpecException, SignatureException, NoSuchProviderException, InvalidKeyException {          List<Block> blocks = UtilsBlock.readLineObject(filename);         Blockchain blockchain = null;         blockchain = BLockchainFactory.getBlockchain(factoryEnum);          if (blocks.size() != 0) {            blockchain.setBlockchainList(blocks);         }         return blockchain;     }      public static Map<String, Account> getBalances(String filename, Blockchain blockchain, Map<String, Account> balances) throws IOException, NoSuchAlgorithmException, SignatureException, InvalidKeySpecException, NoSuchProviderException, InvalidKeyException {         //start test           //папка чтобы проверить есть ли         File folder = new File(filename);         List<String> files = new ArrayList<>();         for (File file : folder.listFiles()) {             if(!file.isDirectory()){                 files.add(file.getAbsolutePath());             }         }          if (files.size() > 0 ){             File file = new File(files.get(files.size()-1));             if(file.exists() && file.length() > 0){                 balances = SaveBalances.readLineObject(filename);             }          }          if (balances == null) {             balances = new HashMap<>();         }          Block block;         if(blockchain != null && blockchain.sizeBlockhain() > 0){             block = blockchain.getBlock(blockchain.sizeBlockhain() - 1);             balances = UtilsBalance.calculateBalance(balances, block);           }           return balances;     }      public static void deleteFiles(String fileDelit) {         UtilsFileSaveRead.deleteAllFiles(fileDelit);     }       public static Block miningDay(             Account minner,             Blockchain blockchain,             long blockGenerationInterval,             int DIFFICULTY_ADJUSTMENT_INTERVAL,             List<DtoTransaction> transactionList,             Map<String, Account> balances,             long index     ) throws IOException, NoSuchAlgorithmException, SignatureException, InvalidKeySpecException, NoSuchProviderException, InvalidKeyException {         Directors directors = new Directors();         //получение транзакций с сети         List<DtoTransaction> listTransactions = transactionList;          //определение валидных транзакций         List<DtoTransaction> forAdd = new ArrayList<>();          //проверяет целостность транзакции, что они подписаны правильно         cicle:         for (DtoTransaction transaction : listTransactions) {             if (transaction.verify()) {                  Account account = balances.get(transaction.getSender());                 if (account == null) {                     System.out.println(\"minerAccount null\");                     continue cicle;                 }                 //NAME_LAW_ADDRESS_START если адресс  означает правила выбранные сетью                 if(transaction.getCustomer().startsWith(Seting.NAME_LAW_ADDRESS_START) && !balances.containsKey(transaction.getCustomer())){                     //если в названия закона совпадает с корпоративными должностями, то закон является действительным только когда                     //отправитель совпадает с законом //                    List<Director> enumPosition = directors.getDirectors();                     List<String> corporateSeniorPositions = directors.getDirectors().stream()                             .map(t->t.getName()).collect(Collectors.toList());                     System.out.println(\"LawsController: create_law: \" + transaction.getLaws().getPacketLawName()                             + \"contains: \" + corporateSeniorPositions.contains(transaction.getLaws().getPacketLawName()));                     if(corporateSeniorPositions.contains(transaction.getLaws().getPacketLawName())                             && !UtilsGovernment.checkPostionSenderEqualsLaw(transaction.getSender(), transaction.getLaws())){                         System.out.println(\"if your create special corporate position, you need \" +                                 \"sender to be equals with first law: now its wrong\");                         continue cicle;                     }                 }                 if(transaction.getLaws() == null){                     System.out.println(\"law cannot to be null: \");                     continue cicle;                 }                  if (account != null) {                     if(transaction.getSender().equals(Seting.BASIS_ADDRESS)){                         System.out.println(\"only this miner can input basis adress in this block\");                         continue cicle;                     }                     if(transaction.getCustomer().equals(Seting.BASIS_ADDRESS)){                         System.out.println(\"basis address canot to be customer(recipient)\");                         continue cicle;                     }                      if( account.getDigitalDollarBalance() < transaction.getDigitalDollar() + transaction.getBonusForMiner()){                         System.out.println(\"sender don't have digital dollar: \" + account.getAccount() + \" balance: \" + account.getDigitalDollarBalance() );                         System.out.println(\"digital dollar for send: \" + (transaction.getDigitalDollar() + transaction.getBonusForMiner()));                         continue cicle;                     }                     if (account.getDigitalStockBalance() < transaction.getDigitalStockBalance()){                         System.out.println(\"sender don't have digital reputation: \" + account.getAccount() + \" balance: \" + account.getDigitalStockBalance());                         System.out.println(\"digital reputation for send: \" + (transaction.getDigitalDollar() + transaction.getBonusForMiner()));                         continue cicle;                     }                     if(transaction.getSender().equals(transaction.getCustomer()) ){                         System.out.println(\"sender end recipient equals \" + transaction.getSender() + \" : recipient: \" + transaction.getCustomer());                         continue cicle;                     }                     forAdd.add(transaction);                 }              }         }           //доход майнера         double minerRewards = Seting.DIGITAL_DOLLAR_REWARDS_BEFORE;         double digitalReputationForMiner = Seting.DIGITAL_STOCK_REWARDS_BEFORE;          //доход основателя         double founderReward = Seting.DIGITAL_DOLLAR_FOUNDER_REWARDS_BEFORE;         double founderDigigtalReputationReward = Seting.DIGITAL_REPUTATION_FOUNDER_REWARDS_BEFORE;          Base base = new Base58();          //суммирует все вознаграждения майнеров         PrivateKey privateKey = UtilsSecurity.privateBytToPrivateKey(base.decode(Seting.BASIS_PASSWORD));         double sumRewards = forAdd.stream().collect(Collectors.summingDouble(DtoTransaction::getBonusForMiner));          //вознаграждения майнера         DtoTransaction minerRew = new DtoTransaction(Seting.BASIS_ADDRESS, minner.getAccount(),                 minerRewards, digitalReputationForMiner, new Laws(), sumRewards, VoteEnum.YES );          //подписывает         byte[] signGold = UtilsSecurity.sign(privateKey, minerRew.toSign());         minerRew.setSign(signGold);          //вознаграждение основателя         DtoTransaction founderRew = new DtoTransaction(Seting.BASIS_ADDRESS, blockchain.getADDRESS_FOUNDER(),                 founderReward, founderDigigtalReputationReward, new Laws(), 0.0, VoteEnum.YES);         byte[] signFounder = UtilsSecurity.sign(privateKey, founderRew.toSign());          founderRew.setSign(signFounder);           forAdd.add(minerRew);         forAdd.add(founderRew);           //определение сложности и создание блока         int difficulty = UtilsBlock.difficulty(blockchain.getBlockchainList(), blockGenerationInterval, DIFFICULTY_ADJUSTMENT_INTERVAL);          System.out.println(\"Mining: miningBlock: difficulty: \" + difficulty + \" index: \" + index);           //blockchain.getHashBlock(blockchain.sizeBlockhain() - 1)         Block block = new Block(                 forAdd,                 blockchain.getHashBlock(blockchain.sizeBlockhain() - 1),                 minner.getAccount(),                 blockchain.getADDRESS_FOUNDER(),                 difficulty,                 index);          return block;     } }","package International_Trade_Union.model;  import International_Trade_Union.setings.Seting; import International_Trade_Union.utils.UtilsFileSaveRead;  import java.io.FileNotFoundException;   public class User {     private static String addressMiner=\"\";      public static void setUserAddress(String addressMiner) { //        System.out.println(\"change minerAccount: \" + addressMiner); //        UtilsFileSaveRead.save(addressMiner, Seting.ORIGINAL_ACCOUNT, false);         User.addressMiner = addressMiner;     }      public static String getUserAddress() throws FileNotFoundException {         addressMiner = UtilsFileSaveRead.read(Seting.ORIGINAL_ACCOUNT);         System.out.println(\"user: \" + addressMiner);         if(addressMiner.isEmpty() || addressMiner == null)             addressMiner = \"empty \";         return addressMiner;     } }","package International_Trade_Union.network;  import International_Trade_Union.entity.DtoTransaction.DtoTransaction; import International_Trade_Union.model.Mining; import International_Trade_Union.setings.Seting; import International_Trade_Union.utils.*; import org.json.JSONException;  import java.io.File; import java.io.IOException; import java.security.InvalidKeyException; import java.security.NoSuchAlgorithmException; import java.security.NoSuchProviderException; import java.security.SignatureException; import java.security.spec.InvalidKeySpecException; import java.util.ArrayList; import java.util.List; import java.util.stream.Collectors;  public class AllTransactions {     private static List<DtoTransaction> instance = new ArrayList<>();     //все транзакции которые уже добавлены в блок, нужно чтобы повторно     //не добавлялись в блок если они скачены с дисковери.     private static List<DtoTransaction> sendedTransaction = new ArrayList<>();      public static List<DtoTransaction> readFrom() throws IOException, NoSuchAlgorithmException, InvalidKeySpecException, SignatureException, NoSuchProviderException, InvalidKeyException {         return UtilsTransaction.readLineObject(Seting.ORGINAL_ALL_TRANSACTION_FILE);     }      public static synchronized List<DtoTransaction> getInstance() throws IOException, NoSuchAlgorithmException, InvalidKeySpecException, SignatureException, NoSuchProviderException, InvalidKeyException {         if (instance == null) {             instance = new ArrayList<>();         }         instance = new ArrayList<>();          //считываем с пула транзакции из дисковери.         for (String s : Seting.ORIGINAL_ADDRESSES) {             try {                 String json = UtilUrl.readJsonFromUrl(s + \"/getTransactions\");                 List<DtoTransaction> list = UtilsJson.jsonToDtoTransactionList(json);                  instance.addAll(list);               } catch (IOException | JSONException e) {                  System.out.println(\"AllTransaction: getInstance: Error\");                 continue;             }           }          instance.addAll(UtilsTransaction.readLineObject(Seting.ORGINAL_ALL_TRANSACTION_FILE));         instance = instance.stream().distinct().collect(Collectors.toList());          sendedTransaction = getInsanceSended();          instance.removeAll(sendedTransaction);         return instance;     }      public static synchronized void clearAllTransaction() {         instance = new ArrayList<>();         Mining.deleteFiles(Seting.ORGINAL_ALL_TRANSACTION_FILE);     }      public static synchronized void clearAllSendedTransaction(long index) {         if(index % (Seting.COUNT_BLOCK_IN_DAY * Seting.DAY_DELETED_SENDED_FILE) == 0){             sendedTransaction = new ArrayList<>();             Mining.deleteFiles(Seting.ORIGINAL_ALL_SENDED_TRANSACTION_FILE);             System.out.println(\"clear delete sended transaction\");         }      }      public static synchronized void clearUsedTransaction(List<DtoTransaction> transactions) throws IOException, NoSuchAlgorithmException, SignatureException, InvalidKeySpecException, NoSuchProviderException, InvalidKeyException {         instance = getInstance();         List<DtoTransaction> temporaryDto = new ArrayList<>();          instance = temporaryDto;         instance.removeAll(transactions);         Mining.deleteFiles(Seting.ORGINAL_ALL_TRANSACTION_FILE);         for (DtoTransaction dtoTransaction : instance) {              UtilsTransaction.saveAllTransaction(dtoTransaction, Seting.ORGINAL_ALL_TRANSACTION_FILE);         }       }      public static synchronized void addTransaction(DtoTransaction transaction) throws IOException, NoSuchAlgorithmException, SignatureException, InvalidKeySpecException, NoSuchProviderException, InvalidKeyException {          instance = getInstance();         instance.add(transaction);         Mining.deleteFiles(Seting.ORGINAL_ALL_TRANSACTION_FILE);         instance = instance.stream().filter(UtilsUse.distinctByKey(DtoTransaction::toSign)).collect(Collectors.toList());         for (DtoTransaction dtoTransaction : instance) {             UtilsTransaction.saveAllTransaction(dtoTransaction, Seting.ORGINAL_ALL_TRANSACTION_FILE);         }       }      public static synchronized void addSendedTransaction(List<DtoTransaction> transactions) throws IOException, NoSuchAlgorithmException, InvalidKeySpecException, SignatureException, NoSuchProviderException, InvalidKeyException {         sendedTransaction = getInsanceSended();         sendedTransaction.addAll(transactions);          Mining.deleteFiles(Seting.ORIGINAL_ALL_SENDED_TRANSACTION_FILE);         for (DtoTransaction dtoTransaction : sendedTransaction) {             UtilsTransaction.saveAllTransaction(dtoTransaction, Seting.ORIGINAL_ALL_SENDED_TRANSACTION_FILE);         }          System.out.println(\"AllTransaction: addSendedTransaction: \" + sendedTransaction.size());      }      public static List<DtoTransaction> getInsanceSended() throws IOException, NoSuchAlgorithmException, InvalidKeySpecException, SignatureException, NoSuchProviderException, InvalidKeyException {         if (sendedTransaction == null) {             sendedTransaction = new ArrayList<>();         }         sendedTransaction = UtilsTransaction.readLineObject(Seting.ORIGINAL_ALL_SENDED_TRANSACTION_FILE);         sendedTransaction = sendedTransaction.stream().distinct().collect(Collectors.toList());         return sendedTransaction;     }  }","package International_Trade_Union.network;    import International_Trade_Union.entity.DtoTransaction.DtoTransaction;  import java.util.ArrayList; import java.util.List;  public class Transactions {     public  List<DtoTransaction> getTransactions() {         List<DtoTransaction> transactions = new ArrayList<>();         return transactions;     } }","package International_Trade_Union.node;  import java.util.HashSet; import java.util.Set;  public class Nodes {      public int size(){         return urlAddress.size();     }      public Nodes() {         this.urlAddress = new HashSet<>();     }      public Nodes(Set<String> urlAddress) {         this.urlAddress = urlAddress;     }      private  Set<String> urlAddress = new HashSet<>();      public  void setUrlAddress(Set<String> urlAddress) {         this.urlAddress = urlAddress;     }     public void addAddress(String addressUrl){         urlAddress.add(addressUrl);     }      public  Set<String> getUrlAddresses() {         return urlAddress;     }      public void clear(){         urlAddress = new HashSet<>();     } }","package International_Trade_Union.setings;  import International_Trade_Union.about_usDraft.AboutUsDraft; import International_Trade_Union.about_us_engDraft.AboutUsEngDraft; import International_Trade_Union.CorporateCharterEngDraft.CorporateCharter; import International_Trade_Union.governments.Directors; import International_Trade_Union.governments.NamePOSITION; import International_Trade_Union.utils.UtilsUse;  import java.util.Set;  public interface Seting {     // значение используется для вычисления процентов     int HUNDRED_PERCENT = 100;     // значение используется как константа года,     // в данной системе отсутствует високосный год     int YEAR = 360;      Directors directors = new Directors();       //используется для очистки из файла, где хранятся отправленные транзакции,     //чтобы предотвратить добавление повторно уже отправленных транзакций     int DAY_DELETED_SENDED_FILE = 3;        //За какой период последних блоков учитывать для отбора акционеров.     //Акционерами могут быть только с наибольшим количеством баланса     //отправители и майнеры.     int BOARDS_BLOCK = (int) (Seting.COUNT_BLOCK_IN_DAY * YEAR);       //минимальное значение количество положительных голосов, для того чтобы избрать     // Совет Директоров и Совет Корпоративных Верховных Судей,     int ORIGINAL_LIMIT_MIN_VOTE = 1; //(int) (200 * Seting.COUNT_BLOCK_IN_DAY * 1 / 8);       //прямая демократия, сколько голосов нужно, чтобы правило вступило в силу,     //без необходимости правительства     double ALL_STOCK_VOTE = 100000.0;        //Минимальное значение чтобы Совет Корпоративных Верховных Судей могла избрать Верховного Судью     int ORIGINAL_LIMIT_MIN_VOTE_CORPORATE_COUNCIL_OF_REFEREES = 3;      //Минимальное значение остатка голосов чтобы Совет директоров утверждал бюджет,     //стратегический план, в создании новых должностей и назначении новых должностей,     //и т.д. Также участвовал в утверждении законов, вместе с другими участниками.     int ORIGINAL_LIMIT_MIN_VOTE_BOARD_OF_DIRECTORS = 15;//15;      //Минимальное количество остатка голосов чтобы Совет Акционеров     //утверждал вместе с остальными участниками в утверждении законов.     int ORIGINAL_LIMIT_MIN_VOTE_BOARD_OF_SHAREHOLDERS = 100; //100;      //голос Генерального Исполнительного Директора     int ORIGINAL_LIMIT_MIN_VOTE_GENERAL_EXECUTIVE_DIRECTOR = 1;      //голос Верховного Судьи     int ORIGINAL_LIMIT_MIN_VOTE_HIGHT_JUDGE = 1;      //для преодоления верховного судьи, если Верховный Судья не одобрил закон     //то нужно получить в два раза больше голосов, чтобы преодолеть вето Верховного Судьи     int POWERFUL_VOTE = 2;      //данная мера нужна чтобы если один счет голосует за несколько кандидатов,     //его голос не делился равномерно, а становился значительно сильнее,     //чтобы не допустить монополии, если очень богатый человек захочет должностные лица поставить к власти     //то он не сможет пример: счет X проголосовал ЗА = 2 закона и ПРОТИВ = 3 закона     //100 = voteYES, 100 = voteNO, voteYES / (2^3) = 12.5 , voteNO / (3^3) = 3.7     //таким образом чем больше голосует, тем меньше голосов остается для избрания     //должностных лиц, это защита от сверхбогатых участников Совета Акционеров     int POWERING_FOR_VOTING = 3;       //голос должностных лиц,     int VOTE_GOVERNMENT = 1;     //голос должностных лиц вместо акций учитывается только один     //голос, как будто у них одна акция     double STOCK_VOTE_GOVERNMENT = 1;      //    процент который получает основатель от добычи     Double FOUNDERS_REWARD = 2.0;      //address for send rewards     String BASIS_ADDRESS = \"faErFrDnBhfSfNnj1hYjxydKNH28cRw1PBwDQEXH3QsJ\";     String BASIS_PASSWORD = \"3hupFSQNWwiJuQNc68HiWzPgyNpQA2yy9iiwhytMS7rZyfPddNRwtvExeevhayzN6xL2YmTXN6NCA8jBhV9ge1w8KciHedGUMgZyq2T7rDdvekVNwEgf5pQrELv8VAEvQ4Kb5uviXJFuMyuD1kRAGExrZym5nppyibEVnTC9Uiw8YzUh2JmVT9iUajnVV3wJ5foMs\";      //сложность коррекция каждые n блоков     int DIFFICULTY_ADJUSTMENT_INTERVAL = (int) (Seting.COUNT_BLOCK_IN_DAY / 2);     int DIFFICULTY_ADJUSTMENT_INTERVAL_TEST = 10;      long BLOCK_GENERATION_INTERVAL = Seting.BLOCK_TIME * 1000;// after Seting.BLOCK_TIME     long BLOCK_GENERATION_INTERVAL_TEST = 0 * 1000;       long INTERVAL_TARGET = 600000;     long INTERVAL_TARGET_TEST = 25000;      // плата за обслуживание каждые 6 месяцев.     Double ANNUAL_MAINTENANCE_FREE_DIGITAL_DOLLAR_YEAR = 0.2;     //отрицательная ставка для цифровой акции     double ANNUAL_MAINTENANCE_FREE_DIGITAL_STOCK_YEAR = 0.4;     //каждые сколько месяцев снимать     int HALF_YEAR = 2;      //стоимость создания закона 5     double COST_LAW = 5;     //с чего начинается адрес пакета закона     //сокращенно корпорация     String NAME_LAW_ADDRESS_START = \"LIBER\";      int HASH_COMPLEXITY_GENESIS = 1;      //совет акционеров    int BOARD_OF_SHAREHOLDERS = 1500;      //ПОПРАВКА В УСТАВЕ    //требования к поправкам     String AMENDMENT_TO_THE_CHARTER = \"AMENDMENT_TO_THE_CHARTER\";      //директора созданные Советом директоров     String ADD_DIRECTOR = \"ADD_DIRECTOR\";      //бюджет должен формировать только палата представителей     String BUDGET = \"BUDGET\";      //план также утверждается на четыре года и утверждается только палатой представителей     //каждый план обязан содержать дату начала планирования с какого числа вступает в силу.     //FOUR-YEAR PLAN     String STRATEGIC_PLAN = \"STRATEGIC_PLAN\";       //лимиты для ведения поправок     //палата судей минимум 5 голосов     int ORIGINAL_LIMIT_MIN_VOTE_CORPORATE_COUNCIL_OF_REFEREES_AMENDMENT = 5;// 5;     //палата представителей 20% голосов     int ORIGINAL_LIMIT_MIN_VOTE_BOARD_OF_DIRECTORS_AMENDMENT =            directors.getDirector(NamePOSITION.BOARD_OF_DIRECTORS.toString()).getCount() * 20 / 100;      //Совет акционеров минимум 20% голосов     int ORIGINAL_LIMIT_MINT_VOTE_BOARD_OF_SHAREHOLDERS_AMENDMENT = BOARD_OF_SHAREHOLDERS * 20 / 100;       //    адресс основателя: здесь будет мой адрес. Сейчас заглушка     String ADDRESS_FOUNDER_TEST = \"stExZb8ifLfnFoq4JJuTifpAcscegATH8znhwW26zyTa\";     String ADDRESS_FOUNDER = \"stExZb8ifLfnFoq4JJuTifpAcscegATH8znhwW26zyTa\";      String CORPORATE_CHARTER_DRAFT = International_Trade_Union.CorporateCharterDraft.CorporateCharter.getAllConstitution() + \"\\n\" + CorporateCharter.getAllConstitution() + AboutUsDraft.getAboutUs()             + AboutUsEngDraft.getAboutUs();      //КЛЮЧЕВОЕ НАЗВАНИЕ ПАКЕТА ЧТО ЭТО УСТАВ, ДЕЙСТВУЮЩИЙ УСТАВ ПОДПИСАН ОСНОВАТЕЛЕМ.     String ORIGINAL_CHARTER_CURRENT_LAW_PACKAGE_NAME = \"ORIGINAL_CHARTER_CURRENT_LAW_PACKAGE_NAME\";      //КЛЮЧЕВОЕ НАЗВАНИЕ ДЛЯ КОДА КОТОРЫЙ СОПРОВОЖДАЕТСЯ С УСТАВОМ     String ORIGINAL_CHARTER_CURRENT_ALL_CODE = \"ORIGINAL_CHARTER_CURRENT_ALL_CODE\";      //начальная сумма основателя     Double FOUNDERS_REMUNERATION_DIGITAL_DOLLAR = 30000000.0;     double FOUNDERS_REMNUNERATION_DIGITAL_STOCK = 30000000.0;       // сколько секунд в сутках     int DAY_SECOND = 86400;      //    за сколько секунд добывается каждый блок     int BLOCK_TIME = 150;       //сколько блоков добывается в сутки     double COUNT_BLOCK_IN_DAY = (DAY_SECOND / BLOCK_TIME);      //подсчет голосов для должности в годах, учитываются только те голоса     //которые не позже четырех лет для законов и должностей,     //голоса отданные за законы должны обновляться каждые четыре года     //как и за должности     int POSITION_YEAR_VOTE = (int) Seting.COUNT_BLOCK_IN_DAY * YEAR * 4;     //подсчет голосов для законов в годах     int LAW_YEAR_VOTE = (int) Seting.COUNT_BLOCK_IN_DAY * YEAR * 4;      String ORIGINAL_BLOCKCHAIN_FILE = \"C:\\\\resources\\\\blockchain\\\\\";     String ORIGINAL_BALANCE_FILE = \"C:\\\\resources\\\\balance\\\\\";     String ORIGINAL_BOARD_0F_SHAREHOLDERS_FILE = \"C:\\\\resources\\\\federalGovernment\\\\federalGovernment.txt\";     String ORIGINAL_ALL_CORPORATION_LAWS_FILE = \"C:\\\\resources\\\\federalLaws\\\\\";     String ORIGINAL_ACCOUNT = \"C:\\\\resources\\\\minerAccount\\\\minerAccount.txt\";     String ORIGINAL_CORPORATE_VOTE_FILE = \"C:\\\\resources\\\\vote\\\\\";      String ORIGINAL_ALL_CORPORATION_LAWS_WITH_BALANCE_FILE = \"C:\\\\resources\\\\allLawsWithBalance\\\\\";     String ORGINAL_ALL_TRANSACTION_FILE = \"C:\\\\resources\\\\transactions\\\\\";     String ORIGINAL_ALL_SENDED_TRANSACTION_FILE = \"C:\\\\resources\\\\sendedTransaction\\\\\";     String ORIGINAL_POOL_URL_ADDRESS_FILE = \"C:\\\\resources\\\\poolAddress\\\\\";      //адресса внешних сервисов     Set<String> ORIGINAL_ADDRESSES = Set.of(\"http://194.87.236.238:80\");       int SIZE_FILE_LIMIT = 100;      //папки файла для тестирования с сохранениям файла     String TEST_LAST_BLOCK = \".\\\\src\\\\test\\\\java\\\\unitted_states_of_mankind\\\\resourceTestingFileSaved\\\\lastBlock\\\\\";     String INDEX_TEST = \".\\\\src\\\\test\\\\java\\\\unitted_states_of_mankind\\\\resourceTestingFileSaved\\\\index\\\\index.txt\";     String TEST_BLOCKCHAIN_SAVED = \".\\\\src\\\\test\\\\java\\\\unitted_states_of_mankind\\\\resourceTestingFileSaved\\\\network\\\\\";     String TEST_BLOCKCHAIN_BALANCES = \".\\\\src\\\\test\\\\java\\\\unitted_states_of_mankind\\\\resourceTestingFileSaved\\\\balances\\\\\";     String TEST_FEDERAL_GOVERNMENT = \".\\\\src\\\\test\\\\java\\\\unitted_states_of_mankind\\\\resourceTestingFileSaved\\\\federal government\\\\federalGovernment.txt\";     String TEST_FEDERAL_LAWS = \".\\\\src\\\\test\\\\java\\\\unitted_states_of_mankind\\\\resourceTestingFileSaved\\\\laws\\\\\";     String TEST_CURRENT_LAWS = \".\\\\src\\\\test\\\\java\\\\unitted_states_of_mankind\\\\resourceTestingFileSaved\\\\current laws\\\\\";     String TEST_FEDERAL_VOTE = \".\\\\src\\\\test\\\\java\\\\unitted_states_of_mankind\\\\resourceTestingFileSaved\\\\vote\\\\\";     String TEST_ALL_FEDERAL_LAWS_WITH_BALANCE_FILE = \".\\\\src\\\\test\\\\java\\\\unitted_states_of_mankind\\\\resourceTestingFileSaved\\\\allLawsWithBalance\\\\\";      //Временный блокчейн для тестирования     String TEST_LAST_BLOCK_TEMPORARY = \".\\\\src\\\\test\\\\java\\\\unitted_states_of_mankind\\\\resourceTestingFileWithoutSave\\\\lastBlock\\\\\";     String TEST_INDEX_TEMPORARY = \".\\\\src\\\\test\\\\java\\\\unitted_states_of_mankind\\\\resourceTestingFileWithoutSave\\\\index\\\\index.txt\";     String TEST_TEMPORARY_BLOCKCHAIN = \".\\\\src\\\\test\\\\java\\\\unitted_states_of_mankind\\\\resourceTestingFileWithoutSave\\\\temporary blockchain\\\\\";     String TEST_BLOCKCHAIN_BALANCES_TEMPORARY = \".\\\\src\\\\test\\\\java\\\\unitted_states_of_mankind\\\\resourceTestingFileWithoutSave\\\\balances\\\\\";     String TEST_FEDERAL_GOVERNMENT_TEMPORARY = \".\\\\src\\\\test\\\\java\\\\unitted_states_of_mankind\\\\resourceTestingFileWithoutSave\\\\federal government\\\\federalGovernment.txt\";     String TEST_FEDERAL_LAWS_TEMPORARY = \".\\\\src\\\\test\\\\java\\\\unitted_states_of_mankind\\\\resourceTestingFileWithoutSave\\\\laws\\\\\";     String TEST_CURRENT_LAWS_TEMPORARY = \".\\\\src\\\\test\\\\java\\\\unitted_states_of_mankind\\\\resourceTestingFileWithoutSave\\\\current laws\\\\\";     String TEST_FEDERAL_VOTE_TEMPORARY = \".\\\\src\\\\test\\\\java\\\\unitted_states_of_mankind\\\\resourceTestingFileSaved\\\\vote\\\\\";     String TEST_ALL_FEDERAL_LAWS_WITH_BALANCE_TEMPORARY = \".\\\\unitedStates\\\\src\\\\test\\\\java\\\\unitted_states_of_mankind\\\\resourceTestingFileWithoutSave\\\\allLawsWithBalance\\\\\";      String TEST_FILE_WRITE_INFO = \".\\\\src\\\\test\\\\java\\\\unitted_states_of_mankind\\\\blockchainTwentyYearTest\\\\\";     double DIGITAL_DOLLAR_REWARDS_BEFORE = 200.0;     double DIGITAL_STOCK_REWARDS_BEFORE = 200.0;     double DIGITAL_DOLLAR_FOUNDER_REWARDS_BEFORE = Math.round(UtilsUse.countPercents(Seting.DIGITAL_DOLLAR_REWARDS_BEFORE, Seting.FOUNDERS_REWARD));     double DIGITAL_REPUTATION_FOUNDER_REWARDS_BEFORE = Math.round(UtilsUse.countPercents(Seting.DIGITAL_STOCK_REWARDS_BEFORE, Seting.FOUNDERS_REWARD));    }","package International_Trade_Union.sheduled;  import org.springframework.context.annotation.Configuration; import org.springframework.scheduling.annotation.EnableScheduling;  @EnableScheduling @Configuration public class SchedulerConfig { }","package International_Trade_Union.utils.base;  public interface Base {     String encode(byte[] input);     byte[] decode(String input); }","package International_Trade_Union.utils.base;    /*  * Copyright 2011 Google Inc.  * Copyright 2018 Andreas Schildbach  *  * From https://github.com/bitcoinj/bitcoinj/blob/master/core/src/main/java/org/bitcoinj/core/Base58.java  *  * Licensed under the Apache License, Version 2.0 (the \"License\");  * you may not use this file except in compliance with the License.  * You may obtain a copy of the License at  *  *    http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an \"AS IS\" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */  import java.math.BigInteger; import java.util.Arrays;  /**  * Base58 is a way to encode Bitcoin addresses (or arbitrary data) as alphanumeric strings.  * <p>  * Note that this is not the same base58 as used by Flickr, which you may find referenced around the Internet.  * <p>  * Satoshi explains: why base-58 instead of standard base-64 encoding?  * <ul>  * <li>Don't want 0OIl characters that look the same in some fonts and  *     could be used to create visually identical looking minerAccount numbers.</li>  * <li>A string with non-alphanumeric characters is not as easily accepted as an minerAccount number.</li>  * <li>E-mail usually won't line-break if there's no punctuation to break at.</li>  * <li>Doubleclicking selects the whole number as one word if it's all alphanumeric.</li>  * </ul>  * <p>  * However, note that the encoding/decoding runs in O(n&sup2;) time, so it is not useful for large data.  * <p>  * The basic idea of the encoding is to treat the data bytes as a large number represented using  * base-256 digits, convert the number to be represented using base-58 digits, preserve the exact  * number of leading zeros (which are otherwise lost during the mathematical operations on the  * numbers), and finally represent the resulting base-58 digits as alphanumeric ASCII characters.  */ public class Base58 implements Base {     public static final char[] ALPHABET = \"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz\".toCharArray();     private static final char ENCODED_ZERO = ALPHABET[0];     private static final int[] INDEXES = new int[128];     static {         Arrays.fill(INDEXES, -1);         for (int i = 0; i < ALPHABET.length; i++) {             INDEXES[ALPHABET[i]] = i;         }     }      /**      * Encodes the given bytes as a base58 string (no checksum is appended).      *      * @param input the bytes to encode      * @return the base58-encoded string      */     public String encode(byte[] input) {         if (input.length == 0) {             return \"\";         }         // Count leading zeros.         int zeros = 0;         while (zeros < input.length && input[zeros] == 0) {             ++zeros;         }         // Convert base-256 digits to base-58 digits (plus conversion to ASCII characters)         input = Arrays.copyOf(input, input.length); // since we modify it in-place         char[] encoded = new char[input.length * 2]; // upper bound         int outputStart = encoded.length;         for (int inputStart = zeros; inputStart < input.length; ) {             encoded[--outputStart] = ALPHABET[divmod(input, inputStart, 256, 58)];             if (input[inputStart] == 0) {                 ++inputStart; // optimization - skip leading zeros             }         }         // Preserve exactly as many leading encoded zeros in output as there were leading zeros in input.         while (outputStart < encoded.length && encoded[outputStart] == ENCODED_ZERO) {             ++outputStart;         }         while (--zeros >= 0) {             encoded[--outputStart] = ENCODED_ZERO;         }         // Return encoded string (including encoded leading zeros).         return new String(encoded, outputStart, encoded.length - outputStart);     }      /**      * Decodes the given base58 string into the original data bytes.      *      * @param input the base58-encoded string to decode      * @return the decoded data bytes      */     public byte[] decode(String input) {         if (input.length() == 0) {             return new byte[0];         }         // Convert the base58-encoded ASCII chars to a base58 byte sequence (base58 digits).         byte[] input58 = new byte[input.length()];         for (int i = 0; i < input.length(); ++i) {             char c = input.charAt(i);             int digit = c < 128 ? INDEXES[c] : -1;             if (digit < 0) {                 throw new IllegalStateException(\"InvalidCharacter in base 58\");             }             input58[i] = (byte) digit;         }         // Count leading zeros.         int zeros = 0;         while (zeros < input58.length && input58[zeros] == 0) {             ++zeros;         }         // Convert base-58 digits to base-256 digits.         byte[] decoded = new byte[input.length()];         int outputStart = decoded.length;         for (int inputStart = zeros; inputStart < input58.length; ) {             decoded[--outputStart] = divmod(input58, inputStart, 58, 256);             if (input58[inputStart] == 0) {                 ++inputStart; // optimization - skip leading zeros             }         }         // Ignore extra leading zeroes that were added during the calculation.         while (outputStart < decoded.length && decoded[outputStart] == 0) {             ++outputStart;         }         // Return decoded data (including original number of leading zeros).         return Arrays.copyOfRange(decoded, outputStart - zeros, decoded.length);     }      public  BigInteger decodeToBigInteger(String input) {         return new BigInteger(1, decode(input));     }      /**      * Divides a number, represented as an array of bytes each containing a single digit      * in the specified base, by the given divisor. The given number is modified in-place      * to contain the quotient, and the return value is the remainder.      *      * @param number the number to divide      * @param firstDigit the index within the array of the first non-zero digit      *        (this is used for optimization by skipping the leading zeros)      * @param base the base in which the number's digits are represented (up to 256)      * @param divisor the number to divide by (up to 256)      * @return the remainder of the division operation      */     private byte divmod(byte[] number, int firstDigit, int base, int divisor) {         // this is just long division which accounts for the base of the input digits         int remainder = 0;         for (int i = firstDigit; i < number.length; i++) {             int digit = (int) number[i] & 0xFF;             int temp = remainder * base + digit;             number[i] = (byte) (temp / divisor);             remainder = temp % divisor;         }         return (byte) remainder;     } }","package International_Trade_Union.utils;    import International_Trade_Union.setings.Seting; import International_Trade_Union.model.Account;  import java.io.File; import java.io.IOException; import java.security.InvalidKeyException; import java.security.NoSuchAlgorithmException; import java.security.NoSuchProviderException; import java.security.SignatureException; import java.security.spec.InvalidKeySpecException; import java.util.ArrayList; import java.util.List; import java.util.Map; import java.util.stream.Collectors;  public class SaveBalances {      public static void saveBalances(Map<String, Account> balances, String filename) throws IOException, NoSuchAlgorithmException, SignatureException, InvalidKeySpecException, NoSuchProviderException, InvalidKeyException {         int fileLimit = Seting.SIZE_FILE_LIMIT * 1024 * 1024;          //папка чтобы проверить есть ли         File folder = new File(filename);         List<String> files = new ArrayList<>();         for (File file : folder.listFiles()) {             if(!file.isDirectory()){                 files.add(file.getAbsolutePath());             }         }          int count = 0;         files = files.stream().sorted().collect(Collectors.toList());         String nextFile = \"\";          if (files.size() > 0) {             nextFile = files.get(files.size()-1);              count = Integer.parseInt(nextFile.replaceAll(\"[^\\\\d]\", \"\"));           }          File file = new File(nextFile);          if(file.length() >= fileLimit){             count++;          }          nextFile = filename + count + \".txt\";          List<String> jsons = new ArrayList<>();         for (Map.Entry<String, Account> stringAccountEntry : balances.entrySet()) {             String json = UtilsJson.objToStringJson(stringAccountEntry.getValue());             jsons.add(json);         }  //        String json = UtilsJson.objToStringJson(minerAccount); //        UtilsFileSaveRead.save(json + \"\\n\", nextFile);         UtilsFileSaveRead.saves(jsons, nextFile, true);      }      public static Map<String, Account> readLineObject(String filename ) throws IOException, NoSuchAlgorithmException, InvalidKeySpecException, SignatureException, NoSuchProviderException, InvalidKeyException {         List<Account> accounts = new ArrayList<>();         File folder = new File(filename);         for (final File fileEntry : folder.listFiles()) {             if (fileEntry.isDirectory()) {                 System.out.println(\"is directory \" + fileEntry.getAbsolutePath());             } else {                 List<String> list = UtilsFileSaveRead.reads(fileEntry.getAbsolutePath());                 for (String s : list) {                    Account account = UtilsJson.jsonToAccount(s);                     accounts.add(account);                 }              }         }         Map<String, Account> balances = accounts                 .stream()                 .collect(Collectors.toMap(Account::getAccount, t->t, (v1, v2) -> v1));         return balances;     } }","package International_Trade_Union.utils;    import International_Trade_Union.model.Account; import International_Trade_Union.setings.Seting;  import java.util.ArrayList; import java.util.List;  public class UtilAccounts {  //    поиск аккаунта по адрессу     public static Account serchAccountByAddress(List<Account> accountList, String address){         Account result = null;         for (Account account : accountList) {             if(account.getAccount().equals(address)){                 result = account; //                System.out.println(String.format(\"find minerAccount: %s, address %s\", minerAccount.getAccount(), address));                 return result;             }         }         return result;     } //    возвращает список счетов чья наличность больше n     public static List<Account> allAccountsRemnantUpperLimit(              List<Account> accountList, double bottomLineMoney){         List<Account> accounts = new ArrayList<>();                  for (Account account : accountList) {                      if(account.getDigitalDollarBalance()>bottomLineMoney)                         accounts.add(account);                 }               return accounts;     }  //    подсчитывает общий баланс всех участников     public static double getAllBalance( List<Account> accountList){         double allBalance = 0.0;              for (Account account : accountList) {                 if(!account.getAccount().equals(Seting.BASIS_ADDRESS))                     allBalance+=account.getDigitalDollarBalance();             }           return allBalance;     }     }","package International_Trade_Union.utils;  import International_Trade_Union.entity.DtoTransaction.DtoTransaction; import International_Trade_Union.setings.Seting;  import java.io.File; import java.io.IOException; import java.security.InvalidKeyException; import java.security.NoSuchAlgorithmException; import java.security.NoSuchProviderException; import java.security.SignatureException; import java.security.spec.InvalidKeySpecException; import java.util.ArrayList; import java.util.HashSet; import java.util.List; import java.util.Set; import java.util.stream.Collectors;  public class UtilsAllAddresses {     public static void saveAllAddresses(String adress, String filename) throws IOException, NoSuchAlgorithmException, SignatureException, InvalidKeySpecException, NoSuchProviderException, InvalidKeyException {         int fileLimit = Seting.SIZE_FILE_LIMIT * 1024 * 1024;          //папка чтобы проверить есть ли         File folder = new File(filename);         List<String> files = new ArrayList<>();         for (File file : folder.listFiles()) {             if(!file.isDirectory()){                 files.add(file.getAbsolutePath());             }         }           int count = 0;         files = files.stream().sorted().collect(Collectors.toList());         String nextFile = \"\";          if (files.size() > 0) {             nextFile = files.get(files.size()-1);              count = Integer.parseInt(nextFile.replaceAll(\"[^\\\\d]\", \"\"));           }          File file = new File(nextFile);          if(file.length() >= fileLimit){             count++;          }          nextFile = filename + count + \".txt\";          String json = UtilsJson.objToStringJson(adress);         UtilsFileSaveRead.save(json + \"\\n\", nextFile);      }      public static Set<String> readLineObject(String filename ) throws IOException, NoSuchAlgorithmException, InvalidKeySpecException, SignatureException, NoSuchProviderException, InvalidKeyException {         Set<String> allAddresses = new HashSet<>();         File folder = new File(filename);         for (final File fileEntry : folder.listFiles()) {             if (fileEntry.isDirectory()) {                 System.out.println(\"is directory \" + fileEntry.getAbsolutePath());             } else {                 Set<String> list = UtilsFileSaveRead.readSet(fileEntry.getAbsolutePath())                         .stream().collect(Collectors.toSet());                 for (String s : list) {                     allAddresses.add(s);                 }              }         }          allAddresses = allAddresses                 .stream()                 .collect(Collectors.toSet());           return allAddresses;     }  }","package International_Trade_Union.utils;    import International_Trade_Union.entity.DtoTransaction.DtoTransaction; import International_Trade_Union.entity.blockchain.Blockchain; import International_Trade_Union.entity.blockchain.block.Block; import International_Trade_Union.setings.Seting; import International_Trade_Union.model.Account; import International_Trade_Union.vote.VoteEnum;  import java.io.IOException; import java.security.*; import java.security.spec.InvalidKeySpecException; import java.util.*;   public class UtilsBalance {      //подсчет по штучно баланса     public  static Map<String, Account> calculateBalance(Map<String, Account> balances, Block block) throws IOException, NoSuchAlgorithmException, SignatureException, InvalidKeySpecException, NoSuchProviderException, InvalidKeyException {           double percent = Seting.ANNUAL_MAINTENANCE_FREE_DIGITAL_DOLLAR_YEAR / Seting.HALF_YEAR;         double digitalReputationPercent = Seting.ANNUAL_MAINTENANCE_FREE_DIGITAL_STOCK_YEAR / Seting.HALF_YEAR;             int i = (int) block.getIndex();               for (int j = 0; j < block.getDtoTransactions().size(); j++) {                 int BasisSendCount = 0;                   DtoTransaction transaction = block.getDtoTransactions().get(j);                  if(transaction.getSender().startsWith(Seting.NAME_LAW_ADDRESS_START)){                     System.out.println(\"law balance cannot be sender\");                     continue;                 }                 if (transaction.verify()) {                     if(transaction.getSender().equals(Seting.BASIS_ADDRESS))                         BasisSendCount++;                       Account sender = getBalance(transaction.getSender(), balances);                     Account customer = getBalance(transaction.getCustomer(), balances);                      boolean sendTrue = true;                     if(sender.getAccount().equals(Seting.BASIS_ADDRESS) && BasisSendCount > 2){                         System.out.println(\"Basis address can send only two the base address can send no more than two times per block:\" + Seting.BASIS_ADDRESS);                         continue;                     }                      double minerRewards = Seting.DIGITAL_DOLLAR_REWARDS_BEFORE;                     double digitalReputationForMiner = Seting.DIGITAL_STOCK_REWARDS_BEFORE;                        if(sender.getAccount().equals(Seting.BASIS_ADDRESS) ){                        if(i > 1 && (transaction.getDigitalDollar() > minerRewards || transaction.getDigitalStockBalance() > digitalReputationForMiner )){                            System.out.println(\"rewards cannot be upper than \" + minerRewards);                            continue;                        }                         if(!customer.getAccount().equals(block.getFounderAddress()) && !customer.getAccount().equals(block.getMinerAddress())){                             System.out.println(\"Basis address can send only to founder or miner\");                             continue;                         }                     }                     sendTrue = UtilsBalance.sendMoney(sender, customer, transaction.getDigitalDollar(), transaction.getDigitalStockBalance(), transaction.getBonusForMiner(), transaction.getVoteEnum());                      //если транзация валидная то записать данн иыезменения в баланс                     if(sendTrue){                         balances.put(sender.getAccount(), sender);                         balances.put(customer.getAccount(), customer);                     }                  }              }           if (i != 0 && i / Seting.COUNT_BLOCK_IN_DAY % (Seting.YEAR / Seting.HALF_YEAR) == 0.0) {              for (Map.Entry<String, Account> changeBalance : balances.entrySet()) {                 Account change = changeBalance.getValue();                 change.setDigitalStockBalance(change.getDigitalStockBalance() - UtilsUse.countPercents(change.getDigitalStockBalance(), digitalReputationPercent));                 change.setDigitalDollarBalance(change.getDigitalDollarBalance() - UtilsUse.countPercents(change.getDigitalDollarBalance(), percent));             }         }           return balances;      }     //подсчет целиком баланса     public static Map<String, Account> calculateBalances(List<Block> blocks) throws IOException, NoSuchAlgorithmException, SignatureException, InvalidKeySpecException, NoSuchProviderException, InvalidKeyException {         Map<String, Account> balances = new HashMap<>();         for (Block block :  blocks) {             calculateBalance(balances, block);         }          return balances;      }        public static Account getBalance(String address, Map<String, Account> balances) {         if (balances.containsKey(address)) {             return balances.get(address);         } else {             Account account = new Account(address, 0.0, 0.0);             return account;         }     }       public static Account findAccount(Blockchain blockList, String address) throws IOException, NoSuchAlgorithmException, SignatureException, InvalidKeySpecException, NoSuchProviderException, InvalidKeyException {         Map<String, Account> accountMap = calculateBalances(blockList.getBlockchainList());         Account account = accountMap.get(address);         return account != null? account: new Account(address, 0.0, 0.0);     }      public static boolean sendMoney(Account senderAddress, Account recipientAddress, double digitalDollar, double digitalReputation, double minerRewards) throws NoSuchAlgorithmException, InvalidKeySpecException, IOException, SignatureException, NoSuchProviderException, InvalidKeyException {         return sendMoney(senderAddress, recipientAddress, digitalDollar, digitalReputation, minerRewards, VoteEnum.YES);     }      public static boolean sendMoney(Account senderAddress, Account recipientAddress, double digitalDollar, double digitalReputation, double minerRewards, VoteEnum voteEnum) throws NoSuchAlgorithmException, InvalidKeySpecException, NoSuchProviderException, IOException, SignatureException, InvalidKeyException {         double remnantDigitalDollar = 0.0;         double remnantDigitalReputation = 0.0;         boolean sendTrue = true;         if (senderAddress.getAccount().equals(recipientAddress.getAccount())) {             System.out.println(\"sender %s, recipient %s cannot be equals! Error!\".format(senderAddress.getAccount(), recipientAddress.getAccount()));             sendTrue = false;         }          remnantDigitalDollar = senderAddress.getDigitalDollarBalance();         remnantDigitalReputation = senderAddress.getDigitalStockBalance();          if (!senderAddress.getAccount().equals(Seting.BASIS_ADDRESS)) {             if(remnantDigitalDollar < digitalDollar + minerRewards){                 sendTrue = false;             }             else if(remnantDigitalReputation < digitalReputation){                     System.out.printf(\"sender power %f, les than powerSend:  %f\\n\",                             senderAddress.getDigitalStockBalance(), digitalReputation);                     sendTrue = false;              } else if (recipientAddress.getAccount().equals(Seting.BASIS_ADDRESS)) {                 System.out.println(\"Basis canot to be recipient;\");                 sendTrue = false;             } else {                  senderAddress.setDigitalDollarBalance(senderAddress.getDigitalDollarBalance() - digitalDollar);                 senderAddress.setDigitalStockBalance(senderAddress.getDigitalStockBalance() - digitalReputation);                 recipientAddress.setDigitalDollarBalance(recipientAddress.getDigitalDollarBalance() + digitalDollar);                 //сделано чтобы можно было увеличить или отнять власть                 if (voteEnum.equals(VoteEnum.YES)) {                     recipientAddress.setDigitalStockBalance(recipientAddress.getDigitalStockBalance() + digitalReputation);                 } else if (voteEnum.equals(VoteEnum.NO)) {                     //политика сдерживания.                     recipientAddress.setDigitalStockBalance(recipientAddress.getDigitalStockBalance() - digitalReputation);                 }              }           }  else if (senderAddress.getAccount().equals(Seting.BASIS_ADDRESS)) {              recipientAddress.setDigitalDollarBalance(recipientAddress.getDigitalDollarBalance() + digitalDollar);             recipientAddress.setDigitalStockBalance(recipientAddress.getDigitalStockBalance() + digitalReputation);          }         return sendTrue;     } }","package International_Trade_Union.utils;   import com.fasterxml.jackson.core.JsonProcessingException; import International_Trade_Union.config.BLockchainFactory; import International_Trade_Union.config.BlockchainFactoryEnum; import International_Trade_Union.entity.DtoTransaction.DtoTransaction; import International_Trade_Union.entity.blockchain.Blockchain; import International_Trade_Union.entity.blockchain.block.Block; import International_Trade_Union.setings.Seting;   import java.io.*; import java.security.*; import java.security.spec.InvalidKeySpecException; import java.util.*; import java.util.stream.Collectors;  public class UtilsBlock {      public static void saveBlocks(List<Block> blocks, String filename) throws IOException {         int fileLimit = Seting.SIZE_FILE_LIMIT * 1024 * 1024;          //папка чтобы проверить есть ли         File folder = new File(filename);         List<String> files = new ArrayList<>();         for (File file : folder.listFiles()) {             if(!file.isDirectory()){                 files.add(file.getAbsolutePath());             }         }          int count = 0;         files = files.stream().sorted().collect(Collectors.toList());         String nextFile = \"\";          if (files.size() > 0) {             nextFile = files.get(files.size()-1);              count = Integer.parseInt(nextFile.replaceAll(\"[^\\\\d]\", \"\"));           }          File file = new File(nextFile);          if(file.length() >= fileLimit){             count++;          }          nextFile = filename + count + \".txt\";          List<String> jsons = new ArrayList<>();         for (Block block: blocks) {             String json = UtilsJson.objToStringJson(block);             jsons.add(json);         }  //        String json = UtilsJson.objToStringJson(minerAccount); //        UtilsFileSaveRead.save(json + \"\\n\", nextFile);         UtilsFileSaveRead.saves(jsons, nextFile, true);     }     public static void saveBLock(Block block, String filename) throws IOException, NoSuchAlgorithmException, SignatureException, InvalidKeySpecException, NoSuchProviderException, InvalidKeyException {         int fileLimit = Seting.SIZE_FILE_LIMIT * 1024 * 1024;          //папка чтобы проверить есть ли         File folder = new File(filename);         List<String> files = new ArrayList<>();         for (File file : folder.listFiles()) {             if(!file.isDirectory()){                 files.add(file.getAbsolutePath());             }         }           int count = 0;         files = files.stream().sorted().collect(Collectors.toList());         String nextFile = \"\";          if (files.size() > 0) {             nextFile = files.get(files.size()-1);              count = Integer.parseInt(nextFile.replaceAll(\"[^\\\\d]\", \"\"));           }          File file = new File(nextFile);          if(file.length() >= fileLimit){             count++;          }           nextFile = filename + count + \".txt\";          String json = UtilsJson.objToStringJson(block);         UtilsFileSaveRead.save(json + \"\\n\", nextFile);      }        public static List<Block> read(String nameFile) throws FileNotFoundException, JsonProcessingException {         return  UtilsJson.jsonToListBLock(UtilsFileSaveRead.read(nameFile));     }      public static List<Block> readLineObject(String filename ) throws IOException, NoSuchAlgorithmException, InvalidKeySpecException, SignatureException, NoSuchProviderException, InvalidKeyException {         List<Block> blocks = new ArrayList<>();         File folder = new File(filename);          for (final File fileEntry : folder.listFiles()) {             if (fileEntry.isDirectory()) {                 System.out.println(\"is directory \" + fileEntry.getAbsolutePath());             } else {                List<String> list = UtilsFileSaveRead.reads(fileEntry.getAbsolutePath());                 for (String s : list) {                      Block block = UtilsJson.jsonToBLock(s);                     blocks.add(block);                 }              }         }         blocks = blocks                 .stream()                 .sorted(Comparator.comparing(Block::getIndex))                 .collect(Collectors.toList());          return blocks;     }     public static Blockchain readBLock(String nameFile, long BLOCK_GENERATION_INTERVAL, int DIFFICULTY_ADJUSTMENT_INTERVAL, long INTERVAL_TARGET , String ADDRESS_FOUNDER) throws NoSuchAlgorithmException, InvalidKeySpecException, IOException, SignatureException, NoSuchProviderException, InvalidKeyException {         List<Block> blocks = null;         List<List<Block>> list = new ArrayList<>();          File folder = new File(nameFile);          for (final File fileEntry : folder.listFiles()) {             if (fileEntry.isDirectory()) {                 System.out.println(\"is directory \" + fileEntry.getAbsolutePath());             } else {                 blocks = UtilsJson.jsonToListBLock(UtilsFileSaveRead.read(fileEntry.getAbsolutePath()));                 list.add(blocks);             }         }          // new Blockchain(BLOCK_GENERATION_INTERVAL, DIFFICULTY_ADJUSTMENT_INTERVAL, INTERVAL_TARGET, ADDRESS_FOUNDER);         Blockchain blockchain = BLockchainFactory.getBlockchain(BlockchainFactoryEnum.ORIGINAL);         blockchain.setBlockchainList(new ArrayList<>());          for (List<Block> lists : list) {             for (int i = 0; i < lists.size(); i++) {                 blockchain.addBlock(lists.get(i));             }          }          List<Block> blockList = blockchain.getBlockchainList()                 .stream()                 .sorted(Comparator.comparing(Block::getIndex))                 .collect(Collectors.toList());         blockchain.setBlockchainList(blockList);          return blockchain;     }      public static Blockchain readBLock() throws IOException, NoSuchAlgorithmException, InvalidKeySpecException, SignatureException, NoSuchProviderException, InvalidKeyException {        return readBLock(Seting.TEST_FILE_WRITE_INFO, Seting.BLOCK_GENERATION_INTERVAL,  Seting.DIFFICULTY_ADJUSTMENT_INTERVAL, Seting.INTERVAL_TARGET, Seting.ADDRESS_FOUNDER );     }      public static boolean isValidTimestamp(Block newBlock, Block prevBLock, long timestamp){         return (prevBLock.getTimestamp().getTime() - timestamp <newBlock.getTimestamp().getTime())                 && newBlock.getTimestamp().getTime() < System.currentTimeMillis();     }      //https://lhartikk.github.io/jekyll/update/2017/07/13/chapter2.html     //сайт сложности     //https://lhartikk.github.io/jekyll/update/2017/07/13/chapter2.html     //https://tproger.ru/translations/blockchain-explained/      //new https://guicommits.com/building-blockchain-with-python/      /**определяет сложность, раз пол дня корректирует сложность. В сутках 576 блоков.      * каждый блок добывается примерно 2.3 минуты*/     public static int difficulty(List<Block> blocks, long BLOCK_GENERATION_INTERVAL, int  DIFFICULTY_ADJUSTMENT_INTERVAL ){          //секунды как часто создается блоки         int difficulty = 1;         Block latestBlock = blocks.get(blocks.size() -1);         if(latestBlock.getIndex() != 0 && latestBlock.getIndex() % DIFFICULTY_ADJUSTMENT_INTERVAL == 0){             difficulty = getAdjustedDifficulty(latestBlock, blocks, BLOCK_GENERATION_INTERVAL, DIFFICULTY_ADJUSTMENT_INTERVAL);             System.out.println(\"difficulty: change dificulty: \" + difficulty);         }         else {             difficulty =  latestBlock.getHashCompexity();         }         return difficulty == 0? 1: difficulty;     }       /**получить сложность*/     private static int getAdjustedDifficulty(Block latestBlock, List<Block> blocks, long BLOCK_GENERATION_INTERVAL, int DIFFICULTY_ADJUSTMENT_INTERVAL){         Block prevAdjustmentBlock = blocks.get(blocks.size() - DIFFICULTY_ADJUSTMENT_INTERVAL);          long timeExpected = BLOCK_GENERATION_INTERVAL * DIFFICULTY_ADJUSTMENT_INTERVAL;         long timeTaken = latestBlock.getTimestamp().getTime() - prevAdjustmentBlock.getTimestamp().getTime();          if(timeTaken < timeExpected / 2){              return prevAdjustmentBlock.getHashCompexity() + 1;         }else if(timeTaken > timeExpected * 2){              return prevAdjustmentBlock.getHashCompexity() - 1;         }else {             return prevAdjustmentBlock.getHashCompexity();         }     }      public static boolean validationOneBlock(             String addressFounder,             Block previusblock,             Block thisBlock,             long blockGenerationInterval,             int difficultyAdjustmentInterval,             List<Block> lastBlock) throws IOException, NoSuchAlgorithmException, SignatureException, InvalidKeySpecException, NoSuchProviderException, InvalidKeyException {          boolean addressFounderReward = false;         boolean addressMinerReward = false;         if(!addressFounder.equals(thisBlock.getFounderAddress())){             System.out.println(\"genesis address not equals block founder: \");             System.out.println(\"genesis address: \" + addressFounder);             System.out.println(\"block address: \" + thisBlock.getFounderAddress());             return false;          }               String actualPrevHash = previusblock.hashForBlockchain();             String recordedPrevHash = thisBlock.getPreviousHash();            boolean validated = true;         int countBasisSendFounder = 0;         int countBasisSendAll = 0;         finished:         for (DtoTransaction transaction : thisBlock.getDtoTransactions()) {             if(transaction.verify() && transaction.getSender().equals(Seting.BASIS_ADDRESS)){                 double minerReward = Seting.DIGITAL_DOLLAR_REWARDS_BEFORE;                 double minerPowerReward = Seting.DIGITAL_STOCK_REWARDS_BEFORE;                    if(transaction.getSender().equals(Seting.BASIS_ADDRESS)&&                         transaction.getCustomer().equals(thisBlock.getMinerAddress()) && transaction.getDigitalDollar() > minerReward                         && thisBlock.getIndex() > 1){                     System.out.println(\"wrong transaction: reward miner wrong digital dollar: \" + minerReward + \" index: \" + thisBlock.getIndex());                     System.out.println(\"sendmoney \" + transaction.getDigitalDollar());                     validated = false;                     break;                 }                 if(transaction.getSender().equals(Seting.BASIS_ADDRESS) &&                         transaction.getCustomer().equals(thisBlock.getMinerAddress()) && transaction.getDigitalStockBalance()                         > minerPowerReward                         && thisBlock.getIndex() > 1){                     System.out.println(\"wrong transaction: reward miner wrong digital stock: \" + minerPowerReward + \" need: \" + transaction.getDigitalStockBalance());                     System.out.println(transaction);                     validated = false;                     break;                 }                   if(transaction.getSender().equals(Seting.BASIS_ADDRESS)                         &&transaction.getCustomer().equals(addressFounder)){                     countBasisSendFounder += 1;                 }                  if(transaction.getSender().equals(Seting.BASIS_ADDRESS)&&!transaction.getCustomer().equals(addressFounder))                 {                     countBasisSendAll +=1;                 }                  if(countBasisSendFounder > 2 && thisBlock.getIndex() > 1){                     System.out.println(\"basis sender send for founder uper one: \" + countBasisSendFounder);                     validated = false;                     break;                 }                  if(countBasisSendAll > 1 && thisBlock.getIndex() > 1){                     System.out.println(\"basis sender send uper two: \" + countBasisSendAll + \" block index: \" + thisBlock.getIndex());                     validated = false;                     break;                 }             }             else if(!transaction.verify()){                 System.out.println(\"wrong transaction: \" + transaction + \" verify: \" + transaction.verify());                 validated = false;                 break finished;             }          }             if(!UtilsUse.hashComplexity(thisBlock.getHashBlock(), thisBlock.getHashCompexity())){                 System.out.println(\"does't start hash with 0\");                 System.out.println(\"this block hash: \" + thisBlock.getHashBlock());                 return false;             }              if(!actualPrevHash.equals(recordedPrevHash)){                 System.out.println(\"Blockchain is invalid, expected: \" + recordedPrevHash + \" actual: \" + actualPrevHash );                 System.out.println(\"index block: \" + thisBlock.getIndex());                 System.out.println(\"wrong chain hash\");                 return false;             }          return validated;     }      public static void deleteFiles(){         UtilsFileSaveRead.deleteAllFiles(Seting.ORIGINAL_BLOCKCHAIN_FILE);          UtilsFileSaveRead.deleteAllFiles(Seting.ORIGINAL_BALANCE_FILE);         UtilsFileSaveRead.deleteAllFiles(Seting.ORIGINAL_ALL_CORPORATION_LAWS_FILE);         UtilsFileSaveRead.deleteAllFiles(Seting.ORIGINAL_ALL_CORPORATION_LAWS_WITH_BALANCE_FILE);     }      public static boolean validation(List<Block> blocks, long BLOCK_GENERATION_INTERVAL, int DIFFICULTY_ADJUSTMENT_INTERVAL ) throws IOException, NoSuchAlgorithmException, SignatureException, InvalidKeySpecException, NoSuchProviderException, InvalidKeyException {         boolean validated = true;         List<Block> temporary = new ArrayList<>();         Block prevBlock  = null;         for (Block block : blocks) {             if(prevBlock == null){                 prevBlock = block;                 temporary.add(block);                 continue;             }              temporary.add(block);              validated = validationOneBlock(block.getFounderAddress(),                     prevBlock,                     block,                     BLOCK_GENERATION_INTERVAL,                     DIFFICULTY_ADJUSTMENT_INTERVAL,                     temporary );             if(validated == false){                  System.out.println(\"ERROR: UtilsBlock: validation: prevBLock.Hash():\" + prevBlock.getHashBlock());                 System.out.println(\"ERROR: UtilsBlock: validation: index:\" + block.getIndex());                 System.out.println(\"ERROR: UtilsBlock: validation: block.Hash():\" + block.getHashBlock());                 System.out.println(\"ERROR: UtilsBlock: validation: BLOCK_GENERATION_INTERVAL:\" + BLOCK_GENERATION_INTERVAL);                 System.out.println(\"ERROR: UtilsBlock: validation: DIFFICULTY_ADJUSTMENT_INTERVAL:\" + DIFFICULTY_ADJUSTMENT_INTERVAL);                 System.out.println(\"ERROR: UtilsBlock: validation: temporary:\" + temporary.size());                 return false;             }             prevBlock = block;         }         return validated;     } }","package International_Trade_Union.utils;  public class UtilsCheckDtoTransaction {  }","package International_Trade_Union.utils;  import java.io.*; import java.util.ArrayList; import java.util.HashSet; import java.util.List; import java.util.Set;  public class UtilsFileSaveRead {      public static void save(String object, String fileName) throws IOException {        save(object, fileName, true);     }     public static void save(String object, String fileName, boolean save){         try(BufferedWriter writer = new BufferedWriter(new FileWriter(fileName, save))) {             writer.write(object);             writer.flush();          }catch (IOException e){             e.printStackTrace();         }       }      public static void saves(List<String> objects, String fileName, boolean save){          try(BufferedWriter writer = new BufferedWriter(new FileWriter(fileName, save))) {              for (String s : objects) {                 writer.write(s + \"\\n\");             }             writer.flush();          }catch (IOException e){             e.printStackTrace();         }     }      public static String read(String file) throws FileNotFoundException {         String text = \"\";         File file1 = new File(file);         if(!file1.exists()){             System.out.println(\"file dosn't have\");             return text;         }         try( BufferedReader reader = new BufferedReader(new FileReader(file))){             while (reader.ready()){                 text += reader.readLine();             }         }catch (IOException e){             e.printStackTrace();         }         return text;     }     public static Set<String> readSet(String file){         Set<String> list = new HashSet<>();          try( BufferedReader reader = new BufferedReader(new FileReader(file))){             while (reader.ready()){                 list.add(reader.readLine());             }         }catch (IOException e){             e.printStackTrace();         }         return list;     }     public static List<String> reads(String file){         List<String> list = new ArrayList<>();          try( BufferedReader reader = new BufferedReader(new FileReader(file))){             while (reader.ready()){                 list.add(reader.readLine());             }         }catch (IOException e){             e.printStackTrace();         }         return list;     }         public static void deleteAllFiles(String path){         File folder = new File(path);         for (File file : folder.listFiles()) {             if(!file.isDirectory()){                 file.delete();             }         }     }      public static void deleteFile(String path){         File file = new File(path);         file.delete();     }  }","package International_Trade_Union.utils;  import com.fasterxml.jackson.core.JsonProcessingException; import com.fasterxml.jackson.core.type.TypeReference; import com.fasterxml.jackson.databind.ObjectMapper; import International_Trade_Union.entity.DtoTransaction.DtoTransaction; import International_Trade_Union.entity.EntityChain; import International_Trade_Union.entity.blockchain.block.Block; import International_Trade_Union.model.Account; import International_Trade_Union.vote.CurrentLawVotes; import International_Trade_Union.vote.LawEligibleForParliamentaryApproval; import International_Trade_Union.vote.Laws;   import java.io.IOException; import java.io.StringWriter; import java.util.List; import java.util.Set;  public class UtilsJson {     public static String objToStringJson(Object object) throws IOException {         ObjectMapper mapper = new ObjectMapper();         StringWriter writer = new StringWriter();         mapper.writeValue(writer, object);         return writer.toString();     }      public static Object jsonToListBLock(String json, Class cls) throws JsonProcessingException {         ObjectMapper mapper = new ObjectMapper();         return mapper.readValue(json, cls);     }      public static List<Block> jsonToListBLock(String json) throws JsonProcessingException {         ObjectMapper mapper = new ObjectMapper();         return mapper.readValue(json, new TypeReference<List<Block>>(){});     }     public static List<Account> jsonToListAccounts(String json) throws JsonProcessingException {         ObjectMapper mapper = new ObjectMapper();         return mapper.readValue(json, new TypeReference<List<Account>>(){});     }      public static Set<String> jsonToSetAddresses(String json) throws  JsonProcessingException{         ObjectMapper mapper = new ObjectMapper();         return mapper.readValue(json, new TypeReference<Set<String>>(){});     }     public static Block jsonToBLock(String json) throws JsonProcessingException {         ObjectMapper mapper = new ObjectMapper();         return mapper.readValue(json, Block.class);     }      public static Laws jsonToLaw(String json) throws JsonProcessingException {         ObjectMapper mapper = new ObjectMapper();         return mapper.readValue(json, Laws.class);     }      public static CurrentLawVotes jsonToVote(String json) throws  JsonProcessingException{         ObjectMapper mapper = new ObjectMapper();         return mapper.readValue(json, CurrentLawVotes.class);     }      public static LawEligibleForParliamentaryApproval jsonToCurrentLaw(String json) throws JsonProcessingException {         ObjectMapper mapper = new ObjectMapper();         return mapper.readValue(json, LawEligibleForParliamentaryApproval.class);     }     public static Account jsonToAccount(String json) throws JsonProcessingException {         ObjectMapper mapper = new ObjectMapper();         return mapper.readValue(json, Account.class);     }     public static EntityChain jsonToEntityChain(String json) throws  JsonProcessingException{         ObjectMapper mapper = new ObjectMapper();         return mapper.readValue(json, EntityChain.class);     }      public static DtoTransaction jsonToDtoTransaction(String json) throws  JsonProcessingException{         ObjectMapper mapper = new ObjectMapper();         return mapper.readValue(json, DtoTransaction.class);      }      public static List<DtoTransaction> jsonToDtoTransactionList(String json) throws  JsonProcessingException{         ObjectMapper mapper = new ObjectMapper();         return mapper.readValue(json, new TypeReference<List<DtoTransaction>>(){});     } }","package International_Trade_Union.utils;    import International_Trade_Union.model.Keys; import International_Trade_Union.utils.base.Base; import International_Trade_Union.utils.base.Base58;  import org.bouncycastle.asn1.ASN1ObjectIdentifier; import org.bouncycastle.asn1.x9.ECNamedCurveTable; import org.bouncycastle.asn1.x9.X9ECParameters; import org.bouncycastle.crypto.params.ECNamedDomainParameters; import org.bouncycastle.crypto.params.ECPublicKeyParameters; import org.bouncycastle.jcajce.provider.asymmetric.ec.BCECPublicKey; import org.bouncycastle.jce.provider.BouncyCastleProvider; import org.bouncycastle.jce.spec.ECNamedCurveParameterSpec; import org.bouncycastle.jce.spec.ECPublicKeySpec; import org.bouncycastle.math.ec.ECCurve; import org.bouncycastle.math.ec.ECPoint;  import java.io.IOException; import java.math.BigInteger; import java.nio.charset.StandardCharsets; import java.security.*; import java.security.interfaces.ECPublicKey; import java.security.spec.*;  //https://metamug.com/article/security/sign-verify-digital-signature-ecdsa-java.html //https://stackoverflow.com/questions/8451205/create-privatekey-and-publickey-having-a-byte-array-encoded-in-base-64 public class UtilsSecurity {     private static final String SPEC = \"secp256k1\";     private static final String ALGO_ECDSA = \"ECDSA\";     private static final String PROVIDER = \"BC\";      static {         Security.addProvider(new org.bouncycastle.jce.provider.BouncyCastleProvider());     }     public static Keys generateKeyPair() throws NoSuchAlgorithmException, InvalidAlgorithmParameterException, NoSuchProviderException, InvalidKeySpecException {        Base base = new Base58();         Security.addProvider(new org.bouncycastle.jce.provider.BouncyCastleProvider());         ECGenParameterSpec ecSpec = new ECGenParameterSpec(SPEC);         KeyPairGenerator g = KeyPairGenerator.getInstance(ALGO_ECDSA, PROVIDER);         g.initialize(ecSpec, new SecureRandom());         KeyPair keyPair = g.generateKeyPair();         String pub = base.encode(UtilsSecurity.compressed(keyPair.getPublic().getEncoded()));         String priv = base.encode(keyPair.getPrivate().getEncoded());         Keys keys = new Keys(pub, priv);         return keys;     }      public static PrivateKey privateBytToPrivateKey(byte[] bytes) throws NoSuchAlgorithmException, InvalidKeySpecException, NoSuchProviderException {         EncodedKeySpec privateKeySpec = new PKCS8EncodedKeySpec(bytes);         KeyFactory generator = KeyFactory.getInstance(ALGO_ECDSA, PROVIDER);         return generator.generatePrivate(privateKeySpec);     }      public static PublicKey publicByteToPublicKey(byte[] bytes) throws NoSuchAlgorithmException, InvalidKeySpecException, NoSuchProviderException {         //new X509EncodedKeySpec         EncodedKeySpec publicKeySpec = new X509EncodedKeySpec(bytes);         KeyFactory generator = KeyFactory.getInstance(ALGO_ECDSA, PROVIDER);         return generator.generatePublic(publicKeySpec);     }       public static KeyPair createKeyPairWithPrivkeyPubKey(PrivateKey privateKey, PublicKey publicKey){         return new KeyPair(publicKey, privateKey);     }       public static byte[] sign(PrivateKey privateKey, String hex) throws NoSuchAlgorithmException, NoSuchProviderException, InvalidKeyException, SignatureException, IOException {         Signature signature = Signature.getInstance(ALGO_ECDSA, PROVIDER);         signature.initSign(privateKey);         signature.update(hex.getBytes(StandardCharsets.UTF_8));         byte[] signByte = signature.sign();         return signByte;     }      public static boolean verify(String sha256message, byte[] sign, PublicKey publicKey) throws NoSuchAlgorithmException, NoSuchProviderException, InvalidKeyException, SignatureException {         Signature signature = Signature.getInstance(ALGO_ECDSA, PROVIDER);         signature.initVerify(publicKey);         signature.update(sha256message.getBytes(StandardCharsets.UTF_8));         return signature.verify(sign);     }       public static byte[] compressed(byte[] pub) throws NoSuchAlgorithmException, NoSuchProviderException, InvalidAlgorithmParameterException, InvalidKeySpecException {          // === NOT PART OF THE CODE, JUST GETTING TEST VECTOR ===         PublicKey publicKey = UtilsSecurity.publicByteToPublicKey(pub);          ECPublicKey key = (ECPublicKey) publicKey;         byte[] x = key.getW().getAffineX().toByteArray();         byte[] y = key.getW().getAffineY().toByteArray();          // assumes that x and y are (unsigned) big endian encoded         BigInteger xbi = new BigInteger(1, x);         BigInteger ybi = new BigInteger(1, y);         X9ECParameters x9 = ECNamedCurveTable.getByName(SPEC);         ASN1ObjectIdentifier oid = ECNamedCurveTable.getOID(SPEC);         ECCurve curve = x9.getCurve();         ECPoint point = curve.createPoint(xbi, ybi);         ECNamedDomainParameters dParams = new ECNamedDomainParameters(oid,                 x9.getCurve(), x9.getG(), x9.getN(), x9.getH(), x9.getSeed());         ECPublicKeyParameters pubKey = new ECPublicKeyParameters(point, dParams);         System.out.println(pubKey);          // some additional encoding tricks         byte[] compressed = point.getEncoded(true);         return compressed;     }     public static ECPublicKey decodeKey(byte[] encoded) {          ECNamedCurveParameterSpec params = org.bouncycastle.jce.ECNamedCurveTable.getParameterSpec(SPEC);         org.bouncycastle.jce.spec.ECPublicKeySpec keySpec = new ECPublicKeySpec(params.getCurve().decodePoint(encoded), params);         return new BCECPublicKey(ALGO_ECDSA, keySpec, BouncyCastleProvider.CONFIGURATION);     } }","package International_Trade_Union.utils;  import International_Trade_Union.controllers.BasisController; import International_Trade_Union.entity.DtoTransaction.DtoTransaction; import International_Trade_Union.entity.blockchain.block.Block; import International_Trade_Union.governments.Directors; import International_Trade_Union.governments.UtilsGovernment; import International_Trade_Union.network.AllTransactions; import International_Trade_Union.setings.Seting;  import java.io.File; import java.io.IOException; import java.security.InvalidKeyException; import java.security.NoSuchAlgorithmException; import java.security.NoSuchProviderException; import java.security.SignatureException; import java.security.spec.InvalidKeySpecException; import java.util.ArrayList; import java.util.Comparator; import java.util.List; import java.util.stream.Collectors;  public class UtilsTransaction {     public static void saveAllTransaction(DtoTransaction dtoTransaction, String filename) throws IOException, NoSuchAlgorithmException, SignatureException, InvalidKeySpecException, NoSuchProviderException, InvalidKeyException {         int fileLimit = Seting.SIZE_FILE_LIMIT * 1024 * 1024;          //папка чтобы проверить есть ли         File folder = new File(filename);         List<String> files = new ArrayList<>();         for (File file : folder.listFiles()) {             if(!file.isDirectory()){                 files.add(file.getAbsolutePath());             }         }           int count = 0;         files = files.stream().sorted().collect(Collectors.toList());         String nextFile = \"\";          if (files.size() > 0) {             nextFile = files.get(files.size()-1);              count = Integer.parseInt(nextFile.replaceAll(\"[^\\\\d]\", \"\"));           }          File file = new File(nextFile);          if(file.length() >= fileLimit){             count++;          }          nextFile = filename + count + \".txt\";          String json = UtilsJson.objToStringJson(dtoTransaction);         UtilsFileSaveRead.save(json + \"\\n\", nextFile);      }      public static List<DtoTransaction> readLineObject(String filename ) throws IOException, NoSuchAlgorithmException, InvalidKeySpecException, SignatureException, NoSuchProviderException, InvalidKeyException {         List<DtoTransaction> dtoTransactions = new ArrayList<>();         File folder = new File(filename);         for (final File fileEntry : folder.listFiles()) {             if (fileEntry.isDirectory()) {                 System.out.println(\"is directory \" + fileEntry.getAbsolutePath());             } else {                 List<String> list = UtilsFileSaveRead.reads(fileEntry.getAbsolutePath());                 for (String s : list) {                      DtoTransaction dtoTransaction = UtilsJson.jsonToDtoTransaction(s);                     dtoTransactions.add(dtoTransaction);                 }              }         }         dtoTransactions = dtoTransactions                 .stream()                 .collect(Collectors.toList());          return dtoTransactions;     }       public static void sendTransaction(DtoTransaction dtoTransaction){      } }","package International_Trade_Union.utils;    import International_Trade_Union.setings.Seting;  import java.io.IOException;  import java.math.BigDecimal; import java.nio.charset.Charset; import java.nio.charset.StandardCharsets; import java.security.MessageDigest; import java.security.NoSuchAlgorithmException; import java.util.HashMap; import java.util.List; import java.util.Random; import java.util.Set; import java.util.concurrent.ConcurrentHashMap; import java.util.function.Function; import java.util.function.Predicate; import java.util.regex.Matcher; import java.util.regex.Pattern;  public class UtilsUse {     private static MessageDigest digest;      static {         try {             digest = MessageDigest.getInstance(\"SHA-256\");         } catch (NoSuchAlgorithmException e) {             e.printStackTrace();         }     } //    одно число от другого в процентах     public static Double percentDifferent(Double first, Double second){         return (first / second - 1) * Seting.HUNDRED_PERCENT;     }      //найти моду     public static int mode(List<Integer> array)     {         HashMap<Integer,Integer> hm = new HashMap<Integer,Integer>();         int max  = 1;         int temp = 0;          for(int i = 0; i < array.size(); i++) {              if (hm.get(array.get(i)) != null) {                  int count = hm.get(array.get(i));                 count++;                 hm.put(array.get(i), count);                  if(count > max) {                     max  = count;                     temp = array.get(i);                 }             }              else                 hm.put(array.get(i),1);         }         return temp;     }      public static BigDecimal percentDifferent(BigDecimal first, BigDecimal second){         return first.divide(second).subtract(new BigDecimal(1)).multiply(new BigDecimal(Seting.HUNDRED_PERCENT));     }      public static byte[] sha256(String text){         return digest.digest(text.getBytes(StandardCharsets.UTF_8));     }     public static String sha256hash(String text){         byte[] bytes = sha256(text);         return bytesToHex(bytes);     }      private static String bytesToHex(byte[] hash) {         StringBuilder hexString = new StringBuilder(2 * hash.length);         for (int i = 0; i < hash.length; i++) {             String hex = Integer.toHexString(0xff & hash[i]);             if(hex.length() == 1) {                 hexString.append('0');             }             hexString.append(hex);         }         return hexString.toString();     }      public static String generateRandomStr() {         byte[] array = new byte[7]; // length is bounded by 7         new Random().nextBytes(array);         String generatedString = new String(array, Charset.forName(\"UTF-8\"));          return generatedString;     }      public static double countPercents(double sum, double percent){         return sum * percent / Seting.HUNDRED_PERCENT;     }     public static BigDecimal countPercents(BigDecimal sum, BigDecimal percent){         return sum.multiply(percent).divide(new BigDecimal(Seting.HUNDRED_PERCENT));     }      public  static double countGrowth(long block, double percent, double money){         long year = (long) (block / Seting.COUNT_BLOCK_IN_DAY / (Seting.YEAR / Seting.HALF_YEAR));         double opeartion1 = 1+ (percent / Seting.HALF_YEAR)/Seting.HUNDRED_PERCENT;         double operation2 = Math.pow(opeartion1, year);         double result = money * operation2;         return result;     }      public static boolean hashComplexity(String literral, int hashComplexity){          String regex = \"^[0]{\" + Integer.toString(hashComplexity) + \"}\";         Pattern pattern = Pattern.compile(regex);         Matcher matcher = pattern.matcher(literral);         return matcher.find();     }      public static String hashComplexityStr(String str, int hashComplexity) throws IOException {         int randomNumberProof = 0;         String hash = \"\";         while (true){             randomNumberProof++;             hash = UtilsUse.sha256hash(UtilsJson.objToStringJson(str + randomNumberProof));             if(UtilsUse.hashComplexity(hash.substring(0, hashComplexity), hashComplexity))             {                 break;             }          }         return hash;     }      //для филтрации в стриме, чтобы получить уникальные обекты по полям     public static <T> Predicate<T> distinctByKey(Function<? super T, ?> keyExtractor) {         Set<Object> seen = ConcurrentHashMap.newKeySet();         return t -> seen.add(keyExtractor.apply(t));     }     //подсчитать количество нулей идущих подряд в hash     public static long hashCount(String hash) {         long count = 0;         for (int i = 0; i < hash.length(); i++) {             if(hash.charAt(i) == '0') count++;             else return count;         }         return count;     }      //подсчитывает долю в процентах одного числа от другого     public static double percentageShare(double first, double allNumber){         return (first/allNumber)*Seting.HUNDRED_PERCENT;     }      //опреледеляет ближайщее число к году     public static long nearestDateToYear(long block){         long period = (long) (Seting.COUNT_BLOCK_IN_DAY * Seting.YEAR);         return block / period * period;     }   }","package International_Trade_Union.utils;  import com.fasterxml.jackson.databind.ObjectMapper; import org.apache.http.NameValuePair; import org.apache.http.client.methods.HttpPost; import org.apache.http.message.BasicNameValuePair; import org.json.JSONException;  import javax.net.ssl.HttpsURLConnection; import java.io.*; import java.net.*; import java.nio.charset.Charset; import java.util.ArrayList; import java.util.Base64; import java.util.List;  public class UtilUrl {     public static String readJsonFromUrl(String url) throws IOException, JSONException {         InputStream is = new URL(url).openStream();         try {             BufferedReader rd = new BufferedReader(new InputStreamReader(is, Charset.forName(\"UTF-8\")));             String jsonText = readAll(rd);             ObjectMapper mapper = new ObjectMapper();             return jsonText;         } finally {             System.out.println(\"UtilUrl: readJsonFromUrl: \" + url );             is.close();         }     }      private static String readAll(Reader rd) throws IOException {         StringBuilder sb = new StringBuilder();         int cp;         while ((cp = rd.read()) != -1) {             sb.append((char) cp);         }         return sb.toString();     }      public static String getObject(String jsonObject, String requstStr) throws IOException {         URL url = new URL(requstStr);         HttpURLConnection conn = (HttpURLConnection) url.openConnection(); //        conn.connect();         conn.setReadTimeout(10000);         conn.setConnectTimeout(15000);         conn.setRequestMethod(\"POST\");         conn.setRequestProperty(\"Content-Type\", \"application/json; utf-8\");         conn.setRequestProperty(\"Accept\", \"application/json\");         conn.setDoOutput(true);            try(OutputStream outputStream = conn.getOutputStream()) {             byte[] input = jsonObject.getBytes(\"utf-8\");             outputStream.write(input, 0, input.length);             conn.getResponseCode();         }           conn.connect();         try(BufferedReader br = new BufferedReader(                 new InputStreamReader(conn.getInputStream(), \"utf-8\"))) {             StringBuilder response = new StringBuilder();             String responseLine = null;             while ((responseLine = br.readLine()) != null) {                 response.append(responseLine.trim());             }             return response.toString();          }      }         public static int sendPost(String jsonObject, String requestStr) throws IOException {         int response;         URL url = new URL(requestStr);         HttpURLConnection conn = (HttpURLConnection) url.openConnection(); //        conn.connect();         conn.setReadTimeout(10000);         conn.setConnectTimeout(15000);         conn.setRequestMethod(\"POST\");         conn.setRequestProperty(\"Content-Type\", \"application/json; utf-8\");         conn.setRequestProperty(\"Accept\", \"application/json\");         conn.setDoOutput(true);            try(OutputStream outputStream = conn.getOutputStream()) {             byte[] input = jsonObject.getBytes(\"utf-8\");             outputStream.write(input, 0, input.length);              response = conn.getResponseCode();          }           conn.connect();         return response;     }     }","package International_Trade_Union.vote;  import lombok.Data; import International_Trade_Union.model.Account; import International_Trade_Union.setings.Seting; import org.apache.tomcat.util.net.jsse.JSSEUtil;  import java.util.List; import java.util.Map; import java.util.Objects; import java.util.Set; import java.util.stream.Collectors;  @Data public class CurrentLawVotes {     private String addressLaw;     private Set<String> YES;     private Set<String> NO;       public CurrentLawVotes() {     }      public CurrentLawVotes(String addressLaw, Set<String> YES, Set<String> NO) {         this.addressLaw = addressLaw;         this.YES = YES;         this.NO = NO;     }      //подсчет голосов для палат     public int voteGovernment(             Map<String, Account> balances,             List<String> governments      ) {         int yes = 0;         int no = 0;          List<String> addressGovernment = governments;         for (String s : YES) {             if (addressGovernment.contains(s)) {                 yes += Seting.VOTE_GOVERNMENT;             }          }         for (String s : NO) {             if (addressGovernment.contains(s)) {                 no += Seting.VOTE_GOVERNMENT;             }          }           return yes - no;      }      //для избрания должностных лиц     public double votesLaw(Map<String, Account> balances,                            Map<String, Integer> yesAverage, Map<String, Integer> noAverage) {         double yes = 0.0;         double no = 0.0;           //         for (String s : YES) {              int count = 1;             count = yesAverage.get(s) > 0 ? yesAverage.get(s) : 1;             yes += balances.get(s).getDigitalStockBalance() / count;          }         //         for (String s : NO) {             int count = 1;             count = noAverage.get(s) > 0 ? noAverage.get(s) : 1;             no += balances.get(s).getDigitalStockBalance() / count;          }           return yes - no;     }      //для избрания должностных лиц     public double votes(Map<String, Account> balances,                         Map<String, Integer> yesAverage, Map<String, Integer> noAverage) {         double yes = 0.0;         double no = 0.0;         for (String s : YES) {             int count = 1;             count = yesAverage.get(s) > 0 ? yesAverage.get(s) : 1;             yes += balances.get(s).getDigitalStockBalance() / count;          }         for (String s : NO) {             int count = 1;             count = noAverage.get(s) > 0 ? noAverage.get(s) : 1;             no += balances.get(s).getDigitalStockBalance() / count;          }           return yes - no;     }      @Override     public boolean equals(Object o) {         if (this == o) return true;         if (!(o instanceof CurrentLawVotes)) return false;         CurrentLawVotes that = (CurrentLawVotes) o;         return getAddressLaw().equals(that.getAddressLaw());     }      @Override     public int hashCode() {         return Objects.hash(getAddressLaw());     } }","package International_Trade_Union.vote;  public class CurrentLawVotesAverage { }","package International_Trade_Union.vote;  import lombok.Data;  import java.util.List; import java.util.Objects;  @Data public class CurrentLawVotesEndBalance {     private String addressLaw;     private double votes;     //CORPORATE_COUNCIL_OF_REFEREES     private int votesCorporateCouncilOfReferees;      //BOARD_OF_DIRECTORS     private int votesBoardOfDirectors;     private int votesBoardOfShareholders;      //GENERAL_EXECUTIVE_DIRECTOR     private int voteGeneralExecutiveDirector;     private int voteHightJudge;      private int founderVote;     private String packageName;     private List<String> laws;      public CurrentLawVotesEndBalance() {     }      public CurrentLawVotesEndBalance             (String addressLaw,              String packageName,              double votes,              int votesCorporateCouncilOfReferees,              int votesBoardOfDirectors,              int votesBoardOfShareholders,              int voteGeneralExecutiveDirector,              int voteHightJudge,                     int founderVote,              List<String> laws) {         this.addressLaw = addressLaw;         this.packageName = packageName;         this.votesCorporateCouncilOfReferees = votesCorporateCouncilOfReferees;         this.votesBoardOfShareholders = votesBoardOfShareholders;         this.votesBoardOfDirectors = votesBoardOfDirectors;         this.voteGeneralExecutiveDirector = voteGeneralExecutiveDirector;         this.voteHightJudge = voteHightJudge;         this.founderVote = founderVote;          this.votes = votes;         this.laws = laws;      }      @Override     public boolean equals(Object o) {         if (this == o) return true;         if (!(o instanceof CurrentLawVotesEndBalance)) return false;         CurrentLawVotesEndBalance that = (CurrentLawVotesEndBalance) o;         return getAddressLaw().equals(that.getAddressLaw());     }      @Override     public int hashCode() {         return Objects.hash(getAddressLaw());     } }","package International_Trade_Union.vote;   import lombok.Data; import International_Trade_Union.model.Account;  import java.util.Objects;  @Data public class LawEligibleForParliamentaryApproval {     public LawEligibleForParliamentaryApproval(Account account, Laws laws) {         this.account = account;         this.laws = laws;         this.name = account.getAccount();     }      public LawEligibleForParliamentaryApproval() {     }      private String name;     private Account account;     private Laws laws;      @Override     public boolean equals(Object o) {         if (this == o) return true;         if (!(o instanceof LawEligibleForParliamentaryApproval)) return false;         LawEligibleForParliamentaryApproval that = (LawEligibleForParliamentaryApproval) o;         return Objects.equals(getName(), that.getName()) && Objects.equals(getAccount(), that.getAccount()) && Objects.equals(getLaws(), that.getLaws());     }      @Override     public int hashCode() {         return Objects.hash(getName(), getAccount(), getLaws());     } }","package International_Trade_Union.vote;   import lombok.Data; import International_Trade_Union.setings.Seting; import International_Trade_Union.utils.UtilsJson; import International_Trade_Union.utils.UtilsUse;  import java.io.IOException; import java.util.List; import java.util.Objects;  @Data public class Laws {     //название пакета закона     String packetLawName;     List<String> laws;     String hashLaw;      public Laws() {     }      public Laws(String packetLawName, List<String> laws) throws IOException {         this.packetLawName = packetLawName;         this.laws = laws;         this.hashLaw = Seting.NAME_LAW_ADDRESS_START + UtilsUse.sha256hash(UtilsJson.objToStringJson(this));     }      @Override     public boolean equals(Object o) {         if (this == o) return true;         if (!(o instanceof Laws)) return false;         Laws laws = (Laws) o;         return getHashLaw().equals(laws.getHashLaw());     }      @Override     public int hashCode() {         return Objects.hash(getHashLaw());     } }","package International_Trade_Union.vote;  import International_Trade_Union.entity.DtoTransaction.DtoTransaction; import International_Trade_Union.entity.blockchain.Blockchain; import International_Trade_Union.entity.blockchain.block.Block; import International_Trade_Union.governments.Director; import International_Trade_Union.governments.Directors; import International_Trade_Union.governments.UtilsGovernment; import International_Trade_Union.model.Account; import International_Trade_Union.model.FIndPositonHelperData; import International_Trade_Union.setings.Seting;  import java.io.IOException; import java.security.InvalidKeyException; import java.security.NoSuchAlgorithmException; import java.security.NoSuchProviderException; import java.security.SignatureException; import java.security.spec.InvalidKeySpecException; import java.util.*; import java.util.stream.Collectors;  public class UtilsCurrentLaw {     //подсчет по штучно баланса     public static Map<String, CurrentLawVotes> calculateVote(Map<String, CurrentLawVotes> votes, List<Account> governments, Block block) throws IOException, NoSuchAlgorithmException, SignatureException, InvalidKeySpecException, NoSuchProviderException, InvalidKeyException {          for (int j = 0; j < block.getDtoTransactions().size(); j++) {             DtoTransaction transaction = block.getDtoTransactions().get(j);              if (transaction.getSender().startsWith(Seting.NAME_LAW_ADDRESS_START)) {                 System.out.println(\"law balance cannot be sender\");                 continue;             }             if (transaction.verify() && transaction.getCustomer().startsWith(Seting.NAME_LAW_ADDRESS_START)) {                 for (Account account : governments) {                     //основатель не может участвовать в голосовании                     //!block.getFounderAddress().equals(transaction.getSender())                     if (transaction.getSender().equals(account.getAccount())) {                         CurrentLawVotes currentLawVotes = votes.get(transaction.getCustomer());                          if (currentLawVotes == null) {                             currentLawVotes = new CurrentLawVotes();                             currentLawVotes.setAddressLaw(transaction.getCustomer());                             currentLawVotes.setYES(new HashSet<>());                             currentLawVotes.setNO(new HashSet<>());                              votes.put(transaction.getCustomer(), currentLawVotes);                         }                          if (transaction.getVoteEnum().equals(VoteEnum.YES)) {                              currentLawVotes.getYES().add(transaction.getSender());                             currentLawVotes.getNO().remove(transaction.getSender());                          } else if (transaction.getVoteEnum().equals(VoteEnum.NO)) {                             currentLawVotes.getNO().add(transaction.getSender());                             currentLawVotes.getYES().remove(transaction.getSender());                         }                     }                 }              }          }           return votes;      }      //подсчет целиком баланса     public static Map<String, CurrentLawVotes> calculateVotes(List<Account> governments, List<Block> blocks) throws IOException, NoSuchAlgorithmException, SignatureException, InvalidKeySpecException, NoSuchProviderException, InvalidKeyException {         Map<String, CurrentLawVotes> votes = new HashMap<>();         for (Block block : blocks) {             calculateVote(votes, governments, block);         }          return votes;      }      //возвращаяет усредненное количество голосов,     //суть проста если есть один акаунт и он имеет 100 акций     //и проголосовал за один закон то все сто акций будут для этого закона как сто голосов     //если за два закона то 100/2 то есть если он на протяжении трех лет проголосовал     //за n законов, то его голоса делятся на n.     public static Map<String, Integer> calculateAverageVotesYes(Map<String, CurrentLawVotes> votesMap) {         Map<String, Integer> voteAverage = new HashMap<>();         for (Map.Entry<String, CurrentLawVotes> current : votesMap.entrySet()) {             for (String yesVoteAddress : current.getValue().getYES()) {                 if (voteAverage.containsKey(yesVoteAddress)) {                     int count = voteAverage.get(yesVoteAddress);                     voteAverage.put(yesVoteAddress, count + 1);                 } else {                     int count = 1;                     voteAverage.put(yesVoteAddress, count);                 }             }          }         return voteAverage;     }      //подсчитывает голоса No     public static Map<String, Integer> calculateAverageVotesNo(Map<String, CurrentLawVotes> votesMap) {         Map<String, Integer> voteAverage = new HashMap<>();         for (Map.Entry<String, CurrentLawVotes> current : votesMap.entrySet()) {             for (String yesVoteAddress : current.getValue().getNO()) {                 if (voteAverage.containsKey(yesVoteAddress)) {                     int count = voteAverage.get(yesVoteAddress);                     voteAverage.put(yesVoteAddress, count + 1);                 } else {                     int count = 1;                     voteAverage.put(yesVoteAddress, count);                 }             }          }         return voteAverage;     }        //возвращает списки позиций     public static Map<Director, List<String>> findPositions(              Map<String, Account> balances,             Blockchain blockchain,             List<LawEligibleForParliamentaryApproval> allGovernment,             List<Account> BoardOfShareholders,             Map<Director, FIndPositonHelperData> fIndPositonHelperData      ) throws IOException, NoSuchAlgorithmException, InvalidKeySpecException, SignatureException, NoSuchProviderException, InvalidKeyException {         //список должностей         Directors directors = new Directors();         Map<Director, List<LawEligibleForParliamentaryApproval>> positionsListMap = new HashMap<>();         //добавление всех должностей         for (Director higherSpecialPositions : directors.getDirectors()) {             positionsListMap.put(higherSpecialPositions, UtilsLaws.getPossions(allGovernment, higherSpecialPositions));         }         //список законов с голосами         Map<Director, List<CurrentLawVotesEndBalance>> curentLawVotesEndBalance = new HashMap<>();         for (Map.Entry<Director, List<LawEligibleForParliamentaryApproval>> corp : positionsListMap.entrySet()) {             //убрать повторяющиеся должности из списка.             corp.setValue(corp.getValue().stream() //                    .filter(t-> finalBoardOfShareholders.contains(new Account(t.getLaws().getLaws().get(0), 0, 0)))                     .distinct().collect(Collectors.toList()));              //получить баланс и голоса для действующих законов             curentLawVotesEndBalance.put(corp.getKey(), UtilsGovernment.filters(corp.getValue(), balances, BoardOfShareholders,                     blockchain.getBlockchainList(), Seting.POSITION_YEAR_VOTE));             List<CurrentLawVotesEndBalance> temporary;             if (fIndPositonHelperData.get(corp.getKey()).isElectedWithStock()) {                   //отобрать голоса выше лимита                 curentLawVotesEndBalance.put(corp.getKey(), curentLawVotesEndBalance.get(corp.getKey()));                 List<CurrentLawVotesEndBalance> electedByStock =                         curentLawVotesEndBalance.get(corp.getKey())                                 .stream()                                 .filter(t->directors.isElectedByStocks(t.getPackageName()))                                 .filter(t -> t.getVotes() >= Seting.ORIGINAL_LIMIT_MIN_VOTE)                                 .sorted(Comparator.comparing(CurrentLawVotesEndBalance::getVotes).reversed())                                 .limit(corp.getKey().getCount())                                 .collect(Collectors.toList());                  System.out.println(\"UtilsCurrentLaw: findPostion: \");                 System.out.println(\"*******************************\");                 electedByStock.stream().forEach(System.out::println);                 System.out.println(\"*******************************\");                  //отобрать то количество которое соответсвтвует данной должности                 temporary = electedByStock;              } else {                  curentLawVotesEndBalance.put(corp.getKey(), curentLawVotesEndBalance.get(corp.getKey()));                 //отобрать то количество которое соответсвтвует данной должности                 //избираемые премьер министром                 if(fIndPositonHelperData.get(corp.getKey()).isElectedWithPrimeMinister()){                     //отобрать голоса выше лимита                     curentLawVotesEndBalance.put(corp.getKey(), curentLawVotesEndBalance.get(corp.getKey()));                     List<CurrentLawVotesEndBalance> electedByPrimeMinister =                             curentLawVotesEndBalance.get(corp.getKey())                                     .stream()                                     .filter(t->directors.isElectedCEO(t.getPackageName()))                                     .filter(t -> t.getVoteGeneralExecutiveDirector() >= Seting.ORIGINAL_LIMIT_MIN_VOTE_GENERAL_EXECUTIVE_DIRECTOR)                                     .sorted(Comparator.comparing(CurrentLawVotesEndBalance::getVoteGeneralExecutiveDirector).reversed())                                     .collect(Collectors.toList());                       //отобрать то количество которое соответсвтвует данной должности                     temporary = electedByPrimeMinister;                 }                 //избираемые палатой представителей                 else if(fIndPositonHelperData.get(corp.getKey()).isElectedWithHousOfRepresentativies()){                     //отобрать голоса выше лимита                     curentLawVotesEndBalance.put(corp.getKey(), curentLawVotesEndBalance.get(corp.getKey()));                     List<CurrentLawVotesEndBalance> electedByHouseOfRepresentatives =                             curentLawVotesEndBalance.get(corp.getKey())                                     .stream()                                     .filter(t->directors.isElectedByBoardOfDirectors(t.getPackageName()))                                     .filter(t -> t.getVotesBoardOfDirectors() >= Seting.ORIGINAL_LIMIT_MIN_VOTE_BOARD_OF_DIRECTORS)                                     .sorted(Comparator.comparing(CurrentLawVotesEndBalance::getVotesBoardOfDirectors).reversed())                                     .collect(Collectors.toList());                       //отобрать то количество которое соответсвтвует данной должности                     temporary = electedByHouseOfRepresentatives;                    }                 //избираемые палатаой верховных судей                 else if(fIndPositonHelperData.get(corp.getKey()).isElectedWithChamberOfHightJudjes()){                     //отобрать голоса выше лимита                     curentLawVotesEndBalance.put(corp.getKey(), curentLawVotesEndBalance.get(corp.getKey()));                     List<CurrentLawVotesEndBalance> electedByChamberOfSupremeJudges =                             curentLawVotesEndBalance.get(corp.getKey())                                     .stream()                                     .filter(t->directors.isElectedBYCorporateCouncilOfReferees(t.getPackageName()))                                     .filter(t -> t.getVotesCorporateCouncilOfReferees() >= Seting.ORIGINAL_LIMIT_MIN_VOTE_CORPORATE_COUNCIL_OF_REFEREES)                                     .sorted(Comparator.comparing(CurrentLawVotesEndBalance::getVotesCorporateCouncilOfReferees).reversed())                                     .collect(Collectors.toList());                       //отобрать то количество которое соответсвтвует данной должности                     temporary = electedByChamberOfSupremeJudges;                  }                 else {                     temporary = curentLawVotesEndBalance.get(corp.getKey()).stream()                              .collect(Collectors.toList());                 }              }              temporary = temporary.stream().distinct().collect(Collectors.toList());              curentLawVotesEndBalance.put(corp.getKey(), temporary);         }           List<LawEligibleForParliamentaryApproval> lawEligibleForParliamentaryApprovals =                 UtilsLaws.readLineCurrentLaws(Seting.ORIGINAL_ALL_CORPORATION_LAWS_WITH_BALANCE_FILE);           Map<Director, List<String>> currentPossitions = new HashMap<>();         for (Map.Entry<Director, FIndPositonHelperData> fIndPositonHelperData1 : fIndPositonHelperData.entrySet()) {             List<CurrentLawVotesEndBalance> position = curentLawVotesEndBalance.get(fIndPositonHelperData1.getKey());             //список адресов на данную позицию, пример члена палаты представителей             List<String> currntAddress = new ArrayList<>();             for (CurrentLawVotesEndBalance address : position) {                 for (LawEligibleForParliamentaryApproval lawEligibleForParliamentaryApproval : lawEligibleForParliamentaryApprovals) {                       if (lawEligibleForParliamentaryApproval.getLaws().getHashLaw().equals(address.getAddressLaw())) {                          currntAddress.add(lawEligibleForParliamentaryApproval.getLaws().getLaws().get(0));                      }                 }              }             currentPossitions.put(fIndPositonHelperData1.getKey(), currntAddress);          }           return currentPossitions;     }      //найти членов палаты представителей     //возвращает список позиций     public static List<String> findPosition(             Map<String, Account> balances,             Blockchain blockchain,             List<LawEligibleForParliamentaryApproval> allGovernment,             List<Account> BoardOfShareholders,             Directors positions,             boolean withLimit      ) throws IOException, NoSuchAlgorithmException, InvalidKeySpecException, SignatureException, NoSuchProviderException, InvalidKeyException {         //список должностей          Map<Director, List<LawEligibleForParliamentaryApproval>> positionsListMap = new HashMap<>();         //добавление всех должностей         for (Director higherSpecialPositions : positions.getDirectors()) {             positionsListMap.put(higherSpecialPositions, UtilsLaws.getPossions(allGovernment, higherSpecialPositions));         }         //список законов с голосами         Map<Director, List<CurrentLawVotesEndBalance>> curentLawVotesEndBalance = new HashMap<>();         for (Map.Entry<Director, List<LawEligibleForParliamentaryApproval>> corp : positionsListMap.entrySet()) {             //убрать повторяющиеся должности из списка.             corp.setValue(corp.getValue().stream() //                    .filter(t-> finalBoardOfShareholders.contains(new Account(t.getLaws().getLaws().get(0), 0, 0)))                     .distinct().collect(Collectors.toList()));              //получить баланс и голоса для действующих законов             curentLawVotesEndBalance.put(corp.getKey(), UtilsGovernment.filters(corp.getValue(), balances, BoardOfShareholders,                     blockchain.getBlockchainList(), Seting.POSITION_YEAR_VOTE));             List<CurrentLawVotesEndBalance> temporary;             if (withLimit) {                 //отобрать голоса выше лимита                 curentLawVotesEndBalance.put(corp.getKey(), curentLawVotesEndBalance.get(corp.getKey())                         .stream().filter(t -> t.getVotes() >= Seting.ORIGINAL_LIMIT_MIN_VOTE)                         .collect(Collectors.toList()));                  //отобрать то количество которое соответсвтвует данной должности                 temporary = curentLawVotesEndBalance.get(corp.getKey()).stream()                         .filter(t -> !t.getPackageName().equals(corp.getKey()))                         .sorted(Comparator.comparing(CurrentLawVotesEndBalance::getVotes).reversed())                         .limit(corp.getKey().getCount()).collect(Collectors.toList());             } else {                 //отобрать то количество которое соответсвтвует данной должности                 temporary = curentLawVotesEndBalance.get(corp.getKey()).stream()                         .filter(t -> !t.getPackageName().equals(corp.getKey()))                         .sorted(Comparator.comparing(CurrentLawVotesEndBalance::getVotes).reversed())                         .collect(Collectors.toList());             }               curentLawVotesEndBalance.put(corp.getKey(), temporary);         }           List<LawEligibleForParliamentaryApproval> lawEligibleForParliamentaryApprovals =                 UtilsLaws.readLineCurrentLaws(Seting.ORIGINAL_ALL_CORPORATION_LAWS_WITH_BALANCE_FILE);          //список адресов на данную позицию, пример члена палаты представителей         List<String> currntAddress = new ArrayList<>();          List<CurrentLawVotesEndBalance> position = curentLawVotesEndBalance.get(positions);          for (CurrentLawVotesEndBalance address : position) {             for (LawEligibleForParliamentaryApproval lawEligibleForParliamentaryApproval : lawEligibleForParliamentaryApprovals) {                   if (lawEligibleForParliamentaryApproval.getLaws().getHashLaw().equals(address.getAddressLaw())) {                      currntAddress.add(lawEligibleForParliamentaryApproval.getLaws().getLaws().get(0));                  }             }         }           return currntAddress;     } }","package International_Trade_Union.vote;  import International_Trade_Union.governments.Director; import International_Trade_Union.governments.Directors; import com.fasterxml.jackson.core.JsonProcessingException; import International_Trade_Union.entity.DtoTransaction.DtoTransaction; import International_Trade_Union.entity.blockchain.block.Block; import International_Trade_Union.setings.Seting; import International_Trade_Union.model.Account; import International_Trade_Union.utils.UtilsFileSaveRead; import International_Trade_Union.utils.UtilsJson; import International_Trade_Union.utils.UtilsUse;   import java.io.File; import java.io.IOException; import java.security.InvalidKeyException; import java.security.NoSuchAlgorithmException; import java.security.NoSuchProviderException; import java.security.SignatureException; import java.security.spec.InvalidKeySpecException; import java.util.*; import java.util.stream.Collectors;  public class UtilsLaws {     public static void saveLaws(List<Laws> laws, String filename) throws IOException {         int fileLimit = Seting.SIZE_FILE_LIMIT * 1024 * 1024;          //папка чтобы проверить есть ли         File folder = new File(filename);         List<String> files = new ArrayList<>();         for (File file : folder.listFiles()) {             if(!file.isDirectory()){                 files.add(file.getAbsolutePath());             }         }          int count = 0;         files = files.stream().sorted().collect(Collectors.toList());         String nextFile = \"\";          if (files.size() > 0) {             nextFile = files.get(files.size()-1);              count = Integer.parseInt(nextFile.replaceAll(\"[^\\\\d]\", \"\"));           }          File file = new File(nextFile);          if(file.length() >= fileLimit){             count++;          }          nextFile = filename + count + \".txt\";          List<String> jsons = new ArrayList<>();         for (Laws laws1: laws) {             String json = UtilsJson.objToStringJson(laws1);             jsons.add(json);         }  //        String json = UtilsJson.objToStringJson(minerAccount); //        UtilsFileSaveRead.save(json + \"\\n\", nextFile);         UtilsFileSaveRead.saves(jsons, nextFile, true);     }     public static void saveLaw(Laws laws, String filename) throws IOException, NoSuchAlgorithmException, SignatureException, InvalidKeySpecException, NoSuchProviderException, InvalidKeyException {         int fileLimit = Seting.SIZE_FILE_LIMIT * 1024 * 1024;          //папка чтобы проверить есть ли         File folder = new File(filename);         List<String> files = new ArrayList<>();         for (File file : folder.listFiles()) {             if (!file.isDirectory()) {                 files.add(file.getAbsolutePath());             }         }          int count = 0;         files = files.stream().sorted().collect(Collectors.toList());         String nextFile = \"\";          if (files.size() > 0) {             nextFile = files.get(files.size() - 1);              count = Integer.parseInt(nextFile.replaceAll(\"[^\\\\d]\", \"\"));           }          File file = new File(nextFile);          if (file.length() >= fileLimit) {             count++;          }          nextFile = filename + count + \".txt\";          String json = UtilsJson.objToStringJson(laws);         UtilsFileSaveRead.save(json + \"\\n\", nextFile);      }      public static void saveCurrentsLaws(List<LawEligibleForParliamentaryApproval> lawEligibleForParliamentaryApprovals, String filename) throws IOException {         int fileLimit = Seting.SIZE_FILE_LIMIT * 1024 * 1024;          //папка чтобы проверить есть ли         File folder = new File(filename);         List<String> files = new ArrayList<>();         for (File file : folder.listFiles()) {             if(!file.isDirectory()){                 files.add(file.getAbsolutePath());             }         }          int count = 0;         files = files.stream().sorted().collect(Collectors.toList());         String nextFile = \"\";          if (files.size() > 0) {             nextFile = files.get(files.size()-1);              count = Integer.parseInt(nextFile.replaceAll(\"[^\\\\d]\", \"\"));           }          File file = new File(nextFile);          if(file.length() >= fileLimit){             count++;          }          nextFile = filename + count + \".txt\";          List<String> jsons = new ArrayList<>();         for (LawEligibleForParliamentaryApproval lawEligibleForParliamentaryApproval : lawEligibleForParliamentaryApprovals) {             String json = UtilsJson.objToStringJson(lawEligibleForParliamentaryApproval);             jsons.add(json);         }  //        String json = UtilsJson.objToStringJson(minerAccount); //        UtilsFileSaveRead.save(json + \"\\n\", nextFile);         UtilsFileSaveRead.saves(jsons, nextFile, true);     }     public static void saveCurrentLaw(LawEligibleForParliamentaryApproval lawEligibleForParliamentaryApproval, String filename) throws IOException, NoSuchAlgorithmException, SignatureException, InvalidKeySpecException, NoSuchProviderException, InvalidKeyException {         int fileLimit = Seting.SIZE_FILE_LIMIT * 1024 * 1024;          //папка чтобы проверить есть ли         File folder = new File(filename);         List<String> files = new ArrayList<>();         for (File file : folder.listFiles()) {             if (!file.isDirectory()) {                 files.add(file.getAbsolutePath());             }         }          int count = 0;         files = files.stream().sorted().collect(Collectors.toList());         String nextFile = \"\";          if (files.size() > 0) {             nextFile = files.get(files.size() - 1);              count = Integer.parseInt(nextFile.replaceAll(\"[^\\\\d]\", \"\"));           }          File file = new File(nextFile);          if (file.length() >= fileLimit) {             count++;          }          nextFile = filename + count + \".txt\";          String json = UtilsJson.objToStringJson(lawEligibleForParliamentaryApproval);         UtilsFileSaveRead.save(json + \"\\n\", nextFile);      }      public static List<Laws> readLineLaws(String filename) throws IOException, NoSuchAlgorithmException, InvalidKeySpecException, SignatureException, NoSuchProviderException, InvalidKeyException {         List<Laws> laws = new ArrayList<>();         File folder = new File(filename);         for (final File fileEntry : folder.listFiles()) {             if (fileEntry.isDirectory()) {                 System.out.println(\"is directory \" + fileEntry.getAbsolutePath());             } else {                 List<String> list = UtilsFileSaveRead.reads(fileEntry.getAbsolutePath());                 for (String s : list) {                      Laws laws1 = UtilsJson.jsonToLaw(s);                     laws.add(laws1);                 }              }         }         laws = laws                 .stream()                 .sorted(Comparator.comparing(Laws::getPacketLawName))                 .collect(Collectors.toList());          return laws;     }      public static List<LawEligibleForParliamentaryApproval> readLineCurrentLaws(String filename) throws JsonProcessingException {         List<LawEligibleForParliamentaryApproval> laws = new ArrayList<>();         File folder = new File(filename);         for (final File fileEntry : folder.listFiles()) {             if (fileEntry.isDirectory()) {                 System.out.println(\"is directory \" + fileEntry.getAbsolutePath());             } else {                 List<String> list = UtilsFileSaveRead.reads(fileEntry.getAbsolutePath());                 for (String s : list) {                      LawEligibleForParliamentaryApproval laws1 = UtilsJson.jsonToCurrentLaw(s);                     laws.add(laws1);                 }              }         }          return laws;     }       //возвращает все счета законов     public static List<Account> allPackegeLaws(Map<String, Account> balances) {         List<Account> laws = new ArrayList<>();         laws = balances.entrySet()                 .stream()                 .map(t -> t.getValue())                 .filter(t -> t.getAccount().startsWith(Seting.NAME_LAW_ADDRESS_START))                 .collect(Collectors.toList());         return laws;     }      //возвращает пакет законов и их счета     public static Map<String, Laws> getPackageLaws(List<Block> blocks) throws IOException, NoSuchAlgorithmException, SignatureException, InvalidKeySpecException, NoSuchProviderException, InvalidKeyException {         Map<String, Laws> laws = new HashMap<>();         for (Block block : blocks) {             for (DtoTransaction dtoTransaction : block.getDtoTransactions()) {                 if (dtoTransaction.verify()) {                     if (dtoTransaction.getCustomer().startsWith(Seting.NAME_LAW_ADDRESS_START) && dtoTransaction.getBonusForMiner() >= Seting.COST_LAW) {                         if(dtoTransaction.getLaws() != null && !laws.containsKey(dtoTransaction.getCustomer())){                             laws.put(dtoTransaction.getCustomer(), dtoTransaction.getLaws());                         }                      }                 }             }          }         return laws;     }      //проверяет валидность закона     public static boolean isValidHashLaw(Laws laws) throws IOException {         String hash = laws.getHashLaw();         String hashLaw = Seting.NAME_LAW_ADDRESS_START + UtilsUse.sha256hash(UtilsJson.objToStringJson(laws));         System.out.println(\"UtilsLaw: isValidHashLaw: \" + hash.equals(hashLaw));         System.out.println(\"hash: \" + hash);         System.out.println(\"hashLaw: \" + hashLaw);         return hash.equals(hashLaw);     }        public static List<Account> allPackageLaws(List<Account> accounts){         List<Account> currentLaws = accounts.stream()                 .filter(t -> t.getAccount().startsWith(Seting.NAME_LAW_ADDRESS_START))                 .collect(Collectors.toList());         return currentLaws;     }      //возвращяет список всех законов, как действующих, так и не действующих, если закон новый то автоматически сохраняет его     public static Map<String, Laws> getLaws(List<Block> blocks, String fileLaws) throws IOException, NoSuchAlgorithmException, InvalidKeySpecException, SignatureException, NoSuchProviderException, InvalidKeyException {         List<Laws> lawsForSave = new ArrayList<>();         Map<String, Laws> lawsMap = new HashMap<>();         File file = new File(fileLaws);         List<Laws> lawsList = new ArrayList<>();         if (file.exists()) {             lawsList = readLineLaws(fileLaws);         }         lawsMap = getPackageLaws(blocks);          for (Map.Entry<String, Laws> map : lawsMap.entrySet()) {             if (!lawsList.contains(map.getValue())) {                 if( map.getValue() != null &&                         map.getValue().packetLawName != null&&                         map.getValue().getLaws() != null                         && !map.getValue().getHashLaw().isEmpty()                         && (map.getValue().getLaws().size() > 0)){                          lawsForSave.add(map.getValue());                 }              }          }         saveLaws(lawsForSave, fileLaws);         return lawsMap;     }     public static List<LawEligibleForParliamentaryApproval> getCurrentLaws(Map<String, Laws> lawsMap, Map<String, Account> balances, String fileCurrentLaws) throws IOException, NoSuchAlgorithmException, SignatureException, InvalidKeySpecException, NoSuchProviderException, InvalidKeyException {         List<Account> lawsBalances = allPackegeLaws(balances);           List<LawEligibleForParliamentaryApproval> lawEligibleForParliamentaryApprovals = new ArrayList<>();         LawEligibleForParliamentaryApproval lawEligibleForParliamentaryApproval = null;         File file = new File(fileCurrentLaws);         if (file.exists()) {             lawEligibleForParliamentaryApprovals = readLineCurrentLaws(fileCurrentLaws);         }          for (LawEligibleForParliamentaryApproval eligibleForParliamentaryApproval : lawEligibleForParliamentaryApprovals) {             if(lawsBalances.contains(eligibleForParliamentaryApproval.getAccount())){                 eligibleForParliamentaryApproval.getAccount().                         setDigitalStockBalance(balances.get(eligibleForParliamentaryApproval.getAccount().getAccount()).getDigitalStockBalance());                 eligibleForParliamentaryApproval.getAccount().                         setDigitalDollarBalance(balances.get(eligibleForParliamentaryApproval.getAccount().getAccount()).getDigitalDollarBalance());             }          }           List<LawEligibleForParliamentaryApproval> temporary = new ArrayList<>();         for (Account account : lawsBalances) {             lawEligibleForParliamentaryApproval = new LawEligibleForParliamentaryApproval(account, lawsMap.get(account.getAccount()));             temporary.add(lawEligibleForParliamentaryApproval);         }           lawEligibleForParliamentaryApprovals.addAll(temporary);           lawEligibleForParliamentaryApprovals = lawEligibleForParliamentaryApprovals.stream()                 .filter(t->Objects.nonNull(t.getLaws()))                 .filter(t->Objects.nonNull(t.getAccount()))                 .filter(t->Objects.nonNull(t.getLaws().getHashLaw()))                 .filter(t->Objects.nonNull(t.getLaws().getLaws()))                 .filter(t->Objects.nonNull(t.getName()))                 .filter(t->Objects.nonNull(t.getLaws().getPacketLawName()))                 .filter(t->t != null).                 filter(UtilsUse.distinctByKey(LawEligibleForParliamentaryApproval::getName)).collect(Collectors.toList());          return lawEligibleForParliamentaryApprovals;      }         //отбирает позицию вакансий     public static List<LawEligibleForParliamentaryApproval> getPossions(List<LawEligibleForParliamentaryApproval> lawEligibleForParliamentaryApprovals, Director higherSpecialPositions){          List<LawEligibleForParliamentaryApproval> temporary = new ArrayList<>();         temporary = lawEligibleForParliamentaryApprovals.stream()                 .filter(t->Objects.nonNull(t))                 .filter(t->Objects.nonNull(t.getLaws()))                 .filter(t->Objects.nonNull(t.getLaws().getLaws()))                 .filter(t->Objects.nonNull(t.getLaws().getPacketLawName()))                 .filter(t->Objects.nonNull(t.getName()))                 .filter(t->Objects.nonNull(t.getLaws().getHashLaw()))                 .sorted((f1, f2) -> Double.compare(f2.getAccount().getDigitalStockBalance(), f1.getAccount().getDigitalStockBalance()))                 .filter(t-> t.getLaws().getPacketLawName().equals(higherSpecialPositions.getName()))                 .limit(higherSpecialPositions.getCount())                 .collect(Collectors.toList());         return temporary;      }       //удаляет из списка не лигитимные должности     public static List<LawEligibleForParliamentaryApproval> deletePossions(List<LawEligibleForParliamentaryApproval> lawEligibleForParliamentaryApprovals, List<LawEligibleForParliamentaryApproval> forDeleted, Directors higherSpecialPositions){         List<LawEligibleForParliamentaryApproval> temporary = new ArrayList<>();         for (LawEligibleForParliamentaryApproval lawEligibleForParliamentaryApproval : forDeleted) {             if(lawEligibleForParliamentaryApproval != null &&                     lawEligibleForParliamentaryApproval.getLaws() != null &&                     lawEligibleForParliamentaryApproval.getLaws().getPacketLawName() != null &&                     lawEligibleForParliamentaryApproval.getLaws().getHashLaw() != null &&                     lawEligibleForParliamentaryApproval.getLaws().getHashLaw() != null &&                     lawEligibleForParliamentaryApproval.getLaws().getPacketLawName().equals(higherSpecialPositions.getNames())){                 if(lawEligibleForParliamentaryApprovals.contains(lawEligibleForParliamentaryApproval)){                     temporary.add(lawEligibleForParliamentaryApproval);                 }else {                     continue;                 }             }             temporary.add(lawEligibleForParliamentaryApproval);         }         return temporary;     }   }","package International_Trade_Union.vote;  public enum VoteEnum {     YES,     NO }","package International_Trade_Union;  import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication;   @SpringBootApplication public class UnitedStatesApplication { \tpublic static void main(String[] args) { \t\tSpringApplication.run(UnitedStatesApplication.class, args); \t}  }","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","",""],"hashLaw":"LIBER10406f42a16accf222cd8731cf51cbf18ea2c9a9a2517fcb5f17ac4f0c60974d"},"bonusForMiner":5.0,"voteEnum":"YES","sign":"MEQCICa9jPVcy8FsfO1u2j+WWShtrN9H8a29mXRhnomksImuAiBiGjmeM9J0mTD8njhcShaOto6c9t0VHno2k+4u/Q+v8A=="}
{"sender":"stExZb8ifLfnFoq4JJuTifpAcscegATH8znhwW26zyTa","customer":"LIBERb867962d8c3c78c1bc0a8bdcf61db37ca3358d30748b8a732a9d1ffc01e3a3b7","digitalDollar":0.0,"digitalStockBalance":0.0,"laws":{"packetLawName":"BOARD_OF_DIRECTORS","laws":["stExZb8ifLfnFoq4JJuTifpAcscegATH8znhwW26zyTa","mercurygermes@gmail.com"],"hashLaw":"LIBERb867962d8c3c78c1bc0a8bdcf61db37ca3358d30748b8a732a9d1ffc01e3a3b7"},"bonusForMiner":5.0,"voteEnum":"YES","sign":"MEUCIQCHKeJg+jzdSMUp1/5glnPKkTPB33Li2ozK443FfPYi8AIgDfUKTlxuil6m+cHGZe8jjBfLnscaLROGhIiRZKKkbx4="}
{"sender":"stExZb8ifLfnFoq4JJuTifpAcscegATH8znhwW26zyTa","customer":"LIBER7735c1012865cebb0c17e37f4144a1c3267dee7f94eeb125bcc6e3b8a2fc03ca","digitalDollar":0.0,"digitalStockBalance":0.0,"laws":{"packetLawName":"ADD_DIRECTORPRESIDENT_COMPANY","laws":["ADD_DIRECTORPRESIDENT_COMPANY","ADD_DIRECTOR","ADD_DIRECTOR","ADD_DIRECTOR","ADD_DIRECTOR","ADD_DIRECTOR","ADD_DIRECTOR","ADD_DIRECTOR","ADD_DIRECTOR","ADD_DIRECTOR","ADD_DIRECTOR","ADD_DIRECTOR","ADD_DIRECTOR"],"hashLaw":"LIBER7735c1012865cebb0c17e37f4144a1c3267dee7f94eeb125bcc6e3b8a2fc03ca"},"bonusForMiner":5.0,"voteEnum":"YES","sign":"MEUCIQDXCl5IHIqQp5vUhMs2fz+hEogULsMriTezqCn/yPxVxwIgF+tqvsth9946FA1pQeb+hTADytutJAtIHIZKDAwwk4U="}
{"sender":"stExZb8ifLfnFoq4JJuTifpAcscegATH8znhwW26zyTa","customer":"LIBERcd4756c0dff667851602fd358843bd271df4efa84c1fe8431096d0a074344ba5","digitalDollar":0.0,"digitalStockBalance":0.0,"laws":{"packetLawName":"ADD_DIRECTORLIBERTY_FRACTION","laws":[null,null,null],"hashLaw":"LIBERcd4756c0dff667851602fd358843bd271df4efa84c1fe8431096d0a074344ba5"},"bonusForMiner":5.0,"voteEnum":"YES","sign":"MEYCIQCB/UK6djl0cxeDtznjH69hOqu66w2C3FwIxSSn0bTahwIhAPXrO8lwvl+8TLdTtboDzM4D5C86sHm5ZL9/dnvSNuQm"}
{"sender":"stExZb8ifLfnFoq4JJuTifpAcscegATH8znhwW26zyTa","customer":"LIBER5cbd8462f4071f6a376943c6f1fec2798a07cc7918cf7a554eb4f17a87cd59d9","digitalDollar":0.0,"digitalStockBalance":0.0,"laws":{"packetLawName":"ADD_DIRECTORLIBERTY","laws":[null,null,null],"hashLaw":"LIBER5cbd8462f4071f6a376943c6f1fec2798a07cc7918cf7a554eb4f17a87cd59d9"},"bonusForMiner":5.0,"voteEnum":"YES","sign":"MEUCIGiL++2hRsgkIEK/O9BbKEFR6Sk+Xpr/VOwdm+BZLaPGAiEAt4xgoDkZ2bDb2RiLMYbD9+ZOQqTs18Z8Dmz0fByvI7E="}
{"sender":"stExZb8ifLfnFoq4JJuTifpAcscegATH8znhwW26zyTa","customer":"LIBERd94258d0c782227eea3c2ec7e7935cf07819ff4a509555df4a7589d7c9b009b7","digitalDollar":0.0,"digitalStockBalance":0.0,"laws":{"packetLawName":"ADD_DIRECTOR_LIBERTY_END_PROSPERITY","laws":[null,null,null],"hashLaw":"LIBERd94258d0c782227eea3c2ec7e7935cf07819ff4a509555df4a7589d7c9b009b7"},"bonusForMiner":5.0,"voteEnum":"YES","sign":"MEUCIEDb3p79n8aSXG+Bx8il7knSc12E5e4vz5Tst09ZB0IWAiEA2t6DJHIhWQg5IYKUcpvXzXM1xVXRXHHTJM6tKamI43s="}
{"sender":"stExZb8ifLfnFoq4JJuTifpAcscegATH8znhwW26zyTa","customer":"LIBER57b7e7461fa7fa2fd8fa9348364f318c98d064033c07dd2c68a5bc8431becd7d","digitalDollar":0.0,"digitalStockBalance":0.0,"laws":{"packetLawName":"FRACTION_LIBERTY_END_PROSPERITY","laws":[null,null,null],"hashLaw":"LIBER57b7e7461fa7fa2fd8fa9348364f318c98d064033c07dd2c68a5bc8431becd7d"},"bonusForMiner":5.0,"voteEnum":"YES","sign":"MEUCIQCM+lXgAxShbwG8qux9Mbn1aBOJlq4B7rEL41q13OBY1QIgDSTjSGilujbRtxkf99H2yMBa8fYw4qsP16DPQkY2jxc="}
{"sender":"stExZb8ifLfnFoq4JJuTifpAcscegATH8znhwW26zyTa","customer":"LIBERdcef42ee1882e08e599887b744a88220de839f42246fd89c2caba7c924c9a6cb","digitalDollar":0.0,"digitalStockBalance":0.0,"laws":{"packetLawName":"FRACTION","laws":["stExZb8ifLfnFoq4JJuTifpAcscegATH8znhwW26zyTa","PROSPERITY FACTION the prosperity faction was created by the founder and puts the spread of this system in the world and the prosperity of the participants in this system in the first place. mercurygermes@gmail.com"],"hashLaw":"LIBERdcef42ee1882e08e599887b744a88220de839f42246fd89c2caba7c924c9a6cb"},"bonusForMiner":5.0,"voteEnum":"YES","sign":"MEQCIHs2r/lGiDlvPGoQ7VeZswvW5Oa2c9nZye47Pas2Z6jyAiAiPnflxAo46pYHuA/iJDsOJLwpfqB0WKnrUk0rlritlw=="}
{"sender":"stExZb8ifLfnFoq4JJuTifpAcscegATH8znhwW26zyTa","customer":"LIBER0018e1c46e0aa2af0852bfbd72d2743638cd2ca8158a1cba75a8433284ef5dbc","digitalDollar":0.0,"digitalStockBalance":0.0,"laws":{"packetLawName":"","laws":[],"hashLaw":""},"bonusForMiner":0.0,"voteEnum":"NO","sign":"MEUCIQCkeHaTVX7cmLQR5F5tk4VO3q92QRR8dmOeIbx6M8/WDgIgFFGImgBKD09gGjAyQpKGZdyp8wH6PyhstATVAvVWTjU="}
{"sender":"stExZb8ifLfnFoq4JJuTifpAcscegATH8znhwW26zyTa","customer":"LIBER10406f42a16accf222cd8731cf51cbf18ea2c9a9a2517fcb5f17ac4f0c60974d","digitalDollar":0.0,"digitalStockBalance":0.0,"laws":{"packetLawName":"","laws":[],"hashLaw":""},"bonusForMiner":0.0,"voteEnum":"NO","sign":"MEUCIC/1/8rv3blvFNSKPfDJWOHEv+KH2ievovyPS4Xtjy+sAiEAtOVASRFZklJnxiSxSLiR5VKU0VBT7mQdu6U8UJBCQu0="}
{"sender":"stExZb8ifLfnFoq4JJuTifpAcscegATH8znhwW26zyTa","customer":"LIBER0018e1c46e0aa2af0852bfbd72d2743638cd2ca8158a1cba75a8433284ef5dbc","digitalDollar":0.0,"digitalStockBalance":0.0,"laws":{"packetLawName":"","laws":[],"hashLaw":""},"bonusForMiner":0.0,"voteEnum":"NO","sign":"MEUCIQDIOwYMLaO6pQRbW60shK8i+kXGdBJejw8NF4zJcohd6AIgDoiaKWOsF9gysvdKjWtFwZiBv9x3RBjw8c9yH+RZ8n0="}
{"sender":"stExZb8ifLfnFoq4JJuTifpAcscegATH8znhwW26zyTa","customer":"LIBER520a7cedd27ecc7e8d23e590acc93637e26936f4702e02feca622f5d5f0b8006","digitalDollar":0.0,"digitalStockBalance":0.0,"laws":{"packetLawName":"ORIGINAL_CHARTER_CURRENT_LAW_PACKAGE_NAME","laws":["# HOW THE LAWS ARE CHOSEN.  ## Approval of the law _____  ## CHARTER No law is retroactive. No law shall violate the existing statute or be inconsistent with other applicable laws. If there is a contradiction between several laws from one set of laws, then the current one is the one that is higher in the index in the list. Example: alcohol sales package the law under index 3 contradicts the law from index 17, in this case the law under index three will be valid, because he is higher in status. In the event of a conflict between several laws in force, the Judiciary shall give priority to those laws which were adopted earlier, but should be taken into account precisely from the last date of adoption of the law. The law is in force as long as it satisfies the conditions for the adoption of the law and as soon as the condition violated, the law loses its force until the law is re-adopted. In the voting of all laws, only the votes given in the last four years are taken into account. All laws are divided into several groups. 1. Ordinary laws 2. Strategic Plan 3. Budget 4. Appointed by the Legislature 6. Laws that create new positions. These positions are approved only by the Legislative Power. 7. Amendments to the Charter 8. The charter itself  ### REGULAR LAWS To establish ordinary laws, 1. The name of the package of law should not match the highlighted keywords. 2. The law must receive more than 1 vote according to the scoring system described by [VOTE_STOCK](../charterEng/VOTE_STOCK.md) 3. Must receive 10 or more votes of the Board of Directors according to the scoring system described in [ONE_VOTE](../charterEng/ONE_VOTE.md) 4. Must receive 10 or more votes of the Board of Shareholders according to the scoring system described in [ONE_VOTE](../charterEng/ONE_VOTE.md) 5. Must receive 10% of votes from factions according to the counting system described in [VOTE_FRACTION](../charterEng/VOTE_FRACTION.md).  ![asserting customary laws](../screenshots/law-classic.png) Sample code in LawsController current law: ````       //laws must be approved by everyone.          List<CurrentLawVotesEndBalance> notEnoughVotes = current.stream()                  .filter(t -> !directors.contains(t.getPackageName()))                  .filter(t->!Seting.AMENDMENT_TO_THE_CHARTER.equals(t.getPackageName()))                  .filter(t->!directors.isCabinets(t.getPackageName()))                  .filter(t -> !Seting.ORIGINAL_CHARTER_CURRENT_LAW_PACKAGE_NAME.equals(t.getPackageName()))                  .filter(t->!Seting.ORIGINAL_CHARTER_CURRENT_ALL_CODE.equals(t.getPackageName()))                  .filter(t -> t.getVotesBoardOfShareholders() >= Seting.ORIGINAL_LIMIT_MIN_VOTE_BOARD_OF_SHAREHOLDERS                  && t.getVotesBoardOfDirectors() >= Seting.ORIGINAL_LIMIT_MIN_VOTE_BOARD_OF_DIRECTORS                  && t.getVotes() >= Seting.ALL_STOCK_VOTE                  && t.getFractionVote() >= Seting.ORIGINAL_LIMIT_MIN_VOTE_FRACTIONS)                  .sorted(Comparator.comparing(CurrentLawVotesEndBalance::getVotes).reversed()).collect(Collectors.toList());      ````  ### STRATEGIC PLAN. The strategic plan is the general plan for the entire network and is approved in the same way as an ordinary law, but there are some differences from ordinary laws. 1. The strategic plan package should be called STRATEGIC_PLAN 2. All plans that have been approved are sorted from highest to lowest by the number of votes,    received from the Board of Directors. 3. After Sorting, only one PLAN with the highest number of votes received from the Board of Directors is selected.  ```` //the plan is approved by everyone          List<CurrentLawVotesEndBalance> planFourYears = current.stream()                  .filter(t->!directors.contains(t.getPackageName()))                  .filter(t->Seting.STRATEGIC_PLAN.equals(t.getPackageName()))                  .filter(t->!directors.isCabinets(t.getPackageName()))                  .filter(t->t.getVotesBoardOfDirectors() >= Seting.ORIGINAL_LIMIT_MIN_VOTE_BOARD_OF_DIRECTORS                          && t.getVotesBoardOfShareholders() >= Seting.ORIGINAL_LIMIT_MIN_VOTE_BOARD_OF_SHAREHOLDERS                          && t.getFractionVote() >= Seting.ORIGINAL_LIMIT_MIN_VOTE_FRACTIONS                          && t.getVotes() >= Seting.ALL_STOCK_VOTE)                  .sorted(Comparator.comparing(CurrentLawVotesEndBalance::getVotesBoardOfDirectors).reversed())                  .limit(1)                  .collect(Collectors.toList()); ````  ### BUDGET The budget is the overall cost for the system and is approved similarly to the Strategic Plan, but the name of the package should be BUDGET and it is also in a single copy.  ````   //budget approved by everyone          List<CurrentLawVotesEndBalance> budjet = current.stream()                  .filter(t-> !directors.contains(t.getPackageName()))                  .filter(t->Seting.BUDGET.equals(t.getPackageName()))                  .filter(t->!directors.isCabinets(t.getPackageName()))                  .filter(t->                          t.getVotesBoardOfDirectors() >= Seting.ORIGINAL_LIMIT_MIN_VOTE_BOARD_OF_DIRECTORS                          && t.getVotesBoardOfShareholders() >= Seting.ORIGINAL_LIMIT_MIN_VOTE_BOARD_OF_SHAREHOLDERS                          && t.getFractionVote() >= Seting.ORIGINAL_LIMIT_MIN_VOTE_FRACTIONS                          && t.getVotes() >= Seting.ALL_STOCK_VOTE)                  .sorted(Comparator.comparing(CurrentLawVotesEndBalance::getVotesBoardOfDirectors).reversed())                  .limit(1)                  .collect(Collectors.toList()); ````  ### POSTS THAT ARE APPOINTED ONLY BY THE LEGISLATIVE AUTHORITY There are positions that are appointed only by the Legislature and such positions include General Executive Director. This position is similar to the Prime Minister and is Executive Power in this system. Each such position can be limited to the number that is defined in this system. for this position. Example: There is only one CEO position. Elected in the same way as ***strategic plan*** and ***budget***. But the number is determined for each position separately. ````    //positions elected only by all participants          List<CurrentLawVotesEndBalance> electedByBoardOfDirectors = current.stream()                  .filter(t -> directors.isElectedByBoardOfDirectors(t.getPackageName()) || directors.isCabinets(t.getPackageName()))                  .filter(t -> t.getVotesBoardOfDirectors() >= Seting.ORIGINAL_LIMIT_MIN_VOTE_BOARD_OF_DIRECTORS                  && t.getVotesBoardOfShareholders() >= Seting.ORIGINAL_LIMIT_MIN_VOTE_BOARD_OF_SHAREHOLDERS                  && t.getFractionVote() >= Seting.ORIGINAL_LIMIT_MIN_VOTE_FRACTIONS                  && t.getVotes() >= Seting.ALL_STOCK_VOTE)                  .sorted(Comparator.comparing(CurrentLawVotesEndBalance::getVotesBoardOfDirectors).reversed())                  .collect(Collectors.toList());                                     //group by list          Map<String, List<CurrentLawVotesEndBalance>> group = electedByBoardOfDirectors.stream()                  .collect(Collectors.groupingBy(CurrentLawVotesEndBalance::getPackageName));           Map<Director, List<CurrentLawVotesEndBalance>> original_group = new HashMap<>();           // leave the amount that is described in this post          for (Map.Entry<String, List<CurrentLawVotesEndBalance>> stringListEntry : group.entrySet()) {              List<CurrentLawVotesEndBalance> temporary = stringListEntry.getValue();              temporary = temporary.stream()                      .sorted(Comparator.comparing(CurrentLawVotesEndBalance::getVotesBoardOfDirectors))                      .limit(directors.getDirector(stringListEntry.getKey()).getCount())                      .collect(Collectors.toList());              original_group.put(directors.getDirector(stringListEntry.getKey()), temporary);          } ````  There are also positions that are created with the help of laws, these positions are also approved by the Legislative power. For each such position, there is only one seat for each title. The name of such packages starts with ADD_DIRECTOR_. With the obligatory underscore.  ### CHARTER AMENDMENTS To amend the charter, the law package must be named AMENDMENT_TO_THE_CHARTER. For an amendment to be valid 1. It is necessary that 20% or more of the votes received from the Council of Shareholders by the counting system [ONE_VOTE](../charterEng/ONE_VOTE.md). 2. Need to get 20% or more votes from the Board of Directors by the [ONE_VOTE](../charterEng/ONE_VOTE.md) counting system . 3. Need to get 5 or more votes from the Legislative Branch of the Corporate Chief Justices. 4. Need to get 10% or more of votes from factions by counting system [VOTE_FRACTION](../charterEng/VOTE_FRACTION.md).  ![Charter amendments](../screenshots/amendment-chapter.png) ````     //introduction of amendments to the charter          List<CurrentLawVotesEndBalance> chapter_amendment = current.stream()                  .filter(t -> !directors.contains(t.getPackageName()))                  .filter(t-> Seting.AMENDMENT_TO_THE_CHARTER.equals(t.getPackageName()))                  .filter(t->!directors.isCabinets(t.getPackageName()))                  .filter(t -> t.getVotesBoardOfShareholders() >= Seting.ORIGINAL_LIMIT_MINT_VOTE_BOARD_OF_SHAREHOLDERS_AMENDMENT                  && t.getVotesBoardOfDirectors() >= Seting.ORIGINAL_LIMIT_MIN_VOTE_BOARD_OF_DIRECTORS_AMENDMENT                  && t.getVotesCorporateCouncilOfReferees() >= Seting.ORIGINAL_LIMIT_MIN_VOTE_CORPORATE_COUNCIL_OF_REFEREES_AMENDMENT                  && t.getFractionVote() >= Seting.ORIGINAL_LIMIT_MIN_VOTE_FRACTIONS)                  .sorted(Comparator.comparing(CurrentLawVotesEndBalance::getVotesBoardOfDirectors).reversed()).collect(Collectors.toList());  ````  ### SAM CHARTER. The first charter is approved by the founder and it is valid, the vote of the founder for approval The charter never has an expiration date. The charter package name starts with CHARTER_ORIGINAL and the name refone CHARTER_ORIGINAL_CODE. These two packages are a holistic charter, but in the first place, the source code must not contradict the principles described in CHARTER_ORIGINAL. ```` // the charter is always valid, it is signed by the founder          List<CurrentLawVotesEndBalance> CHARTER_ORIGINAL = current.stream()                  .filter(t -> !directors.contains(t.getPackageName()) && Seting.ORIGINAL_CHARTER_CURRENT_LAW_PACKAGE_NAME.equals(t.getPackageName()))                  .filter(t->!directors.isCabinets(t.getPackageName()))                  .filter(t->t.getFounderVote()>=1)                  .sorted(Comparator.comparing(CurrentLawVotesEndBalance::getVotes).reversed())                  .limit(1)                  .collect(Collectors.toList());           // SOURCE CODE CREATED BY THE FOUNDER          List<CurrentLawVotesEndBalance> CHARTER_ORIGINAL_CODE = current.stream()                  .filter(t -> !directors.contains(t.getPackageName()) && Seting.ORIGINAL_CHARTER_CURRENT_ALL_CODE.equals(t.getPackageName()))                  .filter(t->!directors.isCabinets(t.getPackageName()))                  .filter(t->t.getFounderVote()>=1)                  .sorted(Comparator.comparing(CurrentLawVotesEndBalance::getVotes).reversed())                  .limit(1)                  .collect(Collectors.toList()); ```` [Return to main page](../documentationEng/documentationEng.md)","# VOTE_STOCK (How shares are voted.)  How shares are voted. All shares held by the account are equal to the same number of votes. Every time someone makes a transaction to the account, is the packet address that starts with LIBER he votes on this package. Only those votes from which no more than four years have passed are taken into account. If the transaction was made ***VoteEnum.YES,*** then this account receives votes ***for***, formula yesV = number of votes equal to the sender's shares. yesN = how many laws this account voted for with VoteEnum.YES resultYES = yesV / yesN). Example: an account voted for three accounts that start with LIBER, 100 shares, 100 votes. 100 / 3 = 33.3 means each account will receive 33.3 votes.  If the transaction was made with VoteEnum.NO, then the same formula is used, but now all bills for which he voted against are taken into account example the same account voted for two accounts against, it has the same one hundred shares. resultNO = noV / noN = 50 = 50 means every bill he voted for, against will receive 50 votes against. Further, each score that starts with LIBER counts and sums up all the votes given to it ***FOR*** (VoteEnum.YES) and ***NO*** (VoteEnum.NO). Then this formula is used remainder = resultYES - resultNO. It is this result that is displayed as votes cast. At any time you can change your voice, but only to the opposite, which means if If you voted for a YES candidate then you can only change to NO and back. The number of times you can change your voice is not limited. With each block there is a recalculation of votes, if you lose your shares, your candidates also lose their votes. This measure is specifically implemented so that elected positions were interested in the fact that those who vote for them prospered and did not lose their shares. Only CORPORATE_COUNCIL_OF_REFEREES and BOARD_OF_DIRECTORS are elected this way Only the last transaction given for each account counts, unless you have updated your vote, then after four years it will be cancelled. 100,000 votes are needed to approve the law  ______  ```` //code is in class class CurrentLawVotes method: votesLaw public double votesLaw(Map<String, Account> balances,       Map<String, Integer> yesAverage, Map<String, Integer> noAverage) {          double yes = 0.0;          double no = 0.0;                                for (String s : YES) {               int count = 1;            count = yesAverage.get(s) > 0 ? yesAverage.get(s) : 1;            yes += balances.get(s).getDigitalStockBalance() / count;          }                   for (String s : NO) {             int count = 1;              count = noAverage.get(s) > 0 ? noAverage.get(s) : 1;             no += balances.get(s).getDigitalStockBalance() / count);           }            return yes - no;     }  ````  [back to home](../documentationEng/documentationEng.md)","# ONE_VOTE (One Voice)  When these positions are voted count as one score = one vote (CORPORATE_COUNCIL_OF_REFEREES-Council of Corporate Judges, BOARD_OF_DIRECTORS-Board of Directors, GENERAL_EXECUTIVE_DIRECTOR-General Executive Director, HIGH_JUDGE - Supreme Judge and Board of Shareholders). Each score that starts with LIBER counts all votes FOR (VoteEnum.YES) and AGAINST (VoteEnum.NO) for it further deducted from FOR - AGAINST = if the balances are above the threshold, then it becomes the current law. But if a position is elected, then after that it is sorted from largest to smallest and the largest number that is described for this position is selected. Recalculation of votes occurs every block.  After voting, the vote can only be changed to the opposite one. There is no limit on the number of times you can change your vote. Only those votes that are given by accounts are taken into account in office, for example, if the account ceases to be on the Board of Directors, his vote as The Board of Directors does not, and will not, count in voting. All votes are valid until the bills voters are in their positions. Only those votes from which no more than four years, but each participant may at any time renew their vote.  ______  CODE class CurrentLawVotes: method voteGovernment  ```` public int voteGovernment(              Map<String, Account> balances,              List<String> governments) {         int yes = 0;          int no = 0;          List<String> addressGovernment = governments;        for (String s : YES) {              if (addressGovernment.contains(s)) {                  yes += Seting.VOTE_GOVERNMENT;             }           }          for (String s : NO) {            if (addressGovernment.contains(s)) {                  no += Seting.VOTE_GOVERNMENT;             }          }         return yes - no;     }  ````  [back to home](../documentationEng/documentationEng.md)","#VOTE_FRACTION This voting system is used only for factions. First, 100 factions are selected that have become legitimate. Then all the votes given to 100 selected factions are summed up. After that, the share of each fraction from the total amount is determined. votes cast for this faction. The number of votes of each faction is equal to its percentage shares. Thus, if a faction has 23% of the votes of all votes, out of 100 factions, then her vote is equal to 23%.  Then every time a faction votes for laws, that start with LIBER (VoteEnum.YES) or (VoteEnum.NO). This law counts all the votes given *** for *** and *** against ***, after which it is subtracted from *** for *** - *** against ***. This result is displayed as a percentage.  ````   //faction vote      public double voteFractions(Map<String, Double> fractions){          double yes = 0;          double no = 0;          double sum = fractions.entrySet().stream()                  .map(t->t.getValue())                  .collect(Collectors.toList())                  .stream().reduce(0.0, Double::sum);           for (String s : YES) {              if (fractions.containsKey(s)) {                  yes += (fractions.get(s)/sum) * Seting.HUNDRED_PERCENT;              }           }          for (String s : NO) {              if (fractions.containsKey(s)) {                  no += (fractions.get(s)/sum) * Seting.HUNDRED_PERCENT;              }           }          return yes - no;       }  ````  [Return to main page](../documentationEng/documentationEng.md)","# Penalty mechanism  You make a transaction in which you lose this amount of shares, but and the account to which the penalty is directed loses such an amount of shares.  Valid for digital dollars only. ![Lead fine](../screenshots/lead_a_fine_eng.png) ______  ## MECHANISM_FOR_REDUCING_THE_NUMBER_OF_SHARES MECHANISM FOR REDUCING THE NUMBER OF SHARES. Entering penalties. Every time one account sends a digital share to another account but uses VoteEnum.NO, the account recipient's digital shares are reduced by the amount sent by the share sender. Example account A sent to account B 100 digital shares with VoteEnum.NO, then account A and account B both lose 100 digital shares. This measure is needed so that there is a mechanism to dismiss the Board of Shareholders and also allows you to lower your votes destructive accounts, since the number of votes is equal to the number of shares in the Election of the Board of Directors and when electing CORPORATE_COUNCIL_OF_REFEREES. This mechanism only works on digital shares and only if the sender has made a transaction with VoteEnum.NO.  [exit to home](../documentationEng/documentationEng.md)","# WHO_HAS_THE_RIGHT_TO_CREATE_LAWS Who has the right to create laws  String WHO_HAS_THE_RIGHT_TO_CREATE_LAWS = Who has the right to make laws. Create Laws in Cryptocurrency International Trade Union Corporations Have the Rights all network members who have at least five digital dollars. To create law through the International Trade Union Corporation's cryptocurrency mechanism It is necessary to create an object of the Laws class inside this cryptocurrency, where packetLawName is the name of the law package. List<String> laws - is a list of laws, String hashLaw - is the address of this package of laws and starts with LIBER. For a law to be included in the pool of laws, you need to create a transaction where the recipient is the hashLaw of this law and the reward miner is equal to five digital dollars (5) of this cryptocurrency. After that, as the law gets into the block, it will be in the pool laws and it will be possible to vote for it. The number of lines in a package of laws can be as many as needed and there are no restrictions.  [Exit to home](../documentationEng/documentationEng.md)","# POWERS_OF_THE_CORPORATE_COUNCIL_OF_JUDGES Judicial Power. Approves the Chief Justice. Participates in the voting on the introduction of amendments.  The judicial power of the International Trade Union Corporation is vested in one Supreme Court and such inferior courts as the Corporation International The Merchant Union may issue and establish from time to time. Judges of both the supreme and inferior courts hold their offices, with good conduct and in due time receive remuneration for their services. Remuneration must be given from the budget established by laws. Judicial power extends to all cases of law and justice, including those initiated by members to challenge the misappropriation of funds, arising under these Articles, the laws of the International Trade Union Corporation and treaties, imprisoned or to be imprisoned according to their authority. to controversy, in which the International Trade Union will be party to a dispute between two or more members of the network. No judgment shall be secret, but justice shall be administered openly and free of charge, completely and without delay, and every person shall have legal protection against injury to life, liberty, or property. Supreme Court CORPORATE_COUNCIL_OF_REFEREES and Chief Justice HIGH_JUDGE.  ## How the Corporate Council of Judges is elected. The Corporate Council of Judges consists of 55 accounts and is elected by the Network Members, with the scoring system described in VOTE_STOCK, similar to Board of Directors and Factions. The 55 accounts that received the most votes are selected. ![stock votes](../screenshots/stock_vote.png) ```` //minimum value for the number of positive votes for the law to be valid,          //positions elected by shares CORPORATE_COUNCIL_OF_REFEREES          List<CurrentLawVotesEndBalance> electedByStockCorporateCouncilOfReferees = current.stream()                  .filter(t -> directors.isElectedByStocks(t.getPackageName()))                  .filter(t -> t.getPackageName().equals(NamePOSITION.CORPORATE_COUNCIL_OF_REFEREES.toString()))                  .filter(t -> t.getVotes() >= Seting.ORIGINAL_LIMIT_MIN_VOTE)                  .sorted(Comparator.comparing(CurrentLawVotesEndBalance::getVotes).reversed())                  .limit(directors.getDirector(NamePOSITION.CORPORATE_COUNCIL_OF_REFEREES.toString()).getCount())                  .collect(Collectors.toList()); ````  Each score of such a judge is equal to one vote, similar to [ONE_VOTE](../charterEng/ONE_VOTE.md)  [Exit to home](../documentationEng/documentationEng.md)","# String HOW_THE_CHIEF_JUDGE_IS_CHOSEN HOW HIGH_JUDGE IS CHOSEN. The Chief Justice is elected by CORPORATE_COUNCIL_OF_REFEREES. Each member of the network can apply for the position of Chief Justice by creating a law called package that matches HIGH_JUDGE position, where the address of the sender of this transaction must match the first line from the list of laws of this package. The cost of the law is five digital dollars as a reward to the earner. The account with the most remaining votes receives the position. The voting mechanism is described in [ONE_VOTE](../charterEng/ONE_VOTE.md). Elects the Chief Justice, Corporate Council of Judges. (CORPORATE_COUNCIL_OF_REFEREES) Sample code as stated by the supreme judge. Class LawsController: method currentLaw. Code section  ````        //positions elected by the board of corporate chief judges        List<CurrentLawVotesEndBalance> electedByCorporateCouncilOfReferees = current.stream()                 .filter(t -> directors.isElectedBYCorporateCouncilOfReferees(t.getPackageName()))                 .filter(t -> t.getVotesCorporateCouncilOfReferees() >= Seting.ORIGINAL_LIMIT_MIN_VOTE_CORPORATE_COUNCIL_OF_REFEREES)                 .sorted(Comparator.comparing(CurrentLawVotesEndBalance::getVotesCorporateCouncilOfReferees)).collect(Collectors.toList()); ````  ## Powers of Chief Justice Chief Justice can participate in resolving disputes within network members, like CORPORATE_COUNCIL_OF_REFEREES, but his vote is higher than that of CORPORATE_COUNCIL_OF_REFEREES.  [Exit to home](../documentationEng/documentationEng.md)","# PROPERTY_OF_THE_CORPORATION PROPERTY OF THE CORPORATION. All property owned by the International Trade Union Corporation, cannot be sold without a valid law, where the sale process will be described and at what price the property will be sold. The founder's account, and the accounts of other members are not corporate account, the Board of Directors must create a separate account which will be budgeted and managed only by members of the current members of the Board of Directors.  [Exit to home](../documentationEng/documentationEng.md)","# GENERAL_EXECUTIVE_DIRECTOR General Executive Director This Director coordinates the actions of the other senior directors to implement the strategic plan or the tasks assigned to it by the laws in force. All powers must be given to him through existing laws. This is the highest position elected by the Corporation and is essentially the analogue of the prime minister.  ## How the CEO is elected This director is elected by the Legislature 1. The Board of Directors must give more than 10 or more votes using the [ONE_VOTE](../charterEng/ONE_VOTE.md) method 2. The Board of Shareholders must give more than 10 or more votes using the [ONE_VOTE](../charterEng/ONE_VOTE.md) method 3. Fractions must give 10% or more votes using the [VOTE_FRACTION](../charterEng/VOTE_FRACTION.md) method 4. Network participants must give more than one vote using the [VOTE_STOCK](../charterEng/VOTE_STOCK.md) method 5. Next comes the sorting from highest to lowest received votes from the Board of Directors and 6. One account with the most votes from the Board of Directors is selected  ````   //positions elected only by all participants          List<CurrentLawVotesEndBalance> electedByBoardOfDirectors = current.stream()                  .filter(t -> directors.isElectedByBoardOfDirectors(t.getPackageName()) || directors.isCabinets(t.getPackageName()))                  .filter(t -> t.getVotesBoardOfDirectors() >= Seting.ORIGINAL_LIMIT_MIN_VOTE_BOARD_OF_DIRECTORS                  && t.getVotesBoardOfShareholders() >= Seting.ORIGINAL_LIMIT_MIN_VOTE_BOARD_OF_SHAREHOLDERS                  && t.getFractionVote() >= Seting.ORIGINAL_LIMIT_MIN_VOTE_FRACTIONS                  && t.getVotes() >= Seting.ALL_STOCK_VOTE)                  .sorted(Comparator.comparing(CurrentLawVotesEndBalance::getVotesBoardOfDirectors).reversed())                  .collect(Collectors.toList());                                    //group by list          Map<String, List<CurrentLawVotesEndBalance>> group = electedByBoardOfDirectors.stream()                  .collect(Collectors.groupingBy(CurrentLawVotesEndBalance::getPackageName));           Map<Director, List<CurrentLawVotesEndBalance>> original_group = new HashMap<>();           // leave the amount that is described in this post          for (Map.Entry<String, List<CurrentLawVotesEndBalance>> stringListEntry : group.entrySet()) {              List<CurrentLawVotesEndBalance> temporary = stringListEntry.getValue();              temporary = temporary.stream()                      .sorted(Comparator.comparing(CurrentLawVotesEndBalance::getVotesBoardOfDirectors))                      .limit(directors.getDirector(stringListEntry.getKey()).getCount())                      .collect(Collectors.toList());              original_group.put(directors.getDirector(stringListEntry.getKey()), temporary);          }  ````  ````   public static List<CurrentLawVotesEndBalance> filtersVotes(              List<LawEligibleForParliamentaryApproval> approvalList,              Map<String, Account> balances,              List<Account> BoardOfShareholders,              List<Block> blocks,              int limitBlocks      ) throws IOException, NoSuchAlgorithmException, SignatureException, InvalidKeySpecException, NoSuchProviderException, InvalidKeyException {          //acting laws whose votes are greater than ORIGINAL_LIMIT_MIN_VOTE          List<CurrentLawVotesEndBalance> current = new ArrayList<>();          Map<String, CurrentLawVotes> votesMap = null;          List<Account> accounts = balances.entrySet().stream().map(t -> t.getValue()).collect(Collectors.toList());          if (blocks.size() > limitBlocks) {              votesMap = UtilsCurrentLaw.calculateVotes(accounts, blocks.subList(blocks.size() - limitBlocks, blocks.size()));          } else {              votesMap = UtilsCurrentLaw.calculateVotes(accounts, blocks);          }           //calculate the average number of times he voted for          Map<String, Integer> yesAverage = UtilsCurrentLaw.calculateAverageVotesYes(votesMap);          //calculate the average number of times he downvoted          Map<String, Integer> noAverage = UtilsCurrentLaw.calculateAverageVotesNo(votesMap);            //count the votes for the normal laws and laws of positions          for (LawEligibleForParliamentaryApproval lawEligibleForParliamentaryApproval : approvalList) {              if (votesMap.containsKey(lawEligibleForParliamentaryApproval.getLaws().getHashLaw())) {                  String address = lawEligibleForParliamentaryApproval.getLaws().getHashLaw();                  String packageName = lawEligibleForParliamentaryApproval.getLaws().getPacketLawName();                  List<String> laws = lawEligibleForParliamentaryApproval.getLaws().getLaws();                  double vote = 0;                  int supremeVotes = 0;                  int boafdOfShareholderVotes = 0;                  int houseOfRepresentativiesVotes = 0;                  int primeMinisterVotes = 0;                  int-highhtJudgesVotes = 0;                  int founderVote = 0;                  double fraction = 0;                   //count special votes for laws                  vote = votesMap.get(lawEligibleForParliamentaryApproval.getLaws().getHashLaw()).votesLaw(balances, yesAverage, noAverage);                  List<String> boardOfShareholdersAddress = BoardOfShareholders.stream().map(t -> t.getAccount()).collect(Collectors.toList());                  boafdOfShareholderVotes = votesMap.get(lawEligibleForParliamentaryApproval.getLaws().getHashLaw()).voteGovernment(balances, boardOfShareholdersAddress);                   List<String> founder = List.of(Seting.ADDRESS_FOUNDER);                  founderVote = votesMap.get(lawEligibleForParliamentaryApproval.getLaws().getHashLaw()).voteGovernment(balances, founder);                  CurrentLawVotesEndBalance currentLawVotesEndBalance = new CurrentLawVotesEndBalance(                          address,                          packagename,                          vote,                          supremeVotes,                          houseOfRepresentativesVotes,                          boafdOfShareholderVotes,                          primeMinisterVotes,                          hightJudgesVotes,                          founderVote,                          fraction,                          laws);                  current.add(currentLawVotesEndBalance);               }          }           List<String> houseOfRepresentativies = new ArrayList<>();          List<String> chamberOfSumpremeJudges = new ArrayList<>();          Map<String, Double> fractions = new HashMap<>();           for (CurrentLawVotesEndBalance currentLawVotesEndBalance: current) {              if(currentLawVotesEndBalance.getPackageName().equals(NamePOSITION.BOARD_OF_DIRECTORS.toString())){                  if(currentLawVotesEndBalance.getVotes() >= Seting.ORIGINAL_LIMIT_MIN_VOTE){                      houseOfRepresentativies.add(currentLawVotesEndBalance.getLaws().get(0));                  }               }              if(currentLawVotesEndBalance.getPackageName().equals(NamePOSITION.CORPORATE_COUNCIL_OF_REFEREES.toString())){                  if(currentLawVotesEndBalance.getVotes() >= Seting.ORIGINAL_LIMIT_MIN_VOTE){                      chamberOfSumpremeJudges.add(currentLawVotesEndBalance.getLaws().get(0));                  }               }                if(currentLawVotesEndBalance.getPackageName().equals(NamePOSITION.FRACTION.toString())){                  if(currentLawVotesEndBalance.getVotes() >= Seting.ORIGINAL_LIMIT_MIN_VOTE){                      fractions.put(currentLawVotesEndBalance.getLaws().get(0), currentLawVotesEndBalance.getVotes());                  }              }           }             for (CurrentLawVotesEndBalance currentLawVotesEndBalance : current) {              if(votesMap.containsKey(currentLawVotesEndBalance.getAddressLaw())){                    double vote = votesMap.get(currentLawVotesEndBalance.getAddressLaw()).votesLaw(balances, yesAverage, noAverage);                  int supremeVotes = votesMap.get(currentLawVotesEndBalance.getAddressLaw()).voteGovernment(balances, chamberOfSumpremeJudges);                  int houseOfRepresentativiesVotes = votesMap.get(currentLawVotesEndBalance.getAddressLaw()).voteGovernment(balances, houseOfRepresentativies);                  double fractionsVotes = votesMap.get(currentLawVotesEndBalance.getAddressLaw()).voteFractions(fractions);                   currentLawVotesEndBalance.setVotes(vote);                  currentLawVotesEndBalance.setVotesBoardOfDirectors(houseOfRepresentativiesVotes);                  currentLawVotesEndBalance.setVotesCorporateCouncilOfReferees(supremeVotes);                  currentLawVotesEndBalance.setFractionVote(fractionsVotes);              }           }           //examines the CEO          List<String> primeMinister = new ArrayList<>();          List<String> hightJudge = new ArrayList<>();          for (CurrentLawVotesEndBalance currentLawVotesEndBalance : current) {              if(currentLawVotesEndBalance.getPackageName().equals(NamePOSITION.GENERAL_EXECUTIVE_DIRECTOR.toString())){                  if(currentLawVotesEndBalance.getVotesBoardOfDirectors() >= Seting.ORIGINAL_LIMIT_MIN_VOTE_BOARD_OF_DIRECTORS                  && currentLawVotesEndBalance.getFractionVote() >= Seting.ORIGINAL_LIMIT_MIN_VOTE_FRACTIONS                  && currentLawVotesEndBalance.getVotesBoardOfShareholders() >= Seting.ORIGINAL_LIMIT_MIN_VOTE_BOARD_OF_SHAREHOLDERS                  && currentLawVotesEndBalance.getVotes() >= Seting.ALL_STOCK_VOTE){                      primeMinister.add(currentLawVotesEndBalance.getLaws().get(0));                  }              }               if(currentLawVotesEndBalance.getPackageName().equals(NamePOSITION.HIGH_JUDGE.toString())){                  if(currentLawVotesEndBalance.getVotesCorporateCouncilOfReferees() >= Seting.ORIGINAL_LIMIT_MIN_VOTE_CORPORATE_COUNCIL_OF_REFEREES){                      hightJudge.add(currentLawVotesEndBalance.getLaws().get(0));                  }              }          }          for (CurrentLawVotesEndBalance currentLawVotesEndBalance : current) {              if(votesMap.containsKey(currentLawVotesEndBalance.getAddressLaw())){                  int primeMinisterVotes = votesMap.get(currentLawVotesEndBalance.getAddressLaw()).voteGovernment(balances, primeMinister);                  int hightJudgeVotes = votesMap.get(currentLawVotesEndBalance.getAddressLaw()).voteGovernment(balances, hightJudge);                   currentLawVotesEndBalance.setVoteGeneralExecutiveDirector(primeMinisterVotes);                  currentLawVotesEndBalance.setVoteHightJudge(hightJudgeVotes);              }           }            return current;       }  ````  [Exit to home](../documentationEng/documentationEng.md)","# EXPLANATION WHY MONEY DEMURAGE IS USED HERE The negative rate is now applied in many countries, this measure stimulates money holders when the price is excessively high, saturate the market with money. The amount of money mined for each block is 200 digital dollars and 200 digital shares, also 2% of each mining reward to the founder, which is 4 digital dollars and 4 digital Shares for each block mining. Here it is used as the Theories of Silvio Gesell, as well as the school of monetarism in a modified form.  With Silvio Gezel, the negative rate was 1% per month, which would just kill the economy, under monetarism, the growth of the money supply had to be proportional to the growth of GDP, but since in this system fails to calculate the real GDP growth, I set a fixed growth, also if the monetary growth will equal GDP, there is a high probability of Hyperinflation, since GDP does not always reflect real economic growth. Money must be solid so that a business can predict its long-term investments and from monetarism, only the part that the money supply should grow linearly, but in general there is a mix of different economic schools, including the Austrian School of Economics.  With a negative rate of 0.1% every six months for digital dollars and 0.2% for digital stocks, we avoid the consequences of a severe economic crisis for this currency.  Such a mechanism creates a price corridor where the lower limit of the value of these digital currencies is the total number of issued digital currencies. dollars and digital stocks, and the upper limit is the real value. Since as soon as the value becomes higher than the real value, it becomes more profitable for holders to sell digital dollars and digital shares at inflated prices, thereby saturating the market with money and creating a correction in the market.  The main source of monetary crises is rapid changes in commodity prices and slow changes in wages. Example: Imagine that the value of the currency has risen sharply by 30%, it becomes more profitable for holders not to invest money, since income from holding currency, higher than now pay more expensive employees, because of the fact that the money stops invest. People do not receive wages, which leads to the fact that a huge number of goods are not sold, and this leads to the fact that some manufacturers go bankrupt and lay off many workers, which further reduces wages. wages from the rest, as the labor market becomes surplus.  Which, in turn, causes even more fear among money holders to invest, and this process continues until the moment when until the value of money starts to decline due to the fact that the total number of production chains has decreased and goods have also decreased. \" Example: Let's imagine that we had inflation and the value of money fell by 40% within a month, the cost of goods increases sharply, but wages have not risen, so a lot of goods will not be bought, which leads to the closure of production chains, which, in turn, due to an excess of workers in the labor market, reduces wages, which also further reduces the number of goods sold. The first case A deflationary spiral occurs due to a sharp reduction in money in the market, the second stagflation occurs more often when a sharply excess amount of money enters the market. And these two phenomena are two sides of the same coin, in one case we get a deflationary spiral in the other stagflation.  To avoid such crises, in this cryptocurrency, money grows in the same predictable amount. 204 (4 - founder reward, 200 - earner reward) digital dollars and shares per block, about 576 blocks per day. A negative rate adjusts the value of coins every six months. It is also forbidden to use fractional reserve banking for these coins, as their number grows linearly, and will not be able to cover the debts incurred due to fractional reserve banking, due to lack of cash, since with fractional reserve banking, the increase in debt will be much higher than this protocol will create money.  Also, if you increase the money supply by changing the settings, and making the money supply increase much higher, it can cause hyperinflation or even galloping inflation. If it is necessary to increase the growth of the money supply, this should only happen through amendments, keeping the founder's remuneration percentage at two percent. And mining per block should not increase more than 5% for ten years, each subsequent increase that may be made must pass at least ten years through amendments, and no more than 5% per block from the reward of the last block. (Example: if we change through amendments, then the extraction should not be higher than 210 coins, but each following will be no more than five percent of the last. Thus, the next increase introduced by without amendment will be 220.5 coins. But this amendment will be introduced only in ten years after the first production adjustment)  With a lack of money supply, if the number of mined coins has not been changed through an amendment, you can add a few additional zeros after the decimal point, so it will simply increase the value of the coins, without increasing the total money supply.  Negative rates should not be higher than 0.5% per annum and lower than 0.2% per annum. Negative rates can only be changed through amendments.  [Exit to home](../documentationEng/documentationEng.md)","# FREEDOM_OF_SPEECH The right to free speech No body of this corporation or entity shall prohibit free practice any religion; or restrict freedom of speech, conscience or the press or the right of people to peacefully assemble or associate with one another, or not associate with one another, and apply to the management of the Corporation of the International Trade Union and to this corporation with a petition for satisfaction of complaints; + or violate the right to the fruits of one's labor or the right to a peaceful life of their choice. Freedoms of speech and conscience include the freedom to contribute to political campaigns or nominations for corporate office and shall be construed as extending equally to any means of communication.  [Exit to home](../documentationEng/documentationEng.md)","# RIGHTS Natural Rights All members of the network must respect the Natural Human Rights and not violate them. \"The presumption of innocence must also be respected and every member of the network must have the right to a fair and independent trial. Each participant has the right to a lawyer or to be his own lawyer.  The International Trade Union Corporation shall not regulate the cost of goods and services of network members that sell through this platform. Also, the Corporation should not ban individual brands on its site, but may prohibit the sale of entire groups of goods that fall within the characteristics described by applicable laws, if this prohibition does not violate Natural Human Rights. As a source of rights, you can take as a precedent Countries recognized as democratic countries.  A detailed list is at the United Nations (UN)  The right to live Right to liberty and security of person Right to privacy The right to determine and indicate one's nationality The right to use one's native language The right to freedom of movement and choice of place of stay and residence Right to freedom of conscience  Freedom of thought and speech Freedom of Information The right to form public associations The right to hold public events The right to participate in the management of the affairs of the Corporation of the International Trade Union The right to appeal to the bodies of the Corporation of the International Trade Union and local governments.   [Exit to home](../documentationEng/documentationEng.md)","#LEGISLATURE. Power consists of 4 groups in this system. 1. Board of Shareholders 2. Board of Directors 3. Fractions 4. Independent members of the network.  All participants must participate in the vote for the law adopted by the system to be valid. For all votes, only votes cast in the last four years count. All members may hold multiple positions from different groups, but may not hold more than one position in the same category. Example: One account can be both ***Member of the Network*** and ***Member of the Board of Directors*** and ***Member of the Board of Shareholders***, but one account cannot hold multiple seats on the Board of Directors or in the Board of Shareholders.  It is this part of the vote that is taken into account when electing the Board of Directors and Fractions. ![stock_vote](../screenshots/stock_vote.png) ## Board of Shareholders The Board of Shareholders is automatically appointed by the system. The Board of Shareholders consists of 1500 accounts with the largest number of shares, but only those accounts are selected that have either been mining in the last year, either sent digital dollars or digital shares, or participated in voting. A member of one Board of Shareholders has one vote. One score equals one vote. The voting system described in [ONE_VOTE](../charterEng/ONE_VOTE.md) is used  ````    //determining the board of shareholders      public static List<Account> findBoardOfShareholders(Map<String, Account> balances, List<Block> blocks, int limit) {          List<Block> minersHaveMoreStock = null;          if (blocks.size() > limit) {              minersHaveMoreStock = blocks.subList(blocks.size() - limit, blocks.size());          } else {              minersHaveMoreStock = blocks;          }          List<Account> boardAccounts = minersHaveMoreStock.stream().map(                          t -> new Account(t.getMinerAddress(), 0, 0))                  .collect(Collectors.toList());           for (Block block : minersHaveMoreStock) {              for (DtoTransaction dtoTransaction : block.getDtoTransactions()) {                  boardAccounts.add(new Account(dtoTransaction.getSender(), 0, 0));              }           } ````  ## Board of Directors The Board of Directors is elected by the members of the network. The Board of Directors consists of 301 accounts that received the most votes according to the system described in [VOTE_STOCK](../charterEng/VOTE_STOCK.md). Each score is equal to one vote, described in [ONE_VOTE](../charterEng/ONE_VOTE.md).  ````   //minimum value for the number of positive votes for the law to be valid,          //positions elected by shares of the board of directors          List<CurrentLawVotesEndBalance> electedByStockBoardOfDirectors = current.stream()                  .filter(t -> directors.isElectedByStocks(t.getPackageName()))                  .filter(t -> t.getPackageName().equals(NamePOSITION.BOARD_OF_DIRECTORS.toString()))                  .filter(t -> t.getVotes() >= Seting.ORIGINAL_LIMIT_MIN_VOTE)                  .sorted(Comparator.comparing(CurrentLawVotesEndBalance::getVotes).reversed())                  .limit(directors.getDirector(NamePOSITION.BOARD_OF_DIRECTORS.toString()).getCount())                  .collect(Collectors.toList()); ````  ### How to apply for a board position First you need to go to the tab in ***apply for a position*** Select BOARD_OF_DIRECTORS and fill in all the lines with the required data. ![apply_board_of_directors](../screenshots/apply_board_or_directors.png)  ## Fractions. The factions are elected by the members of the network. There are only 100 revenge for factions. One hundred with the most votes received by the system described in [VOTE_STOCK](../charterEng/VOTE_STOCK.md) becomes a faction. The vote of each faction is equal to the share which she received relatively 99 other factions. Each faction has a vote described in [VOTE_FRACTION](../charterEng/VOTE_FRACTION.md).  ```` //select factions          List<CurrentLawVotesEndBalance> electedFraction = current.stream()                  .filter(t -> directors.isElectedByStocks(t.getPackageName()))                  .filter(t -> t.getPackageName().equals(NamePOSITION.FRACTION.toString()))                  .filter(t -> t.getVotes() >= Seting.ORIGINAL_LIMIT_MIN_VOTE)                  .sorted(Comparator.comparing(CurrentLawVotesEndBalance::getVotes).reversed())                  .limit(directors.getDirector(NamePOSITION.FRACTION.toString()).getCount())                  .collect(Collectors.toList()); ````  ### How to create a new faction To create a faction, you need to follow the same procedure as for submitting to the board of directors. ![apply_fraction](../screenshots/apply_fraction.png)   ## Independent Network Members. All network members who have shares and are not included in the first three categories listed above, are ***independent members of the network***. The votes of each such participant are equal to to the number of shares at the moment and is described in detail in [VOTE_STOCK](../charterEng/VOTE_STOCK.md).   [Exit to home](../documentationEng/documentationEng.md)","На русском-russian","# КАК ИЗБИРАЮТСЯ ЗАКОНЫ.   ## Утверждение закона _____  ## УСТАВ Ни один закон не имеет обратной силы. Ни один закон не должен нарушать действующий устав или противоречит  другим действующим законам. Если есть противотечение между несколькими законами из одного пакета законов,  то действующим является тот который в списке находится выше по индексу. Пример: пакет по продаже алкоголя  закон под индексом 3 противоречит закону из индекса 17, в данном случае закон под индексом три будет действующим,  так как он более высокая по статусу.  В случае противоречия нескольких действующих Законов Судебная Власть должна отдавать приоритет, тем законам, которые были приняты ранее, но учитывать должны именно с последней даты принятия закона. Закон является Действующим, пока удовлетворяет условиям принятия закона и как только условие  нарушено, закон теряет свою силу, до повторного принятия закона. В голосовании всех законов, учитываются только голоса отданные за последние четыре года. Все законы делятся на несколько групп. 1. Обычные законы 2. Стратегический План 3. Бюджет 4. Назначаемые должности Законодательной властью 6. Законы, которые создают новые должности. Данные должности утверждаются только Законодательной Властью. 7. Поправки в Устав 8. Сам устав  ### ОБЫЧНЫЕ ЗАКОНЫ Чтобы утвердить обычные законы,  1. название пакета закона не должно совпадать с выделенными ключевыми словами. 2. Закон должен получить больше 1 голоса по системе подсчета описанной [VOTE_STOCK](../charter/VOTE_STOCK.md) 3. Должен получить 10 или больше голосов Совета Директоров по системе подсчета описанной в [ONE_VOTE](../charter/ONE_VOTE.md) 4. Должен получить 10 или больше голосов Совета Акционеров по системе подсчета описанной в [ONE_VOTE](../charter/ONE_VOTE.md) 5. Должен получить 10% голосов от фракций по системе подсчета описанной в [VOTE_FRACTION](../charter/VOTE_FRACTION.md).  ![утверждение обычных законов](../screenshots/law-classic.png) Пример кода в LawsController current law: ````      //законы должны быть одобрены всеми.         List<CurrentLawVotesEndBalance> notEnoughVotes = current.stream()                 .filter(t -> !directors.contains(t.getPackageName()))                 .filter(t->!Seting.AMENDMENT_TO_THE_CHARTER.equals(t.getPackageName()))                 .filter(t->!directors.isCabinets(t.getPackageName()))                 .filter(t -> !Seting.ORIGINAL_CHARTER_CURRENT_LAW_PACKAGE_NAME.equals(t.getPackageName()))                 .filter(t->!Seting.ORIGINAL_CHARTER_CURRENT_ALL_CODE.equals(t.getPackageName()))                 .filter(t -> t.getVotesBoardOfShareholders() >= Seting.ORIGINAL_LIMIT_MIN_VOTE_BOARD_OF_SHAREHOLDERS                 && t.getVotesBoardOfDirectors() >= Seting.ORIGINAL_LIMIT_MIN_VOTE_BOARD_OF_DIRECTORS                 && t.getVotes() >= Seting.ALL_STOCK_VOTE                 && t.getFractionVote() >= Seting.ORIGINAL_LIMIT_MIN_VOTE_FRACTIONS)                 .sorted(Comparator.comparing(CurrentLawVotesEndBalance::getVotes).reversed()).collect(Collectors.toList());      ````  ### СТРАТЕГИЧЕСКИЙ ПЛАН. Стратегический план является общим планом для всей сети и утверждается аналогично обычному закону, но есть некоторые отличия от обычных законов. 1. Пакет стратегического плана должен называться STRATEGIC_PLAN 2. Все планы которые прошли одобрение, сортируется от наибольшего к наименьшему по количеству голосов, полученных от Совета Директоров. 3. После Сортировки отбираются только один ПЛАН с наибольшим количеством голосов полученных от Совета Директоров.  ```` //план утверждается всеми         List<CurrentLawVotesEndBalance> planFourYears = current.stream()                 .filter(t->!directors.contains(t.getPackageName()))                 .filter(t->Seting.STRATEGIC_PLAN.equals(t.getPackageName()))                 .filter(t->!directors.isCabinets(t.getPackageName()))                 .filter(t->t.getVotesBoardOfDirectors() >= Seting.ORIGINAL_LIMIT_MIN_VOTE_BOARD_OF_DIRECTORS                         && t.getVotesBoardOfShareholders() >= Seting.ORIGINAL_LIMIT_MIN_VOTE_BOARD_OF_SHAREHOLDERS                         && t.getFractionVote() >= Seting.ORIGINAL_LIMIT_MIN_VOTE_FRACTIONS                         && t.getVotes() >= Seting.ALL_STOCK_VOTE)                 .sorted(Comparator.comparing(CurrentLawVotesEndBalance::getVotesBoardOfDirectors).reversed())                 .limit(1)                 .collect(Collectors.toList()); ````  ### БЮДЖЕТ Бюджет является общими расходами для системы и утверждается аналогично Стратегическому Плану, но название пакета Должно быть BUDGET и он тоже в единственном экземпляре.  ````  //бюджет утверждается всеми         List<CurrentLawVotesEndBalance> budjet = current.stream()                 .filter(t-> !directors.contains(t.getPackageName()))                 .filter(t->Seting.BUDGET.equals(t.getPackageName()))                 .filter(t->!directors.isCabinets(t.getPackageName()))                 .filter(t->                         t.getVotesBoardOfDirectors() >= Seting.ORIGINAL_LIMIT_MIN_VOTE_BOARD_OF_DIRECTORS                         && t.getVotesBoardOfShareholders() >= Seting.ORIGINAL_LIMIT_MIN_VOTE_BOARD_OF_SHAREHOLDERS                         && t.getFractionVote() >= Seting.ORIGINAL_LIMIT_MIN_VOTE_FRACTIONS                         && t.getVotes() >= Seting.ALL_STOCK_VOTE)                 .sorted(Comparator.comparing(CurrentLawVotesEndBalance::getVotesBoardOfDirectors).reversed())                 .limit(1)                 .collect(Collectors.toList()); ````  ### ДОЛЖНОСТИ КОТОРЫЕ НАЗНАЧАЮТСЯ ТОЛЬКО ЗАКОНОДАТЕЛЬНОЙ ВЛАСТЬЮ Есть должности которые назначаются только Законодательной властью и таким должностям относиться Генеральный Исполнительный Директор. Данная должность аналогична премьер-министру и является Исполнительной Властью в данной системе. Каждая такая должность может быть ограничена количеством, которое определено в данной системе для данной должности. Пример: Генеральный Исполнительный Директор есть только одно место. Избирается аналогично как ***стратегический план*** и ***бюджет***. Но количество определяется для каждой должности отдельно. ````   //позиции избираемые только всеми участниками         List<CurrentLawVotesEndBalance> electedByBoardOfDirectors = current.stream()                 .filter(t -> directors.isElectedByBoardOfDirectors(t.getPackageName()) || directors.isCabinets(t.getPackageName()))                 .filter(t -> t.getVotesBoardOfDirectors() >= Seting.ORIGINAL_LIMIT_MIN_VOTE_BOARD_OF_DIRECTORS                 && t.getVotesBoardOfShareholders() >= Seting.ORIGINAL_LIMIT_MIN_VOTE_BOARD_OF_SHAREHOLDERS                 && t.getFractionVote() >= Seting.ORIGINAL_LIMIT_MIN_VOTE_FRACTIONS                 && t.getVotes() >= Seting.ALL_STOCK_VOTE)                 .sorted(Comparator.comparing(CurrentLawVotesEndBalance::getVotesBoardOfDirectors).reversed())                 .collect(Collectors.toList());                                    //групируем по списку         Map<String, List<CurrentLawVotesEndBalance>> group = electedByBoardOfDirectors.stream()                 .collect(Collectors.groupingBy(CurrentLawVotesEndBalance::getPackageName));          Map<Director, List<CurrentLawVotesEndBalance>> original_group = new HashMap<>();          //оставляем то количество которое описано в данной должности         for (Map.Entry<String, List<CurrentLawVotesEndBalance>> stringListEntry : group.entrySet()) {             List<CurrentLawVotesEndBalance> temporary = stringListEntry.getValue();             temporary = temporary.stream()                     .sorted(Comparator.comparing(CurrentLawVotesEndBalance::getVotesBoardOfDirectors))                     .limit(directors.getDirector(stringListEntry.getKey()).getCount())                     .collect(Collectors.toList());             original_group.put(directors.getDirector(stringListEntry.getKey()), temporary);         } ````  Также есть должности которые создаются с помощью законов, данные должности утверждаются тоже Законодательной властью. Для каждой такой должности только одно место, для каждого названия.  Название таких пакетов начинается с ADD_DIRECTOR_. С обязательным нижним подчеркиванием.  ### ПОПРАВКИ В УСТАВ Чтобы внести поправки в устав, нужно чтобы пакет закона должен называться AMENDMENT_TO_THE_CHARTER. Для того чтобы поправка считалась действующей 1. Нужно чтобы 20% или больше голосов получила от Совета Акционеров системой подсчета [ONE_VOTE](../charter/ONE_VOTE.md). 2. Нужно, чтобы получить 20% или больше голосов от Совета Директоров системой подсчета [ONE_VOTE](../charter/ONE_VOTE.md). 3. Нужно, чтобы получить 5 или больше голосов от Законодательной Власти Корпоративных Верховных Судей. 4. Нужно, чтобы получить 10% или больше голосов от фракций системой подсчета [VOTE_FRACTION](../charter/VOTE_FRACTION.md).  ![поправки в устав](../screenshots/amendment-chapter.png) ````    //внедрение поправок в устав         List<CurrentLawVotesEndBalance> chapter_amendment = current.stream()                 .filter(t -> !directors.contains(t.getPackageName()))                 .filter(t-> Seting.AMENDMENT_TO_THE_CHARTER.equals(t.getPackageName()))                 .filter(t->!directors.isCabinets(t.getPackageName()))                 .filter(t -> t.getVotesBoardOfShareholders() >= Seting.ORIGINAL_LIMIT_MINT_VOTE_BOARD_OF_SHAREHOLDERS_AMENDMENT                 && t.getVotesBoardOfDirectors() >= Seting.ORIGINAL_LIMIT_MIN_VOTE_BOARD_OF_DIRECTORS_AMENDMENT                 && t.getVotesCorporateCouncilOfReferees() >= Seting.ORIGINAL_LIMIT_MIN_VOTE_CORPORATE_COUNCIL_OF_REFEREES_AMENDMENT                 && t.getFractionVote() >= Seting.ORIGINAL_LIMIT_MIN_VOTE_FRACTIONS)                 .sorted(Comparator.comparing(CurrentLawVotesEndBalance::getVotesBoardOfDirectors).reversed()).collect(Collectors.toList());  ````  ### САМ УСТАВ. Первый устав утверждается основателем и он является действующим, голос основателя для утверждения устава никогда не имеет срока годности. Название пакета устава начинается с CHARTER_ORIGINAL и название исходного кода CHARTER_ORIGINAL_CODE. Эти два пакета и являются целостным уставом, но в первую очередь, исходный код не должен противоречить принципам описанным в CHARTER_ORIGINAL. ```` //устав всегда действующий он подписан основателем         List<CurrentLawVotesEndBalance> CHARTER_ORIGINAL = current.stream()                 .filter(t -> !directors.contains(t.getPackageName()) && Seting.ORIGINAL_CHARTER_CURRENT_LAW_PACKAGE_NAME.equals(t.getPackageName()))                 .filter(t->!directors.isCabinets(t.getPackageName()))                 .filter(t->t.getFounderVote()>=1)                 .sorted(Comparator.comparing(CurrentLawVotesEndBalance::getVotes).reversed())                 .limit(1)                 .collect(Collectors.toList());          //ИСХОДНЫЙ КОД СОЗДАННЫЙ ОСНОВАТЕЛЕМ         List<CurrentLawVotesEndBalance> CHARTER_ORIGINAL_CODE = current.stream()                 .filter(t -> !directors.contains(t.getPackageName()) && Seting.ORIGINAL_CHARTER_CURRENT_ALL_CODE.equals(t.getPackageName()))                 .filter(t->!directors.isCabinets(t.getPackageName()))                 .filter(t->t.getFounderVote()>=1)                 .sorted(Comparator.comparing(CurrentLawVotesEndBalance::getVotes).reversed())                 .limit(1)                 .collect(Collectors.toList()); ```` [Возврат на главную](../documentation/documentationRus.md)","# VOTE_STOCK (Как с помощью акций происходит голосование.)  Как с помощью акций происходит голосование.  Все акции которым счет владеет, приравниваются такому же количеству голосов.  Каждый раз когда кто-то делает транзакцию на счет, является адресом пакета который начинается с  LIBER он голосует по данному пакету. Учитываются только те голоса, с которых не прошло больше четырех лет.  Если транзакция была совершена ***VoteEnum.YES,*** то данный счет получает голоса ***за***, формуле  yesV = количество голосов равные количеству акций отправителя. yesN = за сколько законов данный счет проголосовал с VoteEnum.YES resultYES = yesV / yesN). Пример: счет проголосовал за три счета, которые начинаются с LIBER, на счету сто акций, значит сто голосов. 100 / 3 = 33.3 значит каждый счет получит по 33.3 голоса.   Если транзакция была совершена с VoteEnum.NO,  то используется такая же формула, но учитываются теперь все счета за которые он проголосовал против  пример тот же счет проголосовал за два счёта против, у него те же сто акций.  resultNO = noV / noN = 50 = 50 значит каждый счет за который он проголосовал,  против получит 50 голосов против.  Дальше каждый счет который начитается с LIBER подсчитывает и суммирует все отданные ему голоса ***ЗА*** (VoteEnum.YES) и ***ПРОТИВ*** (VoteEnum.NO).  Потом используется данная формула remainder = resultYES - resultNO.  Именно этот результат и отображается как отданные голоса. В любой момент можно изменить свой голос, но только на противоположный, что значит если  вы проголосовали за кандидата YES то вы можете изменить только на NO и обратно.  Количество раз сколько вы можете изменить свой голос не ограничено. С каждым блоком происходит перерасчет голосов, если вы теряете свои акции, ваши кандидаты  также теряют свои голоса. Данная мера специально так реализовано чтобы избираемые должности  были заинтересованы в том чтобы те кто голосует за них, процветал и не теряли свои акции.  Таким способом избираются Только CORPORATE_COUNCIL_OF_REFEREES и BOARD_OF_DIRECTORS Учитывается только последняя транзакция отданная за каждый счет, если вы не обновляли свой голос,  то по прошествии четырех лет он аннулируется. Для Утверждения Закона нужно 100 тысяч голосов  ______  ```` //код находится в классе class CurrentLawVotes method: votesLaw  public double votesLaw(Map<String, Account> balances,      Map<String, Integer> yesAverage, Map<String, Integer> noAverage) {         double yes = 0.0;         double no = 0.0;                               for (String s : YES) {              int count = 1;           count = yesAverage.get(s) > 0 ? yesAverage.get(s) : 1;           yes += balances.get(s).getDigitalStockBalance() / count;         }                  for (String s : NO) {            int count = 1;             count = noAverage.get(s) > 0 ? noAverage.get(s) : 1;            no += balances.get(s).getDigitalStockBalance() / count);          }           return yes - no;    }   ````  [возврат на главную](../documentation/documentationRus.md)","# ONE_VOTE (Один Голос)  Когда голосуют данные должности, учитывается как один счет = один голос   (CORPORATE_COUNCIL_OF_REFEREES-Совет Корпоративных Судей,  BOARD_OF_DIRECTORS-Совет Директоров, GENERAL_EXECUTIVE_DIRECTOR-Генеральный Исполнительный Директор, HIGH_JUDGE-Верховный Судья и Совет Акционеров).  Каждый счет который начинается с LIBER, учитывает все голоса ЗА (VoteEnum.YES) и ПРОТИВ (VoteEnum.NO) за него  дальше отнимается от ЗА - ПРОТИВ = если остатков выше порога, то он становиться действующим законом. Но если избирается должности,  то после сортируется от наибольшего к наименьшим и отбираются то количество наибольших, которое описано для данной должности.  Перерасчет голосов происходит каждый блок.   После голосования голос можно поменять только на противоположный.  Ограничений на количество сколько раз можно поменять свой голос нет. Учитываются только те голоса которые даны счетами  находящимися в своей должности, к примеру если счет перестал быть в Совете Директор, его голос как в качестве  Совета Директоров не учитывается, и не будет учитываться в голосовании. Все голоса действуют, пока счета  проголосовавшие находятся в своих должностях. Учитываются также только те голоса, от которых прошло не более  четырех лет, но каждый участник, может в любой момент времени обновить свой голос.   ______  КОД class CurrentLawVotes: method voteGovernment  ```` public int voteGovernment(             Map<String, Account> balances,             List<String> governments) {        int yes = 0;         int no = 0;         List<String> addressGovernment = governments;       for (String s : YES) {             if (addressGovernment.contains(s)) {                 yes += Seting.VOTE_GOVERNMENT;            }          }         for (String s : NO) {           if (addressGovernment.contains(s)) {                 no += Seting.VOTE_GOVERNMENT;            }         }        return yes - no;    }   ````  [возврат на главную](../documentation/documentationRus.md)","# VOTE_FRACTION  Данная система голосования используется только для фракций. Сначала отбираются 100 фракций, которые стали легитимными. Дальше суммируется все голоса отданные 100 отобранным фракциям. После чего определяется доля каждой фракции от общих количество  голосов отданных за данную фракцию. Количество голосов каждой фракции приравниваются ее доли в процентах. Таким образом если фракция имеет 23% голосов от всех голосов, из 100 фракций, то ее голос приравнивается к 23%.  Дальше каждый раз когда фракция голосует за законы, которые начинаются с LIBER (VoteEnum.YES) или (VoteEnum.NO). У данного закона подсчитываются все голоса отданные ***за*** и ***против***, после чего отнимается от ***за*** - ***против***. Именно этот результат отображается в процентах.  ````  //голос фракции     public double voteFractions(Map<String, Double> fractions){         double yes = 0;         double no = 0;         double sum = fractions.entrySet().stream()                 .map(t->t.getValue())                 .collect(Collectors.toList())                 .stream().reduce(0.0, Double::sum);          for (String s : YES) {             if (fractions.containsKey(s)) {                 yes += (fractions.get(s)/sum) * Seting.HUNDRED_PERCENT;             }          }         for (String s : NO) {             if (fractions.containsKey(s)) {                 no += (fractions.get(s)/sum) * Seting.HUNDRED_PERCENT;             }          }         return yes - no;      }  ````  [Возврат на главную](../documentation/documentationRus.md)","# Механизм штрафов  Вы совершаете транзакцию, при которой, вы теряете данную сумму акций, но  и счет на который направлен штраф теряет такую сумму акций.  Действует только на цифровые доллары. ![Вести штраф](../screenshots/lead_a_fine.png) ______  ## MECHANISM_FOR_REDUCING_THE_NUMBER_OF_SHARES  МЕХАНИЗМ СНИЖЕНИЯ КОЛИЧЕСТВА АКЦИЙ. Ввод штрафов.  Каждый раз когда один счет отправляет на другой счет цифровую акцию, но использует VoteEnum.NO, счет  цифровых акций получателя снижается на то количество которое отправил отправитель акций.  Пример счет А отправил на счет Б 100 цифровых акций с VoteEnum.NO, тогда счет А и счет Б оба теряют 100  цифровых акций. Данная мера нужна чтобы был механизм снять с должности Совета акционеров и также позволяет снижать голоса  деструктивных счетов, так как количество голосов, равно количеству акций, при Избрании Совета Директоров и  при избрании CORPORATE_COUNCIL_OF_REFEREES.  Данный механизм действует только на цифровые акции и только в том случае, что отправитель совершил транзакцию с VoteEnum.NO.  [выход на главную](../documentation/documentationRus.md)","# WHO_HAS_THE_RIGHT_TO_CREATE_LAWS Кто имеет права создавать законы  String WHO_HAS_THE_RIGHT_TO_CREATE_LAWS = Кто имеет Права создавать законы. Создавать законы в криптовалюте Корпорации Международный Торговый Союз имеют права  все участники сети, которые имеют минимум пять цифровых долларов.  Для создания закона через механизм криптовалюты Корпорации Международного торгового Союза  Нужно внутри данной криптовалюты Создать объект класса Laws, где packetLawName - является названием пакета законов.  List<String> laws - является списком законов, String hashLaw - является адресом данного пакета законов и начинается с LIBER.  Чтобы Закон попал в пул законов нужно создать транзакцию где получателем являться hashLaw данного закона и вознаграждение  майнера равно пять цифровых доллара (5)  данной криптовалюты. После этого как закон попадет в блок, он окажется в пуле  законов и за него можно будет голосовать.  Количество строк в пакете законов может быть столько, сколько понадобиться и нет никаких ограничений.  [Выход на главную](../documentation/documentationRus.md)","# POWERS_OF_THE_CORPORATE_COUNCIL_OF_JUDGES  Судебная Власть.  Утверждает Верховного судью. Участвует в голосовании внедрения поправок.   Судебная власть Корпорации Международного Торгового Союза принадлежит  одному Верховному суду и таким нижестоящим судам, которые Корпорация Международный  Торговый Союз может время от времени издавать и учреждать.  Судьи как верховных, так и нижестоящих судов занимают свои должности, при хорошем поведении и  в установленные сроки получают за свои услуги вознаграждение.  Вознаграждение должно даваться с бюджета, установленными законами. Судебная власть распространяется на все дела по закону и справедливости,  в том числе инициированные членами для оспаривания незаконного расходования средств,  возникающего в соответствии с настоящем Уставом, законами Корпорации Международного Торгового Союза и договорами,  заключенными или которые будут заключены в соответствии с их авторитетом.  К спорам,  в которых Международный Торговый Союз будут стороной к разногласиям между двумя или более участников сети.  Ни один суд не должен быть тайным, но правосудие должно вершиться открыто и бесплатно, полностью и безотлагательно,  и каждый человек должен иметь правовую защиту от вреда, причиненного жизни, свободе или имуществу.  Верховный Суд CORPORATE_COUNCIL_OF_REFEREES и верховный судья HIGH_JUDGE.  ## Как избирается Корпоративный Совет Судей. Корпоративный Совет судей состоит из 55 счетов и избирается Участниками сети, с системой подсчета описанной в VOTE_STOCK, аналогично Совету Директоров и Фракциям. Отбираются 55 счетов, которые получили наибольшее количество голосов. ![голоса акциями](../screenshots/stock_vote.png) ```` //минимальное значение количество положительных голосов для того чтобы закон действовал,         //позиции избираемые акциями CORPORATE_COUNCIL_OF_REFEREES         List<CurrentLawVotesEndBalance> electedByStockCorporateCouncilOfReferees = current.stream()                 .filter(t -> directors.isElectedByStocks(t.getPackageName()))                 .filter(t -> t.getPackageName().equals(NamePOSITION.CORPORATE_COUNCIL_OF_REFEREES.toString()))                 .filter(t -> t.getVotes() >= Seting.ORIGINAL_LIMIT_MIN_VOTE)                 .sorted(Comparator.comparing(CurrentLawVotesEndBalance::getVotes).reversed())                 .limit(directors.getDirector(NamePOSITION.CORPORATE_COUNCIL_OF_REFEREES.toString()).getCount())                 .collect(Collectors.toList()); ````  Каждый счет такого судьи приравнивается одному голосу аналогично [ONE_VOTE](../charter/ONE_VOTE.md)  [Выход на главную](../documentation/documentationRus.md)","#  String HOW_THE_CHIEF_JUDGE_IS_CHOSEN КАК ИЗБИРАЕТСЯ ВЕРХОВНЫЙ СУДЬЯ HIGH_JUDGE. Верховный Судья избирается CORPORATE_COUNCIL_OF_REFEREES.  Каждый участник сети может подать на должность Верховного Судьи, создав закон, с названием  пакета который совпадает с HIGH_JUDGE  должностью, где адрес отправителя данной транзакции должен совпадать с первой строкой из списка законов данного пакета.  Стоимость закона пять цифровых долларов в качестве вознаграждения добытчику.   Счет с наибольшим количеством голосов остатка получает данную должность.  Механизм голосования описан [ONE_VOTE](../charter/ONE_VOTE.md).  Избирает Верховного Судью, Корпоративный Совет Судей. (CORPORATE_COUNCIL_OF_REFEREES)  Пример кода как утверждается верховный судья. Class LawsController: method currentLaw. Участок кода   ````       //позиции избираемые советом корпоративных верховных судей       List<CurrentLawVotesEndBalance> electedByCorporateCouncilOfReferees = current.stream()                .filter(t -> directors.isElectedBYCorporateCouncilOfReferees(t.getPackageName()))                .filter(t -> t.getVotesCorporateCouncilOfReferees() >= Seting.ORIGINAL_LIMIT_MIN_VOTE_CORPORATE_COUNCIL_OF_REFEREES)                .sorted(Comparator.comparing(CurrentLawVotesEndBalance::getVotesCorporateCouncilOfReferees)).collect(Collectors.toList());  ````  ## Полномочия верховного судьи Верховный судья может участвовать в решении споров внутри членов сети, как и CORPORATE_COUNCIL_OF_REFEREES, но его голос выше чем голос CORPORATE_COUNCIL_OF_REFEREES.  [Выход на главную](../documentation/documentationRus.md)","# PROPERTY_OF_THE_CORPORATION СОБСТВЕННОСТЬ КОРПОРАЦИИ. Вся собственность которая принадлежит Корпорации Международного Торгового Союза, не может быть продана без действующего закона,  где будет описан процесс продажи и по какой стоимости будет продана собственность. Счет основателя, и счета других участников не является  счетом корпорации, Совет Директоров должен создать отдельный счет который будет бюджетом и управляться только членами действующих членов Совета Директоров.  [Выход на главную](../documentation/documentationRus.md)","# GENERAL_EXECUTIVE_DIRECTOR Генеральный Исполнительный Директор Данный Директор координирует действия остальных высших директоров для реализации стратегического плана или  поставленных перед ним задач действующими законами.  Все полномочия должны быть ему выданы через действующие законы.  Это самая высокая должность избираемая Корпорацией и является по своей сути аналогом премьер-министра.  ## Как избирается Генеральный Исполнительный Директор Данный директор избирается Законодательной властью 1. Совет Директоров должен дать больше 10 или больше голосов методом [ONE_VOTE](../charter/ONE_VOTE.md) 2. Совет Акционеров должен дать больше 10 или больше голосов методом [ONE_VOTE](../charter/ONE_VOTE.md) 3. Фракции должны дать 10% или больше голосов методом [VOTE_FRACTION](../charter/VOTE_FRACTION.md) 4. Участники сети должны дать больше одного голоса методом [VOTE_STOCK](../charter/VOTE_STOCK.md) 5. Дальше происходит сортировка от наибольшего к наименьшему полученых голосов от Совета Директоров и 6. Отбирается один счет с наибольшим количеством голосов от Совета Директоров  ````  //позиции избираемые только всеми участниками         List<CurrentLawVotesEndBalance> electedByBoardOfDirectors = current.stream()                 .filter(t -> directors.isElectedByBoardOfDirectors(t.getPackageName()) || directors.isCabinets(t.getPackageName()))                 .filter(t -> t.getVotesBoardOfDirectors() >= Seting.ORIGINAL_LIMIT_MIN_VOTE_BOARD_OF_DIRECTORS                 && t.getVotesBoardOfShareholders() >= Seting.ORIGINAL_LIMIT_MIN_VOTE_BOARD_OF_SHAREHOLDERS                 && t.getFractionVote() >= Seting.ORIGINAL_LIMIT_MIN_VOTE_FRACTIONS                 && t.getVotes() >= Seting.ALL_STOCK_VOTE)                 .sorted(Comparator.comparing(CurrentLawVotesEndBalance::getVotesBoardOfDirectors).reversed())                 .collect(Collectors.toList());                                   //групируем по списку         Map<String, List<CurrentLawVotesEndBalance>> group = electedByBoardOfDirectors.stream()                 .collect(Collectors.groupingBy(CurrentLawVotesEndBalance::getPackageName));          Map<Director, List<CurrentLawVotesEndBalance>> original_group = new HashMap<>();          //оставляем то количество которое описано в данной должности         for (Map.Entry<String, List<CurrentLawVotesEndBalance>> stringListEntry : group.entrySet()) {             List<CurrentLawVotesEndBalance> temporary = stringListEntry.getValue();             temporary = temporary.stream()                     .sorted(Comparator.comparing(CurrentLawVotesEndBalance::getVotesBoardOfDirectors))                     .limit(directors.getDirector(stringListEntry.getKey()).getCount())                     .collect(Collectors.toList());             original_group.put(directors.getDirector(stringListEntry.getKey()), temporary);         }  ````  ````  public static List<CurrentLawVotesEndBalance> filtersVotes(             List<LawEligibleForParliamentaryApproval> approvalList,             Map<String, Account> balances,             List<Account> BoardOfShareholders,             List<Block> blocks,             int limitBlocks     ) throws IOException, NoSuchAlgorithmException, SignatureException, InvalidKeySpecException, NoSuchProviderException, InvalidKeyException {         //действующие законы чьи голоса больше ORIGINAL_LIMIT_MIN_VOTE         List<CurrentLawVotesEndBalance> current = new ArrayList<>();         Map<String, CurrentLawVotes> votesMap = null;         List<Account> accounts = balances.entrySet().stream().map(t -> t.getValue()).collect(Collectors.toList());         if (blocks.size() > limitBlocks) {             votesMap = UtilsCurrentLaw.calculateVotes(accounts, blocks.subList(blocks.size() - limitBlocks, blocks.size()));         } else {             votesMap = UtilsCurrentLaw.calculateVotes(accounts, blocks);         }          //подсчитать средннее количество раз сколько он проголосовал за         Map<String, Integer> yesAverage = UtilsCurrentLaw.calculateAverageVotesYes(votesMap);         //подсчитать среднее количество раз сколько он проголосовал против         Map<String, Integer> noAverage = UtilsCurrentLaw.calculateAverageVotesNo(votesMap);           //подсчитываем голоса для для обычных законов и законов позиций         for (LawEligibleForParliamentaryApproval lawEligibleForParliamentaryApproval : approvalList) {             if (votesMap.containsKey(lawEligibleForParliamentaryApproval.getLaws().getHashLaw())) {                 String address = lawEligibleForParliamentaryApproval.getLaws().getHashLaw();                 String packageName = lawEligibleForParliamentaryApproval.getLaws().getPacketLawName();                 List<String> laws = lawEligibleForParliamentaryApproval.getLaws().getLaws();                 double vote = 0;                 int supremeVotes = 0;                 int boafdOfShareholderVotes = 0;                 int houseOfRepresentativiesVotes = 0;                 int primeMinisterVotes = 0;                 int hightJudgesVotes = 0;                 int founderVote = 0;                 double fraction = 0;                  //для законов подсчитываем специальные голоса                 vote = votesMap.get(lawEligibleForParliamentaryApproval.getLaws().getHashLaw()).votesLaw(balances, yesAverage, noAverage);                 List<String> boardOfShareholdersAddress = BoardOfShareholders.stream().map(t -> t.getAccount()).collect(Collectors.toList());                 boafdOfShareholderVotes = votesMap.get(lawEligibleForParliamentaryApproval.getLaws().getHashLaw()).voteGovernment(balances, boardOfShareholdersAddress);                  List<String> founder = List.of(Seting.ADDRESS_FOUNDER);                 founderVote = votesMap.get(lawEligibleForParliamentaryApproval.getLaws().getHashLaw()).voteGovernment(balances, founder);                 CurrentLawVotesEndBalance currentLawVotesEndBalance = new CurrentLawVotesEndBalance(                         address,                         packageName,                         vote,                         supremeVotes,                         houseOfRepresentativiesVotes,                         boafdOfShareholderVotes,                         primeMinisterVotes,                         hightJudgesVotes,                         founderVote,                         fraction,                         laws);                 current.add(currentLawVotesEndBalance);              }         }          List<String> houseOfRepresentativies = new ArrayList<>();         List<String> chamberOfSumpremeJudges = new ArrayList<>();         Map<String, Double> fractions = new HashMap<>();          for (CurrentLawVotesEndBalance currentLawVotesEndBalance: current) {             if(currentLawVotesEndBalance.getPackageName().equals(NamePOSITION.BOARD_OF_DIRECTORS.toString())){                 if(currentLawVotesEndBalance.getVotes() >= Seting.ORIGINAL_LIMIT_MIN_VOTE){                     houseOfRepresentativies.add(currentLawVotesEndBalance.getLaws().get(0));                 }              }             if(currentLawVotesEndBalance.getPackageName().equals(NamePOSITION.CORPORATE_COUNCIL_OF_REFEREES.toString())){                 if(currentLawVotesEndBalance.getVotes() >= Seting.ORIGINAL_LIMIT_MIN_VOTE){                     chamberOfSumpremeJudges.add(currentLawVotesEndBalance.getLaws().get(0));                 }              }               if(currentLawVotesEndBalance.getPackageName().equals(NamePOSITION.FRACTION.toString())){                 if(currentLawVotesEndBalance.getVotes() >= Seting.ORIGINAL_LIMIT_MIN_VOTE){                     fractions.put(currentLawVotesEndBalance.getLaws().get(0), currentLawVotesEndBalance.getVotes());                 }             }          }            for (CurrentLawVotesEndBalance currentLawVotesEndBalance : current) {             if(votesMap.containsKey(currentLawVotesEndBalance.getAddressLaw())){                   double vote = votesMap.get(currentLawVotesEndBalance.getAddressLaw()).votesLaw(balances, yesAverage, noAverage);                 int supremeVotes  = votesMap.get(currentLawVotesEndBalance.getAddressLaw()).voteGovernment(balances, chamberOfSumpremeJudges);                 int houseOfRepresentativiesVotes = votesMap.get(currentLawVotesEndBalance.getAddressLaw()).voteGovernment(balances, houseOfRepresentativies);                 double fractionsVotes = votesMap.get(currentLawVotesEndBalance.getAddressLaw()).voteFractions(fractions);                  currentLawVotesEndBalance.setVotes(vote);                 currentLawVotesEndBalance.setVotesBoardOfDirectors(houseOfRepresentativiesVotes);                 currentLawVotesEndBalance.setVotesCorporateCouncilOfReferees(supremeVotes);                 currentLawVotesEndBalance.setFractionVote(fractionsVotes);             }          }          //изирается Генеральный исполнительный директор         List<String> primeMinister = new ArrayList<>();         List<String> hightJudge = new ArrayList<>();         for (CurrentLawVotesEndBalance currentLawVotesEndBalance : current) {             if(currentLawVotesEndBalance.getPackageName().equals(NamePOSITION.GENERAL_EXECUTIVE_DIRECTOR.toString())){                 if(currentLawVotesEndBalance.getVotesBoardOfDirectors() >= Seting.ORIGINAL_LIMIT_MIN_VOTE_BOARD_OF_DIRECTORS                 && currentLawVotesEndBalance.getFractionVote() >= Seting.ORIGINAL_LIMIT_MIN_VOTE_FRACTIONS                 && currentLawVotesEndBalance.getVotesBoardOfShareholders() >= Seting.ORIGINAL_LIMIT_MIN_VOTE_BOARD_OF_SHAREHOLDERS                 && currentLawVotesEndBalance.getVotes() >= Seting.ALL_STOCK_VOTE){                     primeMinister.add(currentLawVotesEndBalance.getLaws().get(0));                 }             }              if(currentLawVotesEndBalance.getPackageName().equals(NamePOSITION.HIGH_JUDGE.toString())){                 if(currentLawVotesEndBalance.getVotesCorporateCouncilOfReferees() >= Seting.ORIGINAL_LIMIT_MIN_VOTE_CORPORATE_COUNCIL_OF_REFEREES){                     hightJudge.add(currentLawVotesEndBalance.getLaws().get(0));                 }             }         }         for (CurrentLawVotesEndBalance currentLawVotesEndBalance : current) {             if(votesMap.containsKey(currentLawVotesEndBalance.getAddressLaw())){                 int primeMinisterVotes = votesMap.get(currentLawVotesEndBalance.getAddressLaw()).voteGovernment(balances, primeMinister);                 int hightJudgeVotes = votesMap.get(currentLawVotesEndBalance.getAddressLaw()).voteGovernment(balances, hightJudge);                  currentLawVotesEndBalance.setVoteGeneralExecutiveDirector(primeMinisterVotes);                 currentLawVotesEndBalance.setVoteHightJudge(hightJudgeVotes);             }          }           return current;      }  ````  [Выход на главную](../documentation/documentationRus.md)","# ОБЯСНЕНИЕ ПОЧЕМУ ЗДЕСЬ ИСПОЛЬЗУЕТСЯ  ДЕМЕРЕДЖ ДЕНЕГ Отрицательная ставка сейчас применяется во множестве стран, данная мера стимулирует держателей денег, когда цена чрезмерно завышена,  насыщать рынок деньгами.  Количество добываемых денег за каждый блок составляет 200 цифровых долларов и 200 цифровых акций,  также 2% от каждой добычи вознаграждение основателю, что составляет 4 цифровых доллара и 4 цифровых Акций при каждой добыче блока.  Здесь используется как Теории Сильвио Гезеля, а также школы монетаризма в измененном виде.  У Сильвио Гезеля, отрицательная ставка составляла 1% в месяц, что просто убило бы экономику, при монетаризме рост, денежной массы должен был быть пропорционален росту ВВП, но так как в данной системе не получиться посчитать реальный рост ВВП, я установил фиксированный рост, также если денежный рост  будет равен ВВП, есть высокая вероятность Гиперинфляции, так как ВВП не всегда отражает реальный экономический рост.  Деньги должны быть твердые, чтобы бизнес мог прогнозировать свои долгосрочные вложения и от монетаризма, взята только та часть что  денежная масса должна расти линейно, но в целом здесь микс из разных экономических школ, включая Австрийскую экономическую школу.   При отрицательной ставке 0.1% каждые пол года для цифровых долларов и 0.2% для цифровых акций мы избегаем последствий тяжелого экономического кризиса для данной валюты.   Такой механизм создает коридор цен, где нижняя граница стоимости данных цифровых валют является общее количество выпущенных цифровых  долларов и цифровых акций, а верхняя граница является реальная стоимость. Так как только стоимость становиться выше реальной стоимости,  держателям выгодней становиться продавать цифровые доллары и цифровые акции, по завышенным ценам, тем самым насыщая рынок деньгами  и создавая коррекцию на рынке.   Основным источником монетарных кризисов, является быстрыми изменениями цен на товары и медленным изменением заработных плат.  Пример: Представим что стоимость валюты резко подорожало на 30%, держателям выгодней становиться не инвестировать деньги, так как  доходы от удерживания валюты, выше чем теперь уже оплачивать более дорогих сотрудников, из-за того деньги перестают  инвестироваться. Люди не дополучают заработные платы, что приводит к тому, что огромное количество товаров не реализуется,  и это приводит к тому, часть производителей банкротится и увольняют множество рабочих, что еще больше снижает заработную  плату у оставшихся, так как становиться профицитный рынок труда.   Что в свою очередь еще больше вызывает страх у держателей денег инвестировать и данный процесс продолжается до того момента,  пока стоимость денег не начинает сокращаться в связи с тем что общее количество производственных цепочек сократилось и также сократились товары.              \" Пример: Представим что у нас произошла инфляция и стоимость денег упала на 40% в течение месяца, стоимость товаров резко возрастает,  но заработные платы не выросли, таким образом множество товаров не будут куплены, что приводит к закрытию производственных цепочек,  что в свою очередь из-за избытка рабочих на рынке труда, снижает заработную плату, что также в свою очередь еще больше сокращает  количество проданных товаров. Первый случай Дефляционная спираль возникает из-за резкого сокращения денег на рынке, второй  случай стагфляция чаще возникает когда на рынок поступает резко избыточное количество денег.  И это оба явления две стороны одной медали, в одном случае мы получаем дефляционную спираль в другом стагфляцию.              Чтобы не возникали такие кризисы, в данной криптовалюте деньги прирастают в одинаковом предсказуемом количестве.  204 (4 - вознаграждение основателю, 200 - вознаграждение добытчику)  цифровых долларов и акций за блок, в сутках около 576 блоков. А отрицательная ставка корректирует стоимость монет каждые пол года.  Также запрещено использовать частичное банковское резервирование для данных монет, так как их количество растет линейно, и  не сможет покрыть долги возникшие из-за частичного банковского резервирования, в связи отсутствия с недостатком  наличности, так как при частичном банковском резервировании рост долгов будет намного выше, чем данный протокол будет создавать денег.   Также если увеличить денежную массу изменив настройки, и сделав прирост денежной массы значительно выше, может вызвать гиперинфляцию или  даже галопирующую инфляцию. Если нужно будет увеличить прирост денежной массы это должно происходить только через внесения поправок,  сохраняя процент вознаграждения основателя в двух процентах. И добыча за блок не должна увеличиваться больше 5% в течение  десяти лет, каждое следующее увеличение которое может вноситься должно проходить не менее десяти лет через поправки,  и не более 5% за блок от вознаграждения последнего блока. (Пример: если мы изменили  через поправки, то добыча не должна быть выше 210 монет, но каждые следующие будет не больше пяти процентов от последнего.  Таким образом следующее увеличение внесенное через поправки составит 220.5 монет. Но Эту поправку внесут только через десять лет после первой поправки по изменению добычи)   При недостатке денежной массы, если не было изменено количество добываемых монет через поправку, можно добавить несколько  дополнительных нулей после запятой, таким образом это просто увеличит ценность монет, без увелечения общей выпущенной денежной массы.  Отрицательные ставки не должны быть выше 0.5% годовых и ниже 0.2% годовых. Отрицательные ставки можно изменять только через внесения поправок.   [Выход на главную](../documentation/documentationRus.md)","# FREEDOM_OF_SPEECH Право свободы слова  Ни один орган данной корпорации или субъект не должен запрещать свободное исповедание  какой-либо религии; или ограничивать свободу слова, совести или печати или право людей мирно собираться или объединяться друг с другом, или не объединяться друг с другом, и  обращаться к руководству Корпорации Международного Торгового Союза и к данной корпорации с ходатайством об удовлетворении жалоб; \" + или нарушать право на плоды своего труда или  право на мирную жизнь по своему выбору.  Свободы слова и совести включают свободу вносить вклад в  политические кампании или кандидатуры на корпоративные должности и должны толковаться как  распространяющиеся в равной степени на любые средства коммуникации.  [Выход на главную](../documentation/documentationRus.md)","# RIGHTS Естественные Права Все члены сети, должны соблюдать Естественные Права Человека и не нарушать их.  \"Также должно соблюдаться презумпция невиновности и каждый участник сети должен иметь права на честное независимое  судебное разбирательство.  Каждый участник имеет права на адвоката или быть самому себе адвокатом.   Корпорация Международный Торговый Союз не должна регулировать стоимость товаров и услуг участников сети, которые  продают через данную платформу.  Также Корпорация не должна запрещать отдельные бренды на своей площадке, но может  запрещать продавать целые группы товаров, которые попадают по характеристикам описанных действующими законами, если  этот запрет не нарушает Естественные Права Человека. В качестве источника прав можно брать  в качестве прецедента Страны признанные демократическими странами.    Детальный список есть в Организации Объединенных Наций (ООН)  Право на жизнь Право на свободу и личную неприкосновенность Право на неприкосновенность частной жизни Право определять и указывать свою национальную принадлежность Право на пользование родным языком Право на свободу передвижения и выбора места пребывания и жительства Право на свободу совести  Свобода мысли и слова Свобода информации Право на создание общественных объединений Право на проведение публичных мероприятий Право на участие в управлении делами Корпорации Международного Торгового Союза Право на обращение в органы Корпорации Международного Торгового Союза и органы местного самоуправления.   [Выход на главную](../documentation/documentationRus.md)","#ЗАКОНОДАТЕЛЬНАЯ ВЛАСТЬ. Власть состоит из 4 групп в данной системе. 1. Совет Акционеров 2. Совет Директоров 3. Фракции  4. Независимые участники сети.  Все участники должны участвовать в голосовании чтобы был действителен закон принятый системой. Для всех голосов учитываются только голоса отданные за последние четыре года. Все участники могут занимать несколько должностей из разных групп, но не могут занимать в одной категории должностей несколько мест. Пример: Один счет может быть как ***Независимым участником сети*** и ***Членом Совета Директоров*** и ***Членом Совета Акционеров***, но один счет не сможет занять несколько мест в Совете Директоров или в Совете Акционеров.  Именно данная часть голоса учитывается при избрании Совета Директоров и Фракций. ![stock_vote](../screenshots/stock_vote.png) ## Совет Акционеров Совет Акционеров назначается системой автоматически. Совет Акционеров состоит из 1500 счетов с наибольшим количеством акций, но отбираются только те счета, которые за последний год либо занимались добычей, либо отправляли цифровые доллары или цифровые акции, или участвовали в голосовании. Член одного Совета акционеров имеет один голос. Один счет равен одному голосу.  Используется система голосования описанная в [ONE_VOTE](../charter/ONE_VOTE.md)  ````   //определение совета акционеров     public static List<Account> findBoardOfShareholders(Map<String, Account> balances, List<Block> blocks, int limit) {         List<Block> minersHaveMoreStock = null;         if (blocks.size() > limit) {             minersHaveMoreStock = blocks.subList(blocks.size() - limit, blocks.size());         } else {             minersHaveMoreStock = blocks;         }         List<Account> boardAccounts = minersHaveMoreStock.stream().map(                         t -> new Account(t.getMinerAddress(), 0, 0))                 .collect(Collectors.toList());          for (Block block : minersHaveMoreStock) {             for (DtoTransaction dtoTransaction : block.getDtoTransactions()) {                 boardAccounts.add(new Account(dtoTransaction.getSender(), 0, 0));             }          } ````  ## Совет Директоров  Совет директоров избирается участниками сети. Совет Директоров состоит из 301 счетов которые получили наибольшее количество голосов по системе описанной в [VOTE_STOCK](../charter/VOTE_STOCK.md). Каждый счет приравнивается одному голосу, описанному в [ONE_VOTE](../charter/ONE_VOTE.md).  ````  //минимальное значение количество положительных голосов для того чтобы закон действовал,         //позиции избираемые акциями совета директоров         List<CurrentLawVotesEndBalance> electedByStockBoardOfDirectors = current.stream()                 .filter(t -> directors.isElectedByStocks(t.getPackageName()))                 .filter(t -> t.getPackageName().equals(NamePOSITION.BOARD_OF_DIRECTORS.toString()))                 .filter(t -> t.getVotes() >= Seting.ORIGINAL_LIMIT_MIN_VOTE)                 .sorted(Comparator.comparing(CurrentLawVotesEndBalance::getVotes).reversed())                 .limit(directors.getDirector(NamePOSITION.BOARD_OF_DIRECTORS.toString()).getCount())                 .collect(Collectors.toList()); ````  ### Как подать на должность совета директоров Сначала нужно зайти во вкладку в ***apply for a position*** Выбрать BOARD_OF_DIRECTORS и заполнить все строки нужными данными. ![apply_board_of_directors](../screenshots/apply_board_or_directors.png)  ## Фракции. Фракции избираются участниками сети.  Есть только 100 месть для фракций. Сто с наибольшим количеством голосов полученных по системе описанной в [VOTE_STOCK](../charter/VOTE_STOCK.md) становиться фракцией. Голос каждой фракции приравнивается доли которую она получила относительно 99 других фракций. Каждая фракция имеет голос описанный в [VOTE_FRACTION](../charter/VOTE_FRACTION.md).  ```` //избранные фракции         List<CurrentLawVotesEndBalance> electedFraction = current.stream()                 .filter(t -> directors.isElectedByStocks(t.getPackageName()))                 .filter(t -> t.getPackageName().equals(NamePOSITION.FRACTION.toString()))                 .filter(t -> t.getVotes() >= Seting.ORIGINAL_LIMIT_MIN_VOTE)                 .sorted(Comparator.comparing(CurrentLawVotesEndBalance::getVotes).reversed())                 .limit(directors.getDirector(NamePOSITION.FRACTION.toString()).getCount())                 .collect(Collectors.toList()); ````  ### Как создать новую фракцию Для создания фракции нужно проделать ту же процедуру действий, что и для подачи на совет директоров. ![apply_fraction](../screenshots/apply_fraction.png)   ##  Независимые Участники сети. Все участники сети которые имеют акции и не входят в первые три выше перечисленные категории, являются ***независимыми участниками сети***. Голоса каждого такого участника приравнивается к количеству акций на данный момент и детально описано в [VOTE_STOCK](../charter/VOTE_STOCK.md).   [Выход на главную](../documentation/documentationRus.md)","","","","","","","","","","",""],"hashLaw":"LIBER520a7cedd27ecc7e8d23e590acc93637e26936f4702e02feca622f5d5f0b8006"},"bonusForMiner":5.0,"voteEnum":"YES","sign":"MEUCIGb5VUCCwtc0DlhwlDtOYE0LvBaoidT8CiQ+LMNHS6rQAiEA7TzmLPx7X6YzmfDtmjKLENEcv8nTtX60rTwua+KxSws="}
{"sender":"stExZb8ifLfnFoq4JJuTifpAcscegATH8znhwW26zyTa","customer":"LIBERc64d89a86abe0627ed5d0210c417e80a848eee1f1a958299fe8cc4ebf6201030","digitalDollar":0.0,"digitalStockBalance":0.0,"laws":{"packetLawName":"ORIGINAL_CHARTER_CURRENT_ALL_CODE","laws":["package International_Trade_Union.config;   import International_Trade_Union.entity.blockchain.Blockchain; import International_Trade_Union.setings.Seting;  import java.io.IOException; import java.security.InvalidKeyException; import java.security.NoSuchAlgorithmException; import java.security.NoSuchProviderException; import java.security.SignatureException; import java.security.spec.InvalidKeySpecException;  public class BLockchainFactory {      public static Blockchain getBlockchain(BlockchainFactoryEnum factoryEnum) throws NoSuchAlgorithmException, InvalidKeySpecException, IOException, SignatureException, NoSuchProviderException, InvalidKeyException {         switch (factoryEnum){             case TEST:                 return new Blockchain(                         Seting.BLOCK_GENERATION_INTERVAL_TEST,                         Seting.DIFFICULTY_ADJUSTMENT_INTERVAL_TEST,                         Seting.INTERVAL_TARGET_TEST,                         Seting.ADDRESS_FOUNDER_TEST);              case ORIGINAL:                 return new Blockchain(                         Seting.BLOCK_GENERATION_INTERVAL,                         Seting.DIFFICULTY_ADJUSTMENT_INTERVAL,                         Seting.INTERVAL_TARGET,                         Seting.ADDRESS_FOUNDER                 );             default: return null;         }     } }","package International_Trade_Union.config;  public enum BlockchainFactoryEnum {     TEST,     ORIGINAL }","package International_Trade_Union.controllers;  import International_Trade_Union.entity.AddressUrl; import International_Trade_Union.entity.SubBlockchainEntity; import org.json.JSONException;  import org.springframework.http.MediaType; import International_Trade_Union.entity.DtoTransaction.DtoTransaction; import International_Trade_Union.entity.blockchain.Blockchain; import International_Trade_Union.entity.blockchain.block.Block; import International_Trade_Union.config.BLockchainFactory; import International_Trade_Union.config.BlockchainFactoryEnum; import International_Trade_Union.entity.EntityChain; import International_Trade_Union.model.Account; import International_Trade_Union.model.Mining; import International_Trade_Union.model.User; import International_Trade_Union.network.AllTransactions; import International_Trade_Union.setings.Seting; import International_Trade_Union.utils.*; import International_Trade_Union.vote.*; import org.springframework.http.HttpStatus; import org.springframework.http.ResponseEntity; import org.springframework.stereotype.Controller; import org.springframework.ui.Model; import org.springframework.util.Assert; import org.springframework.web.bind.annotation.*; import org.springframework.web.context.request.RequestAttributes; import org.springframework.web.context.request.RequestContextHolder; import org.springframework.web.context.request.ServletRequestAttributes;  import javax.servlet.http.HttpServletRequest; import java.io.IOException;  import java.security.*; import java.security.spec.InvalidKeySpecException;  import java.util.*; import java.util.stream.Collectors;  @Controller public class BasisController {     private static Blockchain blockchain;      private static Set<String> excludedAddresses = new HashSet<>();      public static HttpServletRequest getCurrentRequest() {         RequestAttributes requestAttributes = RequestContextHolder.getRequestAttributes();         if(requestAttributes == null)             return null;         Assert.state(requestAttributes != null, \"Could not find current request via RequestContextHolder\");         Assert.isInstanceOf(ServletRequestAttributes.class, requestAttributes);         HttpServletRequest servletRequest = ((ServletRequestAttributes) requestAttributes).getRequest();         Assert.state(servletRequest != null, \"Could not find current HttpServletRequest\");         return servletRequest;     }       public static Set<String> getExcludedAddresses() {         HttpServletRequest request = getCurrentRequest();         if(request == null)             return excludedAddresses;          String scheme = request.getScheme();         String serverName = request.getServerName();         int serverPort = request.getServerPort();         String contextPath = request.getContextPath();  // includes leading forward slash          String localaddress = scheme + \"://\" + serverName + \":\" + serverPort;          excludedAddresses.add(localaddress);         return excludedAddresses;     }      public static void setExcludedAddresses(Set<String> excludedAddresses) {         BasisController.excludedAddresses = excludedAddresses;     }      private static Set<String> nodes = new HashSet<>(); //    private static Nodes nodes = new Nodes();       public static void setNodes(Set<String> nodes) {         BasisController.nodes = nodes;     }      /**Возвращает список хостов*/     public static Set<String> getNodes() throws IOException, NoSuchAlgorithmException, InvalidKeySpecException, SignatureException, NoSuchProviderException, InvalidKeyException {          nodes = new HashSet<>();          Set<String> temporary = UtilsAllAddresses.readLineObject(Seting.ORIGINAL_POOL_URL_ADDRESS_FILE);           nodes.addAll(temporary);           nodes = nodes.stream()                 .filter(t -> !t.isBlank())                 .filter(t -> t.startsWith(\"\\\"\"))                 .collect(Collectors.toSet());         nodes = nodes.stream().map(t -> t.replaceAll(\"\\\"\", \"\")).collect(Collectors.toSet());         nodes.addAll(Seting.ORIGINAL_ADDRESSES);         return nodes;     }       /**Возвращяет действующий блокчейн*/     public static Blockchain getBlockchain() {         return blockchain;     }      public static synchronized void setBlockchain(Blockchain blockchain) {         BasisController.blockchain = blockchain;     }       static {         try {             blockchain = BLockchainFactory.getBlockchain(BlockchainFactoryEnum.ORIGINAL);         } catch (NoSuchAlgorithmException e) {             throw new RuntimeException(e);         } catch (InvalidKeySpecException e) {             throw new RuntimeException(e);         } catch (IOException e) {             throw new RuntimeException(e);         } catch (SignatureException e) {             throw new RuntimeException(e);         } catch (NoSuchProviderException e) {             throw new RuntimeException(e);         } catch (InvalidKeyException e) {             throw new RuntimeException(e);         }     }       public BasisController() {     }      //TODO если вы прервали mine, то перед следующим вызовом перезапустите сервер и вызовите /addBlock перед mine     //TODO if you interrupted mine, restart the server before next call and call /addBlock before mine     //TODO иначе будет расождение в файле балансов     //TODO otherwise there will be a discrepancy in the balance file        /**Стартует добычу, начинает майнинг*/     @GetMapping(\"/mine\")     public synchronized String mine(Model model) throws NoSuchAlgorithmException, InvalidKeySpecException, IOException, SignatureException, NoSuchProviderException, InvalidKeyException, JSONException, CloneNotSupportedException {         String text = \"\";         //нахождение адрессов         findAddresses();         sendAddress();          //собирает класс список балансов из файла расположенного по пути Seting.ORIGINAL_BALANCE_FILE         Map<String, Account> balances = SaveBalances.readLineObject(Seting.ORIGINAL_BALANCE_FILE);         //собирает объект блокчейн из файла         blockchain = Mining.getBlockchain(                 Seting.ORIGINAL_BLOCKCHAIN_FILE,                 BlockchainFactoryEnum.ORIGINAL);          //если блокчейн работает то продолжить         if (!blockchain.validatedBlockchain()) {             text = \"wrong chain: неправильный блокчейн, добыча прекращена\";             model.addAttribute(\"text\", text);             return \"wrong blockchain\";         }          //Прежде чем добыть новый блок сначала в сети ищет самый длинный блокчейн         resolve_conflicts();          //если размер блокчейна меньше или равно единице, сохранить в файл генезис блок         long index = blockchain.sizeBlockhain();         if (blockchain.sizeBlockhain() <= 1) {             //сохранение генезис блока             if (blockchain.sizeBlockhain() == 1) {                 UtilsBlock.saveBLock(blockchain.getBlock(0), Seting.ORIGINAL_BLOCKCHAIN_FILE);             }              //получить список балансов из файла             balances = Mining.getBalances(Seting.ORIGINAL_BALANCE_FILE, blockchain, balances);             //удалить старые файлы баланса             Mining.deleteFiles(Seting.ORIGINAL_BALANCE_FILE);             //сохранить балансы             SaveBalances.saveBalances(balances, Seting.ORIGINAL_BALANCE_FILE);          }         //скачать список балансов из файла         balances = SaveBalances.readLineObject(Seting.ORIGINAL_BALANCE_FILE);          //получить счет майнера         Account miner = balances.get(User.getUserAddress());         if (miner == null) {             //если в блокчейне не было баланса, то баланс равен нулю             miner = new Account(User.getUserAddress(), 0, 0);         }          //транзакции которые мы добавили в блок и теперь нужно удалить из файла, в папке resources/transactions         List<DtoTransaction> temporaryDtoList = AllTransactions.getInstance();          //раз в три для очищяет файлы в папке resources/sendedTransaction данная папка         //хранит уже добавленые в блокчейн транзации, чтобы повторно не добавлять в         //в блок уже добавленные транзакции         AllTransactions.clearAllSendedTransaction(index);         AllTransactions.clearUsedTransaction(AllTransactions.getInsanceSended());         System.out.println(\"BasisController: start mine:\");          //Сам процесс Майнинга         //DIFFICULTY_ADJUSTMENT_INTERVAL как часто происходит коррекция         //BLOCK_GENERATION_INTERVAL как часто должен находить блок         //temporaryDtoList добавляет транзакции в блок         Block block = Mining.miningDay(                 miner,                 blockchain,                 Seting.BLOCK_GENERATION_INTERVAL,                 Seting.DIFFICULTY_ADJUSTMENT_INTERVAL,                 temporaryDtoList,                 balances,                 index         );         System.out.println(\"BasisController: finish mine:\");         //save sended transaction         //сохранить уже добавленные в блок транзакции,         //чтобы избежать повторного добавления         AllTransactions.addSendedTransaction(temporaryDtoList);          //нужна для корректировки сложности         int diff = Seting.DIFFICULTY_ADJUSTMENT_INTERVAL;         //Тестирование блока         List<Block> testingValidationsBlock = null;          if (blockchain.sizeBlockhain() > diff) {              testingValidationsBlock = blockchain.subBlock(blockchain.sizeBlockhain() - diff, blockchain.sizeBlockhain());         } else {             testingValidationsBlock = blockchain.clone();         }         //проверяет последние 288 блоков на валидность.         if (testingValidationsBlock.size() > 1) {             boolean validationTesting = UtilsBlock.validationOneBlock(                     blockchain.genesisBlock().getFounderAddress(),                     testingValidationsBlock.get(testingValidationsBlock.size() - 1),                     block,                     Seting.BLOCK_GENERATION_INTERVAL,                     diff,                     testingValidationsBlock);              if (validationTesting == false) {                 System.out.println(\"wrong validation block: \" + validationTesting);                 System.out.println(\"index block: \" + block.getIndex());                 text = \"wrong validation\";             }             testingValidationsBlock.add(block.clone());         }          //добавляет последний блок в блокчейн         blockchain.addBlock(block);         //сохраняет последний блок в файл         UtilsBlock.saveBLock(block, Seting.ORIGINAL_BLOCKCHAIN_FILE);          //перерасчет балансов, подсчитывает какие изменения произошли в балансах         balances = Mining.getBalances(Seting.ORIGINAL_BALANCE_FILE, blockchain, balances);         Mining.deleteFiles(Seting.ORIGINAL_BALANCE_FILE);         //сохраняет в файл уже заново посчитанные балансы.         SaveBalances.saveBalances(balances, Seting.ORIGINAL_BALANCE_FILE);          //получает все созданные когда либо законы         Map<String, Laws> allLaws = UtilsLaws.getLaws(blockchain.getBlockchainList(), Seting.ORIGINAL_ALL_CORPORATION_LAWS_FILE);          //возвращает все законы с голосами проголосовавшими за них         List<LawEligibleForParliamentaryApproval> allLawsWithBalance = UtilsLaws.getCurrentLaws(allLaws, balances, Seting.ORIGINAL_ALL_CORPORATION_LAWS_WITH_BALANCE_FILE);         //удаление устаревних законов         Mining.deleteFiles(Seting.ORIGINAL_ALL_CORPORATION_LAWS_WITH_BALANCE_FILE);         //записывает все законы в файл с их голосами.         UtilsLaws.saveCurrentsLaws(allLawsWithBalance, Seting.ORIGINAL_ALL_CORPORATION_LAWS_WITH_BALANCE_FILE);          //отправляет блокчейн во внешние сервера         sendAllBlocksToStorage(blockchain.getBlockchainList());          text = \"success: блок успешно добыт\";         model.addAttribute(\"text\", text);         return \"redirect:/mining\";      }       /**Возвращает EntityChain который хранит в себе размер блокчейна и список блоков*/     @GetMapping(\"/chain\")     @ResponseBody     public EntityChain full_chain() throws IOException, NoSuchAlgorithmException, InvalidKeySpecException, SignatureException, NoSuchProviderException, InvalidKeyException {         blockchain = Mining.getBlockchain(                 Seting.ORIGINAL_BLOCKCHAIN_FILE,                 BlockchainFactoryEnum.ORIGINAL);         return new EntityChain(blockchain.sizeBlockhain(), blockchain.getBlockchainList());     }      /**возвращяет размер локального блокчейна*/     @GetMapping(\"/size\")     @ResponseBody     public Integer sizeBlockchain() throws IOException, NoSuchAlgorithmException, InvalidKeySpecException, SignatureException, NoSuchProviderException, InvalidKeyException {         blockchain = Mining.getBlockchain(                 Seting.ORIGINAL_BLOCKCHAIN_FILE,                 BlockchainFactoryEnum.ORIGINAL);         return blockchain.sizeBlockhain();     }       /**Возвращает список блоков ОТ до ДО,*/     @PostMapping(\"/sub-blocks\")     @ResponseBody     public List<Block> subBlocks(@RequestBody SubBlockchainEntity entity) throws IOException, NoSuchAlgorithmException, InvalidKeySpecException, SignatureException, NoSuchProviderException, InvalidKeyException {         blockchain = Mining.getBlockchain(                 Seting.ORIGINAL_BLOCKCHAIN_FILE,                 BlockchainFactoryEnum.ORIGINAL);         return blockchain.getBlockchainList().subList(entity.getStart(), entity.getFinish());     }      /**Возвращяет блок по индексу*/     @PostMapping(\"/block\")     @ResponseBody     public Block getBlock(@RequestBody Integer index) throws IOException, NoSuchAlgorithmException, InvalidKeySpecException, SignatureException, NoSuchProviderException, InvalidKeyException {         blockchain = Mining.getBlockchain(                 Seting.ORIGINAL_BLOCKCHAIN_FILE,                 BlockchainFactoryEnum.ORIGINAL);         return blockchain.getBlock(index);     }      //TODO нужно чтобы передавался каждый раз не весь блокчейн а часть, как реализованно в биткоин     //TODO is necessary so that not the entire blockchain is transmitted each time, but a part, as implemented in bitcoin     //TODO need to optimization because now not best      @RequestMapping(\"/resolving\")     public String resolving() throws JSONException, NoSuchAlgorithmException, InvalidKeySpecException, IOException, SignatureException, NoSuchProviderException, InvalidKeyException {         resolve_conflicts();         return \"redirect:/\";     }     /**соединяется к внешним хостам, и скачивает самый длинный блокчейн,      * если, локальный блокчейн, меньше других */     @GetMapping(\"/nodes/resolve\")     public synchronized ResponseEntity resolve_conflicts() throws NoSuchAlgorithmException, InvalidKeySpecException, IOException, SignatureException, NoSuchProviderException, InvalidKeyException, JSONException {         Blockchain temporaryBlockchain = BLockchainFactory.getBlockchain(BlockchainFactoryEnum.ORIGINAL);         Blockchain bigBlockchain = BLockchainFactory.getBlockchain(BlockchainFactoryEnum.ORIGINAL);         blockchain = Mining.getBlockchain(                 Seting.ORIGINAL_BLOCKCHAIN_FILE,                 BlockchainFactoryEnum.ORIGINAL);         int blocks_current_size = blockchain.sizeBlockhain();         long hashCountZeroTemporary = 0;         long hashCountZeroBigBlockchain = 0;         EntityChain entityChain = null;          long hashCountZeroAll = 0;         //count hash start with zero all         for (Block block : blockchain.getBlockchainList()) {             hashCountZeroAll += UtilsUse.hashCount(block.getHashBlock());         }          Set<String> nodesAll = getNodes(); //        nodesAll.addAll(Seting.ORIGINAL_ADDRESSES_BLOCKCHAIN_STORAGE);         System.out.println(\"BasisController: resolve: size: \" + getNodes().size());         for (String s : nodesAll) {             System.out.println(\"BasisController: resove: address: \" + s);             String temporaryjson = null;              if (BasisController.getExcludedAddresses().contains(s)) {                 System.out.println(\"its your address or excluded address: \" + s);                 continue;             }             try {                 if(s.contains(\"localhost\") || s.contains(\"127.0.0.1\"))                     continue;                 String address = s + \"/chain\";                 System.out.println(\"BasisController:resolve conflicts: address: \" + s + \"/size\");                 String sizeStr = UtilUrl.readJsonFromUrl(s + \"/size\");                 Integer size = Integer.valueOf(sizeStr);                 if (size > blocks_current_size) {                     System.out.println(\"size from address: \" + s + \" upper than: \" + size + \":blocks_current_size \" + blocks_current_size);                     //Test start algorithm                     SubBlockchainEntity subBlockchainEntity = new SubBlockchainEntity(blocks_current_size, size);                     String subBlockchainJson = UtilsJson.objToStringJson(subBlockchainEntity);                      List<Block> emptyList = new ArrayList<>();                       List<Block> subBlocks = UtilsJson.jsonToListBLock(UtilUrl.getObject(subBlockchainJson, s + \"/sub-blocks\"));                     emptyList.addAll(subBlocks);                     emptyList.addAll(blockchain.getBlockchainList());                      emptyList = emptyList.stream().sorted(Comparator.comparing(Block::getIndex)).collect(Collectors.toList());                     temporaryBlockchain.setBlockchainList(emptyList);                     if (!temporaryBlockchain.validatedBlockchain()) {                         System.out.println(\"first algorithm not worked\");                         emptyList = new ArrayList<>();                         emptyList.addAll(subBlocks);                         for (int i = blockchain.sizeBlockhain() - 1; i > 0; i--) {                             Block block = UtilsJson.jsonToBLock(UtilUrl.getObject(UtilsJson.objToStringJson(i), s + \"/block\"));                             if (!blockchain.getBlock(i).getHashBlock().equals(block.getHashBlock())) {                                 emptyList.add(block);                             } else {                                 emptyList.add(block);                                 emptyList.addAll(blockchain.getBlockchainList().subList(0, i));                                 emptyList = emptyList.stream().sorted(Comparator.comparing(Block::getIndex)).collect(Collectors.toList());                                 temporaryBlockchain.setBlockchainList(emptyList);                                 break;                             }                         }                     }                     if (!temporaryBlockchain.validatedBlockchain()) {                         System.out.println(\"second algorith not worked\");                         temporaryjson = UtilUrl.readJsonFromUrl(address);                         entityChain = UtilsJson.jsonToEntityChain(temporaryjson);                         temporaryBlockchain.setBlockchainList(                                 entityChain.getBlocks().stream().sorted(Comparator.comparing(Block::getIndex)).collect(Collectors.toList()));                     }                 } else {                     System.out.println(\"BasisController: resove: size less: \" + size + \" address: \" + address);                     continue;                 }             } catch (IOException e) {                 e.printStackTrace();                 System.out.println(\"BasisController: resolve_conflicts: Error: \" + s);                 continue;             }               if (temporaryBlockchain.validatedBlockchain()) {                 for (Block block : temporaryBlockchain.getBlockchainList()) {                     hashCountZeroTemporary += UtilsUse.hashCount(block.getHashBlock());                 }                  if (blocks_current_size < temporaryBlockchain.sizeBlockhain() && hashCountZeroAll < hashCountZeroTemporary) {                     blocks_current_size = temporaryBlockchain.sizeBlockhain();                     bigBlockchain = temporaryBlockchain;                     hashCountZeroBigBlockchain = hashCountZeroTemporary;                 }                 hashCountZeroTemporary = 0;             }          }           if (bigBlockchain.sizeBlockhain() > blockchain.sizeBlockhain() && hashCountZeroBigBlockchain > hashCountZeroAll) {              blockchain = bigBlockchain;             UtilsBlock.deleteFiles();             addBlock(bigBlockchain.getBlockchainList(), BLockchainFactory.getBlockchain(BlockchainFactoryEnum.ORIGINAL));             System.out.println(\"BasisController: resolve: bigblockchain size: \" + bigBlockchain.sizeBlockhain());          }         return new ResponseEntity(HttpStatus.OK);     }       /**      * Перезаписывает весь список блоков, и делает перерасчет баланса, а также других данных      * таких как голоса, совет акционеров и т.д. заново записывает в файлы      */      public static void addBlock(List<Block> orignalBlocks, Blockchain blockchain) throws IOException, NoSuchAlgorithmException, SignatureException, InvalidKeySpecException, NoSuchProviderException, InvalidKeyException {          Map<String, Account> balances = new HashMap<>();         Blockchain temporaryForValidation = BLockchainFactory.getBlockchain(BlockchainFactoryEnum.ORIGINAL);         temporaryForValidation.setBlockchainList(orignalBlocks);         UtilsBlock.deleteFiles();         System.out.println(\"addBlock start\");         for (Block block : orignalBlocks) {             UtilsBlock.saveBLock(block, Seting.ORIGINAL_BLOCKCHAIN_FILE);         }          blockchain = Mining.getBlockchain(                 Seting.ORIGINAL_BLOCKCHAIN_FILE,                 BlockchainFactoryEnum.ORIGINAL);          //перерасчет после добычи         balances = UtilsBalance.calculateBalances(blockchain.getBlockchainList());         Mining.deleteFiles(Seting.ORIGINAL_BALANCE_FILE);         SaveBalances.saveBalances(balances, Seting.ORIGINAL_BALANCE_FILE);           //получение и отображение законов, а также сохранение новых законов         //и изменение действующих законов         Map<String, Laws> allLaws = UtilsLaws.getLaws(blockchain.getBlockchainList(), Seting.ORIGINAL_ALL_CORPORATION_LAWS_FILE);           //возвращает все законы с балансом         List<LawEligibleForParliamentaryApproval> allLawsWithBalance = UtilsLaws.getCurrentLaws(allLaws, balances, Seting.ORIGINAL_ALL_CORPORATION_LAWS_WITH_BALANCE_FILE);         //удаление устаревних законов         Mining.deleteFiles(Seting.ORIGINAL_ALL_CORPORATION_LAWS_WITH_BALANCE_FILE);         UtilsLaws.saveCurrentsLaws(allLawsWithBalance, Seting.ORIGINAL_ALL_CORPORATION_LAWS_WITH_BALANCE_FILE);          System.out.println(\"BasisController: addBlock: finish\");     }      /**Регистрирует новый внешний хост*/     @RequestMapping(method = RequestMethod.POST, value = \"/nodes/register\", consumes = MediaType.APPLICATION_JSON_VALUE)     public synchronized void register_node(@RequestBody AddressUrl urlAddrress) throws IOException, NoSuchAlgorithmException, InvalidKeySpecException, SignatureException, NoSuchProviderException, InvalidKeyException {           for (String s : BasisController.getNodes()) {             String original = s;             String url = s + \"/nodes/register\";              try {                 UtilUrl.sendPost(urlAddrress.getAddress(), url);                 sendAddress();               } catch (Exception e) {                 System.out.println(\"BasisController: register node: wrong node: \" + original);                 BasisController.getNodes().remove(original);                 continue;             }         }          Set<String> nodes = BasisController.getNodes();         nodes = nodes.stream()                 .map(t -> t.replaceAll(\"\\\"\", \"\"))                 .map(t -> t.replaceAll(\"\\\\\\\\\", \"\"))                 .collect(Collectors.toSet());         nodes.add(urlAddrress.getAddress());         BasisController.setNodes(nodes);          Mining.deleteFiles(Seting.ORIGINAL_POOL_URL_ADDRESS_FILE);         nodes.stream().forEach(t -> {             try {                 UtilsAllAddresses.saveAllAddresses(t, Seting.ORIGINAL_POOL_URL_ADDRESS_FILE);             } catch (IOException e) {                 throw new RuntimeException(e);             } catch (NoSuchAlgorithmException e) {                 throw new RuntimeException(e);             } catch (SignatureException e) {                 throw new RuntimeException(e);             } catch (InvalidKeySpecException e) {                 throw new RuntimeException(e);             } catch (NoSuchProviderException e) {                 throw new RuntimeException(e);             } catch (InvalidKeyException e) {                 throw new RuntimeException(e);             }         });      }      //TODO если происходить майнинг, то он возвращает false, пока не прекратиться майнинг.     //TODO if mining occurs, it returns false until mining stops.     /** выззывает метод addBlock который перезаписывает весь список блоков, и другие данные*/     @GetMapping(\"/addBlock\")     public ResponseEntity getBLock() throws IOException, NoSuchAlgorithmException, InvalidKeySpecException, SignatureException, NoSuchProviderException, InvalidKeyException {         blockchain = Mining.getBlockchain(                 Seting.ORIGINAL_BLOCKCHAIN_FILE,                 BlockchainFactoryEnum.ORIGINAL);         UtilsBlock.deleteFiles();         addBlock(blockchain.getBlockchainList(), BLockchainFactory.getBlockchain(BlockchainFactoryEnum.ORIGINAL));         return new ResponseEntity(HttpStatus.OK);     }      /**Возвращяет список хостов, сохраненных на локальном сервере*/     @GetMapping(\"/getNodes\")     public Set<String> getAllNodes() throws IOException, NoSuchAlgorithmException, InvalidKeySpecException, SignatureException, NoSuchProviderException, InvalidKeyException {         Set<String> temporary = UtilsAllAddresses.readLineObject(Seting.ORIGINAL_POOL_URL_ADDRESS_FILE);         nodes.addAll(temporary);         nodes.addAll(Seting.ORIGINAL_ADDRESSES);         nodes = nodes.stream().filter(t -> t.startsWith(\"\\\"\"))                 .collect(Collectors.toSet());         return nodes;     }      /**подключается к другим узлам и у них берет их списки хостов, которые храняться у них,      *  и сохраняет эти списки у себя*/     @GetMapping(\"/findAddresses\")     public void findAddresses() throws IOException, NoSuchAlgorithmException, InvalidKeySpecException, SignatureException, NoSuchProviderException, InvalidKeyException {         for (String s : Seting.ORIGINAL_ADDRESSES) {             Set<String> addressesSet = new HashSet<>();             try {                 String addresses = UtilUrl.readJsonFromUrl(s + \"/getDiscoveryAddresses\");                 addressesSet = UtilsJson.jsonToSetAddresses(addresses);             } catch (IOException e) {                 System.out.println(\"BasisController: findAddress: error\");                 continue;             } catch (JSONException e) {                 throw new RuntimeException(e);             }              for (String s1 : addressesSet) {                  register_node(new AddressUrl(s1));             }          }      }      /**Запускает автоматический цикл майнинга, цикл будет идти 2000 шагов*/     @GetMapping(\"/moreMining\")     public void moreMining() throws JSONException, IOException {         for (int i = 1; i < 2000; i++) {             System.out.println(\"block generate i: \" + i);             UtilUrl.readJsonFromUrl(\"http://localhost:8082/mine\");           }     }       /**Отправляет свой список хостов, другим узлам, и пытается автоматически регистрировать у них*/     public static void sendAddress() throws IOException, NoSuchAlgorithmException, InvalidKeySpecException, SignatureException, NoSuchProviderException, InvalidKeyException {         //лист временный для отправки аддресов          for (String s : Seting.ORIGINAL_ADDRESSES) {              String original = s;             String url = s + \"/nodes/register\";              if (BasisController.getExcludedAddresses().contains(url)) {                 System.out.println(\"MainController: its your address or excluded address: \" + url);                 continue;             }             try {                 for (String s1 : BasisController.getNodes()) {                       AddressUrl addressUrl = new AddressUrl(s1);                     String json = UtilsJson.objToStringJson(addressUrl);                     UtilUrl.sendPost(json, url);                 }             } catch (Exception e) {                 System.out.println(\"BasisController: sendAddress: wronge node: \" + original);                  continue;             }           }     }      //должен отправлять блокчейн в хранилище блокчейна     /**Отправляет список блоков в центральные хранилища (пример: http://194.87.236.238:80)*/     public static void sendAllBlocksToStorage(List<Block> blocks) throws IOException, NoSuchAlgorithmException, InvalidKeySpecException, SignatureException, NoSuchProviderException, InvalidKeyException {         String jsonDto;         System.out.println(\"BasisController: sendAllBlocksToStorage: start: \");         try {             jsonDto = UtilsJson.objToStringJson(blocks);         } catch (IOException e) {             throw new RuntimeException(e);         }         int blocks_current_size = blocks.size();         //отправка блокчейна на хранилище блокчейна         System.out.println(\"BasisController: sendAllBlocksToStorage: \");         getNodes().stream().forEach(System.out::println);         for (String s : getNodes()) {               if (BasisController.getExcludedAddresses().contains(s)) {                 System.out.println(\"its your address or excluded address: \" + s);                 continue;             }              try {                 System.out.println(\"BasisController:resolve conflicts: address: \" + s + \"/size\");                 String sizeStr = UtilUrl.readJsonFromUrl(s + \"/size\");                 Integer size =  0;                 if(Integer.valueOf(sizeStr) > 0)                     size = Integer.valueOf(sizeStr);                 System.out.println(\"BasisController: send size: \" + size);                 List<Block> fromToTempBlock = blocks.subList(size, blocks.size());                 String jsonFromTo = UtilsJson.objToStringJson(fromToTempBlock);                 //если блокчейн текущей больше чем в хранилище, то                 //отправить текущий блокчейн отправить в хранилище                 if (size < blocks_current_size) {                     int response = 0;                     //Test start algorithm                     String originalF = s;                     String urlFrom = s + \"/nodes/resolve_from_to_block\";                     try {                         response = UtilUrl.sendPost(jsonFromTo, urlFrom);                     }catch (Exception e){                         System.out.println(\"exception discover: \" + originalF);                         continue;                     }                      System.out.println(\"BasisController: sendAllBlocksStorage: response: \" + response);                      if(response != 0){                         System.out.println(\"BasisController: sendAllBlocks: need change all: \" + response);                         //Test start algorithm                         String original = s;                         String url = s + \"/nodes/resolve_all_blocks\";                         try {                             UtilUrl.sendPost(jsonDto, url);                          }catch (Exception e){                             System.out.println(\"exception discover: \" + original);                             continue;                          }                     }                  }              } catch (JSONException e) {                 e.printStackTrace();                 continue;              } catch (IOException e) {                 e.printStackTrace();                 continue;             }          }      } }","package International_Trade_Union.controllers;  import International_Trade_Union.config.BlockchainFactoryEnum; import International_Trade_Union.entity.blockchain.Blockchain; import International_Trade_Union.model.Mining; import International_Trade_Union.setings.Seting; import org.springframework.web.bind.annotation.GetMapping; import org.springframework.web.bind.annotation.RestController;  import java.io.IOException; import java.security.InvalidKeyException; import java.security.NoSuchAlgorithmException; import java.security.NoSuchProviderException; import java.security.SignatureException; import java.security.spec.InvalidKeySpecException;  @RestController public class BlockchainCheckController {      //TODO во время майнинга, если майнинг не остановлен, он почему то возвращает false, но после остановки true. Нужно исправить.     //TODO during mining, if mining is not stopped, for some reason it returns false, but after stopping it returns true. Need to fix.     //TODO worked after restart server, get true.     //TODO ошибка возникает если прервать mine,     //TODO error occurs if mine is interrupted,      /**Проверяет целостность блокчейна*/     @GetMapping(\"/checkValidation\")     public boolean checkValidation() throws IOException, NoSuchAlgorithmException, SignatureException, InvalidKeySpecException, NoSuchProviderException, InvalidKeyException {         try{             Blockchain blockchain = Mining.getBlockchain(                     Seting.ORIGINAL_BLOCKCHAIN_FILE,                     BlockchainFactoryEnum.ORIGINAL);             System.out.println(\"BlockchainCheckController: checkValidation: size: \" + blockchain.sizeBlockhain());             boolean check = blockchain.validatedBlockchain();             System.out.println(\"check: \" + check);             return check;}         catch (IOException e){             e.printStackTrace();             return false;         }     } }","package International_Trade_Union.controllers;  import International_Trade_Union.config.BlockchainFactoryEnum; import International_Trade_Union.entity.blockchain.Blockchain; import International_Trade_Union.governments.UtilsGovernment; import International_Trade_Union.model.Mining; import International_Trade_Union.utils.SaveBalances; import org.springframework.stereotype.Controller; import org.springframework.ui.Model; import org.springframework.web.bind.annotation.GetMapping; import International_Trade_Union.model.Account; import International_Trade_Union.setings.Seting;  import java.io.IOException; import java.security.InvalidKeyException; import java.security.NoSuchAlgorithmException; import java.security.NoSuchProviderException; import java.security.SignatureException; import java.security.spec.InvalidKeySpecException; import java.util.ArrayList; import java.util.HashMap; import java.util.List; import java.util.Map; import java.util.stream.Collectors;  @Controller public class BoardOfShareholdersController {      /**отображает список Совета Акционеров, отображается в браузере*/     @GetMapping(\"board-of-shareholders\")     public String boardOfShareHolders(Model model) throws NoSuchAlgorithmException, InvalidKeySpecException, IOException, SignatureException, NoSuchProviderException, InvalidKeyException {          Blockchain blockchain = Mining.getBlockchain(                 Seting.ORIGINAL_BLOCKCHAIN_FILE,                 BlockchainFactoryEnum.ORIGINAL);          //Получение баланса         Map<String, Account> balances = new HashMap<>();          balances = SaveBalances.readLineObject(Seting.ORIGINAL_BALANCE_FILE);         List<Account> boardOfShareholders = new ArrayList<>();          boardOfShareholders = UtilsGovernment.findBoardOfShareholders(balances, blockchain.getBlockchainList(), Seting.BOARDS_BLOCK);           model.addAttribute(\"title\", \"Board of shareholders quantity: \" + boardOfShareholders.size());         model.addAttribute(\"boardOfShareholders\", boardOfShareholders);         return \"board-of-shareholders\";     }   }","package International_Trade_Union.controllers;  import International_Trade_Union.originalCorporateCharter.OriginalCHARTER; import International_Trade_Union.originalCorporateCharter.OriginalCHARTER_ENG; import International_Trade_Union.originalCorporateCharter.OriginalPreamble; import International_Trade_Union.originalCorporateCharter.OriginalPreambleEng; import org.springframework.stereotype.Controller; import org.springframework.ui.Model; import org.springframework.web.bind.annotation.GetMapping;  import java.io.IOException; import java.security.InvalidKeyException; import java.security.NoSuchAlgorithmException; import java.security.NoSuchProviderException; import java.security.SignatureException; import java.security.spec.InvalidKeySpecException; import java.util.ArrayList; import java.util.List;  @Controller public class ConstitutionController {      /**Отображает устав в браузере*/     @GetMapping(\"corporate-charter\")     public String constutionRus(Model model) throws NoSuchAlgorithmException, InvalidKeySpecException, IOException, SignatureException, NoSuchProviderException, InvalidKeyException {          model.addAttribute(\"title\", \"corporate charter-корпоративный устав\");         List<String> eng = charterEngList();         List<String> rus = charterRusList();                model.addAttribute(\"rus\", rus);         model.addAttribute(\"eng\", eng);         return \"corporate-charter\";     }      public static String charterRus (){         String string = \"\";         for (String s : charterRusList()) {             string = s + \"\\n\";         }         return string;     }      public static String charterEng(){         String string = \"\";         for (String s : charterEngList()) {             string = s + \"\\n\";         }         return string;     }       public static List<String> charterRusList(){         List<String> rus = new ArrayList<>();           rus.add(\"OriginalPreamble.ARTICLE_0\\n\"+ OriginalPreamble.ARTICLE_0);         rus.add(\"OriginalCHARTER.HOW_LAWS_ARE_CHOSEN_1:\\n\"+ OriginalCHARTER.HOW_LAWS_ARE_CHOSEN_1);         rus.add(\"OriginalCHARTER.VOTE_STOCK_2:\\n\"+ OriginalCHARTER.VOTE_STOCK_2);         rus.add(\"OriginalCHARTER.ONE_VOTE_3:\\n\"+ OriginalCHARTER.ONE_VOTE_3);         rus.add(\"OriginalCHARTER.VOTE_FRACTION_4:\\n\"+ OriginalCHARTER.VOTE_FRACTION_4);         rus.add(\"OriginalCHARTER.Penalty_mechanism_5:\\n\"+ OriginalCHARTER.Penalty_mechanism_5);         rus.add(\"OriginalCHARTER.WHO_HAS_THE_RIGHT_TO_CREATE_LAWS_6:\\n\"+ OriginalCHARTER.WHO_HAS_THE_RIGHT_TO_CREATE_LAWS_6);         rus.add(\"OriginalCHARTER.POWERS_OF_THE_CORPORATE_COUNCIL_OF_JUDGES_7:\\n\"+ OriginalCHARTER.POWERS_OF_THE_CORPORATE_COUNCIL_OF_JUDGES_7);         rus.add(\"OriginalCHARTER.HOW_THE_CHIEF_JUDGE_IS_CHOSEN_8:\\n\"+ OriginalCHARTER.HOW_THE_CHIEF_JUDGE_IS_CHOSEN_8);         rus.add(\"OriginalCHARTER.PROPERTY_OF_THE_CORPORATION_9:\\n\"+ OriginalCHARTER.PROPERTY_OF_THE_CORPORATION_9);         rus.add(\"OriginalCHARTER.GENERAL_EXECUTIVE_DIRECTOR_10:\\n\"+ OriginalCHARTER.GENERAL_EXECUTIVE_DIRECTOR_10);         rus.add(\"OriginalCHARTER.EXPLANATION_WHY_MONEY_DEMURAGE_IS_USED_HERE_11:\\n\"+ OriginalCHARTER.EXPLANATION_WHY_MONEY_DEMURAGE_IS_USED_HERE_11);         rus.add(\"OriginalCHARTER.FREEDOM_OF_SPEECH_12:\\n\"+ OriginalCHARTER.FREEDOM_OF_SPEECH_12);         rus.add(\"OriginalCHARTER.RIGHTS_13:\\n\"+ OriginalCHARTER.RIGHTS_13);         rus.add(\"OriginalCHARTER.LEGISLATURE_14:\\n\"+ OriginalCHARTER.LEGISLATURE_14);          return rus;     }       public static List<String> charterEngList(){         List<String> eng = new ArrayList<>();           eng.add(\"OriginalPreamble.ARTICLE_0\\n\"+ OriginalPreambleEng.ARTICLE_0);         eng.add(\"OriginalCHARTER.HOW_LAWS_ARE_CHOSEN_1:\\n\"+ OriginalCHARTER_ENG.HOW_LAWS_ARE_CHOSEN_1);         eng.add(\"OriginalCHARTER.VOTE_STOCK_2:\\n\"+ OriginalCHARTER_ENG.VOTE_STOCK_2);         eng.add(\"OriginalCHARTER.ONE_VOTE_3:\\n\"+ OriginalCHARTER_ENG.ONE_VOTE_3);         eng.add(\"OriginalCHARTER.VOTE_FRACTION_4:\\n\"+ OriginalCHARTER_ENG.VOTE_FRACTION_4);         eng.add(\"OriginalCHARTER.Penalty_mechanism_5:\\n\"+ OriginalCHARTER_ENG.Penalty_mechanism_5);         eng.add(\"OriginalCHARTER.WHO_HAS_THE_RIGHT_TO_CREATE_LAWS_6:\\n\"+ OriginalCHARTER_ENG.WHO_HAS_THE_RIGHT_TO_CREATE_LAWS_6);         eng.add(\"OriginalCHARTER.POWERS_OF_THE_CORPORATE_COUNCIL_OF_JUDGES_7:\\n\"+ OriginalCHARTER_ENG.POWERS_OF_THE_CORPORATE_COUNCIL_OF_JUDGES_7);         eng.add(\"OriginalCHARTER.HOW_THE_CHIEF_JUDGE_IS_CHOSEN_8:\\n\"+ OriginalCHARTER_ENG.HOW_THE_CHIEF_JUDGE_IS_CHOSEN_8);         eng.add(\"OriginalCHARTER.PROPERTY_OF_THE_CORPORATION_9:\\n\"+ OriginalCHARTER_ENG.PROPERTY_OF_THE_CORPORATION_9);         eng.add(\"OriginalCHARTER.GENERAL_EXECUTIVE_DIRECTOR_10:\\n\"+ OriginalCHARTER_ENG.GENERAL_EXECUTIVE_DIRECTOR_10);         eng.add(\"OriginalCHARTER.EXPLANATION_WHY_MONEY_DEMURAGE_IS_USED_HERE_11:\\n\"+ OriginalCHARTER_ENG.EXPLANATION_WHY_MONEY_DEMURAGE_IS_USED_HERE_11);         eng.add(\"OriginalCHARTER.FREEDOM_OF_SPEECH_12:\\n\"+ OriginalCHARTER_ENG.FREEDOM_OF_SPEECH_12);         eng.add(\"OriginalCHARTER.RIGHTS_13:\\n\"+ OriginalCHARTER_ENG.RIGHTS_13);         eng.add(\"OriginalCHARTER.LEGISLATURE_14:\\n\"+ OriginalCHARTER_ENG.LEGISLATURE_14);          return eng;     } }","package International_Trade_Union.controllers;  import org.springframework.stereotype.Controller; import org.springframework.ui.Model; import org.springframework.web.bind.annotation.GetMapping; import org.springframework.web.bind.annotation.PostMapping; import org.springframework.web.servlet.mvc.support.RedirectAttributes; import International_Trade_Union.model.CreateAccount;  import java.security.InvalidAlgorithmParameterException; import java.security.NoSuchAlgorithmException; import java.security.NoSuchProviderException; import java.security.spec.InvalidKeySpecException; import java.util.Map;  @Controller public class CreateAccountController {       /**Позвалояет создавать счет, отображается в браузере*/     @GetMapping(\"create-account\")     public String createAccount(Model model) throws InvalidAlgorithmParameterException, NoSuchAlgorithmException, InvalidKeySpecException, NoSuchProviderException {         model.addAttribute(\"title\", \"create minerAccount\");         Map<String, String> newAccount = CreateAccount.create();          model.addAttribute(\"login\", newAccount.get(\"pubKey\"));         model.addAttribute(\"password\", newAccount.get(\"privKey\"));         return \"create-account\";     }       @PostMapping(\"create-account\")     public String createNewAccount(RedirectAttributes redirectAttrs) throws InvalidAlgorithmParameterException, NoSuchAlgorithmException, InvalidKeySpecException, NoSuchProviderException {         redirectAttrs.addFlashAttribute(\"title\", \"create minerAccount\");         Map<String, String> newAccount = CreateAccount.create();          redirectAttrs.addFlashAttribute(\"login\", newAccount.get(\"pubKey\"));         redirectAttrs.addFlashAttribute(\"password\", newAccount.get(\"privKey\"));          return \"redirect:/create-account\";     }  }","package International_Trade_Union.controllers;  import International_Trade_Union.config.BlockchainFactoryEnum; import International_Trade_Union.entity.blockchain.Blockchain; import International_Trade_Union.governments.*; import International_Trade_Union.model.Account; import International_Trade_Union.model.FIndPositonHelperData; import International_Trade_Union.model.Mining; import International_Trade_Union.setings.Seting; import International_Trade_Union.utils.SaveBalances; import International_Trade_Union.vote.CurrentLawVotesEndBalance; import International_Trade_Union.vote.LawEligibleForParliamentaryApproval; import International_Trade_Union.vote.UtilsLaws; import org.springframework.stereotype.Controller; import org.springframework.ui.Model; import org.springframework.web.bind.annotation.GetMapping;  import java.io.IOException; import java.security.InvalidKeyException; import java.security.NoSuchAlgorithmException; import java.security.NoSuchProviderException; import java.security.SignatureException; import java.security.spec.InvalidKeySpecException; import java.util.*; import java.util.stream.Collectors;  @Controller public class FractionController {      @GetMapping(\"/fractions\")     public String fractions(Model model) throws IOException, NoSuchAlgorithmException, SignatureException, InvalidKeySpecException, NoSuchProviderException, InvalidKeyException {         Directors directors = new Directors();         Blockchain blockchain = Mining.getBlockchain(                 Seting.ORIGINAL_BLOCKCHAIN_FILE,                 BlockchainFactoryEnum.ORIGINAL);          Map<String, Account> balances = new HashMap<>();         //считывать баланс         balances = SaveBalances.readLineObject(Seting.ORIGINAL_BALANCE_FILE);          List<LawEligibleForParliamentaryApproval> lawEligibleForParliamentaryApprovals =                 UtilsLaws.readLineCurrentLaws(Seting.ORIGINAL_ALL_CORPORATION_LAWS_WITH_BALANCE_FILE);          //получить совет акционеров из файла         List<Account> boardOfShareholders = UtilsGovernment.findBoardOfShareholders(balances, blockchain.getBlockchainList(), Seting.BOARDS_BLOCK);           //TODO доработать оптимизацию         //TODO избавиться от find position в данном методе         //отфильтровать по типам голосов         Map<Director, FIndPositonHelperData> fIndPositonHelperDataMap = new HashMap<>();         for (Director higherSpecialPositions : directors.getDirectors()) {             if (higherSpecialPositions.isElectedByCEO()) {                 fIndPositonHelperDataMap.put(higherSpecialPositions,                         new FIndPositonHelperData(higherSpecialPositions, false, false, true, false, false));             } else if (higherSpecialPositions.isElectedByBoardOfDirectors()) {                 fIndPositonHelperDataMap.put(higherSpecialPositions,                         new FIndPositonHelperData(higherSpecialPositions, false, false, false, true, false));             } else if (higherSpecialPositions.isElectedByCorporateCouncilOfReferees()) {                 fIndPositonHelperDataMap.put(higherSpecialPositions,                         new FIndPositonHelperData(higherSpecialPositions, false, false, false, false, true));             } else {                 fIndPositonHelperDataMap.put(higherSpecialPositions,                         new FIndPositonHelperData(higherSpecialPositions, true, true, false, false, false));              }          }         //подсчитать голоса за все проголосованные заканы         List<CurrentLawVotesEndBalance> current = UtilsGovernment.filtersVotes(                 lawEligibleForParliamentaryApprovals,                 balances,                 boardOfShareholders,                 blockchain.getBlockchainList(),                 Seting.LAW_YEAR_VOTE);  //избранные фракции         List<CurrentLawVotesEndBalance> electedFraction = current.stream()                 .filter(t -> directors.isElectedByStocks(t.getPackageName()))                 .filter(t -> t.getPackageName().equals(NamePOSITION.FRACTION.toString()))                 .filter(t -> t.getVotes() >= Seting.ORIGINAL_LIMIT_MIN_VOTE)                 .sorted(Comparator.comparing(CurrentLawVotesEndBalance::getVotes).reversed())                 .limit(directors.getDirector(NamePOSITION.FRACTION.toString()).getCount())                 .collect(Collectors.toList());          double sum = electedFraction.stream().map(t->t.getVotes())                 .reduce(0.0, Double::sum);         List<FractionPower> currentLaw = new ArrayList<>();         for (CurrentLawVotesEndBalance first : electedFraction) {              double fractionP = (first.getVotes()/sum) * Seting.HUNDRED_PERCENT;             FractionPower fractionPower = new FractionPower(                     first.getAddressLaw(),                     first.getVotes(),                     first.getVotesCorporateCouncilOfReferees(),                     first.getVotesBoardOfDirectors(),                     first.getVotesBoardOfShareholders(),                     first.getVoteGeneralExecutiveDirector(),                     first.getVoteHightJudge(),                     first.getFounderVote(),                     first.getPackageName(),                     first.getLaws(),                     first.getFractionVote(),                     fractionP              );             currentLaw.add(fractionPower);         }           model.addAttribute(\"title\", \"fractions end fractions power\");         model.addAttribute(\"currentLaw\", currentLaw);         return \"/fractions\";     } }","package International_Trade_Union.controllers;  import International_Trade_Union.config.BlockchainFactoryEnum; import International_Trade_Union.entity.DtoTransaction.DtoTransaction; import International_Trade_Union.entity.blockchain.Blockchain; import International_Trade_Union.governments.Director; import International_Trade_Union.governments.Directors; import International_Trade_Union.governments.NamePOSITION; import International_Trade_Union.model.FIndPositonHelperData; import International_Trade_Union.model.Mining; import International_Trade_Union.network.AllTransactions; import International_Trade_Union.utils.base.Base; import International_Trade_Union.utils.base.Base58; import org.springframework.stereotype.Controller; import org.springframework.ui.Model; import org.springframework.web.bind.annotation.GetMapping; import International_Trade_Union.governments.UtilsGovernment; import International_Trade_Union.model.Account; import International_Trade_Union.setings.Seting; import International_Trade_Union.utils.*; import International_Trade_Union.vote.*; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RequestMethod; import org.springframework.web.bind.annotation.RequestParam; import org.springframework.web.servlet.mvc.support.RedirectAttributes;  import java.io.IOException; import java.security.*; import java.security.spec.InvalidKeySpecException; import java.util.*; import java.util.stream.Collectors;  @Controller public class GovernmentController {      //TODO если происходит майнинг почему то происходят ошибки, и если вызвать данный метод, то может     //TODO прерываться сам процесс майнинга     //TODO if mining occurs for some reason, errors are observed, and this method appears, then it can     //TODO interrupt the mining process itself      /**Отображает в браузере список действующих должностей*/     @GetMapping(\"/governments\")     public String corporateSeniorpositions(Model model) throws NoSuchAlgorithmException, InvalidKeySpecException, IOException, SignatureException, NoSuchProviderException, InvalidKeyException {         Blockchain blockchain = Mining.getBlockchain(                 Seting.ORIGINAL_BLOCKCHAIN_FILE,                 BlockchainFactoryEnum.ORIGINAL);          //за сколько времени занимает подсчет         Date start = new Date();         //Получение баланса         Map<String, Account> balances = new HashMap<>();          balances = SaveBalances.readLineObject(Seting.ORIGINAL_BALANCE_FILE);          //Нахождение должности         List<LawEligibleForParliamentaryApproval> allGovernment =                 UtilsLaws.readLineCurrentLaws(Seting.ORIGINAL_ALL_CORPORATION_LAWS_WITH_BALANCE_FILE);          //список должностей         Map<Director, List<LawEligibleForParliamentaryApproval>> positionsListMap = new HashMap<>();          Directors directors = new Directors();         //добавление всех должностей         for (Director higherSpecialPositions : directors.getDirectors()) {             positionsListMap.put(higherSpecialPositions, UtilsLaws.getPossions(allGovernment, higherSpecialPositions));         }          //список акционеров         List<Account> BoardOfShareholders = UtilsGovernment.findBoardOfShareholders(balances, blockchain.getBlockchainList(), Seting.BOARDS_BLOCK);          //список законов с голосами         Map<String, List<CurrentLawVotesEndBalance>> curentLawVotesEndBalance = new HashMap<>();          //TODO доработать оптимизацию         //TODO избавиться от find position в данном методе         Map<Director, FIndPositonHelperData> fIndPositonHelperDataMap = new HashMap<>();         for (Director higherSpecialPositions : directors.getDirectors()) {             if(higherSpecialPositions.isElectedByCEO()){                 fIndPositonHelperDataMap.put(higherSpecialPositions,                         new FIndPositonHelperData(higherSpecialPositions, false, false, true, false, false));             }             else if(higherSpecialPositions.isElectedByBoardOfDirectors()){                 fIndPositonHelperDataMap.put(higherSpecialPositions,                         new FIndPositonHelperData(higherSpecialPositions, false, false, false, true, false));             }             else if(higherSpecialPositions.isElectedByCorporateCouncilOfReferees()){                 fIndPositonHelperDataMap.put(higherSpecialPositions,                         new FIndPositonHelperData(higherSpecialPositions, false, false, false, false, true));             }             else {                 fIndPositonHelperDataMap.put(higherSpecialPositions,                         new FIndPositonHelperData(higherSpecialPositions, true, true, false ,false, false));              }          }          List<CurrentLawVotesEndBalance> current = UtilsGovernment.filtersVotes(                 allGovernment,                 balances,                 BoardOfShareholders,                 blockchain.getBlockchainList(),                 Seting.LAW_YEAR_VOTE);            //минимальное значение количество положительных голосов для того чтобы закон действовал,         //позиции избираемые акциями в совет директоров         List<CurrentLawVotesEndBalance> electedByStockBoardOfDirectors = current.stream()                 .filter(t -> directors.isElectedByStocks(t.getPackageName()))                 .filter(t -> t.getPackageName().equals(NamePOSITION.BOARD_OF_DIRECTORS.toString()))                 .filter(t -> t.getVotes() >= Seting.ORIGINAL_LIMIT_MIN_VOTE)                 .sorted(Comparator.comparing(CurrentLawVotesEndBalance::getVotes).reversed())                 .limit(directors.getDirector(NamePOSITION.BOARD_OF_DIRECTORS.toString()).getCount())                 .collect(Collectors.toList());           //минимальное значение количество положительных голосов для того чтобы закон действовал,         //позиции избираемые акциями electedByStockCorporateCouncilOfReferees         List<CurrentLawVotesEndBalance> electedByStockCorporateCouncilOfReferees = current.stream()                 .filter(t -> directors.isElectedByStocks(t.getPackageName()))                 .filter(t -> t.getPackageName().equals(NamePOSITION.CORPORATE_COUNCIL_OF_REFEREES.toString()))                 .filter(t -> t.getVotes() >= Seting.ORIGINAL_LIMIT_MIN_VOTE)                 .sorted(Comparator.comparing(CurrentLawVotesEndBalance::getVotes).reversed())                 .limit(directors.getDirector(NamePOSITION.CORPORATE_COUNCIL_OF_REFEREES.toString()).getCount())                 .collect(Collectors.toList());            //позиции созданные советом директоров         List<CurrentLawVotesEndBalance> createdByBoardOfDirectors = current.stream()                 .filter(t->t.getPackageName().startsWith(Seting.ADD_DIRECTOR))                 .filter(t->t.getVotesBoardOfDirectors() >= Seting.ORIGINAL_LIMIT_MIN_VOTE_BOARD_OF_DIRECTORS                 && t.getVotesBoardOfShareholders() >= Seting.ORIGINAL_LIMIT_MIN_VOTE_BOARD_OF_SHAREHOLDERS                 && t.getFractionVote() >= Seting.ORIGINAL_LIMIT_MIN_VOTE_FRACTIONS                 && t.getVotes() >= Seting.ALL_STOCK_VOTE)                 .collect(Collectors.toList());         //добавление позиций созданных советом директоров         for (CurrentLawVotesEndBalance currentLawVotesEndBalance : createdByBoardOfDirectors) {             directors.addAllByBoardOfDirectors(currentLawVotesEndBalance.getLaws());         }          //позиции избираемые  только советом директоров в кабинет директоров         List<CurrentLawVotesEndBalance> electedByBoardOfDirectors = current.stream()                 .filter(t -> directors.isElectedByBoardOfDirectors(t.getPackageName()))                 .filter(t -> t.getVotesBoardOfDirectors() >= Seting.ORIGINAL_LIMIT_MIN_VOTE_BOARD_OF_DIRECTORS                 && t.getVotesBoardOfShareholders() >= Seting.ORIGINAL_LIMIT_MIN_VOTE_BOARD_OF_SHAREHOLDERS                 && t.getFractionVote() >= Seting.ORIGINAL_LIMIT_MIN_VOTE_FRACTIONS                 && t.getVotes() >= Seting.ALL_STOCK_VOTE)                 .sorted(Comparator.comparing(CurrentLawVotesEndBalance::getVotesBoardOfDirectors).reversed())                 .collect(Collectors.toList());          List<CurrentLawVotesEndBalance> addDirectors = current.stream()                 .filter(t->t.getPackageName().startsWith(Seting.ADD_DIRECTOR))                 .filter(t->t.getVotesBoardOfDirectors() >= Seting.ORIGINAL_LIMIT_MIN_VOTE_BOARD_OF_DIRECTORS                         && t.getVotesBoardOfShareholders() >= Seting.ORIGINAL_LIMIT_MIN_VOTE_BOARD_OF_SHAREHOLDERS                         && t.getFractionVote() >= Seting.ORIGINAL_LIMIT_MIN_VOTE_FRACTIONS                         && t.getVotes() >= Seting.ALL_STOCK_VOTE)                 .collect(Collectors.toList());          System.out.println(\"***************************************\");         System.out.println(\"GovernmentController: corporateSeniorpositions: elected by Board of Directors;\");         electedByBoardOfDirectors.stream().forEach(System.out::println);         System.out.println(\"***************************************\");          //групируем по списку         Map<String, List<CurrentLawVotesEndBalance>> group = electedByBoardOfDirectors.stream()                 .collect(Collectors.groupingBy(CurrentLawVotesEndBalance::getPackageName));          Map<Director, List<CurrentLawVotesEndBalance>> original_group = new HashMap<>();          //оставляем то количество которое описано в данной должности         for (Map.Entry<String, List<CurrentLawVotesEndBalance>> stringListEntry : group.entrySet()) {             List<CurrentLawVotesEndBalance> temporary = stringListEntry.getValue();             temporary = temporary.stream()                     .sorted(Comparator.comparing(CurrentLawVotesEndBalance::getVotesBoardOfDirectors))                     .limit(directors.getDirector(stringListEntry.getKey()).getCount())                     .collect(Collectors.toList());             original_group.put(directors.getDirector(stringListEntry.getKey()), temporary);         }          //позиции избираемые палатой верховных судей         List<CurrentLawVotesEndBalance> electedByChamberOfSupremeJudges = current.stream()                 .filter(t -> directors.isElectedBYCorporateCouncilOfReferees(t.getPackageName()))                 .filter(t -> t.getVotesCorporateCouncilOfReferees() >= Seting.ORIGINAL_LIMIT_MIN_VOTE_CORPORATE_COUNCIL_OF_REFEREES)                 .sorted(Comparator.comparing(CurrentLawVotesEndBalance::getVotesCorporateCouncilOfReferees)).collect(Collectors.toList());            //избираемые премьер министром         List<CurrentLawVotesEndBalance> GENERAL_EXECUTIVE_DIRECTOR = electedByBoardOfDirectors.stream()                 .filter(t -> directors.isElectedCEO(t.getPackageName()))                 .filter(t -> NamePOSITION.GENERAL_EXECUTIVE_DIRECTOR.toString().equals(t.getPackageName()))                 .filter(t -> t.getVoteGeneralExecutiveDirector() >= Seting.ORIGINAL_LIMIT_MIN_VOTE_GENERAL_EXECUTIVE_DIRECTOR)                 .sorted(Comparator.comparing(CurrentLawVotesEndBalance::getVoteGeneralExecutiveDirector))                 .collect(Collectors.toList());          //избираемые верховным судьей         List<CurrentLawVotesEndBalance> electedByHightJudge = electedByChamberOfSupremeJudges.stream()                 .filter(t -> directors.isElectedBYCorporateCouncilOfReferees(t.getPackageName()))                 .filter(t -> t.getVoteHightJudge() >= Seting.ORIGINAL_LIMIT_MIN_VOTE_HIGHT_JUDGE)                 .collect(Collectors.toList());          //избранные фракции         List<CurrentLawVotesEndBalance> electedFraction = current.stream()                 .filter(t -> directors.isElectedByStocks(t.getPackageName()))                 .filter(t -> t.getPackageName().equals(NamePOSITION.FRACTION.toString()))                 .filter(t -> t.getVotes() >= Seting.ORIGINAL_LIMIT_MIN_VOTE)                 .sorted(Comparator.comparing(CurrentLawVotesEndBalance::getVotes).reversed())                 .limit(directors.getDirector(NamePOSITION.FRACTION.toString()).getCount())                 .collect(Collectors.toList());          curentLawVotesEndBalance.put(\"elected by GENERAL_EXECUTIVE_DIRECTOR: \", GENERAL_EXECUTIVE_DIRECTOR);         curentLawVotesEndBalance.put(\"elected by hight judge: \", electedByHightJudge);         curentLawVotesEndBalance.put(NamePOSITION.BOARD_OF_DIRECTORS.toString(), electedByStockBoardOfDirectors);         curentLawVotesEndBalance.put(NamePOSITION.CORPORATE_COUNCIL_OF_REFEREES.toString(), electedByStockCorporateCouncilOfReferees);         curentLawVotesEndBalance.put(NamePOSITION.HIGH_JUDGE.toString(), electedByChamberOfSupremeJudges);         curentLawVotesEndBalance.put(\"ADD_DIRECTIORS_ \", addDirectors);         curentLawVotesEndBalance.put(NamePOSITION.FRACTION.toString(), electedFraction);          for (Map.Entry<Director, List<CurrentLawVotesEndBalance>> higherSpecialPositionsListMap : original_group.entrySet()) {             curentLawVotesEndBalance.put(higherSpecialPositionsListMap.getKey().toString(), higherSpecialPositionsListMap.getValue());         }           Date finish = new Date();         System.out.println(\"given time: \" + new Date(finish.getTime() - start.getTime()));          model.addAttribute(\"show\", curentLawVotesEndBalance);          model.addAttribute(\"title\", \"current guidance\");          return \"/governments\";     }      @GetMapping(\"/create-position\")     public String createPositionShow(Model model) throws IOException, NoSuchAlgorithmException, InvalidKeySpecException, SignatureException, NoSuchProviderException, InvalidKeyException {         Blockchain blockchain = Mining.getBlockchain(                 Seting.ORIGINAL_BLOCKCHAIN_FILE,                 BlockchainFactoryEnum.ORIGINAL);         Map<String, Account> balances = new HashMap<>();         //считывать баланс         balances = SaveBalances.readLineObject(Seting.ORIGINAL_BALANCE_FILE);          Directors directors = new Directors();          List<LawEligibleForParliamentaryApproval> lawEligibleForParliamentaryApprovals =                 UtilsLaws.readLineCurrentLaws(Seting.ORIGINAL_ALL_CORPORATION_LAWS_WITH_BALANCE_FILE);           List<Account> boardOfShareholders = UtilsGovernment.findBoardOfShareholders(balances, blockchain.getBlockchainList(), Seting.BOARDS_BLOCK);          List<CurrentLawVotesEndBalance> current = UtilsGovernment.filtersVotes(                 lawEligibleForParliamentaryApprovals,                 balances,                 boardOfShareholders,                 blockchain.getBlockchainList(),                 Seting.LAW_YEAR_VOTE);           List<String> positions = directors.getDirectors().stream().map(t->t.getName()).collect(Collectors.toList());         //позиции утвержденные всеми         List<CurrentLawVotesEndBalance> createdByBoardOfDirectors = current.stream()                 .filter(t->t.getPackageName().startsWith(Seting.ADD_DIRECTOR))                 .filter(t->t.getVotesBoardOfDirectors() >= Seting.ORIGINAL_LIMIT_MIN_VOTE_BOARD_OF_DIRECTORS                         && t.getVotesBoardOfShareholders() >= Seting.ORIGINAL_LIMIT_MIN_VOTE_BOARD_OF_SHAREHOLDERS                         && t.getFractionVote() >= Seting.ORIGINAL_LIMIT_MIN_VOTE_FRACTIONS                         && t.getVotes() >= Seting.ALL_STOCK_VOTE)                 .collect(Collectors.toList());         //добавление позиций созданных советом директоров         for (CurrentLawVotesEndBalance currentLawVotesEndBalance : createdByBoardOfDirectors) {             directors.addAllByBoardOfDirectors(currentLawVotesEndBalance.getLaws());         }           positions.addAll(directors.getNames());         positions = positions.stream().distinct().collect(Collectors.toList());         model.addAttribute(\"positions\", positions);         return \"create-position\";     }      /**Отображается в браузере, позволяет создавать новые должности*/     @RequestMapping(value = \"/create-position\", method = RequestMethod.POST, params = \"action=/send\")     public String createLaw(Model model,                             @RequestParam String sender,                             @RequestParam String reward,                             @RequestParam String nameLaw,                             @RequestParam String[] laws,                             @RequestParam String password,                             RedirectAttributes redirectAttrs) throws IOException, NoSuchAlgorithmException, SignatureException, NoSuchProviderException, InvalidKeyException, InvalidKeySpecException {           Laws law = new Laws(nameLaw, Arrays.asList(laws));         Base base = new Base58();          Double rewardD = Double.parseDouble(reward);           DtoTransaction dtoTransaction = new DtoTransaction(                 sender,                 law.getHashLaw(),                 0.0,                 0.0,                 law,                 rewardD,                 VoteEnum.valueOf(\"YES\"));         PrivateKey privateKey = UtilsSecurity.privateBytToPrivateKey(base.decode(password));         byte[] sign = UtilsSecurity.sign(privateKey, dtoTransaction.toSign());          redirectAttrs.addFlashAttribute(\"title\", \"sending result!!!\");         redirectAttrs.addFlashAttribute(\"sender\", sender);          redirectAttrs.addFlashAttribute(\"recipient\", law.getHashLaw());         redirectAttrs.addFlashAttribute(\"dollar\", 0.0);         redirectAttrs.addFlashAttribute(\"stock\", 0.0);         redirectAttrs.addFlashAttribute(\"reward\", rewardD);         redirectAttrs.addFlashAttribute(\"vote\", \"YES\");         dtoTransaction.setSign(sign);          if (dtoTransaction.verify() && UtilsGovernment.checkPostionSenderEqualsLaw(sender, law)) {             redirectAttrs.addFlashAttribute(\"sending\", \"success\");             AllTransactions.addTransaction(dtoTransaction);             String jsonDto = UtilsJson.objToStringJson(dtoTransaction);              for (String s : Seting.ORIGINAL_ADDRESSES) {                 String original = s;                 String url = s + \"/addTransaction\";                 if (BasisController.getExcludedAddresses().contains(url)) {                     System.out.println(\"its your address or excluded address: \" + url);                     continue;                 }                 try {                     UtilUrl.sendPost(jsonDto, url);                  } catch (Exception e) {                     System.out.println(\"exception discovery: \" + original);                  }             }         } else             redirectAttrs.addFlashAttribute(\"sending\", \"wrong transaction\");          return \"redirect:/result-sending\";      } }","package International_Trade_Union.controllers;  import International_Trade_Union.config.BLockchainFactory; import International_Trade_Union.config.BlockchainFactoryEnum; import International_Trade_Union.entity.blockchain.Blockchain; import International_Trade_Union.entity.blockchain.block.Block; import International_Trade_Union.governments.Director; import International_Trade_Union.governments.Directors; import International_Trade_Union.governments.NamePOSITION; import International_Trade_Union.model.FIndPositonHelperData; import International_Trade_Union.model.Mining; import org.springframework.stereotype.Controller; import org.springframework.ui.Model; import org.springframework.web.bind.annotation.*; import org.springframework.web.servlet.mvc.support.RedirectAttributes; import International_Trade_Union.entity.DtoTransaction.DtoTransaction; import International_Trade_Union.governments.UtilsGovernment; import International_Trade_Union.model.Account; import International_Trade_Union.network.AllTransactions; import International_Trade_Union.setings.Seting; import International_Trade_Union.utils.*; import International_Trade_Union.utils.base.Base; import International_Trade_Union.utils.base.Base58; import International_Trade_Union.vote.*;  import java.io.IOException; import java.security.*; import java.security.spec.InvalidKeySpecException; import java.util.*; import java.util.stream.Collectors;   @Controller public class LawsController {       @GetMapping(\"detail-laws\")     public String details(Model model) {         return \"detail-laws\";     }      //TODO реализовать голосвание       /**Отображается в браузере, позволяет увидеть содержимое пакета законов, список действующих законов*/     @GetMapping(\"/detail-laws-current/{addressLaw}\")     public String lawsDetail(@PathVariable(value = \"addressLaw\") String addressLaw, RedirectAttributes redirectAttrs) throws NoSuchAlgorithmException, InvalidKeySpecException, IOException, SignatureException, NoSuchProviderException, InvalidKeyException {         System.out.println(\"LawsController detail-laws-current/{addressLaw}: \" + addressLaw);         redirectAttrs.addAttribute(\"title\", \"detail laws\");         //Seting.ORIGINAL_CURRENT_FEDERAL_LAWS_FILE         List<LawEligibleForParliamentaryApproval> lawEligibleForParliamentaryApprovals =                 UtilsLaws.readLineCurrentLaws(Seting.ORIGINAL_ALL_CORPORATION_LAWS_WITH_BALANCE_FILE);          List<String> currntLaws = new ArrayList<>();         for (LawEligibleForParliamentaryApproval lawEligibleForParliamentaryApproval : lawEligibleForParliamentaryApprovals) {             int i = 0;             if (lawEligibleForParliamentaryApproval.getLaws().getHashLaw().equals(addressLaw)) {                  for (String str : lawEligibleForParliamentaryApproval.getLaws().getLaws()) {                      currntLaws.add(\"\" + i + \": \" + str);                     ++i;                 }              }         }          currntLaws.forEach(System.out::println);         redirectAttrs.addFlashAttribute(\"laws\", currntLaws);         return \"redirect:/detail-laws\";     }      /**Отображается в браузере, показывает содержимое пакета законов, из  списка всех законов*/     @GetMapping(\"/detail-laws-all/{addressLaw}\")     public String lawsDetailAll(@PathVariable(value = \"addressLaw\") String addressLaw, RedirectAttributes redirectAttrs) throws NoSuchAlgorithmException, InvalidKeySpecException, IOException, SignatureException, NoSuchProviderException, InvalidKeyException {         System.out.println(\"LawsController /detail-laws-all/{addressLaw}: \" + addressLaw);         redirectAttrs.addAttribute(\"title\", \"detail laws\");         //ORIGINAL_ALL_CORPORATION_LAWS_FILE         List<Laws> laws = UtilsLaws.readLineLaws(Seting.ORIGINAL_ALL_CORPORATION_LAWS_FILE);         List<String> allLaws = new ArrayList<>();         for (Laws laws1 : laws) {             int i = 0;             if (laws1.getHashLaw().equals(addressLaw)) {                  for (String s : laws1.getLaws()) {                     allLaws.add(\"\" + i + \": \" + s);                     ++i;                 }              }         }          redirectAttrs.addFlashAttribute(\"laws\", allLaws);         return \"redirect:/detail-laws\";     }       @GetMapping(\"/sanction\")     public String sanction(Model model){         return \"/sanction\";     }      @PostMapping(\"/sanction\")     public String sanction(             @RequestParam             String sender,             String recipient,             Double stock,             Double reward,             String password,             RedirectAttributes redirectAttrs      ) throws IOException, NoSuchAlgorithmException, SignatureException, InvalidKeySpecException, NoSuchProviderException, InvalidKeyException {         Base base = new Base58();          Laws laws =  new Laws();         laws.setLaws(new ArrayList<>());         laws.setHashLaw(\"\");         laws.setPacketLawName(\"\");         DtoTransaction dtoTransaction = new DtoTransaction(                 sender,                 recipient,                 0.0,                 stock,                 laws,                 reward,                 VoteEnum.NO);         PrivateKey privateKey = UtilsSecurity.privateBytToPrivateKey(base.decode(password));         byte[] sign = UtilsSecurity.sign(privateKey, dtoTransaction.toSign());         System.out.println(\"Main Controller: new transaction: vote: \" + VoteEnum.NO);         redirectAttrs.addFlashAttribute(\"title\", \"sending result!!!\");         redirectAttrs.addFlashAttribute(\"sender\", sender);         redirectAttrs.addFlashAttribute(\"recipient\", recipient);         redirectAttrs.addFlashAttribute(\"dollar\", 0.0);         redirectAttrs.addFlashAttribute(\"stock\", stock);         redirectAttrs.addFlashAttribute(\"reward\", reward);         redirectAttrs.addFlashAttribute(\"vote\", VoteEnum.NO);         dtoTransaction.setSign(sign);         Directors directors = new Directors();         if(dtoTransaction.verify()){              //если в названия закона совпадает с корпоративными должностями, то закон является действительным только когда             //отправитель совпадает с законом             List<String> corporateSeniorPositions = directors.getDirectors().stream()                     .map(t->t.getName()).collect(Collectors.toList());             System.out.println(\"LawsController: create_law: \" + laws.getPacketLawName() + \"contains: \" + corporateSeniorPositions.contains(laws.getPacketLawName()));             if(corporateSeniorPositions.contains(laws.getPacketLawName()) && !UtilsGovernment.checkPostionSenderEqualsLaw(sender, laws)){                 redirectAttrs.addFlashAttribute(\"sending\", \"wrong transaction: Position to be equals whith send\");                 return \"redirect:/result-sending\";             }             redirectAttrs.addFlashAttribute(\"sending\", \"success\");             System.out.println(\"dto MainController: \" + dtoTransaction);              AllTransactions.addTransaction(dtoTransaction);             String jsonDto = UtilsJson.objToStringJson(dtoTransaction);             for (String s : Seting.ORIGINAL_ADDRESSES) {                  String original = s;                 String url = s +\"/addTransaction\";                 //если адресс совпадает с внутреним хостом, то не отправляет самому себе                 if(BasisController.getExcludedAddresses().contains(url)){                     System.out.println(\"MainController: its your address or excluded address: \" + url);                     continue;                 }                 try {                     //отправка в сеть                     UtilUrl.sendPost(jsonDto, url);                  }catch (Exception e){                     System.out.println(\"exception discover: \" + original);                  }             }            }          else             redirectAttrs.addFlashAttribute(\"sending\", \"wrong transaction\");         return \"redirect:/result-sending\";     }     /**Голосование учитывает голоса как акций, так и голоса избраных представителей*/     @GetMapping(\"/voting\")     public String lawVoting(){         return \"/voting\";     }     @PostMapping(\"/voting\")     public String lawVoting(             @RequestParam             String sender,             String recipient,             Double reward,             String vote,             String password,             RedirectAttributes redirectAttrs      ) throws IOException, NoSuchAlgorithmException, SignatureException, InvalidKeySpecException, NoSuchProviderException, InvalidKeyException {         Base base = new Base58();         vote = vote.toUpperCase(Locale.ROOT);         Laws laws =  new Laws();         laws.setLaws(new ArrayList<>());         laws.setHashLaw(\"\");         laws.setPacketLawName(\"\");         System.out.println(\"LawController: Voting: \" + VoteEnum.valueOf(vote));         DtoTransaction dtoTransaction = new DtoTransaction(                 sender,                 recipient,                 0.0,                 0.0,                 laws,                 reward,                 VoteEnum.valueOf(vote));         PrivateKey privateKey = UtilsSecurity.privateBytToPrivateKey(base.decode(password));         byte[] sign = UtilsSecurity.sign(privateKey, dtoTransaction.toSign());         System.out.println(\"Main Controller: new transaction: vote: \" + vote);         redirectAttrs.addFlashAttribute(\"title\", \"sending result!!!\");         redirectAttrs.addFlashAttribute(\"sender\", sender);         redirectAttrs.addFlashAttribute(\"recipient\", recipient);         redirectAttrs.addFlashAttribute(\"dollar\", 0.0);         redirectAttrs.addFlashAttribute(\"stock\", 0.0);         redirectAttrs.addFlashAttribute(\"reward\", reward);         redirectAttrs.addFlashAttribute(\"vote\", vote);         dtoTransaction.setSign(sign);         Directors directors = new Directors();         if(dtoTransaction.verify()){              //если в названия закона совпадает с корпоративными должностями, то закон является действительным только когда             //отправитель совпадает с законом             List<String> corporateSeniorPositions = directors.getDirectors().stream()                     .map(t->t.getName()).collect(Collectors.toList());             System.out.println(\"LawsController: create_law: \" + laws.getPacketLawName() + \"contains: \" + corporateSeniorPositions.contains(laws.getPacketLawName()));             if(corporateSeniorPositions.contains(laws.getPacketLawName()) && !UtilsGovernment.checkPostionSenderEqualsLaw(sender, laws)){                 redirectAttrs.addFlashAttribute(\"sending\", \"wrong transaction: Position to be equals whith send\");                 return \"redirect:/result-sending\";             }             redirectAttrs.addFlashAttribute(\"sending\", \"success\");             System.out.println(\"dto MainController: \" + dtoTransaction);              AllTransactions.addTransaction(dtoTransaction);             String jsonDto = UtilsJson.objToStringJson(dtoTransaction);             for (String s : Seting.ORIGINAL_ADDRESSES) {                  String original = s;                 String url = s +\"/addTransaction\";                 //если адресс совпадает с внутреним хостом, то не отправляет самому себе                 if(BasisController.getExcludedAddresses().contains(url)){                     System.out.println(\"MainController: its your address or excluded address: \" + url);                     continue;                 }                 try {                     //отправка в сеть                     UtilUrl.sendPost(jsonDto, url);                  }catch (Exception e){                     System.out.println(\"exception discover: \" + original);                  }             }            }          else             redirectAttrs.addFlashAttribute(\"sending\", \"wrong transaction\");         return \"redirect:/result-sending\";     }     /**Отображается в браузере, список все действующих законов*/     @GetMapping(\"/current-laws\")     public String currentLaw(Model model) throws IOException, NoSuchAlgorithmException, InvalidKeySpecException, SignatureException, NoSuchProviderException, InvalidKeyException, CloneNotSupportedException {         Directors directors = new Directors();         Blockchain blockchain = Mining.getBlockchain(                 Seting.ORIGINAL_BLOCKCHAIN_FILE,                 BlockchainFactoryEnum.ORIGINAL);          Map<String, Account> balances = new HashMap<>();         //считывать баланс         balances = SaveBalances.readLineObject(Seting.ORIGINAL_BALANCE_FILE);          List<LawEligibleForParliamentaryApproval> lawEligibleForParliamentaryApprovals =                 UtilsLaws.readLineCurrentLaws(Seting.ORIGINAL_ALL_CORPORATION_LAWS_WITH_BALANCE_FILE);          //получить совет акционеров из файла         List<Account> boardOfShareholders = UtilsGovernment.findBoardOfShareholders(balances, blockchain.getBlockchainList(), Seting.BOARDS_BLOCK);           //TODO доработать оптимизацию         //TODO избавиться от find position в данном методе         //отфильтровать по типам голосов         Map<Director, FIndPositonHelperData> fIndPositonHelperDataMap = new HashMap<>();         for (Director higherSpecialPositions : directors.getDirectors()) {             if (higherSpecialPositions.isElectedByCEO()) {                 fIndPositonHelperDataMap.put(higherSpecialPositions,                         new FIndPositonHelperData(higherSpecialPositions, false, false, true, false, false));             } else if (higherSpecialPositions.isElectedByBoardOfDirectors()) {                 fIndPositonHelperDataMap.put(higherSpecialPositions,                         new FIndPositonHelperData(higherSpecialPositions, false, false, false, true, false));             } else if (higherSpecialPositions.isElectedByCorporateCouncilOfReferees()) {                 fIndPositonHelperDataMap.put(higherSpecialPositions,                         new FIndPositonHelperData(higherSpecialPositions, false, false, false, false, true));             } else {                 fIndPositonHelperDataMap.put(higherSpecialPositions,                         new FIndPositonHelperData(higherSpecialPositions, true, true, false, false, false));              }          }         //подсчитать голоса за все проголосованные заканы         List<CurrentLawVotesEndBalance> current = UtilsGovernment.filtersVotes(                 lawEligibleForParliamentaryApprovals,                 balances,                 boardOfShareholders,                 blockchain.getBlockchainList(),                 Seting.LAW_YEAR_VOTE);             //минимальное значение количество положительных голосов для того чтобы закон действовал,         //позиции избираемые акциями совета директоров         List<CurrentLawVotesEndBalance> electedByStockBoardOfDirectors = current.stream()                 .filter(t -> directors.isElectedByStocks(t.getPackageName()))                 .filter(t -> t.getPackageName().equals(NamePOSITION.BOARD_OF_DIRECTORS.toString()))                 .filter(t -> t.getVotes() >= Seting.ORIGINAL_LIMIT_MIN_VOTE)                 .sorted(Comparator.comparing(CurrentLawVotesEndBalance::getVotes).reversed())                 .limit(directors.getDirector(NamePOSITION.BOARD_OF_DIRECTORS.toString()).getCount())                 .collect(Collectors.toList());          //избранные фракции         List<CurrentLawVotesEndBalance> electedFraction = current.stream()                 .filter(t -> directors.isElectedByStocks(t.getPackageName()))                 .filter(t -> t.getPackageName().equals(NamePOSITION.FRACTION.toString()))                 .filter(t -> t.getVotes() >= Seting.ORIGINAL_LIMIT_MIN_VOTE)                 .sorted(Comparator.comparing(CurrentLawVotesEndBalance::getVotes).reversed())                 .limit(directors.getDirector(NamePOSITION.FRACTION.toString()).getCount())                 .collect(Collectors.toList());         //минимальное значение количество положительных голосов для того чтобы закон действовал,         //позиции избираемые акциями CORPORATE_COUNCIL_OF_REFEREES         List<CurrentLawVotesEndBalance> electedByStockCorporateCouncilOfReferees = current.stream()                 .filter(t -> directors.isElectedByStocks(t.getPackageName()))                 .filter(t -> t.getPackageName().equals(NamePOSITION.CORPORATE_COUNCIL_OF_REFEREES.toString()))                 .filter(t -> t.getVotes() >= Seting.ORIGINAL_LIMIT_MIN_VOTE)                 .sorted(Comparator.comparing(CurrentLawVotesEndBalance::getVotes).reversed())                 .limit(directors.getDirector(NamePOSITION.CORPORATE_COUNCIL_OF_REFEREES.toString()).getCount())                 .collect(Collectors.toList());            //позиции созданные всеми участниками         List<CurrentLawVotesEndBalance> createdByBoardOfDirectors = current.stream()                 .filter(t->t.getPackageName().startsWith(Seting.ADD_DIRECTOR))                 .filter(t->t.getVotesBoardOfDirectors() >= Seting.ORIGINAL_LIMIT_MIN_VOTE_BOARD_OF_DIRECTORS                 && t.getVotesBoardOfShareholders() >= Seting.ORIGINAL_LIMIT_MIN_VOTE_BOARD_OF_SHAREHOLDERS                 && t.getFractionVote() >= Seting.ORIGINAL_LIMIT_MIN_VOTE_FRACTIONS                 && t.getVotes() >= Seting.ALL_STOCK_VOTE)                 .collect(Collectors.toList());         //добавление позиций созданных советом директоров         for (CurrentLawVotesEndBalance currentLawVotesEndBalance : createdByBoardOfDirectors) {             directors.addAllByBoardOfDirectors(currentLawVotesEndBalance.getLaws());         }          //позиции избираемые только всеми участниками         List<CurrentLawVotesEndBalance> electedByBoardOfDirectors = current.stream()                 .filter(t -> directors.isElectedByBoardOfDirectors(t.getPackageName()) || directors.isCabinets(t.getPackageName()))                 .filter(t -> t.getVotesBoardOfDirectors() >= Seting.ORIGINAL_LIMIT_MIN_VOTE_BOARD_OF_DIRECTORS                 && t.getVotesBoardOfShareholders() >= Seting.ORIGINAL_LIMIT_MIN_VOTE_BOARD_OF_SHAREHOLDERS                 && t.getFractionVote() >= Seting.ORIGINAL_LIMIT_MIN_VOTE_FRACTIONS                 && t.getVotes() >= Seting.ALL_STOCK_VOTE)                 .sorted(Comparator.comparing(CurrentLawVotesEndBalance::getVotesBoardOfDirectors).reversed())                 .collect(Collectors.toList());           //групируем по списку         Map<String, List<CurrentLawVotesEndBalance>> group = electedByBoardOfDirectors.stream()                 .collect(Collectors.groupingBy(CurrentLawVotesEndBalance::getPackageName));          Map<Director, List<CurrentLawVotesEndBalance>> original_group = new HashMap<>();          //оставляем то количество которое описано в данной должности         for (Map.Entry<String, List<CurrentLawVotesEndBalance>> stringListEntry : group.entrySet()) {             List<CurrentLawVotesEndBalance> temporary = stringListEntry.getValue();             temporary = temporary.stream()                     .sorted(Comparator.comparing(CurrentLawVotesEndBalance::getVotesBoardOfDirectors))                     .limit(directors.getDirector(stringListEntry.getKey()).getCount())                     .collect(Collectors.toList());             original_group.put(directors.getDirector(stringListEntry.getKey()), temporary);         }            //позиции избираемые советом корпоративных верховных судей         List<CurrentLawVotesEndBalance> electedByCorporateCouncilOfReferees = current.stream()                 .filter(t -> directors.isElectedBYCorporateCouncilOfReferees(t.getPackageName()))                 .filter(t -> t.getVotesCorporateCouncilOfReferees() >= Seting.ORIGINAL_LIMIT_MIN_VOTE_CORPORATE_COUNCIL_OF_REFEREES)                 .sorted(Comparator.comparing(CurrentLawVotesEndBalance::getVotesCorporateCouncilOfReferees)).collect(Collectors.toList());           //избираемые GENERAL_EXECUTIVE_DIRECTOR         List<CurrentLawVotesEndBalance> electedByGeneralExecutiveDirector = electedByBoardOfDirectors.stream()                 .filter(t -> directors.isElectedCEO(t.getPackageName()))                 .filter(t -> NamePOSITION.GENERAL_EXECUTIVE_DIRECTOR.toString().equals(t.getPackageName()))                 .filter(t -> t.getVoteGeneralExecutiveDirector() >= Seting.ORIGINAL_LIMIT_MIN_VOTE_GENERAL_EXECUTIVE_DIRECTOR)                 .sorted(Comparator.comparing(CurrentLawVotesEndBalance::getVoteGeneralExecutiveDirector))                 .collect(Collectors.toList());          //голос верховного судьи         List<CurrentLawVotesEndBalance> electedByHightJudge = electedByCorporateCouncilOfReferees.stream()                 .filter(t -> directors.isElectedBYCorporateCouncilOfReferees(t.getPackageName()))                 .filter(t -> t.getVoteHightJudge() >= Seting.ORIGINAL_LIMIT_MIN_VOTE_HIGHT_JUDGE)                 .collect(Collectors.toList());           //законы должны быть одобрены всеми.         List<CurrentLawVotesEndBalance> notEnoughVotes = current.stream()                 .filter(t -> !directors.contains(t.getPackageName()))                 .filter(t->!Seting.AMENDMENT_TO_THE_CHARTER.equals(t.getPackageName()))                 .filter(t->!directors.isCabinets(t.getPackageName()))                 .filter(t -> !Seting.ORIGINAL_CHARTER_CURRENT_LAW_PACKAGE_NAME.equals(t.getPackageName()))                 .filter(t->!Seting.ORIGINAL_CHARTER_CURRENT_ALL_CODE.equals(t.getPackageName()))                 .filter(t -> t.getVotesBoardOfShareholders() >= Seting.ORIGINAL_LIMIT_MIN_VOTE_BOARD_OF_SHAREHOLDERS                 && t.getVotesBoardOfDirectors() >= Seting.ORIGINAL_LIMIT_MIN_VOTE_BOARD_OF_DIRECTORS                 && t.getVotes() >= Seting.ALL_STOCK_VOTE                 && t.getFractionVote() >= Seting.ORIGINAL_LIMIT_MIN_VOTE_FRACTIONS)                 .sorted(Comparator.comparing(CurrentLawVotesEndBalance::getVotes).reversed()).collect(Collectors.toList());            //внедрение поправок в устав         List<CurrentLawVotesEndBalance> chapter_amendment = current.stream()                 .filter(t -> !directors.contains(t.getPackageName()))                 .filter(t-> Seting.AMENDMENT_TO_THE_CHARTER.equals(t.getPackageName()))                 .filter(t->!directors.isCabinets(t.getPackageName()))                 .filter(t -> t.getVotesBoardOfShareholders() >= Seting.ORIGINAL_LIMIT_MINT_VOTE_BOARD_OF_SHAREHOLDERS_AMENDMENT                 && t.getVotesBoardOfDirectors() >= Seting.ORIGINAL_LIMIT_MIN_VOTE_BOARD_OF_DIRECTORS_AMENDMENT                 && t.getVotesCorporateCouncilOfReferees() >= Seting.ORIGINAL_LIMIT_MIN_VOTE_CORPORATE_COUNCIL_OF_REFEREES_AMENDMENT                 && t.getFractionVote() >= Seting.ORIGINAL_LIMIT_MIN_VOTE_FRACTIONS)                 .sorted(Comparator.comparing(CurrentLawVotesEndBalance::getVotesBoardOfDirectors).reversed()).collect(Collectors.toList());          //бюджет утверждается всеми         List<CurrentLawVotesEndBalance> budjet = current.stream()                 .filter(t-> !directors.contains(t.getPackageName()))                 .filter(t->Seting.BUDGET.equals(t.getPackageName()))                 .filter(t->!directors.isCabinets(t.getPackageName()))                 .filter(t->                         t.getVotesBoardOfDirectors() >= Seting.ORIGINAL_LIMIT_MIN_VOTE_BOARD_OF_DIRECTORS                         && t.getVotesBoardOfShareholders() >= Seting.ORIGINAL_LIMIT_MIN_VOTE_BOARD_OF_SHAREHOLDERS                         && t.getFractionVote() >= Seting.ORIGINAL_LIMIT_MIN_VOTE_FRACTIONS                         && t.getVotes() >= Seting.ALL_STOCK_VOTE)                 .sorted(Comparator.comparing(CurrentLawVotesEndBalance::getVotesBoardOfDirectors).reversed())                 .limit(1)                 .collect(Collectors.toList());           //добавляет законы, которые создают новые должности утверждается всеми         List<CurrentLawVotesEndBalance> addDirectors = current.stream()                 .filter(t->t.getPackageName().startsWith(Seting.ADD_DIRECTOR))                 .filter(t->t.getVotesBoardOfDirectors() >= Seting.ORIGINAL_LIMIT_MIN_VOTE_BOARD_OF_DIRECTORS                 && t.getVotesBoardOfShareholders() >= Seting.ORIGINAL_LIMIT_MIN_VOTE_BOARD_OF_SHAREHOLDERS                 && t.getFractionVote() >= Seting.ORIGINAL_LIMIT_MIN_VOTE_FRACTIONS                 && t.getVotes() >= Seting.ALL_STOCK_VOTE)                 .collect(Collectors.toList());          //план утверждается всеми         List<CurrentLawVotesEndBalance> planFourYears = current.stream()                 .filter(t->!directors.contains(t.getPackageName()))                 .filter(t->Seting.STRATEGIC_PLAN.equals(t.getPackageName()))                 .filter(t->!directors.isCabinets(t.getPackageName()))                 .filter(t->t.getVotesBoardOfDirectors() >= Seting.ORIGINAL_LIMIT_MIN_VOTE_BOARD_OF_DIRECTORS                         && t.getVotesBoardOfShareholders() >= Seting.ORIGINAL_LIMIT_MIN_VOTE_BOARD_OF_SHAREHOLDERS                         && t.getFractionVote() >= Seting.ORIGINAL_LIMIT_MIN_VOTE_FRACTIONS                         && t.getVotes() >= Seting.ALL_STOCK_VOTE)                 .sorted(Comparator.comparing(CurrentLawVotesEndBalance::getVotesBoardOfDirectors).reversed())                 .limit(1)                 .collect(Collectors.toList());           //устав всегда действующий он подписан основателем         List<CurrentLawVotesEndBalance> CHARTER_ORIGINAL = current.stream()                 .filter(t -> !directors.contains(t.getPackageName()) && Seting.ORIGINAL_CHARTER_CURRENT_LAW_PACKAGE_NAME.equals(t.getPackageName()))                 .filter(t->!directors.isCabinets(t.getPackageName()))                 .filter(t->t.getFounderVote()>=1)                 .sorted(Comparator.comparing(CurrentLawVotesEndBalance::getVotes).reversed())                 .limit(1)                 .collect(Collectors.toList());          //ИСХОДНЫЙ КОД СОЗДАННЫЙ ОСНОВАТЕЛЕМ         List<CurrentLawVotesEndBalance> CHARTER_ORIGINAL_CODE = current.stream()                 .filter(t -> !directors.contains(t.getPackageName()) && Seting.ORIGINAL_CHARTER_CURRENT_ALL_CODE.equals(t.getPackageName()))                 .filter(t->!directors.isCabinets(t.getPackageName()))                 .filter(t->t.getFounderVote()>=1)                 .sorted(Comparator.comparing(CurrentLawVotesEndBalance::getVotes).reversed())                 .limit(1)                 .collect(Collectors.toList());           int startBlock = 23660;         int finishBlock = 23670;         if(blockchain.sizeBlockhain() > finishBlock){             List<Block> blocksCharter = blockchain.subBlock(startBlock, finishBlock);             //учитывает отрезок блоков для выяснения подлиности устава             List<CurrentLawVotesEndBalance> charterBlocks = UtilsGovernment.filtersVotes(                     lawEligibleForParliamentaryApprovals,                     balances,                     boardOfShareholders,                     blocksCharter,                     Seting.LAW_YEAR_VOTE             );             List<CurrentLawVotesEndBalance> charterCheckBlock = charterBlocks.stream()                     .filter(t -> !directors.contains(t.getPackageName()) && Seting.ORIGINAL_CHARTER_CURRENT_LAW_PACKAGE_NAME.equals(t.getPackageName()))                     .filter(t->!directors.isCabinets(t.getPackageName()))                     .filter(t->t.getFounderVote()>=1)                     .sorted(Comparator.comparing(CurrentLawVotesEndBalance::getVotes).reversed())                     .limit(1)                     .collect(Collectors.toList());              CHARTER_ORIGINAL.addAll(charterCheckBlock);               List<CurrentLawVotesEndBalance> charterOriginalCode = charterBlocks.stream()                     .filter(t -> !directors.contains(t.getPackageName()) && Seting.ORIGINAL_CHARTER_CURRENT_ALL_CODE.equals(t.getPackageName()))                     .filter(t->!directors.isCabinets(t.getPackageName()))                     .filter(t->t.getFounderVote()>=1)                     .sorted(Comparator.comparing(CurrentLawVotesEndBalance::getVotes).reversed())                     .limit(1)                     .collect(Collectors.toList());              CHARTER_ORIGINAL_CODE.addAll(charterOriginalCode);         }           for (Map.Entry<Director, List<CurrentLawVotesEndBalance>> higherSpecialPositionsListMap : original_group.entrySet()) {             current.addAll(higherSpecialPositionsListMap.getValue());         }           current = new ArrayList<>();         current.addAll(addDirectors);         current.addAll(budjet);         current.addAll(electedFraction);         current.addAll(planFourYears);         current.addAll(electedByStockBoardOfDirectors);         current.addAll(electedByStockCorporateCouncilOfReferees);         current.addAll(electedByBoardOfDirectors);         current.addAll(electedByCorporateCouncilOfReferees);         current.addAll(electedByGeneralExecutiveDirector);         current.addAll(electedByHightJudge);         current.addAll(notEnoughVotes);         current.addAll(CHARTER_ORIGINAL);         current.addAll(CHARTER_ORIGINAL_CODE);         current.addAll(chapter_amendment);         current = current.stream()                 .filter(UtilsUse.distinctByKey(CurrentLawVotesEndBalance::getAddressLaw))                 .collect(Collectors.toList());         System.out.println(\"notEnoughVotes: \" + notEnoughVotes);          model.addAttribute(\"title\", \"How the current laws are made is described in the charter.\" +                 \" \");         model.addAttribute(\"currentLaw\", current);         return \"current-laws\";     }      /**Отображается в браузере, список всех пакета законов*/     @GetMapping(\"/all-laws\")     public String allLaws(Model model) throws IOException, NoSuchAlgorithmException, InvalidKeySpecException, SignatureException, NoSuchProviderException, InvalidKeyException {         Blockchain blockchain = Mining.getBlockchain(                 Seting.ORIGINAL_BLOCKCHAIN_FILE,                 BlockchainFactoryEnum.ORIGINAL);          Map<String, Account> balances = new HashMap<>();         balances = SaveBalances.readLineObject(Seting.ORIGINAL_BALANCE_FILE);           List<Account> boardOfShareholders = UtilsGovernment.findBoardOfShareholders(balances, blockchain.getBlockchainList(), Seting.BOARDS_BLOCK);           List<LawEligibleForParliamentaryApproval> lawEligibleForParliamentaryApprovals =                 UtilsLaws.readLineCurrentLaws(Seting.ORIGINAL_ALL_CORPORATION_LAWS_WITH_BALANCE_FILE);         //данные для отображения           Directors directors = new Directors();         //TODO доработать оптимизацию         //TODO избавиться от find position в данном методе         //TODO доработать оптимизацию         //TODO избавиться от find position в данном методе         Map<Director, FIndPositonHelperData> fIndPositonHelperDataMap = new HashMap<>();         for (Director higherSpecialPositions : directors.getDirectors()) {             if (higherSpecialPositions.isElectedByCEO()) {                 fIndPositonHelperDataMap.put(higherSpecialPositions,                         new FIndPositonHelperData(higherSpecialPositions, false, false, true, false, false));             } else if (higherSpecialPositions.isElectedByBoardOfDirectors()) {                 fIndPositonHelperDataMap.put(higherSpecialPositions,                         new FIndPositonHelperData(higherSpecialPositions, false, false, false, true, false));             } else if (higherSpecialPositions.isElectedByCorporateCouncilOfReferees()) {                 fIndPositonHelperDataMap.put(higherSpecialPositions,                         new FIndPositonHelperData(higherSpecialPositions, false, false, false, false, true));             } else if (higherSpecialPositions.isElectedByStocks()) {                 fIndPositonHelperDataMap.put(higherSpecialPositions,                         new FIndPositonHelperData(higherSpecialPositions, true, true, false, false, false));              }          }           List<CurrentLawVotesEndBalance> current = UtilsGovernment.filtersVotes(                 lawEligibleForParliamentaryApprovals,                 balances,                 boardOfShareholders,                 blockchain.getBlockchainList(),                 Seting.LAW_YEAR_VOTE);           current = current.stream().distinct().collect(Collectors.toList());          current = current.stream().sorted(Comparator.comparing(CurrentLawVotesEndBalance::getVotes).reversed()).collect(Collectors.toList());         model.addAttribute(\"allLaws\", current);         return \"all-laws\";     }       /**Создать новую должность*/     @GetMapping(\"/add_position\")     public String addPostion(Model model){         model.addAttribute(\"title\", \"Create a new position\");         return \"add_position\";     }      @PostMapping(\"/add_position\")     public String addPosition( @RequestParam String sender,                                @RequestParam String reward,                                @RequestParam String nameLaw,                                @RequestParam String[] laws,                                @RequestParam String password,                                RedirectAttributes redirectAttrs) throws IOException, NoSuchAlgorithmException, SignatureException, InvalidKeySpecException, NoSuchProviderException, InvalidKeyException {          nameLaw = Seting.ADD_DIRECTOR + nameLaw;         String[] lawsAdd = new String[laws.length];         for (int i = 0; i < laws.length; i++) {             lawsAdd[i] = Seting.ADD_DIRECTOR + laws[i];         }         laws = lawsAdd;          Laws law = new Laws(nameLaw, Arrays.asList(laws));         Base base = new Base58();          Double rewardD = Double.parseDouble(reward);           DtoTransaction dtoTransaction = new DtoTransaction(                 sender,                 law.getHashLaw(),                 0.0,                 0.0,                 law,                 rewardD,                 VoteEnum.valueOf(\"YES\"));         PrivateKey privateKey = UtilsSecurity.privateBytToPrivateKey(base.decode(password));         byte[] sign = UtilsSecurity.sign(privateKey, dtoTransaction.toSign());          redirectAttrs.addFlashAttribute(\"title\", \"sending result!!!\");         redirectAttrs.addFlashAttribute(\"sender\", sender);          redirectAttrs.addFlashAttribute(\"recipient\", law.getHashLaw());         redirectAttrs.addFlashAttribute(\"dollar\", 0.0);         redirectAttrs.addFlashAttribute(\"stock\", 0.0);         redirectAttrs.addFlashAttribute(\"reward\", rewardD);         redirectAttrs.addFlashAttribute(\"vote\", \"YES\");         dtoTransaction.setSign(sign);          Directors directors = new Directors();         if (dtoTransaction.verify()) {              //если в названия закона совпадает с корпоративными должностями, то закон является действительным только когда             //отправитель совпадает с законом             List<Director> enumPosition = directors.getDirectors();             List<String> corporateSeniorPositions = enumPosition.stream()                     .map(t->t.getName())                     .collect(Collectors.toList());              if (corporateSeniorPositions.contains(law.getPacketLawName()) && !UtilsGovernment.checkPostionSenderEqualsLaw(sender, law)) {                 redirectAttrs.addFlashAttribute(\"sending\", \"wrong transaction: Position to be equals whith send\");                 return \"redirect:/result-sending\";             }              redirectAttrs.addFlashAttribute(\"sending\", \"success\");             AllTransactions.addTransaction(dtoTransaction);             String jsonDto = UtilsJson.objToStringJson(dtoTransaction);              for (String s : Seting.ORIGINAL_ADDRESSES) {                 String original = s;                 String url = s + \"/addTransaction\";                 if (BasisController.getExcludedAddresses().contains(url)) {                     System.out.println(\"its your address or excluded address: \" + url);                     continue;                 }                 try {                     UtilUrl.sendPost(jsonDto, url);                  } catch (Exception e) {                     System.out.println(\"exception discovery: \" + original);                  }             }         } else             redirectAttrs.addFlashAttribute(\"sending\", \"wrong transaction\");          return \"redirect:/result-sending\";      }      /**Отображается в браузере, позволяет создать новый пакет законов*/     @GetMapping(\"/create-law\")     public String createLawsShow(Model model) {         return \"create-law\";     }       @RequestMapping(value = \"/create-law\", method = RequestMethod.POST, params = \"action=/send\")     public String createLaw(Model model,                             @RequestParam String sender,                             @RequestParam String reward,                             @RequestParam String nameLaw,                             @RequestParam String[] laws,                             @RequestParam String password,                             RedirectAttributes redirectAttrs) throws IOException, NoSuchAlgorithmException, SignatureException, NoSuchProviderException, InvalidKeyException, InvalidKeySpecException {           Laws law = new Laws(nameLaw, Arrays.asList(laws));         Base base = new Base58();          Double rewardD = Double.parseDouble(reward);           DtoTransaction dtoTransaction = new DtoTransaction(                 sender,                 law.getHashLaw(),                 0.0,                 0.0,                 law,                 rewardD,                 VoteEnum.valueOf(\"YES\"));         PrivateKey privateKey = UtilsSecurity.privateBytToPrivateKey(base.decode(password));         byte[] sign = UtilsSecurity.sign(privateKey, dtoTransaction.toSign());          redirectAttrs.addFlashAttribute(\"title\", \"sending result!!!\");         redirectAttrs.addFlashAttribute(\"sender\", sender);          redirectAttrs.addFlashAttribute(\"recipient\", law.getHashLaw());         redirectAttrs.addFlashAttribute(\"dollar\", 0.0);         redirectAttrs.addFlashAttribute(\"stock\", 0.0);         redirectAttrs.addFlashAttribute(\"reward\", rewardD);         redirectAttrs.addFlashAttribute(\"vote\", \"YES\");         dtoTransaction.setSign(sign);          Directors directors = new Directors();         if (dtoTransaction.verify()) {              //если в названия закона совпадает с корпоративными должностями, то закон является действительным только когда             //отправитель совпадает с законом             List<Director> enumPosition = directors.getDirectors();             List<String> corporateSeniorPositions = enumPosition.stream()                     .map(t->t.getName())                     .collect(Collectors.toList());              if (corporateSeniorPositions.contains(law.getPacketLawName()) && !UtilsGovernment.checkPostionSenderEqualsLaw(sender, law)) {                 redirectAttrs.addFlashAttribute(\"sending\", \"wrong transaction: Position to be equals whith send\");                 return \"redirect:/result-sending\";             }              redirectAttrs.addFlashAttribute(\"sending\", \"success\");             AllTransactions.addTransaction(dtoTransaction);             String jsonDto = UtilsJson.objToStringJson(dtoTransaction);              for (String s : Seting.ORIGINAL_ADDRESSES) {                 String original = s;                 String url = s + \"/addTransaction\";                 if (BasisController.getExcludedAddresses().contains(url)) {                     System.out.println(\"its your address or excluded address: \" + url);                     continue;                 }                 try {                     UtilUrl.sendPost(jsonDto, url);                  } catch (Exception e) {                     System.out.println(\"exception discovery: \" + original);                  }             }         } else             redirectAttrs.addFlashAttribute(\"sending\", \"wrong transaction\");          return \"redirect:/result-sending\";      }  }","package International_Trade_Union.controllers;  import International_Trade_Union.about_us_engDraft.AboutUsEngDraft; import International_Trade_Union.governments.Director; import International_Trade_Union.governments.Directors; import International_Trade_Union.governments.UtilsGovernment; import International_Trade_Union.originalCorporateCharter.OriginalPreamble; import International_Trade_Union.originalCorporateCharter.OriginalPreambleEng;  import org.json.JSONException; import org.springframework.http.HttpStatus; import org.springframework.http.ResponseEntity; import org.springframework.stereotype.Controller; import org.springframework.ui.Model; import org.springframework.web.bind.annotation.GetMapping; import org.springframework.web.bind.annotation.PostMapping; import org.springframework.web.bind.annotation.RequestParam; import org.springframework.web.servlet.mvc.support.RedirectAttributes; import International_Trade_Union.entity.DtoTransaction.DtoTransaction; import International_Trade_Union.model.Account; import International_Trade_Union.model.User; import International_Trade_Union.network.AllTransactions; import International_Trade_Union.setings.Seting; import International_Trade_Union.utils.*; import International_Trade_Union.utils.base.Base; import International_Trade_Union.utils.base.Base58; import International_Trade_Union.vote.Laws; import International_Trade_Union.vote.VoteEnum;   import java.io.IOException; import java.net.http.WebSocket; import java.security.*; import java.security.spec.InvalidKeySpecException; import java.util.*; import java.util.stream.Collectors;  @Controller public class MainController {      @GetMapping(\"/\")     public String home(Model model) throws IOException, NoSuchAlgorithmException, InvalidKeySpecException, SignatureException, NoSuchProviderException, InvalidKeyException {           model.addAttribute(\"title\", \"Corporation International Trade Union.\");         Map<String, Account> balances = new HashMap<>();          //догрузить блокчейн //        List<Block> blocks = UtilsBlock.readLineObject(Seting.ORIGINAL_BLOCKCHAIN_FILE); //        balances = UtilsBalance.calculateBalances(blocks);         balances = SaveBalances.readLineObject(Seting.ORIGINAL_BALANCE_FILE);           Account account = UtilsBalance.getBalance(User.getUserAddress(), balances);         model.addAttribute(\"account\", account);          return \"home\";     }       @PostMapping(\"/setMinner\")     public String setMinnerAddress(@RequestParam(value = \"setMinner\") String setMinner, RedirectAttributes redirectAttrs){         System.out.println(\"MainController:  \" + setMinner);         UtilsFileSaveRead.save(setMinner, Seting.ORIGINAL_ACCOUNT, false);         return \"redirect:/home\";     }        @GetMapping(\"about\")     public String aboutUs(Model model){         model.addAttribute(\"title\", \"ABOUT US\");         model.addAttribute(\"eng\", OriginalPreambleEng.ARTICLE_0);         model.addAttribute(\"rus\", OriginalPreamble.ARTICLE_0);         return \"about\";     }     @GetMapping(\"result-sending\")     public String resultSending(Model model){          return \"result-sending\";     }      @PostMapping(\"/\")     public String new_transaction(             @RequestParam  String sender,             @RequestParam  String recipient,                                    Double dollar,                                    Double stock,                                    Double reward,                                    @RequestParam  String password,                                   RedirectAttributes redirectAttrs) throws IOException, NoSuchAlgorithmException, SignatureException, InvalidKeySpecException, NoSuchProviderException, InvalidKeyException {         Base base = new Base58();          Laws laws =  new Laws();         laws.setLaws(new ArrayList<>());         laws.setHashLaw(\"\");         laws.setPacketLawName(\"\");         DtoTransaction dtoTransaction = new DtoTransaction(                 sender,                 recipient,                 dollar,                 stock,                 laws,                 reward,                 VoteEnum.YES);         PrivateKey privateKey = UtilsSecurity.privateBytToPrivateKey(base.decode(password));         byte[] sign = UtilsSecurity.sign(privateKey, dtoTransaction.toSign());         System.out.println(\"Main Controller: new transaction: vote: \" +VoteEnum.YES);         redirectAttrs.addFlashAttribute(\"title\", \"sending result!!!\");         redirectAttrs.addFlashAttribute(\"sender\", sender);         redirectAttrs.addFlashAttribute(\"recipient\", recipient);         redirectAttrs.addFlashAttribute(\"dollar\", dollar);         redirectAttrs.addFlashAttribute(\"stock\", stock);         redirectAttrs.addFlashAttribute(\"reward\", reward);         redirectAttrs.addFlashAttribute(\"vote\", VoteEnum.YES);         dtoTransaction.setSign(sign);         Directors directors = new Directors();         if(dtoTransaction.verify()){              //если в названия закона совпадает с корпоративными должностями, то закон является действительным только когда             //отправитель совпадает с законом             List<String> corporateSeniorPositions = directors.getDirectors().stream()                     .map(t->t.getName()).collect(Collectors.toList());             System.out.println(\"LawsController: create_law: \" + laws.getPacketLawName() + \"contains: \" + corporateSeniorPositions.contains(laws.getPacketLawName()));             if(corporateSeniorPositions.contains(laws.getPacketLawName()) && !UtilsGovernment.checkPostionSenderEqualsLaw(sender, laws)){                 redirectAttrs.addFlashAttribute(\"sending\", \"wrong transaction: Position to be equals whith send\");                 return \"redirect:/result-sending\";             }             redirectAttrs.addFlashAttribute(\"sending\", \"success\");             System.out.println(\"dto MainController: \" + dtoTransaction);              AllTransactions.addTransaction(dtoTransaction);             String jsonDto = UtilsJson.objToStringJson(dtoTransaction);             for (String s : Seting.ORIGINAL_ADDRESSES) {                  String original = s;                 String url = s +\"/addTransaction\";                 //если адресс совпадает с внутреним хостом, то не отправляет самому себе                 if(BasisController.getExcludedAddresses().contains(url)){                     System.out.println(\"MainController: its your address or excluded address: \" + url);                     continue;                 }                 try {                     //отправка в сеть                     UtilUrl.sendPost(jsonDto, url);                  }catch (Exception e){                     System.out.println(\"exception discover: \" + original);                  }             }            }          else             redirectAttrs.addFlashAttribute(\"sending\", \"wrong transaction\");         return \"redirect:/result-sending\";     }       @GetMapping(\"/seting\")     public String seting(Model model){         model.addAttribute(\"title\", \"Settings\");         return \"seting\";     }   }","package International_Trade_Union.controllers;  import International_Trade_Union.config.BLockchainFactory; import International_Trade_Union.config.BlockchainFactoryEnum; import International_Trade_Union.entity.blockchain.Blockchain; import International_Trade_Union.model.Account; import International_Trade_Union.model.User; import International_Trade_Union.setings.Seting; import International_Trade_Union.utils.SaveBalances; import International_Trade_Union.utils.UtilsBalance; import org.springframework.stereotype.Controller; import org.springframework.ui.Model; import org.springframework.web.bind.annotation.GetMapping; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RestController;  import java.io.IOException; import java.security.InvalidKeyException; import java.security.NoSuchAlgorithmException; import java.security.NoSuchProviderException; import java.security.SignatureException; import java.security.spec.InvalidKeySpecException; import java.util.HashMap; import java.util.Map;  @Controller public class MineController {     private static Blockchain blockchain;     static {         try {             blockchain = BLockchainFactory.getBlockchain(BlockchainFactoryEnum.ORIGINAL);         } catch (NoSuchAlgorithmException e) {             throw new RuntimeException(e);         } catch (InvalidKeySpecException e) {             throw new RuntimeException(e);         } catch (IOException e) {             throw new RuntimeException(e);         } catch (SignatureException e) {             throw new RuntimeException(e);         } catch (NoSuchProviderException e) {             throw new RuntimeException(e);         } catch (InvalidKeyException e) {             throw new RuntimeException(e);         }     }      @RequestMapping(\"/mining\")     public String miming(Model model) throws IOException, NoSuchAlgorithmException, InvalidKeySpecException, SignatureException, NoSuchProviderException, InvalidKeyException {         model.addAttribute(\"title\", \"Corporation International Trade Union.\");          return \"mining\";     }    }","package International_Trade_Union.controllers;  import International_Trade_Union.entity.DtoTransaction.DtoTransaction; import International_Trade_Union.network.AllTransactions; import org.springframework.http.MediaType; import org.springframework.web.bind.annotation.RequestBody; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RequestMethod; import org.springframework.web.bind.annotation.RestController;  import java.io.IOException; import java.security.InvalidKeyException; import java.security.NoSuchAlgorithmException; import java.security.NoSuchProviderException; import java.security.SignatureException; import java.security.spec.InvalidKeySpecException;  @RestController public class TransactionController {     @RequestMapping(method = RequestMethod.POST, value = \"/addTransaction\", consumes = MediaType.APPLICATION_JSON_VALUE)     public  void add(@RequestBody DtoTransaction data) throws IOException, NoSuchAlgorithmException, SignatureException, InvalidKeySpecException, NoSuchProviderException, InvalidKeyException {         System.out.println(\"add transaction: \" + data);         AllTransactions.getInstance();         AllTransactions.addTransaction(data);         System.out.println(\"TransactionController: add: \" + AllTransactions.getInstance().size());     }  }","package International_Trade_Union.entity.blockchain.block;  import International_Trade_Union.entity.DtoTransaction.DtoTransaction; import International_Trade_Union.exception.NotValidTransactionException; import International_Trade_Union.utils.UtilsJson; import International_Trade_Union.utils.UtilsUse; import com.fasterxml.jackson.annotation.JsonAutoDetect;  import lombok.Data;  import java.io.IOException; import java.security.InvalidKeyException; import java.security.NoSuchAlgorithmException; import java.security.NoSuchProviderException; import java.security.SignatureException; import java.security.spec.InvalidKeySpecException; import java.sql.Timestamp; import java.util.List; import java.util.Objects;  @JsonAutoDetect @Data public final class Block implements Cloneable {     private List<DtoTransaction> dtoTransactions;     private String previousHash;     private String minerAddress;     private String founderAddress;     private long randomNumberProof;     private double minerRewards;     private int hashCompexity;     private Timestamp timestamp;     private long index;     private String hashBlock;      public Block(List<DtoTransaction> dtoTransactions,  String previousHex, String minerAddress, String founderAddress, int hashCompexity, long index) throws IOException, NoSuchAlgorithmException, SignatureException, NoSuchProviderException, InvalidKeyException, InvalidKeySpecException {         this.dtoTransactions = dtoTransactions;         this.previousHash = previousHex;         this.minerAddress = minerAddress;         this.minerRewards = miningRewardsCount();         this.hashCompexity = hashCompexity;         this.founderAddress = founderAddress;         this.timestamp = new Timestamp(System.currentTimeMillis());         this.index = index;         this.hashBlock = findHash(hashCompexity);      }      public Block(List<DtoTransaction> dtoTransactions, String previousHash, String minerAddress, String founderAddress, long randomNumberProof, double minerRewards, int hashCompexity, Timestamp timestamp, long index, String hashBlock) {         this.dtoTransactions = dtoTransactions;         this.previousHash = previousHash;         this.minerAddress = minerAddress;         this.founderAddress = founderAddress;         this.randomNumberProof = randomNumberProof;         this.minerRewards = minerRewards;         this.hashCompexity = hashCompexity;         this.timestamp = timestamp;         this.index = index;         this.hashBlock = hashBlock;     }      @JsonAutoDetect     @Data     private class BlockForHash{         private List<DtoTransaction> transactions;         private String previousHash;         private String minerAddress;         private String founderAddress;         private long randomNumberProof;         private double minerRewards;         private int hashCompexity;         private Timestamp timestamp;         private long index;           public BlockForHash() {         }           public BlockForHash(List<DtoTransaction> transactions,                             String previousHash,                             String minerAddress,                             String founderAddress,                             long randomNumberProof,                             double minerRewards,                             int hashCompexity,                             Timestamp timestamp,                             long index) {             this.transactions = transactions;             this.previousHash = previousHash;             this.minerAddress = minerAddress;             this.founderAddress = founderAddress;             this.randomNumberProof = randomNumberProof;             this.minerRewards = minerRewards;             this.hashCompexity = hashCompexity;             this.timestamp = timestamp;             this.index = index;          }          public String hashForTransaction() throws IOException {             return UtilsUse.sha256hash(jsonString());         }          public String jsonString() throws IOException {             return UtilsJson.objToStringJson(this);         }     }      public Block() {     }      public String hashForBlockchain()             throws             IOException{         return this.hashBlock;     }       public boolean verifyesTransSign() throws IOException, NoSuchAlgorithmException, SignatureException, NoSuchProviderException, InvalidKeyException, InvalidKeySpecException {         for (DtoTransaction dtoTransaction : dtoTransactions) {             if(!dtoTransaction.verify())                 return false;         }         return true;     }      private double miningRewardsCount(){         double rewards = 0.0;         for (DtoTransaction dtoTransaction : dtoTransactions) {              rewards += dtoTransaction.getBonusForMiner();         }          return rewards;     }      public String jsonString() throws IOException {         return UtilsJson.objToStringJson(this);     }     //TODO     public String findHash(int hashCoplexity) throws IOException, NoSuchAlgorithmException, SignatureException, NoSuchProviderException, InvalidKeyException, InvalidKeySpecException {         if (!verifyesTransSign()){             throw new NotValidTransactionException();         }          this.randomNumberProof = 0;         String hash = \"\";         while (true){             this.randomNumberProof++;             BlockForHash block = new BlockForHash(this.dtoTransactions,                     this.previousHash, this.minerAddress, this.founderAddress,                     this.randomNumberProof, this.minerRewards, this.hashCompexity, this.timestamp, this.index);             hash = block.hashForTransaction();             if(UtilsUse.hashComplexity(hash.substring(0, hashCoplexity), hashCoplexity))             {                 break;             }          }         return hash;     }      @Override     public boolean equals(Object o) {           if (this == o) return true;         if (!(o instanceof Block)) return false;         Block block = (Block) o;         return getRandomNumberProof() == block.getRandomNumberProof() && Double.compare(block.getMinerRewards(), getMinerRewards()) == 0 && getHashCompexity() == block.getHashCompexity() && getIndex() == block.getIndex() && Objects.equals(getDtoTransactions(), block.getDtoTransactions()) && Objects.equals(getPreviousHash(), block.getPreviousHash()) && Objects.equals(getMinerAddress(), block.getMinerAddress()) && Objects.equals(getFounderAddress(), block.getFounderAddress()) && Objects.equals(getTimestamp(), block.getTimestamp()) && Objects.equals(getHashBlock(), block.getHashBlock());     }      @Override     public int hashCode() {         return Objects.hash(getDtoTransactions(), getPreviousHash(), getMinerAddress(), getFounderAddress(), getRandomNumberProof(), getMinerRewards(), getHashCompexity(), getTimestamp(), getIndex(), getHashBlock());     }      @Override     public Block clone() throws CloneNotSupportedException {         return new Block(this.dtoTransactions, this.previousHash, this.minerAddress, this.founderAddress,                 this.randomNumberProof, this.minerRewards, this.hashCompexity, this.timestamp, this.index,                 this.hashBlock);     } }","package International_Trade_Union.entity.blockchain;  import International_Trade_Union.entity.DtoTransaction.DtoTransaction; import International_Trade_Union.entity.blockchain.block.Block; import International_Trade_Union.setings.Seting; import International_Trade_Union.utils.UtilsBlock; import International_Trade_Union.utils.UtilsJson; import International_Trade_Union.utils.UtilsSecurity; import International_Trade_Union.utils.UtilsUse; import International_Trade_Union.utils.base.Base; import International_Trade_Union.utils.base.Base58; import International_Trade_Union.vote.Laws; import International_Trade_Union.vote.VoteEnum; import com.fasterxml.jackson.annotation.JsonAutoDetect;  import lombok.Data;  import java.io.IOException; import java.security.*; import java.security.spec.InvalidKeySpecException; import java.util.ArrayList; import java.util.List; import java.util.Objects;   @JsonAutoDetect @Data public class Blockchain implements Cloneable{     private List<Block> blockchainList;     //как часто должно создаваться блок в миллисекундах 1000 миллисекунд = 1 секунд     private long BLOCK_GENERATION_INTERVAL;     //каждые сколько блоков должен происходить перерасчет сложности     private int DIFFICULTY_ADJUSTMENT_INTERVAL;     //блок действителен, если значение блока меньше данного занчения в миллисекунда     private long INTERVAL_TARGET;     private String ADDRESS_FOUNDER;     public int sizeBlockhain(){          return blockchainList.size();     }      public void setBlockchainList(List<Block> blockchainList) throws IOException, NoSuchAlgorithmException, InvalidKeySpecException, SignatureException, NoSuchProviderException, InvalidKeyException {         this.blockchainList = blockchainList;      }      public Blockchain(long BLOCK_GENERATION_INTERVAL, int DIFFICULTY_ADJUSTMENT_INTERVAL, long INTERVAL_TARGET, String ADDRESS_FOUNDER) throws NoSuchAlgorithmException, InvalidKeySpecException, NoSuchProviderException, IOException, SignatureException, InvalidKeyException {         this(new ArrayList<>(), BLOCK_GENERATION_INTERVAL, DIFFICULTY_ADJUSTMENT_INTERVAL, INTERVAL_TARGET, ADDRESS_FOUNDER);      }     public Blockchain(List<Block> blockchainList, long BLOCK_GENERATION_INTERVAL, int DIFFICULTY_ADJUSTMENT_INTERVAL, long INTERVAL_TARGET,String ADDRESS_FOUNDER) throws IOException, NoSuchAlgorithmException, InvalidKeySpecException, SignatureException, NoSuchProviderException, InvalidKeyException {         this.blockchainList = blockchainList;         this.BLOCK_GENERATION_INTERVAL = BLOCK_GENERATION_INTERVAL;         this.DIFFICULTY_ADJUSTMENT_INTERVAL = DIFFICULTY_ADJUSTMENT_INTERVAL;         this.INTERVAL_TARGET = INTERVAL_TARGET;         this.ADDRESS_FOUNDER = ADDRESS_FOUNDER;         Block block = genesisBlock();         addBlock(block);     }      public void addBlock(Block newBlock) throws IOException, NoSuchAlgorithmException, SignatureException, InvalidKeySpecException, NoSuchProviderException, InvalidKeyException { //        if(blockchainList.size() > 2){ //            boolean time = UtilsBlock.isValidTimestamp(blockchainList.get(blockchainList.size()-1), newBlock, INTERVAL_TARGET); //            if(!time){ //                System.out.println(\"time out block add \" + time); //               return; //            } //        }         blockchainList.add(newBlock);       }      public Block genesisBlock() throws IOException, NoSuchAlgorithmException, InvalidKeySpecException, NoSuchProviderException, SignatureException, InvalidKeyException {         Base base = new Base58();         //dto sign         //pub byte keys         //transactions         List<DtoTransaction> transactions = new ArrayList<>();          DtoTransaction gold = new DtoTransaction(Seting.BASIS_ADDRESS, ADDRESS_FOUNDER,                 Seting.FOUNDERS_REMUNERATION_DIGITAL_DOLLAR, Seting.FOUNDERS_REMNUNERATION_DIGITAL_STOCK, new Laws(), 0.0, VoteEnum.YES);         PrivateKey privateKey = UtilsSecurity.privateBytToPrivateKey(base.decode(Seting.BASIS_PASSWORD));         byte[] signGold = UtilsSecurity.sign(privateKey, gold.toSign());         gold.setSign(signGold);         transactions.add(gold);          String genesisHash = genesisPrevHash();         Block block = new Block(transactions,  genesisHash, ADDRESS_FOUNDER, ADDRESS_FOUNDER,  Seting.HASH_COMPLEXITY_GENESIS, blockchainList.size());         return block;     }        public String genesisPrevHash() throws IOException {         return UtilsUse.hashComplexityStr(Seting.CORPORATE_CHARTER_DRAFT, Seting.HASH_COMPLEXITY_GENESIS);     }      public String getHashBlock(int index) throws IOException {         return blockchainList.get(index).hashForBlockchain();     }     public Block getBlock(int index){         return blockchainList.get(index);     }        public boolean validatedBlockchain() throws IOException, NoSuchAlgorithmException, SignatureException, InvalidKeySpecException, NoSuchProviderException, InvalidKeyException {        return UtilsBlock.validation(blockchainList, BLOCK_GENERATION_INTERVAL, DIFFICULTY_ADJUSTMENT_INTERVAL);     }      public String jsonString() throws IOException {         return UtilsJson.objToStringJson(blockchainList);     }     @Override     public boolean equals(Object o) {         if (this == o) return true;         if (!(o instanceof Blockchain)) return false;         Blockchain that = (Blockchain) o;         return getBlockchainList().equals(that.getBlockchainList());     }      @Override     public int hashCode() {         return Objects.hash(getBlockchainList());     }      public  List<Block> subBlock(int startIndex, int finishIndex) throws CloneNotSupportedException {         List<Block> temporary = this.getBlockchainList().subList(startIndex, finishIndex);         List<Block> result = new ArrayList<>();         for (Block block : temporary) {             result.add(block.clone());         }         return result;     }       @Override     public List<Block> clone() throws CloneNotSupportedException {         List<Block> result = new ArrayList<>();         for (Block block : blockchainList) {             result.add(block.clone());         }         return result;      } }","package International_Trade_Union.entity.DtoTransaction;  import org.bouncycastle.jcajce.provider.asymmetric.ec.BCECPublicKey; import International_Trade_Union.setings.Seting; import International_Trade_Union.utils.UtilsJson; import International_Trade_Union.utils.UtilsSecurity; import International_Trade_Union.utils.UtilsUse; import International_Trade_Union.utils.base.Base; import International_Trade_Union.utils.base.Base58; import International_Trade_Union.vote.Laws; import International_Trade_Union.vote.VoteEnum; import com.fasterxml.jackson.annotation.JsonAutoDetect;  import lombok.Data;   import java.io.IOException; import java.security.*; import java.security.spec.InvalidKeySpecException; import java.util.Arrays; import java.util.Objects;   @JsonAutoDetect @Data public class DtoTransaction {     private String sender;     private String customer;     private double digitalDollar;     private double digitalStockBalance;     private Laws laws;     private double bonusForMiner;     private VoteEnum voteEnum;     private byte[] sign;        public DtoTransaction(String sender, String customer, double digitalDollar, double digitalStockBalance, Laws laws, double bonusForMiner, VoteEnum voteEnum) {         this.sender = sender;         this.customer = customer;         this.digitalDollar = digitalDollar;         this.digitalStockBalance = digitalStockBalance;         this.laws = laws;         this.bonusForMiner = bonusForMiner;         this.voteEnum = voteEnum;     }      public DtoTransaction() {     }      //TODO возможно стоит перевести проверку подписи в отдельный utils, под вопросом!!     public boolean verify() throws IOException, NoSuchAlgorithmException, SignatureException, NoSuchProviderException, InvalidKeyException, InvalidKeySpecException {         Base base = new Base58();         byte[] pub = base.decode(sender);         BCECPublicKey publicKey = (BCECPublicKey) UtilsSecurity.decodeKey(pub); //        PublicKey publicKey = UtilsSecurity.publicByteToPublicKey(pub);         String sha = sender + customer + digitalDollar + digitalStockBalance + laws + bonusForMiner;         sha = UtilsUse.sha256hash(sha);         if(sender.isBlank() || customer.isBlank() || digitalDollar < 0 || digitalStockBalance < 0 || bonusForMiner < 0 || laws == null){             System.out.println(\"wrong dto transaction sender or customer blank? or dollar, reputation or reward less then 0\");             return false;         }         if(Seting.BASIS_ADDRESS.equals(publicKey))             return true;         return UtilsSecurity.verify(sha, sign, publicKey);     }      public String toSign(){         String sha = sender + customer + digitalDollar + digitalStockBalance + laws + bonusForMiner;         return UtilsUse.sha256hash(sha);     }  //    public String hashForBlock() throws IOException { //        return UtilsUse.sha256hash(jsonString()); //    }      public String jsonString() throws IOException {         return UtilsJson.objToStringJson(this);     }      @Override     public boolean equals(Object o) {         if (this == o) return true;         if (!(o instanceof DtoTransaction)) return false;         DtoTransaction that = (DtoTransaction) o;         return Double.compare(that.getDigitalDollar(), getDigitalDollar()) == 0 && Double.compare(that.getDigitalStockBalance(), getDigitalStockBalance()) == 0 && Double.compare(that.getBonusForMiner(), getBonusForMiner()) == 0 && getSender().equals(that.getSender()) && getCustomer().equals(that.getCustomer()) && getLaws().equals(that.getLaws()) && getVoteEnum() == that.getVoteEnum() && Arrays.equals(getSign(), that.getSign());     }      @Override     public int hashCode() {         int result = Objects.hash(getSender(), getCustomer(), getDigitalDollar(), getDigitalStockBalance(), getLaws(), getBonusForMiner(), getVoteEnum());         result = 31 * result + Arrays.hashCode(getSign());         return result;     } }","package International_Trade_Union.entity;  import lombok.Data;  @Data public class AddressUrl {     private String address;      public AddressUrl() {     }      public AddressUrl(String address) {         this.address = address;     } }","package International_Trade_Union.entity;   import lombok.Data; import International_Trade_Union.entity.blockchain.block.Block;  import java.util.List;  @Data public class EntityChain {      private int size;     private List<Block> blocks;      public EntityChain() {     }      public EntityChain(int sizeBlockhain, List<Block> blockchainList) {         this.size = sizeBlockhain;         this.blocks = blockchainList;     } }","package International_Trade_Union.entity;   import lombok.Data; import International_Trade_Union.entity.blockchain.Blockchain; import International_Trade_Union.entity.blockchain.block.Block; import International_Trade_Union.model.Account;  import java.util.List; import java.util.Map;  @Data public class ResultMiningData {     private Map<String, Account> balance;     private Blockchain blockchain;     private Block miningBlock;     private List<Block> lastBlock;     private Account governments;  }","package International_Trade_Union.entity;  import lombok.Data;  @Data public class SubBlockchainEntity {     private int start;     private int finish;      public SubBlockchainEntity(int start, int finish) {         this.start = start;         this.finish = finish;     }      public SubBlockchainEntity() {     } }","package International_Trade_Union.governments;   import International_Trade_Union.model.Account;  public class CompareObject {      public int compare(Account o1, Account o2) {         double x1 = o1.getDigitalStockBalance();         double x2 = o2.getDigitalStockBalance();         int power = Double.compare(x1, x2);         if (power != 0)             return power;         double gold1 = o1.getDigitalDollarBalance();         double gold2 = o2.getDigitalDollarBalance();         int gold = Double.compare(gold1, gold2);         if(gold != 0)             return gold;         double first = x1 + gold1;         double second = x2 + gold2;         return Double.compare(first, second);     }      @Override     public boolean equals(Object obj) {         return false;     } }","package International_Trade_Union.governments;  import lombok.AllArgsConstructor; import lombok.Data; import lombok.NoArgsConstructor;  import java.util.Arrays; import java.util.List; import java.util.Locale; import java.util.Objects; import java.util.stream.Collectors;  @Data @NoArgsConstructor @AllArgsConstructor public class Director {     //количество юридических или физических лиц в данной должности     //количество юридических или физических лиц в данной должности     private String name;     private  int count;      private boolean electedByCEO;     private boolean electedByBoardOfDirectors;       private boolean electedByCorporateCouncilOfReferees;     private boolean electedByStocks;     private boolean officeOfDirectors;       @Override     public boolean equals(Object o) {         if (this == o) return true;         if (!(o instanceof Director)) return false;         Director director = (Director) o;         return getName().equals(director.getName());     }      @Override     public int hashCode() {         return Objects.hash(getName());     }      public boolean isAppointedByTheGovernment(){         if(electedByCEO || electedByBoardOfDirectors || electedByCorporateCouncilOfReferees)             return true;         else return false;     }     public int getCount() {         return count;     }     }","package International_Trade_Union.governments;  import International_Trade_Union.setings.Seting; import International_Trade_Union.utils.UtilsUse; import lombok.Data;  import java.util.ArrayList; import java.util.List; import java.util.Locale; import java.util.stream.Collectors;  @Data  public class Directors {     public Directors() {          directors = new ArrayList<>();         Director CORPORATE_COUNCIL_OF_REFEREES = new Director(\"CORPORATE_COUNCIL_OF_REFEREES\", 55, false, false, false, true, false);         Director BOARD_OF_DIRECTORS = new Director(\"BOARD_OF_DIRECTORS\", 301, false, false, false, true, false);          Director GENERAL_EXECUTIVE_DIRECTOR = new Director(\"GENERAL_EXECUTIVE_DIRECTOR\", 1, false, true, false, false, true);         Director HIGH_JUDGE = new Director(\"HIGH_JUDGE\",1, false, false, true, false, false);         Director FRACTION = new Director(\"FRACTION\", 100, false, false, false, true, false);         directors.add(CORPORATE_COUNCIL_OF_REFEREES);         directors.add(BOARD_OF_DIRECTORS);         directors.add(FRACTION);          directors.add(GENERAL_EXECUTIVE_DIRECTOR);         directors.add(HIGH_JUDGE);      }       public Director getDirector(String str){        List<Director> director = directors                .stream()                .filter(t->t.getName().equals(str))                .collect(Collectors.toList());        return director.get(0);      }     private List<Director> directors;      public boolean contains(String str) {         str = str.toUpperCase();         directors = directors.stream().filter(UtilsUse.distinctByKey(Director::getName)).collect(Collectors.toList());         List<String> strings = directors.stream().map(t->t.getName()).collect(Collectors.toList());        return strings.contains(str);     }      public boolean isCabinets(String str) {         List<String> list = directors.stream()                 .filter(t->t.isOfficeOfDirectors())                 .filter(UtilsUse.distinctByKey(Director::getName))                 .map(t->t.getName())                 .collect(Collectors.toList());         return list.contains(str.toUpperCase(Locale.ROOT));     }       //должности которые добавляются только советом директоров     public void addByBoardOfDirectors(String str) {         if (str.startsWith(Seting.ADD_DIRECTOR)) {             Director director = new Director(str, 1, false, true, false, false, true);             directors.add(director);             directors = directors.stream().filter(UtilsUse.distinctByKey(Director::getName)).collect(Collectors.toList());         }      }      public void addAllByBoardOfDirectors(List<String> strings) {         strings = strings.stream()                 .filter(t -> t.startsWith(Seting.ADD_DIRECTOR))                 .distinct()                 .collect(Collectors.toList());         for (String s : strings) {             Director director = new Director(s, 1, false, true, false, false, true);             directors.add(director);         }         directors = directors.stream().filter(UtilsUse.distinctByKey(Director::getName)).collect(Collectors.toList());      }       public List<String> getNames() {         return directors.stream().map(t -> t.getName()).collect(Collectors.toList());     }       public  boolean isElectedByStocks(String str){         List<String> list = directors.stream()                 .filter(t->t.isElectedByStocks())                 .map(t->t.getName())                 .collect(Collectors.toList());          return list.contains(str.toUpperCase(Locale.ROOT));     }     public boolean isElectedCEO(String str){         List<String> list = directors.stream()                 .filter(t->t.isElectedByCEO())                 .map(t->t.getName())                 .collect(Collectors.toList());          return list.contains(str.toUpperCase(Locale.ROOT));     }      public  boolean isElectedByBoardOfDirectors(String  str){         List<String> list = directors.stream()                 .filter(t->t.isElectedByBoardOfDirectors())                 .map(t->t.getName())                 .collect(Collectors.toList());          return list.contains(str.toUpperCase(Locale.ROOT));     }      public boolean isElectedBYCorporateCouncilOfReferees(String  str){         List<String> list = directors.stream()                 .filter(t->t.isElectedByCorporateCouncilOfReferees())                 .map(t->t.getName())                 .collect(Collectors.toList());          return list.contains(str.toUpperCase(Locale.ROOT));     }      public boolean isofficeOfDirectors(String str){         List<String> list = directors.stream()                 .filter(t->t.isOfficeOfDirectors())                 .map(t->t.getName())                 .collect(Collectors.toList());          return list.contains(str.toUpperCase(Locale.ROOT));     } }","package International_Trade_Union.governments;  import lombok.Data;  import java.util.List;  @Data public class FractionPower {     public FractionPower() {     }      public FractionPower(String addressLaw,                          double votes,                          int votesCorporateCouncilOfReferees,                          int votesBoardOfDirectors,                          int votesBoardOfShareholders,                          int voteGeneralExecutiveDirector,                          int voteHightJudge,                          int founderVote,                          String packageName,                          List<String> laws,                          double fractionVote,                          double fractionPower) {         this.addressLaw = addressLaw;         this.votes = votes;         this.votesCorporateCouncilOfReferees = votesCorporateCouncilOfReferees;         this.votesBoardOfDirectors = votesBoardOfDirectors;         this.votesBoardOfShareholders = votesBoardOfShareholders;         this.voteGeneralExecutiveDirector = voteGeneralExecutiveDirector;         this.voteHightJudge = voteHightJudge;         this.founderVote = founderVote;         this.packageName = packageName;         this.laws = laws;         this.fractionVote = fractionVote;         this.fractionPower = fractionPower;      }      private String addressLaw;     private double votes;     //CORPORATE_COUNCIL_OF_REFEREES     private int votesCorporateCouncilOfReferees;      //BOARD_OF_DIRECTORS     private int votesBoardOfDirectors;     private int votesBoardOfShareholders;      //GENERAL_EXECUTIVE_DIRECTOR     private int voteGeneralExecutiveDirector;     private int voteHightJudge;      private int founderVote;     private String packageName;     private List<String> laws;     private double fractionVote;     private double fractionPower;  }","package International_Trade_Union.governments;  public enum NamePOSITION {     BOARD_OF_DIRECTORS,     CORPORATE_COUNCIL_OF_REFEREES,     GENERAL_EXECUTIVE_DIRECTOR,     HIGH_JUDGE,     FRACTION }","package International_Trade_Union.governments;   import International_Trade_Union.entity.DtoTransaction.DtoTransaction; import International_Trade_Union.entity.blockchain.block.Block; import International_Trade_Union.model.Account; import International_Trade_Union.setings.Seting; import International_Trade_Union.vote.*;  import java.io.IOException; import java.security.InvalidKeyException; import java.security.NoSuchAlgorithmException; import java.security.NoSuchProviderException; import java.security.SignatureException; import java.security.spec.InvalidKeySpecException; import java.util.*; import java.util.stream.Collectors;  public class UtilsGovernment {      //для корпоративных позиций, адресс отправителя должен совпадать с первой строкой закона     public static boolean checkPostionSenderEqualsLaw(String addressSender, Laws laws) {         Directors directors = new Directors();         List<Director> enumPosition = directors.getDirectors();         List<String> corporateSeniorPositions = enumPosition.stream().map(t->t.getName()).collect(Collectors.toList());         if (corporateSeniorPositions.contains(laws.getPacketLawName())) {             if (laws.getLaws().get(0) != null && addressSender.equals(laws.getLaws().get(0))) {                 System.out.println(\"UtilsBogernment: checkPostionSenderEqualsLaw: \" + laws.getLaws().get(0) + \" true:\");                 return true;             } else {                 System.out.println(\"UtilsBogernment: checkPostionSenderEqualsLaw: \" + laws.getLaws().get(0) + \" false:\");                 return false;             }         }         System.out.println(\"UtilsBogernment: checkPostionSenderEqualsLaw: \" + laws.getLaws().get(0) + \" not position:\");         return true;     }       //определение совета акционеров     public static List<Account> findBoardOfShareholders(Map<String, Account> balances, List<Block> blocks, int limit) {         List<Block> minersHaveMoreStock = null;         if (blocks.size() > limit) {             minersHaveMoreStock = blocks.subList(blocks.size() - limit, blocks.size());         } else {             minersHaveMoreStock = blocks;         }         List<Account> boardAccounts = minersHaveMoreStock.stream().map(                         t -> new Account(t.getMinerAddress(), 0, 0))                 .collect(Collectors.toList());          for (Block block : minersHaveMoreStock) {             for (DtoTransaction dtoTransaction : block.getDtoTransactions()) {                 boardAccounts.add(new Account(dtoTransaction.getSender(), 0, 0));             }          }           CompareObject compareObject = new CompareObject();          List<Account> boardOfShareholders = balances.entrySet().stream()                 .filter(t -> boardAccounts.contains(t.getValue()))                 .map(t -> t.getValue()).collect(Collectors.toList());           boardOfShareholders = boardOfShareholders                 .stream()                 .filter(t -> !t.getAccount().startsWith(Seting.NAME_LAW_ADDRESS_START))                 .filter(t -> t.getDigitalStockBalance() > 0)                 .sorted(Comparator.comparing(Account::getDigitalStockBalance).reversed())                 .collect(Collectors.toList());          boardOfShareholders = boardOfShareholders                 .stream()                 .limit(Seting.BOARD_OF_SHAREHOLDERS)                 .collect(Collectors.toList());          return boardOfShareholders;     }       public static List<CurrentLawVotesEndBalance> filtersVotes(             List<LawEligibleForParliamentaryApproval> approvalList,             Map<String, Account> balances,             List<Account> BoardOfShareholders,             List<Block> blocks,             int limitBlocks     ) throws IOException, NoSuchAlgorithmException, SignatureException, InvalidKeySpecException, NoSuchProviderException, InvalidKeyException {         //действующие законы чьи голоса больше ORIGINAL_LIMIT_MIN_VOTE         List<CurrentLawVotesEndBalance> current = new ArrayList<>();         Map<String, CurrentLawVotes> votesMap = null;         List<Account> accounts = balances.entrySet().stream().map(t -> t.getValue()).collect(Collectors.toList());         if (blocks.size() > limitBlocks) {             votesMap = UtilsCurrentLaw.calculateVotes(accounts, blocks.subList(blocks.size() - limitBlocks, blocks.size()));         } else {             votesMap = UtilsCurrentLaw.calculateVotes(accounts, blocks);         }          //подсчитать средннее количество раз сколько он проголосовал за         Map<String, Integer> yesAverage = UtilsCurrentLaw.calculateAverageVotesYes(votesMap);         //подсчитать среднее количество раз сколько он проголосовал против         Map<String, Integer> noAverage = UtilsCurrentLaw.calculateAverageVotesNo(votesMap);           //подсчитываем голоса для для обычных законов и законов позиций         for (LawEligibleForParliamentaryApproval lawEligibleForParliamentaryApproval : approvalList) {             if (votesMap.containsKey(lawEligibleForParliamentaryApproval.getLaws().getHashLaw())) {                 String address = lawEligibleForParliamentaryApproval.getLaws().getHashLaw();                 String packageName = lawEligibleForParliamentaryApproval.getLaws().getPacketLawName();                 List<String> laws = lawEligibleForParliamentaryApproval.getLaws().getLaws();                 double vote = 0;                 int supremeVotes = 0;                 int boafdOfShareholderVotes = 0;                 int houseOfRepresentativiesVotes = 0;                 int primeMinisterVotes = 0;                 int hightJudgesVotes = 0;                 int founderVote = 0;                 double fraction = 0;                  //для законов подсчитываем специальные голоса                 vote = votesMap.get(lawEligibleForParliamentaryApproval.getLaws().getHashLaw()).votesLaw(balances, yesAverage, noAverage);                 List<String> boardOfShareholdersAddress = BoardOfShareholders.stream().map(t -> t.getAccount()).collect(Collectors.toList());                 boafdOfShareholderVotes = votesMap.get(lawEligibleForParliamentaryApproval.getLaws().getHashLaw()).voteGovernment(balances, boardOfShareholdersAddress);                  List<String> founder = List.of(Seting.ADDRESS_FOUNDER);                 founderVote = votesMap.get(lawEligibleForParliamentaryApproval.getLaws().getHashLaw()).voteGovernment(balances, founder);                 CurrentLawVotesEndBalance currentLawVotesEndBalance = new CurrentLawVotesEndBalance(                         address,                         packageName,                         vote,                         supremeVotes,                         houseOfRepresentativiesVotes,                         boafdOfShareholderVotes,                         primeMinisterVotes,                         hightJudgesVotes,                         founderVote,                         fraction,                         laws);                 current.add(currentLawVotesEndBalance);              }         }          List<String> houseOfRepresentativies = new ArrayList<>();         List<String> chamberOfSumpremeJudges = new ArrayList<>();         Map<String, Double> fractions = new HashMap<>();          for (CurrentLawVotesEndBalance currentLawVotesEndBalance: current) {             if(currentLawVotesEndBalance.getPackageName().equals(NamePOSITION.BOARD_OF_DIRECTORS.toString())){                 if(currentLawVotesEndBalance.getVotes() >= Seting.ORIGINAL_LIMIT_MIN_VOTE){                     houseOfRepresentativies.add(currentLawVotesEndBalance.getLaws().get(0));                 }              }             if(currentLawVotesEndBalance.getPackageName().equals(NamePOSITION.CORPORATE_COUNCIL_OF_REFEREES.toString())){                 if(currentLawVotesEndBalance.getVotes() >= Seting.ORIGINAL_LIMIT_MIN_VOTE){                     chamberOfSumpremeJudges.add(currentLawVotesEndBalance.getLaws().get(0));                 }              }               if(currentLawVotesEndBalance.getPackageName().equals(NamePOSITION.FRACTION.toString())){                 if(currentLawVotesEndBalance.getVotes() >= Seting.ORIGINAL_LIMIT_MIN_VOTE){                     fractions.put(currentLawVotesEndBalance.getLaws().get(0), currentLawVotesEndBalance.getVotes());                 }             }          }            for (CurrentLawVotesEndBalance currentLawVotesEndBalance : current) {             if(votesMap.containsKey(currentLawVotesEndBalance.getAddressLaw())){                   double vote = votesMap.get(currentLawVotesEndBalance.getAddressLaw()).votesLaw(balances, yesAverage, noAverage);                 int supremeVotes  = votesMap.get(currentLawVotesEndBalance.getAddressLaw()).voteGovernment(balances, chamberOfSumpremeJudges);                 int houseOfRepresentativiesVotes = votesMap.get(currentLawVotesEndBalance.getAddressLaw()).voteGovernment(balances, houseOfRepresentativies);                 double fractionsVotes = votesMap.get(currentLawVotesEndBalance.getAddressLaw()).voteFractions(fractions);                  currentLawVotesEndBalance.setVotes(vote);                 currentLawVotesEndBalance.setVotesBoardOfDirectors(houseOfRepresentativiesVotes);                 currentLawVotesEndBalance.setVotesCorporateCouncilOfReferees(supremeVotes);                 currentLawVotesEndBalance.setFractionVote(fractionsVotes);             }          }          //изирается Генеральный исполнительный директор         List<String> primeMinister = new ArrayList<>();         List<String> hightJudge = new ArrayList<>();         for (CurrentLawVotesEndBalance currentLawVotesEndBalance : current) {             if(currentLawVotesEndBalance.getPackageName().equals(NamePOSITION.GENERAL_EXECUTIVE_DIRECTOR.toString())){                 if(currentLawVotesEndBalance.getVotesBoardOfDirectors() >= Seting.ORIGINAL_LIMIT_MIN_VOTE_BOARD_OF_DIRECTORS                 && currentLawVotesEndBalance.getFractionVote() >= Seting.ORIGINAL_LIMIT_MIN_VOTE_FRACTIONS                 && currentLawVotesEndBalance.getVotesBoardOfShareholders() >= Seting.ORIGINAL_LIMIT_MIN_VOTE_BOARD_OF_SHAREHOLDERS                 && currentLawVotesEndBalance.getVotes() >= Seting.ALL_STOCK_VOTE){                     primeMinister.add(currentLawVotesEndBalance.getLaws().get(0));                 }             }              if(currentLawVotesEndBalance.getPackageName().equals(NamePOSITION.HIGH_JUDGE.toString())){                 if(currentLawVotesEndBalance.getVotesCorporateCouncilOfReferees() >= Seting.ORIGINAL_LIMIT_MIN_VOTE_CORPORATE_COUNCIL_OF_REFEREES){                     hightJudge.add(currentLawVotesEndBalance.getLaws().get(0));                 }             }         }         for (CurrentLawVotesEndBalance currentLawVotesEndBalance : current) {             if(votesMap.containsKey(currentLawVotesEndBalance.getAddressLaw())){                 int primeMinisterVotes = votesMap.get(currentLawVotesEndBalance.getAddressLaw()).voteGovernment(balances, primeMinister);                 int hightJudgeVotes = votesMap.get(currentLawVotesEndBalance.getAddressLaw()).voteGovernment(balances, hightJudge);                  currentLawVotesEndBalance.setVoteGeneralExecutiveDirector(primeMinisterVotes);                 currentLawVotesEndBalance.setVoteHightJudge(hightJudgeVotes);             }          }           return current;      }          //без учета палаты представителей     public static List<CurrentLawVotesEndBalance> filters(List<LawEligibleForParliamentaryApproval> approvalList, Map<String, Account> balances,                                                           List<Account> BoardOfShareholders, List<Block> blocks, int limitBlocks) throws IOException, NoSuchAlgorithmException, InvalidKeySpecException, SignatureException, NoSuchProviderException, InvalidKeyException {         //действующие законы чьи голоса больше ORIGINAL_LIMIT_MIN_VOTE         List<CurrentLawVotesEndBalance> current = new ArrayList<>();         Map<String, CurrentLawVotes> votesMap = null;         List<Account> accounts = balances.entrySet().stream().map(t -> t.getValue()).collect(Collectors.toList());         if (blocks.size() > limitBlocks) {             votesMap = UtilsCurrentLaw.calculateVotes(accounts, blocks.subList(blocks.size() - limitBlocks, blocks.size()));         } else {             votesMap = UtilsCurrentLaw.calculateVotes(accounts, blocks);         }          //подсчитать средннее количество раз сколько он проголосовал за         Map<String, Integer> yesAverage = UtilsCurrentLaw.calculateAverageVotesYes(votesMap);         //подсчитать среднее количество раз сколько он проголосовал против         Map<String, Integer> noAverage = UtilsCurrentLaw.calculateAverageVotesNo(votesMap);          for (LawEligibleForParliamentaryApproval lawEligibleForParliamentaryApproval : approvalList) {             if (votesMap.containsKey(lawEligibleForParliamentaryApproval.getLaws().getHashLaw())) {                 String address = lawEligibleForParliamentaryApproval.getLaws().getHashLaw();                 String packageName = lawEligibleForParliamentaryApproval.getLaws().getPacketLawName();                 List<String> laws = lawEligibleForParliamentaryApproval.getLaws().getLaws();                 double vote = votesMap.get(lawEligibleForParliamentaryApproval.getLaws().getHashLaw()).votes(balances, yesAverage, noAverage);                  CurrentLawVotesEndBalance currentLawVotesEndBalance = new CurrentLawVotesEndBalance(address, packageName, vote, 0, 0, 0, 0, 0, 0, 0,  laws);                 current.add(currentLawVotesEndBalance);              }         }         return current;     }   }","package International_Trade_Union.model;   import lombok.Data; import International_Trade_Union.entity.DtoTransaction.DtoTransaction; import International_Trade_Union.utils.UtilsSecurity; import International_Trade_Union.utils.base.Base; import International_Trade_Union.utils.base.Base58; import International_Trade_Union.vote.Laws; import International_Trade_Union.vote.VoteEnum;  import java.io.IOException; import java.security.*; import java.security.spec.InvalidKeySpecException; import java.util.Objects;   @Data public class Account {     private String account;     private double digitalDollarBalance;     private double digitalStockBalance;       public Account(String account, double digitalDollarBalance) {         this(account, digitalDollarBalance, 0.0);      }      public Account(String account, double digitalDollarBalance, double digitalStockBalance) {         this.account = account;         this.digitalDollarBalance = digitalDollarBalance;         this.digitalStockBalance = digitalStockBalance;     }      public Account() {     }      @Override     public boolean equals(Object o) {         if (this == o) return true;         if (!(o instanceof Account)) return false;         Account account1 = (Account) o;         return getAccount().equals(account1.getAccount());     }      @Override     public int hashCode() {         return Objects.hash(getAccount());     }      private DtoTransaction sendMoney(String recipient, String privatekey, double digitalDollar, double digitalStock, Laws laws, double minerRewards, VoteEnum voteEnum) throws NoSuchAlgorithmException, InvalidKeySpecException, NoSuchProviderException, SignatureException, IOException, InvalidKeyException {          DtoTransaction transaction = null;         if (account.equals(recipient)){             System.out.println(\"sender %s, recipient %s cannot be equals! Error!\".format(account,recipient));             return transaction;         }              if(digitalDollarBalance < digitalDollar + minerRewards  ){                 System.out.println(\"sender don't have digitalDollar\");                 return transaction;             }             if(digitalStockBalance < digitalStock){                 System.out.println(\"sender don't have digitalReputation\");                 return transaction;             }             else{                 Base base = new Base58();                 PrivateKey privateKey = UtilsSecurity.privateBytToPrivateKey(base.decode(privatekey));                  transaction = new DtoTransaction(this.getAccount(), recipient, digitalDollar, digitalStock, laws, minerRewards, voteEnum);                 byte[] signGold = UtilsSecurity.sign(privateKey, transaction.toSign());                 transaction.setSign(signGold);             }         return transaction;     }  //      recipient - получатель //      gold сумма отправки, last Block - это послдний блок.     public DtoTransaction send(String recipient, String privateKey, double digitalDollar, double digitalReputation, Laws laws,  double minerRewards, VoteEnum voteEnum) throws NoSuchAlgorithmException, InvalidKeySpecException, SignatureException, IOException, NoSuchProviderException, InvalidKeyException {          return sendMoney(recipient,privateKey, digitalDollar, digitalReputation, laws, minerRewards, voteEnum);     }      }","package International_Trade_Union.model;  import International_Trade_Union.utils.UtilsSecurity; import International_Trade_Union.utils.base.Base; import International_Trade_Union.utils.base.Base58;  import java.security.InvalidAlgorithmParameterException; import java.security.NoSuchAlgorithmException; import java.security.NoSuchProviderException; import java.security.spec.InvalidKeySpecException; import java.util.HashMap; import java.util.Map;  public class CreateAccount {     public static Map<String, String> create() throws InvalidAlgorithmParameterException, NoSuchAlgorithmException, InvalidKeySpecException, NoSuchProviderException {         Map<String, String> create = new HashMap<>();         Base base = new Base58();         Keys keyPair = UtilsSecurity.generateKeyPair();         String pubkey = keyPair.getPubkey();         String privKey = keyPair.getPrivkey();         System.out.println(\"pubkey: \" + pubkey);         System.out.println(\"privKey: \" + privKey);         create.put(\"pubKey\", pubkey);         create.put(\"privKey\", privKey);         return create;     } }","package International_Trade_Union.model;  import International_Trade_Union.governments.Director; import lombok.AllArgsConstructor; import lombok.Data; import lombok.NoArgsConstructor;  @Data @AllArgsConstructor @NoArgsConstructor public class FIndPositonHelperData {     Director addressPosition;     boolean withLimited;     boolean electedWithStock;     boolean electedWithPrimeMinister;     boolean electedWithHousOfRepresentativies;     boolean electedWithChamberOfHightJudjes;  }","package International_Trade_Union.model;  import lombok.Data;  @Data public class Keys {     private String pubkey;     private String privkey;      public Keys(String pubkey, String privkey) {         this.pubkey = pubkey;         this.privkey = privkey;     } }","package International_Trade_Union.model;    import International_Trade_Union.config.BLockchainFactory; import International_Trade_Union.config.BlockchainFactoryEnum; import International_Trade_Union.entity.DtoTransaction.DtoTransaction; import International_Trade_Union.entity.blockchain.Blockchain; import International_Trade_Union.entity.blockchain.block.Block; import International_Trade_Union.governments.Director; import International_Trade_Union.governments.Directors; import International_Trade_Union.governments.UtilsGovernment; import International_Trade_Union.setings.Seting; import International_Trade_Union.utils.base.Base; import International_Trade_Union.utils.base.Base58; import International_Trade_Union.vote.Laws; import International_Trade_Union.vote.VoteEnum; import International_Trade_Union.utils.*;  import java.io.File; import java.io.IOException; import java.security.*; import java.security.spec.InvalidKeySpecException; import java.util.*; import java.util.stream.Collectors;  public class Mining {      public static Blockchain getBlockchain(String filename, BlockchainFactoryEnum factoryEnum) throws IOException, NoSuchAlgorithmException, InvalidKeySpecException, SignatureException, NoSuchProviderException, InvalidKeyException {          List<Block> blocks = UtilsBlock.readLineObject(filename);         Blockchain blockchain = null;         blockchain = BLockchainFactory.getBlockchain(factoryEnum);          if (blocks.size() != 0) {            blockchain.setBlockchainList(blocks);         }         return blockchain;     }      public static Map<String, Account> getBalances(String filename, Blockchain blockchain, Map<String, Account> balances) throws IOException, NoSuchAlgorithmException, SignatureException, InvalidKeySpecException, NoSuchProviderException, InvalidKeyException {         //start test           //папка чтобы проверить есть ли         File folder = new File(filename);         List<String> files = new ArrayList<>();         for (File file : folder.listFiles()) {             if(!file.isDirectory()){                 files.add(file.getAbsolutePath());             }         }          if (files.size() > 0 ){             File file = new File(files.get(files.size()-1));             if(file.exists() && file.length() > 0){                 balances = SaveBalances.readLineObject(filename);             }          }          if (balances == null) {             balances = new HashMap<>();         }          Block block;         if(blockchain != null && blockchain.sizeBlockhain() > 0){             block = blockchain.getBlock(blockchain.sizeBlockhain() - 1);             balances = UtilsBalance.calculateBalance(balances, block);           }           return balances;     }      public static void deleteFiles(String fileDelit) {         UtilsFileSaveRead.deleteAllFiles(fileDelit);     }       public static Block miningDay(             Account minner,             Blockchain blockchain,             long blockGenerationInterval,             int DIFFICULTY_ADJUSTMENT_INTERVAL,             List<DtoTransaction> transactionList,             Map<String, Account> balances,             long index     ) throws IOException, NoSuchAlgorithmException, SignatureException, InvalidKeySpecException, NoSuchProviderException, InvalidKeyException {         Directors directors = new Directors();         //получение транзакций с сети         List<DtoTransaction> listTransactions = transactionList;          //определение валидных транзакций         List<DtoTransaction> forAdd = new ArrayList<>();          //проверяет целостность транзакции, что они подписаны правильно         cicle:         for (DtoTransaction transaction : listTransactions) {             if (transaction.verify()) {                  Account account = balances.get(transaction.getSender());                 if (account == null) {                     System.out.println(\"minerAccount null\");                     continue cicle;                 }                 //NAME_LAW_ADDRESS_START если адресс  означает правила выбранные сетью                 if(transaction.getCustomer().startsWith(Seting.NAME_LAW_ADDRESS_START) && !balances.containsKey(transaction.getCustomer())){                     //если в названия закона совпадает с корпоративными должностями, то закон является действительным только когда                     //отправитель совпадает с законом //                    List<Director> enumPosition = directors.getDirectors();                     List<String> corporateSeniorPositions = directors.getDirectors().stream()                             .map(t->t.getName()).collect(Collectors.toList());                     System.out.println(\"LawsController: create_law: \" + transaction.getLaws().getPacketLawName()                             + \"contains: \" + corporateSeniorPositions.contains(transaction.getLaws().getPacketLawName()));                     if(corporateSeniorPositions.contains(transaction.getLaws().getPacketLawName())                             && !UtilsGovernment.checkPostionSenderEqualsLaw(transaction.getSender(), transaction.getLaws())){                         System.out.println(\"if your create special corporate position, you need \" +                                 \"sender to be equals with first law: now its wrong\");                         continue cicle;                     }                 }                 if(transaction.getLaws() == null){                     System.out.println(\"law cannot to be null: \");                     continue cicle;                 }                  if (account != null) {                     if(transaction.getSender().equals(Seting.BASIS_ADDRESS)){                         System.out.println(\"only this miner can input basis adress in this block\");                         continue cicle;                     }                     if(transaction.getCustomer().equals(Seting.BASIS_ADDRESS)){                         System.out.println(\"basis address canot to be customer(recipient)\");                         continue cicle;                     }                      if( account.getDigitalDollarBalance() < transaction.getDigitalDollar() + transaction.getBonusForMiner()){                         System.out.println(\"sender don't have digital dollar: \" + account.getAccount() + \" balance: \" + account.getDigitalDollarBalance() );                         System.out.println(\"digital dollar for send: \" + (transaction.getDigitalDollar() + transaction.getBonusForMiner()));                         continue cicle;                     }                     if (account.getDigitalStockBalance() < transaction.getDigitalStockBalance()){                         System.out.println(\"sender don't have digital reputation: \" + account.getAccount() + \" balance: \" + account.getDigitalStockBalance());                         System.out.println(\"digital reputation for send: \" + (transaction.getDigitalDollar() + transaction.getBonusForMiner()));                         continue cicle;                     }                     if(transaction.getSender().equals(transaction.getCustomer()) ){                         System.out.println(\"sender end recipient equals \" + transaction.getSender() + \" : recipient: \" + transaction.getCustomer());                         continue cicle;                     }                     forAdd.add(transaction);                 }              }         }           //доход майнера         double minerRewards = Seting.DIGITAL_DOLLAR_REWARDS_BEFORE;         double digitalReputationForMiner = Seting.DIGITAL_STOCK_REWARDS_BEFORE;          //доход основателя         double founderReward = Seting.DIGITAL_DOLLAR_FOUNDER_REWARDS_BEFORE;         double founderDigigtalReputationReward = Seting.DIGITAL_REPUTATION_FOUNDER_REWARDS_BEFORE;          Base base = new Base58();          //суммирует все вознаграждения майнеров         PrivateKey privateKey = UtilsSecurity.privateBytToPrivateKey(base.decode(Seting.BASIS_PASSWORD));         double sumRewards = forAdd.stream().collect(Collectors.summingDouble(DtoTransaction::getBonusForMiner));          //вознаграждения майнера         DtoTransaction minerRew = new DtoTransaction(Seting.BASIS_ADDRESS, minner.getAccount(),                 minerRewards, digitalReputationForMiner, new Laws(), sumRewards, VoteEnum.YES );          //подписывает         byte[] signGold = UtilsSecurity.sign(privateKey, minerRew.toSign());         minerRew.setSign(signGold);          //вознаграждение основателя         DtoTransaction founderRew = new DtoTransaction(Seting.BASIS_ADDRESS, blockchain.getADDRESS_FOUNDER(),                 founderReward, founderDigigtalReputationReward, new Laws(), 0.0, VoteEnum.YES);         byte[] signFounder = UtilsSecurity.sign(privateKey, founderRew.toSign());          founderRew.setSign(signFounder);           forAdd.add(minerRew);         forAdd.add(founderRew);           //определение сложности и создание блока         int difficulty = UtilsBlock.difficulty(blockchain.getBlockchainList(), blockGenerationInterval, DIFFICULTY_ADJUSTMENT_INTERVAL);          System.out.println(\"Mining: miningBlock: difficulty: \" + difficulty + \" index: \" + index);           //blockchain.getHashBlock(blockchain.sizeBlockhain() - 1)         Block block = new Block(                 forAdd,                 blockchain.getHashBlock(blockchain.sizeBlockhain() - 1),                 minner.getAccount(),                 blockchain.getADDRESS_FOUNDER(),                 difficulty,                 index);          return block;     } }","package International_Trade_Union.model;  import International_Trade_Union.setings.Seting; import International_Trade_Union.utils.UtilsFileSaveRead;  import java.io.FileNotFoundException;   public class User {     private static String addressMiner=\"\";      public static void setUserAddress(String addressMiner) { //        System.out.println(\"change minerAccount: \" + addressMiner); //        UtilsFileSaveRead.save(addressMiner, Seting.ORIGINAL_ACCOUNT, false);         User.addressMiner = addressMiner;     }      public static String getUserAddress() throws FileNotFoundException {         addressMiner = UtilsFileSaveRead.read(Seting.ORIGINAL_ACCOUNT);         System.out.println(\"user: \" + addressMiner);         if(addressMiner.isEmpty() || addressMiner == null)             addressMiner = \"empty \";         return addressMiner;     } }","package International_Trade_Union.network;  import International_Trade_Union.entity.DtoTransaction.DtoTransaction; import International_Trade_Union.model.Mining; import International_Trade_Union.setings.Seting; import International_Trade_Union.utils.*; import org.json.JSONException;  import java.io.File; import java.io.IOException; import java.security.InvalidKeyException; import java.security.NoSuchAlgorithmException; import java.security.NoSuchProviderException; import java.security.SignatureException; import java.security.spec.InvalidKeySpecException; import java.util.ArrayList; import java.util.List; import java.util.stream.Collectors;  public class AllTransactions {     private static List<DtoTransaction> instance = new ArrayList<>();     //все транзакции которые уже добавлены в блок, нужно чтобы повторно     //не добавлялись в блок если они скачены с дисковери.     private static List<DtoTransaction> sendedTransaction = new ArrayList<>();      public static List<DtoTransaction> readFrom() throws IOException, NoSuchAlgorithmException, InvalidKeySpecException, SignatureException, NoSuchProviderException, InvalidKeyException {         return UtilsTransaction.readLineObject(Seting.ORGINAL_ALL_TRANSACTION_FILE);     }      public static synchronized List<DtoTransaction> getInstance() throws IOException, NoSuchAlgorithmException, InvalidKeySpecException, SignatureException, NoSuchProviderException, InvalidKeyException {         if (instance == null) {             instance = new ArrayList<>();         }         instance = new ArrayList<>();          //считываем с пула транзакции из дисковери.         for (String s : Seting.ORIGINAL_ADDRESSES) {             try {                 String json = UtilUrl.readJsonFromUrl(s + \"/getTransactions\");                 List<DtoTransaction> list = UtilsJson.jsonToDtoTransactionList(json);                  instance.addAll(list);               } catch (IOException | JSONException e) {                  System.out.println(\"AllTransaction: getInstance: Error\");                 continue;             }           }          instance.addAll(UtilsTransaction.readLineObject(Seting.ORGINAL_ALL_TRANSACTION_FILE));         instance = instance.stream().distinct().collect(Collectors.toList());          sendedTransaction = getInsanceSended();          instance.removeAll(sendedTransaction);         return instance;     }      public static synchronized void clearAllTransaction() {         instance = new ArrayList<>();         Mining.deleteFiles(Seting.ORGINAL_ALL_TRANSACTION_FILE);     }      public static synchronized void clearAllSendedTransaction(long index) {         if(index % (Seting.COUNT_BLOCK_IN_DAY * Seting.DAY_DELETED_SENDED_FILE) == 0){             sendedTransaction = new ArrayList<>();             Mining.deleteFiles(Seting.ORIGINAL_ALL_SENDED_TRANSACTION_FILE);             System.out.println(\"clear delete sended transaction\");         }      }      public static synchronized void clearUsedTransaction(List<DtoTransaction> transactions) throws IOException, NoSuchAlgorithmException, SignatureException, InvalidKeySpecException, NoSuchProviderException, InvalidKeyException {         instance = getInstance();         List<DtoTransaction> temporaryDto = new ArrayList<>();          instance = temporaryDto;         instance.removeAll(transactions);         Mining.deleteFiles(Seting.ORGINAL_ALL_TRANSACTION_FILE);         for (DtoTransaction dtoTransaction : instance) {              UtilsTransaction.saveAllTransaction(dtoTransaction, Seting.ORGINAL_ALL_TRANSACTION_FILE);         }       }      public static synchronized void addTransaction(DtoTransaction transaction) throws IOException, NoSuchAlgorithmException, SignatureException, InvalidKeySpecException, NoSuchProviderException, InvalidKeyException {          instance = getInstance();         instance.add(transaction);         Mining.deleteFiles(Seting.ORGINAL_ALL_TRANSACTION_FILE);         instance = instance.stream().filter(UtilsUse.distinctByKey(DtoTransaction::toSign)).collect(Collectors.toList());         for (DtoTransaction dtoTransaction : instance) {             UtilsTransaction.saveAllTransaction(dtoTransaction, Seting.ORGINAL_ALL_TRANSACTION_FILE);         }       }      public static synchronized void addSendedTransaction(List<DtoTransaction> transactions) throws IOException, NoSuchAlgorithmException, InvalidKeySpecException, SignatureException, NoSuchProviderException, InvalidKeyException {         sendedTransaction = getInsanceSended();         sendedTransaction.addAll(transactions);          Mining.deleteFiles(Seting.ORIGINAL_ALL_SENDED_TRANSACTION_FILE);         for (DtoTransaction dtoTransaction : sendedTransaction) {             UtilsTransaction.saveAllTransaction(dtoTransaction, Seting.ORIGINAL_ALL_SENDED_TRANSACTION_FILE);         }          System.out.println(\"AllTransaction: addSendedTransaction: \" + sendedTransaction.size());      }      public static List<DtoTransaction> getInsanceSended() throws IOException, NoSuchAlgorithmException, InvalidKeySpecException, SignatureException, NoSuchProviderException, InvalidKeyException {         if (sendedTransaction == null) {             sendedTransaction = new ArrayList<>();         }         sendedTransaction = UtilsTransaction.readLineObject(Seting.ORIGINAL_ALL_SENDED_TRANSACTION_FILE);         sendedTransaction = sendedTransaction.stream().distinct().collect(Collectors.toList());         return sendedTransaction;     }  }","package International_Trade_Union.network;    import International_Trade_Union.entity.DtoTransaction.DtoTransaction;  import java.util.ArrayList; import java.util.List;  public class Transactions {     public  List<DtoTransaction> getTransactions() {         List<DtoTransaction> transactions = new ArrayList<>();         return transactions;     } }","package International_Trade_Union.node;  import java.util.HashSet; import java.util.Set;  public class Nodes {      public int size(){         return urlAddress.size();     }      public Nodes() {         this.urlAddress = new HashSet<>();     }      public Nodes(Set<String> urlAddress) {         this.urlAddress = urlAddress;     }      private  Set<String> urlAddress = new HashSet<>();      public  void setUrlAddress(Set<String> urlAddress) {         this.urlAddress = urlAddress;     }     public void addAddress(String addressUrl){         urlAddress.add(addressUrl);     }      public  Set<String> getUrlAddresses() {         return urlAddress;     }      public void clear(){         urlAddress = new HashSet<>();     } }","package International_Trade_Union.setings;  import International_Trade_Union.about_usDraft.AboutUsDraft; import International_Trade_Union.about_us_engDraft.AboutUsEngDraft; import International_Trade_Union.CorporateCharterEngDraft.CorporateCharter; import International_Trade_Union.governments.Directors; import International_Trade_Union.governments.NamePOSITION; import International_Trade_Union.utils.UtilsUse;  import java.util.Set;  public interface Seting {     // значение используется для вычисления процентов     int HUNDRED_PERCENT = 100;     // значение используется как константа года,     // в данной системе отсутствует високосный год     int YEAR = 360;      Directors directors = new Directors();       //используется для очистки из файла, где хранятся отправленные транзакции,     //чтобы предотвратить добавление повторно уже отправленных транзакций     int DAY_DELETED_SENDED_FILE = 3;        //За какой период последних блоков учитывать для отбора акционеров.     //Акционерами могут быть только с наибольшим количеством баланса     //отправители и майнеры.     int BOARDS_BLOCK = (int) (Seting.COUNT_BLOCK_IN_DAY * YEAR);       //минимальное значение количество положительных голосов, для того чтобы избрать     // Совет Директоров и Совет Корпоративных Верховных Судей,     int ORIGINAL_LIMIT_MIN_VOTE = 1; //(int) (200 * Seting.COUNT_BLOCK_IN_DAY * 1 / 8);       //прямая демократия, сколько голосов нужно, чтобы правило вступило в силу,     //без необходимости правительства     double ALL_STOCK_VOTE = 1.0;        //Минимальное значение чтобы Совет Корпоративных Верховных Судей могла избрать Верховного Судью     int ORIGINAL_LIMIT_MIN_VOTE_CORPORATE_COUNCIL_OF_REFEREES = 2;      //Минимальное значение остатка голосов чтобы Совет директоров утверждал бюджет,     //стратегический план, в создании новых должностей и назначении новых должностей,     //и т.д. Также участвовал в утверждении законов, вместе с другими участниками.     int ORIGINAL_LIMIT_MIN_VOTE_BOARD_OF_DIRECTORS = 10;      //Минимальное количество остатка голосов чтобы Совет Акционеров     //утверждал вместе с остальными участниками в утверждении законов.     int ORIGINAL_LIMIT_MIN_VOTE_BOARD_OF_SHAREHOLDERS = 10; //100;      //голос Генерального Исполнительного Директора     int ORIGINAL_LIMIT_MIN_VOTE_GENERAL_EXECUTIVE_DIRECTOR = 1;      //фракционный голос минимум 10.0     double ORIGINAL_LIMIT_MIN_VOTE_FRACTIONS = 10.0;      //голос Верховного Судьи     int ORIGINAL_LIMIT_MIN_VOTE_HIGHT_JUDGE = 1;      //для преодоления верховного судьи, если Верховный Судья не одобрил закон     //то нужно получить в два раза больше голосов, чтобы преодолеть вето Верховного Судьи     int POWERFUL_VOTE = 2;      //данная мера нужна чтобы если один счет голосует за несколько кандидатов,     //его голос не делился равномерно, а становился значительно сильнее,     //чтобы не допустить монополии, если очень богатый человек захочет должностные лица поставить к власти     //то он не сможет пример: счет X проголосовал ЗА = 2 закона и ПРОТИВ = 3 закона     //100 = voteYES, 100 = voteNO, voteYES / (2^3) = 12.5 , voteNO / (3^3) = 3.7     //таким образом чем больше голосует, тем меньше голосов остается для избрания     //должностных лиц, это защита от сверхбогатых участников Совета Акционеров     int POWERING_FOR_VOTING = 3;       //голос должностных лиц,     int VOTE_GOVERNMENT = 1;     //голос должностных лиц вместо акций учитывается только один     //голос, как будто у них одна акция     double STOCK_VOTE_GOVERNMENT = 1;      //    процент который получает основатель от добычи     Double FOUNDERS_REWARD = 2.0;      //address for send rewards     String BASIS_ADDRESS = \"faErFrDnBhfSfNnj1hYjxydKNH28cRw1PBwDQEXH3QsJ\";     String BASIS_PASSWORD = \"3hupFSQNWwiJuQNc68HiWzPgyNpQA2yy9iiwhytMS7rZyfPddNRwtvExeevhayzN6xL2YmTXN6NCA8jBhV9ge1w8KciHedGUMgZyq2T7rDdvekVNwEgf5pQrELv8VAEvQ4Kb5uviXJFuMyuD1kRAGExrZym5nppyibEVnTC9Uiw8YzUh2JmVT9iUajnVV3wJ5foMs\";      //сложность коррекция каждые n блоков     int DIFFICULTY_ADJUSTMENT_INTERVAL = (int) (Seting.COUNT_BLOCK_IN_DAY / 2);     int DIFFICULTY_ADJUSTMENT_INTERVAL_TEST = 10;      long BLOCK_GENERATION_INTERVAL = Seting.BLOCK_TIME * 1000;// after Seting.BLOCK_TIME     long BLOCK_GENERATION_INTERVAL_TEST = 0 * 1000;       long INTERVAL_TARGET = 600000;     long INTERVAL_TARGET_TEST = 25000;      // плата за обслуживание каждые 6 месяцев.     Double ANNUAL_MAINTENANCE_FREE_DIGITAL_DOLLAR_YEAR = 0.2;     //отрицательная ставка для цифровой акции     double ANNUAL_MAINTENANCE_FREE_DIGITAL_STOCK_YEAR = 0.4;     //каждые сколько месяцев снимать     int HALF_YEAR = 2;      //стоимость создания закона 5     double COST_LAW = 5;     //с чего начинается адрес пакета закона     //сокращенно корпорация     String NAME_LAW_ADDRESS_START = \"LIBER\";      int HASH_COMPLEXITY_GENESIS = 1;      //совет акционеров    int BOARD_OF_SHAREHOLDERS = 1500;      //ПОПРАВКА В УСТАВЕ    //требования к поправкам     String AMENDMENT_TO_THE_CHARTER = \"AMENDMENT_TO_THE_CHARTER\";      //директора созданные Советом директоров     String ADD_DIRECTOR = \"ADD_DIRECTOR_\";        //бюджет должен формировать только палата представителей     String BUDGET = \"BUDGET\";      //план также утверждается на четыре года и утверждается только палатой представителей     //каждый план обязан содержать дату начала планирования с какого числа вступает в силу.     //FOUR-YEAR PLAN     String STRATEGIC_PLAN = \"STRATEGIC_PLAN\";       //лимиты для ведения поправок     //палата судей минимум 5 голосов     int ORIGINAL_LIMIT_MIN_VOTE_CORPORATE_COUNCIL_OF_REFEREES_AMENDMENT = 5;// 5;     //палата представителей 20% голосов     int ORIGINAL_LIMIT_MIN_VOTE_BOARD_OF_DIRECTORS_AMENDMENT =            directors.getDirector(NamePOSITION.BOARD_OF_DIRECTORS.toString()).getCount() * 20 / 100;      //Совет акционеров минимум 20% голосов     int ORIGINAL_LIMIT_MINT_VOTE_BOARD_OF_SHAREHOLDERS_AMENDMENT = BOARD_OF_SHAREHOLDERS * 20 / 100;         //    адресс основателя: здесь будет мой адрес. Сейчас заглушка     String ADDRESS_FOUNDER_TEST = \"stExZb8ifLfnFoq4JJuTifpAcscegATH8znhwW26zyTa\";     String ADDRESS_FOUNDER = \"stExZb8ifLfnFoq4JJuTifpAcscegATH8znhwW26zyTa\";      String CORPORATE_CHARTER_DRAFT = International_Trade_Union.CorporateCharterDraft.CorporateCharter.getAllConstitution() + \"\\n\" + CorporateCharter.getAllConstitution() + AboutUsDraft.getAboutUs()             + AboutUsEngDraft.getAboutUs();      //КЛЮЧЕВОЕ НАЗВАНИЕ ПАКЕТА ЧТО ЭТО УСТАВ, ДЕЙСТВУЮЩИЙ УСТАВ ПОДПИСАН ОСНОВАТЕЛЕМ.     String ORIGINAL_CHARTER_CURRENT_LAW_PACKAGE_NAME = \"ORIGINAL_CHARTER_CURRENT_LAW_PACKAGE_NAME\";      //КЛЮЧЕВОЕ НАЗВАНИЕ ДЛЯ КОДА КОТОРЫЙ СОПРОВОЖДАЕТСЯ С УСТАВОМ     String ORIGINAL_CHARTER_CURRENT_ALL_CODE = \"ORIGINAL_CHARTER_CURRENT_ALL_CODE\";      //начальная сумма основателя     Double FOUNDERS_REMUNERATION_DIGITAL_DOLLAR = 30000000.0;     double FOUNDERS_REMNUNERATION_DIGITAL_STOCK = 30000000.0;       // сколько секунд в сутках     int DAY_SECOND = 86400;      //    за сколько секунд добывается каждый блок     int BLOCK_TIME = 150;       //сколько блоков добывается в сутки     double COUNT_BLOCK_IN_DAY = (DAY_SECOND / BLOCK_TIME);      //подсчет голосов для должности в годах, учитываются только те голоса     //которые не позже четырех лет для законов и должностей,     //голоса отданные за законы должны обновляться каждые четыре года     //как и за должности     int POSITION_YEAR_VOTE = (int) Seting.COUNT_BLOCK_IN_DAY * YEAR * 4;     //подсчет голосов для законов в годах     int LAW_YEAR_VOTE = (int) Seting.COUNT_BLOCK_IN_DAY * YEAR * 4;      String ORIGINAL_BLOCKCHAIN_FILE = \"C:\\\\resources\\\\blockchain\\\\\";     String ORIGINAL_BALANCE_FILE = \"C:\\\\resources\\\\balance\\\\\";     String ORIGINAL_BOARD_0F_SHAREHOLDERS_FILE = \"C:\\\\resources\\\\federalGovernment\\\\federalGovernment.txt\";     String ORIGINAL_ALL_CORPORATION_LAWS_FILE = \"C:\\\\resources\\\\federalLaws\\\\\";     String ORIGINAL_ACCOUNT = \"C:\\\\resources\\\\minerAccount\\\\minerAccount.txt\";     String ORIGINAL_CORPORATE_VOTE_FILE = \"C:\\\\resources\\\\vote\\\\\";      String ORIGINAL_ALL_CORPORATION_LAWS_WITH_BALANCE_FILE = \"C:\\\\resources\\\\allLawsWithBalance\\\\\";     String ORGINAL_ALL_TRANSACTION_FILE = \"C:\\\\resources\\\\transactions\\\\\";     String ORIGINAL_ALL_SENDED_TRANSACTION_FILE = \"C:\\\\resources\\\\sendedTransaction\\\\\";     String ORIGINAL_POOL_URL_ADDRESS_FILE = \"C:\\\\resources\\\\poolAddress\\\\\";      //адресса внешних сервисов     Set<String> ORIGINAL_ADDRESSES = Set.of(\"http://194.87.236.238:80\");       int SIZE_FILE_LIMIT = 100;      //папки файла для тестирования с сохранениям файла     String TEST_LAST_BLOCK = \".\\\\src\\\\test\\\\java\\\\unitted_states_of_mankind\\\\resourceTestingFileSaved\\\\lastBlock\\\\\";     String INDEX_TEST = \".\\\\src\\\\test\\\\java\\\\unitted_states_of_mankind\\\\resourceTestingFileSaved\\\\index\\\\index.txt\";     String TEST_BLOCKCHAIN_SAVED = \".\\\\src\\\\test\\\\java\\\\unitted_states_of_mankind\\\\resourceTestingFileSaved\\\\network\\\\\";     String TEST_BLOCKCHAIN_BALANCES = \".\\\\src\\\\test\\\\java\\\\unitted_states_of_mankind\\\\resourceTestingFileSaved\\\\balances\\\\\";     String TEST_FEDERAL_GOVERNMENT = \".\\\\src\\\\test\\\\java\\\\unitted_states_of_mankind\\\\resourceTestingFileSaved\\\\federal government\\\\federalGovernment.txt\";     String TEST_FEDERAL_LAWS = \".\\\\src\\\\test\\\\java\\\\unitted_states_of_mankind\\\\resourceTestingFileSaved\\\\laws\\\\\";     String TEST_CURRENT_LAWS = \".\\\\src\\\\test\\\\java\\\\unitted_states_of_mankind\\\\resourceTestingFileSaved\\\\current laws\\\\\";     String TEST_FEDERAL_VOTE = \".\\\\src\\\\test\\\\java\\\\unitted_states_of_mankind\\\\resourceTestingFileSaved\\\\vote\\\\\";     String TEST_ALL_FEDERAL_LAWS_WITH_BALANCE_FILE = \".\\\\src\\\\test\\\\java\\\\unitted_states_of_mankind\\\\resourceTestingFileSaved\\\\allLawsWithBalance\\\\\";      //Временный блокчейн для тестирования     String TEST_LAST_BLOCK_TEMPORARY = \".\\\\src\\\\test\\\\java\\\\unitted_states_of_mankind\\\\resourceTestingFileWithoutSave\\\\lastBlock\\\\\";     String TEST_INDEX_TEMPORARY = \".\\\\src\\\\test\\\\java\\\\unitted_states_of_mankind\\\\resourceTestingFileWithoutSave\\\\index\\\\index.txt\";     String TEST_TEMPORARY_BLOCKCHAIN = \".\\\\src\\\\test\\\\java\\\\unitted_states_of_mankind\\\\resourceTestingFileWithoutSave\\\\temporary blockchain\\\\\";     String TEST_BLOCKCHAIN_BALANCES_TEMPORARY = \".\\\\src\\\\test\\\\java\\\\unitted_states_of_mankind\\\\resourceTestingFileWithoutSave\\\\balances\\\\\";     String TEST_FEDERAL_GOVERNMENT_TEMPORARY = \".\\\\src\\\\test\\\\java\\\\unitted_states_of_mankind\\\\resourceTestingFileWithoutSave\\\\federal government\\\\federalGovernment.txt\";     String TEST_FEDERAL_LAWS_TEMPORARY = \".\\\\src\\\\test\\\\java\\\\unitted_states_of_mankind\\\\resourceTestingFileWithoutSave\\\\laws\\\\\";     String TEST_CURRENT_LAWS_TEMPORARY = \".\\\\src\\\\test\\\\java\\\\unitted_states_of_mankind\\\\resourceTestingFileWithoutSave\\\\current laws\\\\\";     String TEST_FEDERAL_VOTE_TEMPORARY = \".\\\\src\\\\test\\\\java\\\\unitted_states_of_mankind\\\\resourceTestingFileSaved\\\\vote\\\\\";     String TEST_ALL_FEDERAL_LAWS_WITH_BALANCE_TEMPORARY = \".\\\\unitedStates\\\\src\\\\test\\\\java\\\\unitted_states_of_mankind\\\\resourceTestingFileWithoutSave\\\\allLawsWithBalance\\\\\";      String TEST_FILE_WRITE_INFO = \".\\\\src\\\\test\\\\java\\\\unitted_states_of_mankind\\\\blockchainTwentyYearTest\\\\\";     double DIGITAL_DOLLAR_REWARDS_BEFORE = 200.0;     double DIGITAL_STOCK_REWARDS_BEFORE = 200.0;     double DIGITAL_DOLLAR_FOUNDER_REWARDS_BEFORE = Math.round(UtilsUse.countPercents(Seting.DIGITAL_DOLLAR_REWARDS_BEFORE, Seting.FOUNDERS_REWARD));     double DIGITAL_REPUTATION_FOUNDER_REWARDS_BEFORE = Math.round(UtilsUse.countPercents(Seting.DIGITAL_STOCK_REWARDS_BEFORE, Seting.FOUNDERS_REWARD));    }","package International_Trade_Union.utils.base;  public interface Base {     String encode(byte[] input);     byte[] decode(String input); }","package International_Trade_Union.utils.base;    /*  * Copyright 2011 Google Inc.  * Copyright 2018 Andreas Schildbach  *  * From https://github.com/bitcoinj/bitcoinj/blob/master/core/src/main/java/org/bitcoinj/core/Base58.java  *  * Licensed under the Apache License, Version 2.0 (the \"License\");  * you may not use this file except in compliance with the License.  * You may obtain a copy of the License at  *  *    http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an \"AS IS\" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */  import java.math.BigInteger; import java.util.Arrays;  /**  * Base58 is a way to encode Bitcoin addresses (or arbitrary data) as alphanumeric strings.  * <p>  * Note that this is not the same base58 as used by Flickr, which you may find referenced around the Internet.  * <p>  * Satoshi explains: why base-58 instead of standard base-64 encoding?  * <ul>  * <li>Don't want 0OIl characters that look the same in some fonts and  *     could be used to create visually identical looking minerAccount numbers.</li>  * <li>A string with non-alphanumeric characters is not as easily accepted as an minerAccount number.</li>  * <li>E-mail usually won't line-break if there's no punctuation to break at.</li>  * <li>Doubleclicking selects the whole number as one word if it's all alphanumeric.</li>  * </ul>  * <p>  * However, note that the encoding/decoding runs in O(n&sup2;) time, so it is not useful for large data.  * <p>  * The basic idea of the encoding is to treat the data bytes as a large number represented using  * base-256 digits, convert the number to be represented using base-58 digits, preserve the exact  * number of leading zeros (which are otherwise lost during the mathematical operations on the  * numbers), and finally represent the resulting base-58 digits as alphanumeric ASCII characters.  */ public class Base58 implements Base {     public static final char[] ALPHABET = \"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz\".toCharArray();     private static final char ENCODED_ZERO = ALPHABET[0];     private static final int[] INDEXES = new int[128];     static {         Arrays.fill(INDEXES, -1);         for (int i = 0; i < ALPHABET.length; i++) {             INDEXES[ALPHABET[i]] = i;         }     }      /**      * Encodes the given bytes as a base58 string (no checksum is appended).      *      * @param input the bytes to encode      * @return the base58-encoded string      */     public String encode(byte[] input) {         if (input.length == 0) {             return \"\";         }         // Count leading zeros.         int zeros = 0;         while (zeros < input.length && input[zeros] == 0) {             ++zeros;         }         // Convert base-256 digits to base-58 digits (plus conversion to ASCII characters)         input = Arrays.copyOf(input, input.length); // since we modify it in-place         char[] encoded = new char[input.length * 2]; // upper bound         int outputStart = encoded.length;         for (int inputStart = zeros; inputStart < input.length; ) {             encoded[--outputStart] = ALPHABET[divmod(input, inputStart, 256, 58)];             if (input[inputStart] == 0) {                 ++inputStart; // optimization - skip leading zeros             }         }         // Preserve exactly as many leading encoded zeros in output as there were leading zeros in input.         while (outputStart < encoded.length && encoded[outputStart] == ENCODED_ZERO) {             ++outputStart;         }         while (--zeros >= 0) {             encoded[--outputStart] = ENCODED_ZERO;         }         // Return encoded string (including encoded leading zeros).         return new String(encoded, outputStart, encoded.length - outputStart);     }      /**      * Decodes the given base58 string into the original data bytes.      *      * @param input the base58-encoded string to decode      * @return the decoded data bytes      */     public byte[] decode(String input) {         if (input.length() == 0) {             return new byte[0];         }         // Convert the base58-encoded ASCII chars to a base58 byte sequence (base58 digits).         byte[] input58 = new byte[input.length()];         for (int i = 0; i < input.length(); ++i) {             char c = input.charAt(i);             int digit = c < 128 ? INDEXES[c] : -1;             if (digit < 0) {                 throw new IllegalStateException(\"InvalidCharacter in base 58\");             }             input58[i] = (byte) digit;         }         // Count leading zeros.         int zeros = 0;         while (zeros < input58.length && input58[zeros] == 0) {             ++zeros;         }         // Convert base-58 digits to base-256 digits.         byte[] decoded = new byte[input.length()];         int outputStart = decoded.length;         for (int inputStart = zeros; inputStart < input58.length; ) {             decoded[--outputStart] = divmod(input58, inputStart, 58, 256);             if (input58[inputStart] == 0) {                 ++inputStart; // optimization - skip leading zeros             }         }         // Ignore extra leading zeroes that were added during the calculation.         while (outputStart < decoded.length && decoded[outputStart] == 0) {             ++outputStart;         }         // Return decoded data (including original number of leading zeros).         return Arrays.copyOfRange(decoded, outputStart - zeros, decoded.length);     }      public  BigInteger decodeToBigInteger(String input) {         return new BigInteger(1, decode(input));     }      /**      * Divides a number, represented as an array of bytes each containing a single digit      * in the specified base, by the given divisor. The given number is modified in-place      * to contain the quotient, and the return value is the remainder.      *      * @param number the number to divide      * @param firstDigit the index within the array of the first non-zero digit      *        (this is used for optimization by skipping the leading zeros)      * @param base the base in which the number's digits are represented (up to 256)      * @param divisor the number to divide by (up to 256)      * @return the remainder of the division operation      */     private byte divmod(byte[] number, int firstDigit, int base, int divisor) {         // this is just long division which accounts for the base of the input digits         int remainder = 0;         for (int i = firstDigit; i < number.length; i++) {             int digit = (int) number[i] & 0xFF;             int temp = remainder * base + digit;             number[i] = (byte) (temp / divisor);             remainder = temp % divisor;         }         return (byte) remainder;     } }","package International_Trade_Union.utils;    import International_Trade_Union.setings.Seting; import International_Trade_Union.model.Account;  import java.io.File; import java.io.IOException; import java.security.InvalidKeyException; import java.security.NoSuchAlgorithmException; import java.security.NoSuchProviderException; import java.security.SignatureException; import java.security.spec.InvalidKeySpecException; import java.util.ArrayList; import java.util.List; import java.util.Map; import java.util.stream.Collectors;  public class SaveBalances {      public static void saveBalances(Map<String, Account> balances, String filename) throws IOException, NoSuchAlgorithmException, SignatureException, InvalidKeySpecException, NoSuchProviderException, InvalidKeyException {         int fileLimit = Seting.SIZE_FILE_LIMIT * 1024 * 1024;          //папка чтобы проверить есть ли         File folder = new File(filename);         List<String> files = new ArrayList<>();         for (File file : folder.listFiles()) {             if(!file.isDirectory()){                 files.add(file.getAbsolutePath());             }         }          int count = 0;         files = files.stream().sorted().collect(Collectors.toList());         String nextFile = \"\";          if (files.size() > 0) {             nextFile = files.get(files.size()-1);              count = Integer.parseInt(nextFile.replaceAll(\"[^\\\\d]\", \"\"));           }          File file = new File(nextFile);          if(file.length() >= fileLimit){             count++;          }          nextFile = filename + count + \".txt\";          List<String> jsons = new ArrayList<>();         for (Map.Entry<String, Account> stringAccountEntry : balances.entrySet()) {             String json = UtilsJson.objToStringJson(stringAccountEntry.getValue());             jsons.add(json);         }  //        String json = UtilsJson.objToStringJson(minerAccount); //        UtilsFileSaveRead.save(json + \"\\n\", nextFile);         UtilsFileSaveRead.saves(jsons, nextFile, true);      }      public static Map<String, Account> readLineObject(String filename ) throws IOException, NoSuchAlgorithmException, InvalidKeySpecException, SignatureException, NoSuchProviderException, InvalidKeyException {         List<Account> accounts = new ArrayList<>();         File folder = new File(filename);         for (final File fileEntry : folder.listFiles()) {             if (fileEntry.isDirectory()) {                 System.out.println(\"is directory \" + fileEntry.getAbsolutePath());             } else {                 List<String> list = UtilsFileSaveRead.reads(fileEntry.getAbsolutePath());                 for (String s : list) {                    Account account = UtilsJson.jsonToAccount(s);                     accounts.add(account);                 }              }         }         Map<String, Account> balances = accounts                 .stream()                 .collect(Collectors.toMap(Account::getAccount, t->t, (v1, v2) -> v1));         return balances;     } }","package International_Trade_Union.utils;    import International_Trade_Union.model.Account; import International_Trade_Union.setings.Seting;  import java.util.ArrayList; import java.util.List;  public class UtilAccounts {  //    поиск аккаунта по адрессу     public static Account serchAccountByAddress(List<Account> accountList, String address){         Account result = null;         for (Account account : accountList) {             if(account.getAccount().equals(address)){                 result = account; //                System.out.println(String.format(\"find minerAccount: %s, address %s\", minerAccount.getAccount(), address));                 return result;             }         }         return result;     } //    возвращает список счетов чья наличность больше n     public static List<Account> allAccountsRemnantUpperLimit(              List<Account> accountList, double bottomLineMoney){         List<Account> accounts = new ArrayList<>();                  for (Account account : accountList) {                      if(account.getDigitalDollarBalance()>bottomLineMoney)                         accounts.add(account);                 }               return accounts;     }  //    подсчитывает общий баланс всех участников     public static double getAllBalance( List<Account> accountList){         double allBalance = 0.0;              for (Account account : accountList) {                 if(!account.getAccount().equals(Seting.BASIS_ADDRESS))                     allBalance+=account.getDigitalDollarBalance();             }           return allBalance;     }     }","package International_Trade_Union.utils;  import International_Trade_Union.entity.DtoTransaction.DtoTransaction; import International_Trade_Union.setings.Seting;  import java.io.File; import java.io.IOException; import java.security.InvalidKeyException; import java.security.NoSuchAlgorithmException; import java.security.NoSuchProviderException; import java.security.SignatureException; import java.security.spec.InvalidKeySpecException; import java.util.ArrayList; import java.util.HashSet; import java.util.List; import java.util.Set; import java.util.stream.Collectors;  public class UtilsAllAddresses {     public static void saveAllAddresses(String adress, String filename) throws IOException, NoSuchAlgorithmException, SignatureException, InvalidKeySpecException, NoSuchProviderException, InvalidKeyException {         int fileLimit = Seting.SIZE_FILE_LIMIT * 1024 * 1024;          //папка чтобы проверить есть ли         File folder = new File(filename);         List<String> files = new ArrayList<>();         for (File file : folder.listFiles()) {             if(!file.isDirectory()){                 files.add(file.getAbsolutePath());             }         }           int count = 0;         files = files.stream().sorted().collect(Collectors.toList());         String nextFile = \"\";          if (files.size() > 0) {             nextFile = files.get(files.size()-1);              count = Integer.parseInt(nextFile.replaceAll(\"[^\\\\d]\", \"\"));           }          File file = new File(nextFile);          if(file.length() >= fileLimit){             count++;          }          nextFile = filename + count + \".txt\";          String json = UtilsJson.objToStringJson(adress);         UtilsFileSaveRead.save(json + \"\\n\", nextFile);      }      public static Set<String> readLineObject(String filename ) throws IOException, NoSuchAlgorithmException, InvalidKeySpecException, SignatureException, NoSuchProviderException, InvalidKeyException {         Set<String> allAddresses = new HashSet<>();         File folder = new File(filename);         for (final File fileEntry : folder.listFiles()) {             if (fileEntry.isDirectory()) {                 System.out.println(\"is directory \" + fileEntry.getAbsolutePath());             } else {                 Set<String> list = UtilsFileSaveRead.readSet(fileEntry.getAbsolutePath())                         .stream().collect(Collectors.toSet());                 for (String s : list) {                     allAddresses.add(s);                 }              }         }          allAddresses = allAddresses                 .stream()                 .collect(Collectors.toSet());           return allAddresses;     }  }","package International_Trade_Union.utils;    import International_Trade_Union.entity.DtoTransaction.DtoTransaction; import International_Trade_Union.entity.blockchain.Blockchain; import International_Trade_Union.entity.blockchain.block.Block; import International_Trade_Union.setings.Seting; import International_Trade_Union.model.Account; import International_Trade_Union.vote.VoteEnum;  import java.io.IOException; import java.security.*; import java.security.spec.InvalidKeySpecException; import java.util.*;   public class UtilsBalance {      //подсчет по штучно баланса     public  static Map<String, Account> calculateBalance(Map<String, Account> balances, Block block) throws IOException, NoSuchAlgorithmException, SignatureException, InvalidKeySpecException, NoSuchProviderException, InvalidKeyException {           double percent = Seting.ANNUAL_MAINTENANCE_FREE_DIGITAL_DOLLAR_YEAR / Seting.HALF_YEAR;         double digitalReputationPercent = Seting.ANNUAL_MAINTENANCE_FREE_DIGITAL_STOCK_YEAR / Seting.HALF_YEAR;             int i = (int) block.getIndex();               for (int j = 0; j < block.getDtoTransactions().size(); j++) {                 int BasisSendCount = 0;                   DtoTransaction transaction = block.getDtoTransactions().get(j);                  if(transaction.getSender().startsWith(Seting.NAME_LAW_ADDRESS_START)){                     System.out.println(\"law balance cannot be sender\");                     continue;                 }                 if (transaction.verify()) {                     if(transaction.getSender().equals(Seting.BASIS_ADDRESS))                         BasisSendCount++;                       Account sender = getBalance(transaction.getSender(), balances);                     Account customer = getBalance(transaction.getCustomer(), balances);                      boolean sendTrue = true;                     if(sender.getAccount().equals(Seting.BASIS_ADDRESS) && BasisSendCount > 2){                         System.out.println(\"Basis address can send only two the base address can send no more than two times per block:\" + Seting.BASIS_ADDRESS);                         continue;                     }                      double minerRewards = Seting.DIGITAL_DOLLAR_REWARDS_BEFORE;                     double digitalReputationForMiner = Seting.DIGITAL_STOCK_REWARDS_BEFORE;                        if(sender.getAccount().equals(Seting.BASIS_ADDRESS) ){                        if(i > 1 && (transaction.getDigitalDollar() > minerRewards || transaction.getDigitalStockBalance() > digitalReputationForMiner )){                            System.out.println(\"rewards cannot be upper than \" + minerRewards);                            continue;                        }                         if(!customer.getAccount().equals(block.getFounderAddress()) && !customer.getAccount().equals(block.getMinerAddress())){                             System.out.println(\"Basis address can send only to founder or miner\");                             continue;                         }                     }                     sendTrue = UtilsBalance.sendMoney(sender, customer, transaction.getDigitalDollar(), transaction.getDigitalStockBalance(), transaction.getBonusForMiner(), transaction.getVoteEnum());                      //если транзация валидная то записать данн иыезменения в баланс                     if(sendTrue){                         balances.put(sender.getAccount(), sender);                         balances.put(customer.getAccount(), customer);                     }                  }              }           if (i != 0 && i / Seting.COUNT_BLOCK_IN_DAY % (Seting.YEAR / Seting.HALF_YEAR) == 0.0) {              for (Map.Entry<String, Account> changeBalance : balances.entrySet()) {                 Account change = changeBalance.getValue();                 change.setDigitalStockBalance(change.getDigitalStockBalance() - UtilsUse.countPercents(change.getDigitalStockBalance(), digitalReputationPercent));                 change.setDigitalDollarBalance(change.getDigitalDollarBalance() - UtilsUse.countPercents(change.getDigitalDollarBalance(), percent));             }         }           return balances;      }     //подсчет целиком баланса     public static Map<String, Account> calculateBalances(List<Block> blocks) throws IOException, NoSuchAlgorithmException, SignatureException, InvalidKeySpecException, NoSuchProviderException, InvalidKeyException {         Map<String, Account> balances = new HashMap<>();         for (Block block :  blocks) {             calculateBalance(balances, block);         }          return balances;      }        public static Account getBalance(String address, Map<String, Account> balances) {         if (balances.containsKey(address)) {             return balances.get(address);         } else {             Account account = new Account(address, 0.0, 0.0);             return account;         }     }       public static Account findAccount(Blockchain blockList, String address) throws IOException, NoSuchAlgorithmException, SignatureException, InvalidKeySpecException, NoSuchProviderException, InvalidKeyException {         Map<String, Account> accountMap = calculateBalances(blockList.getBlockchainList());         Account account = accountMap.get(address);         return account != null? account: new Account(address, 0.0, 0.0);     }      public static boolean sendMoney(Account senderAddress, Account recipientAddress, double digitalDollar, double digitalReputation, double minerRewards) throws NoSuchAlgorithmException, InvalidKeySpecException, IOException, SignatureException, NoSuchProviderException, InvalidKeyException {         return sendMoney(senderAddress, recipientAddress, digitalDollar, digitalReputation, minerRewards, VoteEnum.YES);     }      public static boolean sendMoney(Account senderAddress, Account recipientAddress, double digitalDollar, double digitalReputation, double minerRewards, VoteEnum voteEnum) throws NoSuchAlgorithmException, InvalidKeySpecException, NoSuchProviderException, IOException, SignatureException, InvalidKeyException {         double remnantDigitalDollar = 0.0;         double remnantDigitalReputation = 0.0;         boolean sendTrue = true;         if (senderAddress.getAccount().equals(recipientAddress.getAccount())) {             System.out.println(\"sender %s, recipient %s cannot be equals! Error!\".format(senderAddress.getAccount(), recipientAddress.getAccount()));             sendTrue = false;         }          remnantDigitalDollar = senderAddress.getDigitalDollarBalance();         remnantDigitalReputation = senderAddress.getDigitalStockBalance();          if (!senderAddress.getAccount().equals(Seting.BASIS_ADDRESS)) {             if(remnantDigitalDollar < digitalDollar + minerRewards){                 sendTrue = false;             }             else if(remnantDigitalReputation < digitalReputation){                     System.out.printf(\"sender power %f, les than powerSend:  %f\\n\",                             senderAddress.getDigitalStockBalance(), digitalReputation);                     sendTrue = false;              } else if (recipientAddress.getAccount().equals(Seting.BASIS_ADDRESS)) {                 System.out.println(\"Basis canot to be recipient;\");                 sendTrue = false;             } else {                  senderAddress.setDigitalDollarBalance(senderAddress.getDigitalDollarBalance() - digitalDollar);                 senderAddress.setDigitalStockBalance(senderAddress.getDigitalStockBalance() - digitalReputation);                 recipientAddress.setDigitalDollarBalance(recipientAddress.getDigitalDollarBalance() + digitalDollar);                 //сделано чтобы можно было увеличить или отнять власть                 if (voteEnum.equals(VoteEnum.YES)) {                     recipientAddress.setDigitalStockBalance(recipientAddress.getDigitalStockBalance() + digitalReputation);                 } else if (voteEnum.equals(VoteEnum.NO)) {                     //политика сдерживания.                     recipientAddress.setDigitalStockBalance(recipientAddress.getDigitalStockBalance() - digitalReputation);                 }              }           }  else if (senderAddress.getAccount().equals(Seting.BASIS_ADDRESS)) {              recipientAddress.setDigitalDollarBalance(recipientAddress.getDigitalDollarBalance() + digitalDollar);             recipientAddress.setDigitalStockBalance(recipientAddress.getDigitalStockBalance() + digitalReputation);          }         return sendTrue;     } }","package International_Trade_Union.utils;   import com.fasterxml.jackson.core.JsonProcessingException; import International_Trade_Union.config.BLockchainFactory; import International_Trade_Union.config.BlockchainFactoryEnum; import International_Trade_Union.entity.DtoTransaction.DtoTransaction; import International_Trade_Union.entity.blockchain.Blockchain; import International_Trade_Union.entity.blockchain.block.Block; import International_Trade_Union.setings.Seting;   import java.io.*; import java.security.*; import java.security.spec.InvalidKeySpecException; import java.util.*; import java.util.stream.Collectors;  public class UtilsBlock {      public static void saveBlocks(List<Block> blocks, String filename) throws IOException {         int fileLimit = Seting.SIZE_FILE_LIMIT * 1024 * 1024;          //папка чтобы проверить есть ли         File folder = new File(filename);         List<String> files = new ArrayList<>();         for (File file : folder.listFiles()) {             if(!file.isDirectory()){                 files.add(file.getAbsolutePath());             }         }          int count = 0;         files = files.stream().sorted().collect(Collectors.toList());         String nextFile = \"\";          if (files.size() > 0) {             nextFile = files.get(files.size()-1);              count = Integer.parseInt(nextFile.replaceAll(\"[^\\\\d]\", \"\"));           }          File file = new File(nextFile);          if(file.length() >= fileLimit){             count++;          }          nextFile = filename + count + \".txt\";          List<String> jsons = new ArrayList<>();         for (Block block: blocks) {             String json = UtilsJson.objToStringJson(block);             jsons.add(json);         }  //        String json = UtilsJson.objToStringJson(minerAccount); //        UtilsFileSaveRead.save(json + \"\\n\", nextFile);         UtilsFileSaveRead.saves(jsons, nextFile, true);     }     public static void saveBLock(Block block, String filename) throws IOException, NoSuchAlgorithmException, SignatureException, InvalidKeySpecException, NoSuchProviderException, InvalidKeyException {         int fileLimit = Seting.SIZE_FILE_LIMIT * 1024 * 1024;          //папка чтобы проверить есть ли         File folder = new File(filename);         List<String> files = new ArrayList<>();         for (File file : folder.listFiles()) {             if(!file.isDirectory()){                 files.add(file.getAbsolutePath());             }         }           int count = 0;         files = files.stream().sorted().collect(Collectors.toList());         String nextFile = \"\";          if (files.size() > 0) {             nextFile = files.get(files.size()-1);              count = Integer.parseInt(nextFile.replaceAll(\"[^\\\\d]\", \"\"));           }          File file = new File(nextFile);          if(file.length() >= fileLimit){             count++;          }           nextFile = filename + count + \".txt\";          String json = UtilsJson.objToStringJson(block);         UtilsFileSaveRead.save(json + \"\\n\", nextFile);      }        public static List<Block> read(String nameFile) throws FileNotFoundException, JsonProcessingException {         return  UtilsJson.jsonToListBLock(UtilsFileSaveRead.read(nameFile));     }      public static List<Block> readLineObject(String filename ) throws IOException, NoSuchAlgorithmException, InvalidKeySpecException, SignatureException, NoSuchProviderException, InvalidKeyException {         List<Block> blocks = new ArrayList<>();         File folder = new File(filename);          for (final File fileEntry : folder.listFiles()) {             if (fileEntry.isDirectory()) {                 System.out.println(\"is directory \" + fileEntry.getAbsolutePath());             } else {                List<String> list = UtilsFileSaveRead.reads(fileEntry.getAbsolutePath());                 for (String s : list) {                      Block block = UtilsJson.jsonToBLock(s);                     blocks.add(block);                 }              }         }         blocks = blocks                 .stream()                 .sorted(Comparator.comparing(Block::getIndex))                 .collect(Collectors.toList());          return blocks;     }     public static Blockchain readBLock(String nameFile, long BLOCK_GENERATION_INTERVAL, int DIFFICULTY_ADJUSTMENT_INTERVAL, long INTERVAL_TARGET , String ADDRESS_FOUNDER) throws NoSuchAlgorithmException, InvalidKeySpecException, IOException, SignatureException, NoSuchProviderException, InvalidKeyException {         List<Block> blocks = null;         List<List<Block>> list = new ArrayList<>();          File folder = new File(nameFile);          for (final File fileEntry : folder.listFiles()) {             if (fileEntry.isDirectory()) {                 System.out.println(\"is directory \" + fileEntry.getAbsolutePath());             } else {                 blocks = UtilsJson.jsonToListBLock(UtilsFileSaveRead.read(fileEntry.getAbsolutePath()));                 list.add(blocks);             }         }          // new Blockchain(BLOCK_GENERATION_INTERVAL, DIFFICULTY_ADJUSTMENT_INTERVAL, INTERVAL_TARGET, ADDRESS_FOUNDER);         Blockchain blockchain = BLockchainFactory.getBlockchain(BlockchainFactoryEnum.ORIGINAL);         blockchain.setBlockchainList(new ArrayList<>());          for (List<Block> lists : list) {             for (int i = 0; i < lists.size(); i++) {                 blockchain.addBlock(lists.get(i));             }          }          List<Block> blockList = blockchain.getBlockchainList()                 .stream()                 .sorted(Comparator.comparing(Block::getIndex))                 .collect(Collectors.toList());         blockchain.setBlockchainList(blockList);          return blockchain;     }      public static Blockchain readBLock() throws IOException, NoSuchAlgorithmException, InvalidKeySpecException, SignatureException, NoSuchProviderException, InvalidKeyException {        return readBLock(Seting.TEST_FILE_WRITE_INFO, Seting.BLOCK_GENERATION_INTERVAL,  Seting.DIFFICULTY_ADJUSTMENT_INTERVAL, Seting.INTERVAL_TARGET, Seting.ADDRESS_FOUNDER );     }      public static boolean isValidTimestamp(Block newBlock, Block prevBLock, long timestamp){         return (prevBLock.getTimestamp().getTime() - timestamp <newBlock.getTimestamp().getTime())                 && newBlock.getTimestamp().getTime() < System.currentTimeMillis();     }      //https://lhartikk.github.io/jekyll/update/2017/07/13/chapter2.html     //сайт сложности     //https://lhartikk.github.io/jekyll/update/2017/07/13/chapter2.html     //https://tproger.ru/translations/blockchain-explained/      //new https://guicommits.com/building-blockchain-with-python/      /**определяет сложность, раз пол дня корректирует сложность. В сутках 576 блоков.      * каждый блок добывается примерно 2.3 минуты*/     public static int difficulty(List<Block> blocks, long BLOCK_GENERATION_INTERVAL, int  DIFFICULTY_ADJUSTMENT_INTERVAL ){          //секунды как часто создается блоки         int difficulty = 1;         Block latestBlock = blocks.get(blocks.size() -1);         if(latestBlock.getIndex() != 0 && latestBlock.getIndex() % DIFFICULTY_ADJUSTMENT_INTERVAL == 0){             difficulty = getAdjustedDifficulty(latestBlock, blocks, BLOCK_GENERATION_INTERVAL, DIFFICULTY_ADJUSTMENT_INTERVAL);             System.out.println(\"difficulty: change dificulty: \" + difficulty);         }         else {             difficulty =  latestBlock.getHashCompexity();         }         return difficulty == 0? 1: difficulty;     }       /**получить сложность*/     private static int getAdjustedDifficulty(Block latestBlock, List<Block> blocks, long BLOCK_GENERATION_INTERVAL, int DIFFICULTY_ADJUSTMENT_INTERVAL){         Block prevAdjustmentBlock = blocks.get(blocks.size() - DIFFICULTY_ADJUSTMENT_INTERVAL);          long timeExpected = BLOCK_GENERATION_INTERVAL * DIFFICULTY_ADJUSTMENT_INTERVAL;         long timeTaken = latestBlock.getTimestamp().getTime() - prevAdjustmentBlock.getTimestamp().getTime();          if(timeTaken < timeExpected / 2){              return prevAdjustmentBlock.getHashCompexity() + 1;         }else if(timeTaken > timeExpected * 2){              return prevAdjustmentBlock.getHashCompexity() - 1;         }else {             return prevAdjustmentBlock.getHashCompexity();         }     }      public static boolean validationOneBlock(             String addressFounder,             Block previusblock,             Block thisBlock,             long blockGenerationInterval,             int difficultyAdjustmentInterval,             List<Block> lastBlock) throws IOException, NoSuchAlgorithmException, SignatureException, InvalidKeySpecException, NoSuchProviderException, InvalidKeyException {          boolean addressFounderReward = false;         boolean addressMinerReward = false;         if(!addressFounder.equals(thisBlock.getFounderAddress())){             System.out.println(\"genesis address not equals block founder: \");             System.out.println(\"genesis address: \" + addressFounder);             System.out.println(\"block address: \" + thisBlock.getFounderAddress());             return false;          }               String actualPrevHash = previusblock.hashForBlockchain();             String recordedPrevHash = thisBlock.getPreviousHash();            boolean validated = true;         int countBasisSendFounder = 0;         int countBasisSendAll = 0;         finished:         for (DtoTransaction transaction : thisBlock.getDtoTransactions()) {             if(transaction.verify() && transaction.getSender().equals(Seting.BASIS_ADDRESS)){                 double minerReward = Seting.DIGITAL_DOLLAR_REWARDS_BEFORE;                 double minerPowerReward = Seting.DIGITAL_STOCK_REWARDS_BEFORE;                    if(transaction.getSender().equals(Seting.BASIS_ADDRESS)&&                         transaction.getCustomer().equals(thisBlock.getMinerAddress()) && transaction.getDigitalDollar() > minerReward                         && thisBlock.getIndex() > 1){                     System.out.println(\"wrong transaction: reward miner wrong digital dollar: \" + minerReward + \" index: \" + thisBlock.getIndex());                     System.out.println(\"sendmoney \" + transaction.getDigitalDollar());                     validated = false;                     break;                 }                 if(transaction.getSender().equals(Seting.BASIS_ADDRESS) &&                         transaction.getCustomer().equals(thisBlock.getMinerAddress()) && transaction.getDigitalStockBalance()                         > minerPowerReward                         && thisBlock.getIndex() > 1){                     System.out.println(\"wrong transaction: reward miner wrong digital stock: \" + minerPowerReward + \" need: \" + transaction.getDigitalStockBalance());                     System.out.println(transaction);                     validated = false;                     break;                 }                   if(transaction.getSender().equals(Seting.BASIS_ADDRESS)                         &&transaction.getCustomer().equals(addressFounder)){                     countBasisSendFounder += 1;                 }                  if(transaction.getSender().equals(Seting.BASIS_ADDRESS)&&!transaction.getCustomer().equals(addressFounder))                 {                     countBasisSendAll +=1;                 }                  if(countBasisSendFounder > 2 && thisBlock.getIndex() > 1){                     System.out.println(\"basis sender send for founder uper one: \" + countBasisSendFounder);                     validated = false;                     break;                 }                  if(countBasisSendAll > 1 && thisBlock.getIndex() > 1){                     System.out.println(\"basis sender send uper two: \" + countBasisSendAll + \" block index: \" + thisBlock.getIndex());                     validated = false;                     break;                 }             }             else if(!transaction.verify()){                 System.out.println(\"wrong transaction: \" + transaction + \" verify: \" + transaction.verify());                 validated = false;                 break finished;             }          }             if(!UtilsUse.hashComplexity(thisBlock.getHashBlock(), thisBlock.getHashCompexity())){                 System.out.println(\"does't start hash with 0\");                 System.out.println(\"this block hash: \" + thisBlock.getHashBlock());                 return false;             }              if(!actualPrevHash.equals(recordedPrevHash)){                 System.out.println(\"Blockchain is invalid, expected: \" + recordedPrevHash + \" actual: \" + actualPrevHash );                 System.out.println(\"index block: \" + thisBlock.getIndex());                 System.out.println(\"wrong chain hash\");                 return false;             }          return validated;     }      public static void deleteFiles(){         UtilsFileSaveRead.deleteAllFiles(Seting.ORIGINAL_BLOCKCHAIN_FILE);          UtilsFileSaveRead.deleteAllFiles(Seting.ORIGINAL_BALANCE_FILE);         UtilsFileSaveRead.deleteAllFiles(Seting.ORIGINAL_ALL_CORPORATION_LAWS_FILE);         UtilsFileSaveRead.deleteAllFiles(Seting.ORIGINAL_ALL_CORPORATION_LAWS_WITH_BALANCE_FILE);     }      public static boolean validation(List<Block> blocks, long BLOCK_GENERATION_INTERVAL, int DIFFICULTY_ADJUSTMENT_INTERVAL ) throws IOException, NoSuchAlgorithmException, SignatureException, InvalidKeySpecException, NoSuchProviderException, InvalidKeyException {         boolean validated = true;         List<Block> temporary = new ArrayList<>();         Block prevBlock  = null;         for (Block block : blocks) {             if(prevBlock == null){                 prevBlock = block;                 temporary.add(block);                 continue;             }              temporary.add(block);              validated = validationOneBlock(block.getFounderAddress(),                     prevBlock,                     block,                     BLOCK_GENERATION_INTERVAL,                     DIFFICULTY_ADJUSTMENT_INTERVAL,                     temporary );             if(validated == false){                  System.out.println(\"ERROR: UtilsBlock: validation: prevBLock.Hash():\" + prevBlock.getHashBlock());                 System.out.println(\"ERROR: UtilsBlock: validation: index:\" + block.getIndex());                 System.out.println(\"ERROR: UtilsBlock: validation: block.Hash():\" + block.getHashBlock());                 System.out.println(\"ERROR: UtilsBlock: validation: BLOCK_GENERATION_INTERVAL:\" + BLOCK_GENERATION_INTERVAL);                 System.out.println(\"ERROR: UtilsBlock: validation: DIFFICULTY_ADJUSTMENT_INTERVAL:\" + DIFFICULTY_ADJUSTMENT_INTERVAL);                 System.out.println(\"ERROR: UtilsBlock: validation: temporary:\" + temporary.size());                 return false;             }             prevBlock = block;         }         return validated;     } }","package International_Trade_Union.utils;  import java.io.*; import java.util.ArrayList; import java.util.HashSet; import java.util.List; import java.util.Set;  public class UtilsFileSaveRead {      public static void save(String object, String fileName) throws IOException {        save(object, fileName, true);     }     public static void save(String object, String fileName, boolean save){         try(BufferedWriter writer = new BufferedWriter(new FileWriter(fileName, save))) {             writer.write(object);             writer.flush();          }catch (IOException e){             e.printStackTrace();         }       }      public static void saves(List<String> objects, String fileName, boolean save){          try(BufferedWriter writer = new BufferedWriter(new FileWriter(fileName, save))) {              for (String s : objects) {                 writer.write(s + \"\\n\");             }             writer.flush();          }catch (IOException e){             e.printStackTrace();         }     }      public static String read(String file) throws FileNotFoundException {         String text = \"\";         File file1 = new File(file);         if(!file1.exists()){             System.out.println(\"file dosn't have\");             return text;         }         try( BufferedReader reader = new BufferedReader(new FileReader(file))){             while (reader.ready()){                 text += reader.readLine();             }         }catch (IOException e){             e.printStackTrace();         }         return text;     }     public static Set<String> readSet(String file){         Set<String> list = new HashSet<>();          try( BufferedReader reader = new BufferedReader(new FileReader(file))){             while (reader.ready()){                 list.add(reader.readLine());             }         }catch (IOException e){             e.printStackTrace();         }         return list;     }     public static List<String> reads(String file){         List<String> list = new ArrayList<>();          try( BufferedReader reader = new BufferedReader(new FileReader(file))){             while (reader.ready()){                 list.add(reader.readLine());             }         }catch (IOException e){             e.printStackTrace();         }         return list;     }         public static void deleteAllFiles(String path){         File folder = new File(path);         for (File file : folder.listFiles()) {             if(!file.isDirectory()){                 file.delete();             }         }     }      public static void deleteFile(String path){         File file = new File(path);         file.delete();     }  }","package International_Trade_Union.utils;  import com.fasterxml.jackson.core.JsonProcessingException; import com.fasterxml.jackson.core.type.TypeReference; import com.fasterxml.jackson.databind.ObjectMapper; import International_Trade_Union.entity.DtoTransaction.DtoTransaction; import International_Trade_Union.entity.EntityChain; import International_Trade_Union.entity.blockchain.block.Block; import International_Trade_Union.model.Account; import International_Trade_Union.vote.CurrentLawVotes; import International_Trade_Union.vote.LawEligibleForParliamentaryApproval; import International_Trade_Union.vote.Laws;   import java.io.IOException; import java.io.StringWriter; import java.util.List; import java.util.Set;  public class UtilsJson {     public static String objToStringJson(Object object) throws IOException {         ObjectMapper mapper = new ObjectMapper();         StringWriter writer = new StringWriter();         mapper.writeValue(writer, object);         return writer.toString();     }      public static Object jsonToListBLock(String json, Class cls) throws JsonProcessingException {         ObjectMapper mapper = new ObjectMapper();         return mapper.readValue(json, cls);     }      public static List<Block> jsonToListBLock(String json) throws JsonProcessingException {         ObjectMapper mapper = new ObjectMapper();         return mapper.readValue(json, new TypeReference<List<Block>>(){});     }     public static List<Account> jsonToListAccounts(String json) throws JsonProcessingException {         ObjectMapper mapper = new ObjectMapper();         return mapper.readValue(json, new TypeReference<List<Account>>(){});     }      public static Set<String> jsonToSetAddresses(String json) throws  JsonProcessingException{         ObjectMapper mapper = new ObjectMapper();         return mapper.readValue(json, new TypeReference<Set<String>>(){});     }     public static Block jsonToBLock(String json) throws JsonProcessingException {         ObjectMapper mapper = new ObjectMapper();         return mapper.readValue(json, Block.class);     }      public static Laws jsonToLaw(String json) throws JsonProcessingException {         ObjectMapper mapper = new ObjectMapper();         return mapper.readValue(json, Laws.class);     }      public static CurrentLawVotes jsonToVote(String json) throws  JsonProcessingException{         ObjectMapper mapper = new ObjectMapper();         return mapper.readValue(json, CurrentLawVotes.class);     }      public static LawEligibleForParliamentaryApproval jsonToCurrentLaw(String json) throws JsonProcessingException {         ObjectMapper mapper = new ObjectMapper();         return mapper.readValue(json, LawEligibleForParliamentaryApproval.class);     }     public static Account jsonToAccount(String json) throws JsonProcessingException {         ObjectMapper mapper = new ObjectMapper();         return mapper.readValue(json, Account.class);     }     public static EntityChain jsonToEntityChain(String json) throws  JsonProcessingException{         ObjectMapper mapper = new ObjectMapper();         return mapper.readValue(json, EntityChain.class);     }      public static DtoTransaction jsonToDtoTransaction(String json) throws  JsonProcessingException{         ObjectMapper mapper = new ObjectMapper();         return mapper.readValue(json, DtoTransaction.class);      }      public static List<DtoTransaction> jsonToDtoTransactionList(String json) throws  JsonProcessingException{         ObjectMapper mapper = new ObjectMapper();         return mapper.readValue(json, new TypeReference<List<DtoTransaction>>(){});     } }","package International_Trade_Union.utils;    import International_Trade_Union.model.Keys; import International_Trade_Union.utils.base.Base; import International_Trade_Union.utils.base.Base58;  import org.bouncycastle.asn1.ASN1ObjectIdentifier; import org.bouncycastle.asn1.x9.ECNamedCurveTable; import org.bouncycastle.asn1.x9.X9ECParameters; import org.bouncycastle.crypto.params.ECNamedDomainParameters; import org.bouncycastle.crypto.params.ECPublicKeyParameters; import org.bouncycastle.jcajce.provider.asymmetric.ec.BCECPublicKey; import org.bouncycastle.jce.provider.BouncyCastleProvider; import org.bouncycastle.jce.spec.ECNamedCurveParameterSpec; import org.bouncycastle.jce.spec.ECPublicKeySpec; import org.bouncycastle.math.ec.ECCurve; import org.bouncycastle.math.ec.ECPoint;  import java.io.IOException; import java.math.BigInteger; import java.nio.charset.StandardCharsets; import java.security.*; import java.security.interfaces.ECPublicKey; import java.security.spec.*;  //https://metamug.com/article/security/sign-verify-digital-signature-ecdsa-java.html //https://stackoverflow.com/questions/8451205/create-privatekey-and-publickey-having-a-byte-array-encoded-in-base-64 public class UtilsSecurity {     private static final String SPEC = \"secp256k1\";     private static final String ALGO_ECDSA = \"ECDSA\";     private static final String PROVIDER = \"BC\";      static {         Security.addProvider(new org.bouncycastle.jce.provider.BouncyCastleProvider());     }     public static Keys generateKeyPair() throws NoSuchAlgorithmException, InvalidAlgorithmParameterException, NoSuchProviderException, InvalidKeySpecException {        Base base = new Base58();         Security.addProvider(new org.bouncycastle.jce.provider.BouncyCastleProvider());         ECGenParameterSpec ecSpec = new ECGenParameterSpec(SPEC);         KeyPairGenerator g = KeyPairGenerator.getInstance(ALGO_ECDSA, PROVIDER);         g.initialize(ecSpec, new SecureRandom());         KeyPair keyPair = g.generateKeyPair();         String pub = base.encode(UtilsSecurity.compressed(keyPair.getPublic().getEncoded()));         String priv = base.encode(keyPair.getPrivate().getEncoded());         Keys keys = new Keys(pub, priv);         return keys;     }      public static PrivateKey privateBytToPrivateKey(byte[] bytes) throws NoSuchAlgorithmException, InvalidKeySpecException, NoSuchProviderException {         EncodedKeySpec privateKeySpec = new PKCS8EncodedKeySpec(bytes);         KeyFactory generator = KeyFactory.getInstance(ALGO_ECDSA, PROVIDER);         return generator.generatePrivate(privateKeySpec);     }      public static PublicKey publicByteToPublicKey(byte[] bytes) throws NoSuchAlgorithmException, InvalidKeySpecException, NoSuchProviderException {         //new X509EncodedKeySpec         EncodedKeySpec publicKeySpec = new X509EncodedKeySpec(bytes);         KeyFactory generator = KeyFactory.getInstance(ALGO_ECDSA, PROVIDER);         return generator.generatePublic(publicKeySpec);     }       public static KeyPair createKeyPairWithPrivkeyPubKey(PrivateKey privateKey, PublicKey publicKey){         return new KeyPair(publicKey, privateKey);     }       public static byte[] sign(PrivateKey privateKey, String hex) throws NoSuchAlgorithmException, NoSuchProviderException, InvalidKeyException, SignatureException, IOException {         Signature signature = Signature.getInstance(ALGO_ECDSA, PROVIDER);         signature.initSign(privateKey);         signature.update(hex.getBytes(StandardCharsets.UTF_8));         byte[] signByte = signature.sign();         return signByte;     }      public static boolean verify(String sha256message, byte[] sign, PublicKey publicKey) throws NoSuchAlgorithmException, NoSuchProviderException, InvalidKeyException, SignatureException {         Signature signature = Signature.getInstance(ALGO_ECDSA, PROVIDER);         signature.initVerify(publicKey);         signature.update(sha256message.getBytes(StandardCharsets.UTF_8));         return signature.verify(sign);     }       public static byte[] compressed(byte[] pub) throws NoSuchAlgorithmException, NoSuchProviderException, InvalidAlgorithmParameterException, InvalidKeySpecException {          // === NOT PART OF THE CODE, JUST GETTING TEST VECTOR ===         PublicKey publicKey = UtilsSecurity.publicByteToPublicKey(pub);          ECPublicKey key = (ECPublicKey) publicKey;         byte[] x = key.getW().getAffineX().toByteArray();         byte[] y = key.getW().getAffineY().toByteArray();          // assumes that x and y are (unsigned) big endian encoded         BigInteger xbi = new BigInteger(1, x);         BigInteger ybi = new BigInteger(1, y);         X9ECParameters x9 = ECNamedCurveTable.getByName(SPEC);         ASN1ObjectIdentifier oid = ECNamedCurveTable.getOID(SPEC);         ECCurve curve = x9.getCurve();         ECPoint point = curve.createPoint(xbi, ybi);         ECNamedDomainParameters dParams = new ECNamedDomainParameters(oid,                 x9.getCurve(), x9.getG(), x9.getN(), x9.getH(), x9.getSeed());         ECPublicKeyParameters pubKey = new ECPublicKeyParameters(point, dParams);         System.out.println(pubKey);          // some additional encoding tricks         byte[] compressed = point.getEncoded(true);         return compressed;     }     public static ECPublicKey decodeKey(byte[] encoded) {          ECNamedCurveParameterSpec params = org.bouncycastle.jce.ECNamedCurveTable.getParameterSpec(SPEC);         org.bouncycastle.jce.spec.ECPublicKeySpec keySpec = new ECPublicKeySpec(params.getCurve().decodePoint(encoded), params);         return new BCECPublicKey(ALGO_ECDSA, keySpec, BouncyCastleProvider.CONFIGURATION);     } }","package International_Trade_Union.utils;  import International_Trade_Union.controllers.BasisController; import International_Trade_Union.entity.DtoTransaction.DtoTransaction; import International_Trade_Union.entity.blockchain.block.Block; import International_Trade_Union.governments.Directors; import International_Trade_Union.governments.UtilsGovernment; import International_Trade_Union.network.AllTransactions; import International_Trade_Union.setings.Seting;  import java.io.File; import java.io.IOException; import java.security.InvalidKeyException; import java.security.NoSuchAlgorithmException; import java.security.NoSuchProviderException; import java.security.SignatureException; import java.security.spec.InvalidKeySpecException; import java.util.ArrayList; import java.util.Comparator; import java.util.List; import java.util.stream.Collectors;  public class UtilsTransaction {     public static void saveAllTransaction(DtoTransaction dtoTransaction, String filename) throws IOException, NoSuchAlgorithmException, SignatureException, InvalidKeySpecException, NoSuchProviderException, InvalidKeyException {         int fileLimit = Seting.SIZE_FILE_LIMIT * 1024 * 1024;          //папка чтобы проверить есть ли         File folder = new File(filename);         List<String> files = new ArrayList<>();         for (File file : folder.listFiles()) {             if(!file.isDirectory()){                 files.add(file.getAbsolutePath());             }         }           int count = 0;         files = files.stream().sorted().collect(Collectors.toList());         String nextFile = \"\";          if (files.size() > 0) {             nextFile = files.get(files.size()-1);              count = Integer.parseInt(nextFile.replaceAll(\"[^\\\\d]\", \"\"));           }          File file = new File(nextFile);          if(file.length() >= fileLimit){             count++;          }          nextFile = filename + count + \".txt\";          String json = UtilsJson.objToStringJson(dtoTransaction);         UtilsFileSaveRead.save(json + \"\\n\", nextFile);      }      public static List<DtoTransaction> readLineObject(String filename ) throws IOException, NoSuchAlgorithmException, InvalidKeySpecException, SignatureException, NoSuchProviderException, InvalidKeyException {         List<DtoTransaction> dtoTransactions = new ArrayList<>();         File folder = new File(filename);         for (final File fileEntry : folder.listFiles()) {             if (fileEntry.isDirectory()) {                 System.out.println(\"is directory \" + fileEntry.getAbsolutePath());             } else {                 List<String> list = UtilsFileSaveRead.reads(fileEntry.getAbsolutePath());                 for (String s : list) {                      DtoTransaction dtoTransaction = UtilsJson.jsonToDtoTransaction(s);                     dtoTransactions.add(dtoTransaction);                 }              }         }         dtoTransactions = dtoTransactions                 .stream()                 .collect(Collectors.toList());          return dtoTransactions;     }       public static void sendTransaction(DtoTransaction dtoTransaction){      } }","package International_Trade_Union.utils;    import International_Trade_Union.setings.Seting;  import java.io.IOException;  import java.math.BigDecimal; import java.nio.charset.Charset; import java.nio.charset.StandardCharsets; import java.security.MessageDigest; import java.security.NoSuchAlgorithmException; import java.util.HashMap; import java.util.List; import java.util.Random; import java.util.Set; import java.util.concurrent.ConcurrentHashMap; import java.util.function.Function; import java.util.function.Predicate; import java.util.regex.Matcher; import java.util.regex.Pattern;  public class UtilsUse {     private static MessageDigest digest;      static {         try {             digest = MessageDigest.getInstance(\"SHA-256\");         } catch (NoSuchAlgorithmException e) {             e.printStackTrace();         }     } //    одно число от другого в процентах     public static Double percentDifferent(Double first, Double second){         return (first / second - 1) * Seting.HUNDRED_PERCENT;     }      //найти моду     public static int mode(List<Integer> array)     {         HashMap<Integer,Integer> hm = new HashMap<Integer,Integer>();         int max  = 1;         int temp = 0;          for(int i = 0; i < array.size(); i++) {              if (hm.get(array.get(i)) != null) {                  int count = hm.get(array.get(i));                 count++;                 hm.put(array.get(i), count);                  if(count > max) {                     max  = count;                     temp = array.get(i);                 }             }              else                 hm.put(array.get(i),1);         }         return temp;     }      public static BigDecimal percentDifferent(BigDecimal first, BigDecimal second){         return first.divide(second).subtract(new BigDecimal(1)).multiply(new BigDecimal(Seting.HUNDRED_PERCENT));     }      public static byte[] sha256(String text){         return digest.digest(text.getBytes(StandardCharsets.UTF_8));     }     public static String sha256hash(String text){         byte[] bytes = sha256(text);         return bytesToHex(bytes);     }      private static String bytesToHex(byte[] hash) {         StringBuilder hexString = new StringBuilder(2 * hash.length);         for (int i = 0; i < hash.length; i++) {             String hex = Integer.toHexString(0xff & hash[i]);             if(hex.length() == 1) {                 hexString.append('0');             }             hexString.append(hex);         }         return hexString.toString();     }      public static String generateRandomStr() {         byte[] array = new byte[7]; // length is bounded by 7         new Random().nextBytes(array);         String generatedString = new String(array, Charset.forName(\"UTF-8\"));          return generatedString;     }      public static double countPercents(double sum, double percent){         return sum * percent / Seting.HUNDRED_PERCENT;     }     public static BigDecimal countPercents(BigDecimal sum, BigDecimal percent){         return sum.multiply(percent).divide(new BigDecimal(Seting.HUNDRED_PERCENT));     }      public  static double countGrowth(long block, double percent, double money){         long year = (long) (block / Seting.COUNT_BLOCK_IN_DAY / (Seting.YEAR / Seting.HALF_YEAR));         double opeartion1 = 1+ (percent / Seting.HALF_YEAR)/Seting.HUNDRED_PERCENT;         double operation2 = Math.pow(opeartion1, year);         double result = money * operation2;         return result;     }      public static boolean hashComplexity(String literral, int hashComplexity){          String regex = \"^[0]{\" + Integer.toString(hashComplexity) + \"}\";         Pattern pattern = Pattern.compile(regex);         Matcher matcher = pattern.matcher(literral);         return matcher.find();     }      public static String hashComplexityStr(String str, int hashComplexity) throws IOException {         int randomNumberProof = 0;         String hash = \"\";         while (true){             randomNumberProof++;             hash = UtilsUse.sha256hash(UtilsJson.objToStringJson(str + randomNumberProof));             if(UtilsUse.hashComplexity(hash.substring(0, hashComplexity), hashComplexity))             {                 break;             }          }         return hash;     }      //для филтрации в стриме, чтобы получить уникальные обекты по полям     public static <T> Predicate<T> distinctByKey(Function<? super T, ?> keyExtractor) {         Set<Object> seen = ConcurrentHashMap.newKeySet();         return t -> seen.add(keyExtractor.apply(t));     }     //подсчитать количество нулей идущих подряд в hash     public static long hashCount(String hash) {         long count = 0;         for (int i = 0; i < hash.length(); i++) {             if(hash.charAt(i) == '0') count++;             else return count;         }         return count;     }      //подсчитывает долю в процентах одного числа от другого     public static double percentageShare(double first, double allNumber){         return (first/allNumber)*Seting.HUNDRED_PERCENT;     }      //опреледеляет ближайщее число к году     public static long nearestDateToYear(long block){         long period = (long) (Seting.COUNT_BLOCK_IN_DAY * Seting.YEAR);         return block / period * period;     }   }","package International_Trade_Union.utils;  import com.fasterxml.jackson.databind.ObjectMapper; import org.apache.http.NameValuePair; import org.apache.http.client.methods.HttpPost; import org.apache.http.message.BasicNameValuePair; import org.json.JSONException;  import javax.net.ssl.HttpsURLConnection; import java.io.*; import java.net.*; import java.nio.charset.Charset; import java.util.ArrayList; import java.util.Base64; import java.util.List;  public class UtilUrl {     public static String readJsonFromUrl(String url) throws IOException, JSONException {         InputStream is = new URL(url).openStream();         try {             BufferedReader rd = new BufferedReader(new InputStreamReader(is, Charset.forName(\"UTF-8\")));             String jsonText = readAll(rd);             ObjectMapper mapper = new ObjectMapper();             return jsonText;         } finally {             System.out.println(\"UtilUrl: readJsonFromUrl: \" + url );             is.close();         }     }      private static String readAll(Reader rd) throws IOException {         StringBuilder sb = new StringBuilder();         int cp;         while ((cp = rd.read()) != -1) {             sb.append((char) cp);         }         return sb.toString();     }      public static String getObject(String jsonObject, String requstStr) throws IOException {         URL url = new URL(requstStr);         HttpURLConnection conn = (HttpURLConnection) url.openConnection(); //        conn.connect();         conn.setReadTimeout(10000);         conn.setConnectTimeout(15000);         conn.setRequestMethod(\"POST\");         conn.setRequestProperty(\"Content-Type\", \"application/json; utf-8\");         conn.setRequestProperty(\"Accept\", \"application/json\");         conn.setDoOutput(true);            try(OutputStream outputStream = conn.getOutputStream()) {             byte[] input = jsonObject.getBytes(\"utf-8\");             outputStream.write(input, 0, input.length);             conn.getResponseCode();         }           conn.connect();         try(BufferedReader br = new BufferedReader(                 new InputStreamReader(conn.getInputStream(), \"utf-8\"))) {             StringBuilder response = new StringBuilder();             String responseLine = null;             while ((responseLine = br.readLine()) != null) {                 response.append(responseLine.trim());             }             return response.toString();          }      }         public static int sendPost(String jsonObject, String requestStr) throws IOException {         int response;         URL url = new URL(requestStr);         HttpURLConnection conn = (HttpURLConnection) url.openConnection(); //        conn.connect();         conn.setReadTimeout(10000);         conn.setConnectTimeout(15000);         conn.setRequestMethod(\"POST\");         conn.setRequestProperty(\"Content-Type\", \"application/json; utf-8\");         conn.setRequestProperty(\"Accept\", \"application/json\");         conn.setDoOutput(true);            try(OutputStream outputStream = conn.getOutputStream()) {             byte[] input = jsonObject.getBytes(\"utf-8\");             outputStream.write(input, 0, input.length);              response = conn.getResponseCode();          }           conn.connect();         return response;     }     }","package International_Trade_Union.vote;  import lombok.Data; import International_Trade_Union.model.Account; import International_Trade_Union.setings.Seting; import org.apache.tomcat.util.net.jsse.JSSEUtil;  import java.util.List; import java.util.Map; import java.util.Objects; import java.util.Set; import java.util.stream.Collectors;  @Data public class CurrentLawVotes {     private String addressLaw;     private Set<String> YES;     private Set<String> NO;       public CurrentLawVotes() {     }      public CurrentLawVotes(String addressLaw, Set<String> YES, Set<String> NO) {         this.addressLaw = addressLaw;         this.YES = YES;         this.NO = NO;     }      //голос фракции     public double voteFractions(Map<String, Double> fractions){         double yes = 0;         double no = 0;         double sum = fractions.entrySet().stream()                 .map(t->t.getValue())                 .collect(Collectors.toList())                 .stream().reduce(0.0, Double::sum);          for (String s : YES) {             if (fractions.containsKey(s)) {                 yes += (fractions.get(s)/sum) * Seting.HUNDRED_PERCENT;             }          }         for (String s : NO) {             if (fractions.containsKey(s)) {                 no += (fractions.get(s)/sum) * Seting.HUNDRED_PERCENT;             }          }         return yes - no;      }      //подсчет голосов для палат     public int voteGovernment(             Map<String, Account> balances,             List<String> governments      ) {         int yes = 0;         int no = 0;          List<String> addressGovernment = governments;         for (String s : YES) {             if (addressGovernment.contains(s)) {                 yes += Seting.VOTE_GOVERNMENT;             }          }         for (String s : NO) {             if (addressGovernment.contains(s)) {                 no += Seting.VOTE_GOVERNMENT;             }          }           return yes - no;      }      //для избрания должностных лиц     public double votesLaw(Map<String, Account> balances,                            Map<String, Integer> yesAverage, Map<String, Integer> noAverage) {         double yes = 0.0;         double no = 0.0;           //         for (String s : YES) {              int count = 1;             count = yesAverage.get(s) > 0 ? yesAverage.get(s) : 1;             yes += balances.get(s).getDigitalStockBalance() / count;          }         //         for (String s : NO) {             int count = 1;             count = noAverage.get(s) > 0 ? noAverage.get(s) : 1;             no += balances.get(s).getDigitalStockBalance() / count;          }           return yes - no;     }      //для избрания должностных лиц     public double votes(Map<String, Account> balances,                         Map<String, Integer> yesAverage, Map<String, Integer> noAverage) {         double yes = 0.0;         double no = 0.0;         for (String s : YES) {             int count = 1;             count = yesAverage.get(s) > 0 ? yesAverage.get(s) : 1;             yes += balances.get(s).getDigitalStockBalance() / count;          }         for (String s : NO) {             int count = 1;             count = noAverage.get(s) > 0 ? noAverage.get(s) : 1;             no += balances.get(s).getDigitalStockBalance() / count;          }           return yes - no;     }      @Override     public boolean equals(Object o) {         if (this == o) return true;         if (!(o instanceof CurrentLawVotes)) return false;         CurrentLawVotes that = (CurrentLawVotes) o;         return getAddressLaw().equals(that.getAddressLaw());     }      @Override     public int hashCode() {         return Objects.hash(getAddressLaw());     } }","package International_Trade_Union.vote;  public class CurrentLawVotesAverage { }","package International_Trade_Union.vote;  import lombok.Data;  import java.util.List; import java.util.Objects;  @Data public class CurrentLawVotesEndBalance {     private String addressLaw;     private double votes;     //CORPORATE_COUNCIL_OF_REFEREES     private int votesCorporateCouncilOfReferees;      //BOARD_OF_DIRECTORS     private int votesBoardOfDirectors;     private int votesBoardOfShareholders;      //GENERAL_EXECUTIVE_DIRECTOR     private int voteGeneralExecutiveDirector;     private int voteHightJudge;      private int founderVote;     private String packageName;     private List<String> laws;     private double fractionVote;      public CurrentLawVotesEndBalance() {     }      public CurrentLawVotesEndBalance             (String addressLaw,              String packageName,              double votes,              int votesCorporateCouncilOfReferees,              int votesBoardOfDirectors,              int votesBoardOfShareholders,              int voteGeneralExecutiveDirector,              int voteHightJudge,                     int founderVote,              double fractionVote,              List<String> laws) {         this.addressLaw = addressLaw;         this.packageName = packageName;         this.votesCorporateCouncilOfReferees = votesCorporateCouncilOfReferees;         this.votesBoardOfShareholders = votesBoardOfShareholders;         this.votesBoardOfDirectors = votesBoardOfDirectors;         this.voteGeneralExecutiveDirector = voteGeneralExecutiveDirector;         this.voteHightJudge = voteHightJudge;         this.founderVote = founderVote;         this.fractionVote = fractionVote;          this.votes = votes;         this.laws = laws;      }      @Override     public boolean equals(Object o) {         if (this == o) return true;         if (!(o instanceof CurrentLawVotesEndBalance)) return false;         CurrentLawVotesEndBalance that = (CurrentLawVotesEndBalance) o;         return getAddressLaw().equals(that.getAddressLaw());     }      @Override     public int hashCode() {         return Objects.hash(getAddressLaw());     } }","package International_Trade_Union.vote;   import lombok.Data; import International_Trade_Union.model.Account;  import java.util.Objects;  @Data public class LawEligibleForParliamentaryApproval {     public LawEligibleForParliamentaryApproval(Account account, Laws laws) {         this.account = account;         this.laws = laws;         this.name = account.getAccount();     }      public LawEligibleForParliamentaryApproval() {     }      private String name;     private Account account;     private Laws laws;      @Override     public boolean equals(Object o) {         if (this == o) return true;         if (!(o instanceof LawEligibleForParliamentaryApproval)) return false;         LawEligibleForParliamentaryApproval that = (LawEligibleForParliamentaryApproval) o;         return Objects.equals(getName(), that.getName()) && Objects.equals(getAccount(), that.getAccount()) && Objects.equals(getLaws(), that.getLaws());     }      @Override     public int hashCode() {         return Objects.hash(getName(), getAccount(), getLaws());     } }","package International_Trade_Union.vote;   import lombok.Data; import International_Trade_Union.setings.Seting; import International_Trade_Union.utils.UtilsJson; import International_Trade_Union.utils.UtilsUse;  import java.io.IOException; import java.util.List; import java.util.Objects;  @Data public class Laws {     //название пакета закона     String packetLawName;     List<String> laws;     String hashLaw;      public Laws() {     }      public Laws(String packetLawName, List<String> laws) throws IOException {         this.packetLawName = packetLawName;         this.laws = laws;         this.hashLaw = Seting.NAME_LAW_ADDRESS_START + UtilsUse.sha256hash(UtilsJson.objToStringJson(this));     }      @Override     public boolean equals(Object o) {         if (this == o) return true;         if (!(o instanceof Laws)) return false;         Laws laws = (Laws) o;         return getHashLaw().equals(laws.getHashLaw());     }      @Override     public int hashCode() {         return Objects.hash(getHashLaw());     } }","package International_Trade_Union.vote;  import International_Trade_Union.entity.DtoTransaction.DtoTransaction; import International_Trade_Union.entity.blockchain.Blockchain; import International_Trade_Union.entity.blockchain.block.Block; import International_Trade_Union.governments.Director; import International_Trade_Union.governments.Directors; import International_Trade_Union.governments.UtilsGovernment; import International_Trade_Union.model.Account; import International_Trade_Union.model.FIndPositonHelperData; import International_Trade_Union.setings.Seting;  import java.io.IOException; import java.security.InvalidKeyException; import java.security.NoSuchAlgorithmException; import java.security.NoSuchProviderException; import java.security.SignatureException; import java.security.spec.InvalidKeySpecException; import java.util.*; import java.util.stream.Collectors;  public class UtilsCurrentLaw {     //подсчет по штучно баланса     public static Map<String, CurrentLawVotes> calculateVote(Map<String, CurrentLawVotes> votes, List<Account> governments, Block block) throws IOException, NoSuchAlgorithmException, SignatureException, InvalidKeySpecException, NoSuchProviderException, InvalidKeyException {          for (int j = 0; j < block.getDtoTransactions().size(); j++) {             DtoTransaction transaction = block.getDtoTransactions().get(j);              if (transaction.getSender().startsWith(Seting.NAME_LAW_ADDRESS_START)) {                 System.out.println(\"law balance cannot be sender\");                 continue;             }             if (transaction.verify() && transaction.getCustomer().startsWith(Seting.NAME_LAW_ADDRESS_START)) {                 for (Account account : governments) {                     //основатель не может участвовать в голосовании                     //!block.getFounderAddress().equals(transaction.getSender())                     if (transaction.getSender().equals(account.getAccount())) {                         CurrentLawVotes currentLawVotes = votes.get(transaction.getCustomer());                          if (currentLawVotes == null) {                             currentLawVotes = new CurrentLawVotes();                             currentLawVotes.setAddressLaw(transaction.getCustomer());                             currentLawVotes.setYES(new HashSet<>());                             currentLawVotes.setNO(new HashSet<>());                              votes.put(transaction.getCustomer(), currentLawVotes);                         }                          if (transaction.getVoteEnum().equals(VoteEnum.YES)) {                              currentLawVotes.getYES().add(transaction.getSender());                             currentLawVotes.getNO().remove(transaction.getSender());                          } else if (transaction.getVoteEnum().equals(VoteEnum.NO)) {                             currentLawVotes.getNO().add(transaction.getSender());                             currentLawVotes.getYES().remove(transaction.getSender());                         }                     }                 }              }          }           return votes;      }      //подсчет целиком баланса     public static Map<String, CurrentLawVotes> calculateVotes(List<Account> governments, List<Block> blocks) throws IOException, NoSuchAlgorithmException, SignatureException, InvalidKeySpecException, NoSuchProviderException, InvalidKeyException {         Map<String, CurrentLawVotes> votes = new HashMap<>();         for (Block block : blocks) {             calculateVote(votes, governments, block);         }          return votes;      }      //возвращаяет усредненное количество голосов,     //суть проста если есть один акаунт и он имеет 100 акций     //и проголосовал за один закон то все сто акций будут для этого закона как сто голосов     //если за два закона то 100/2 то есть если он на протяжении трех лет проголосовал     //за n законов, то его голоса делятся на n.     public static Map<String, Integer> calculateAverageVotesYes(Map<String, CurrentLawVotes> votesMap) {         Map<String, Integer> voteAverage = new HashMap<>();         for (Map.Entry<String, CurrentLawVotes> current : votesMap.entrySet()) {             for (String yesVoteAddress : current.getValue().getYES()) {                 if (voteAverage.containsKey(yesVoteAddress)) {                     int count = voteAverage.get(yesVoteAddress);                     voteAverage.put(yesVoteAddress, count + 1);                 } else {                     int count = 1;                     voteAverage.put(yesVoteAddress, count);                 }             }          }         return voteAverage;     }      //подсчитывает голоса No     public static Map<String, Integer> calculateAverageVotesNo(Map<String, CurrentLawVotes> votesMap) {         Map<String, Integer> voteAverage = new HashMap<>();         for (Map.Entry<String, CurrentLawVotes> current : votesMap.entrySet()) {             for (String yesVoteAddress : current.getValue().getNO()) {                 if (voteAverage.containsKey(yesVoteAddress)) {                     int count = voteAverage.get(yesVoteAddress);                     voteAverage.put(yesVoteAddress, count + 1);                 } else {                     int count = 1;                     voteAverage.put(yesVoteAddress, count);                 }             }          }         return voteAverage;     }        //возвращает списки позиций     public static Map<Director, List<String>> findPositions(              Map<String, Account> balances,             Blockchain blockchain,             List<LawEligibleForParliamentaryApproval> allGovernment,             List<Account> BoardOfShareholders,             Map<Director, FIndPositonHelperData> fIndPositonHelperData      ) throws IOException, NoSuchAlgorithmException, InvalidKeySpecException, SignatureException, NoSuchProviderException, InvalidKeyException {         //список должностей         Directors directors = new Directors();         Map<Director, List<LawEligibleForParliamentaryApproval>> positionsListMap = new HashMap<>();         //добавление всех должностей         for (Director higherSpecialPositions : directors.getDirectors()) {             positionsListMap.put(higherSpecialPositions, UtilsLaws.getPossions(allGovernment, higherSpecialPositions));         }         //список законов с голосами         Map<Director, List<CurrentLawVotesEndBalance>> curentLawVotesEndBalance = new HashMap<>();         for (Map.Entry<Director, List<LawEligibleForParliamentaryApproval>> corp : positionsListMap.entrySet()) {             //убрать повторяющиеся должности из списка.             corp.setValue(corp.getValue().stream() //                    .filter(t-> finalBoardOfShareholders.contains(new Account(t.getLaws().getLaws().get(0), 0, 0)))                     .distinct().collect(Collectors.toList()));              //получить баланс и голоса для действующих законов             curentLawVotesEndBalance.put(corp.getKey(), UtilsGovernment.filters(corp.getValue(), balances, BoardOfShareholders,                     blockchain.getBlockchainList(), Seting.POSITION_YEAR_VOTE));             List<CurrentLawVotesEndBalance> temporary;             if (fIndPositonHelperData.get(corp.getKey()).isElectedWithStock()) {                   //отобрать голоса выше лимита                 curentLawVotesEndBalance.put(corp.getKey(), curentLawVotesEndBalance.get(corp.getKey()));                 List<CurrentLawVotesEndBalance> electedByStock =                         curentLawVotesEndBalance.get(corp.getKey())                                 .stream()                                 .filter(t->directors.isElectedByStocks(t.getPackageName()))                                 .filter(t -> t.getVotes() >= Seting.ORIGINAL_LIMIT_MIN_VOTE)                                 .sorted(Comparator.comparing(CurrentLawVotesEndBalance::getVotes).reversed())                                 .limit(corp.getKey().getCount())                                 .collect(Collectors.toList());                  System.out.println(\"UtilsCurrentLaw: findPostion: \");                 System.out.println(\"*******************************\");                 electedByStock.stream().forEach(System.out::println);                 System.out.println(\"*******************************\");                  //отобрать то количество которое соответсвтвует данной должности                 temporary = electedByStock;              } else {                  curentLawVotesEndBalance.put(corp.getKey(), curentLawVotesEndBalance.get(corp.getKey()));                 //отобрать то количество которое соответсвтвует данной должности                 //избираемые премьер министром                 if(fIndPositonHelperData.get(corp.getKey()).isElectedWithPrimeMinister()){                     //отобрать голоса выше лимита                     curentLawVotesEndBalance.put(corp.getKey(), curentLawVotesEndBalance.get(corp.getKey()));                     List<CurrentLawVotesEndBalance> electedByPrimeMinister =                             curentLawVotesEndBalance.get(corp.getKey())                                     .stream()                                     .filter(t->directors.isElectedCEO(t.getPackageName()))                                     .filter(t -> t.getVoteGeneralExecutiveDirector() >= Seting.ORIGINAL_LIMIT_MIN_VOTE_GENERAL_EXECUTIVE_DIRECTOR)                                     .sorted(Comparator.comparing(CurrentLawVotesEndBalance::getVoteGeneralExecutiveDirector).reversed())                                     .collect(Collectors.toList());                       //отобрать то количество которое соответсвтвует данной должности                     temporary = electedByPrimeMinister;                 }                 //избираемые палатой представителей                 else if(fIndPositonHelperData.get(corp.getKey()).isElectedWithHousOfRepresentativies()){                     //отобрать голоса выше лимита                     curentLawVotesEndBalance.put(corp.getKey(), curentLawVotesEndBalance.get(corp.getKey()));                     List<CurrentLawVotesEndBalance> electedByHouseOfRepresentatives =                             curentLawVotesEndBalance.get(corp.getKey())                                     .stream()                                     .filter(t->directors.isElectedByBoardOfDirectors(t.getPackageName()))                                     .filter(t -> t.getVotesBoardOfDirectors() >= Seting.ORIGINAL_LIMIT_MIN_VOTE_BOARD_OF_DIRECTORS)                                     .sorted(Comparator.comparing(CurrentLawVotesEndBalance::getVotesBoardOfDirectors).reversed())                                     .collect(Collectors.toList());                       //отобрать то количество которое соответсвтвует данной должности                     temporary = electedByHouseOfRepresentatives;                    }                 //избираемые палатаой верховных судей                 else if(fIndPositonHelperData.get(corp.getKey()).isElectedWithChamberOfHightJudjes()){                     //отобрать голоса выше лимита                     curentLawVotesEndBalance.put(corp.getKey(), curentLawVotesEndBalance.get(corp.getKey()));                     List<CurrentLawVotesEndBalance> electedByChamberOfSupremeJudges =                             curentLawVotesEndBalance.get(corp.getKey())                                     .stream()                                     .filter(t->directors.isElectedBYCorporateCouncilOfReferees(t.getPackageName()))                                     .filter(t -> t.getVotesCorporateCouncilOfReferees() >= Seting.ORIGINAL_LIMIT_MIN_VOTE_CORPORATE_COUNCIL_OF_REFEREES)                                     .sorted(Comparator.comparing(CurrentLawVotesEndBalance::getVotesCorporateCouncilOfReferees).reversed())                                     .collect(Collectors.toList());                       //отобрать то количество которое соответсвтвует данной должности                     temporary = electedByChamberOfSupremeJudges;                  }                 else {                     temporary = curentLawVotesEndBalance.get(corp.getKey()).stream()                              .collect(Collectors.toList());                 }              }              temporary = temporary.stream().distinct().collect(Collectors.toList());              curentLawVotesEndBalance.put(corp.getKey(), temporary);         }           List<LawEligibleForParliamentaryApproval> lawEligibleForParliamentaryApprovals =                 UtilsLaws.readLineCurrentLaws(Seting.ORIGINAL_ALL_CORPORATION_LAWS_WITH_BALANCE_FILE);           Map<Director, List<String>> currentPossitions = new HashMap<>();         for (Map.Entry<Director, FIndPositonHelperData> fIndPositonHelperData1 : fIndPositonHelperData.entrySet()) {             List<CurrentLawVotesEndBalance> position = curentLawVotesEndBalance.get(fIndPositonHelperData1.getKey());             //список адресов на данную позицию, пример члена палаты представителей             List<String> currntAddress = new ArrayList<>();             for (CurrentLawVotesEndBalance address : position) {                 for (LawEligibleForParliamentaryApproval lawEligibleForParliamentaryApproval : lawEligibleForParliamentaryApprovals) {                       if (lawEligibleForParliamentaryApproval.getLaws().getHashLaw().equals(address.getAddressLaw())) {                          currntAddress.add(lawEligibleForParliamentaryApproval.getLaws().getLaws().get(0));                      }                 }              }             currentPossitions.put(fIndPositonHelperData1.getKey(), currntAddress);          }           return currentPossitions;     }      //найти членов палаты представителей     //возвращает список позиций     public static List<String> findPosition(             Map<String, Account> balances,             Blockchain blockchain,             List<LawEligibleForParliamentaryApproval> allGovernment,             List<Account> BoardOfShareholders,             Directors positions,             boolean withLimit      ) throws IOException, NoSuchAlgorithmException, InvalidKeySpecException, SignatureException, NoSuchProviderException, InvalidKeyException {         //список должностей          Map<Director, List<LawEligibleForParliamentaryApproval>> positionsListMap = new HashMap<>();         //добавление всех должностей         for (Director higherSpecialPositions : positions.getDirectors()) {             positionsListMap.put(higherSpecialPositions, UtilsLaws.getPossions(allGovernment, higherSpecialPositions));         }         //список законов с голосами         Map<Director, List<CurrentLawVotesEndBalance>> curentLawVotesEndBalance = new HashMap<>();         for (Map.Entry<Director, List<LawEligibleForParliamentaryApproval>> corp : positionsListMap.entrySet()) {             //убрать повторяющиеся должности из списка.             corp.setValue(corp.getValue().stream() //                    .filter(t-> finalBoardOfShareholders.contains(new Account(t.getLaws().getLaws().get(0), 0, 0)))                     .distinct().collect(Collectors.toList()));              //получить баланс и голоса для действующих законов             curentLawVotesEndBalance.put(corp.getKey(), UtilsGovernment.filters(corp.getValue(), balances, BoardOfShareholders,                     blockchain.getBlockchainList(), Seting.POSITION_YEAR_VOTE));             List<CurrentLawVotesEndBalance> temporary;             if (withLimit) {                 //отобрать голоса выше лимита                 curentLawVotesEndBalance.put(corp.getKey(), curentLawVotesEndBalance.get(corp.getKey())                         .stream().filter(t -> t.getVotes() >= Seting.ORIGINAL_LIMIT_MIN_VOTE)                         .collect(Collectors.toList()));                  //отобрать то количество которое соответсвтвует данной должности                 temporary = curentLawVotesEndBalance.get(corp.getKey()).stream()                         .filter(t -> !t.getPackageName().equals(corp.getKey()))                         .sorted(Comparator.comparing(CurrentLawVotesEndBalance::getVotes).reversed())                         .limit(corp.getKey().getCount()).collect(Collectors.toList());             } else {                 //отобрать то количество которое соответсвтвует данной должности                 temporary = curentLawVotesEndBalance.get(corp.getKey()).stream()                         .filter(t -> !t.getPackageName().equals(corp.getKey()))                         .sorted(Comparator.comparing(CurrentLawVotesEndBalance::getVotes).reversed())                         .collect(Collectors.toList());             }               curentLawVotesEndBalance.put(corp.getKey(), temporary);         }           List<LawEligibleForParliamentaryApproval> lawEligibleForParliamentaryApprovals =                 UtilsLaws.readLineCurrentLaws(Seting.ORIGINAL_ALL_CORPORATION_LAWS_WITH_BALANCE_FILE);          //список адресов на данную позицию, пример члена палаты представителей         List<String> currntAddress = new ArrayList<>();          List<CurrentLawVotesEndBalance> position = curentLawVotesEndBalance.get(positions);          for (CurrentLawVotesEndBalance address : position) {             for (LawEligibleForParliamentaryApproval lawEligibleForParliamentaryApproval : lawEligibleForParliamentaryApprovals) {                   if (lawEligibleForParliamentaryApproval.getLaws().getHashLaw().equals(address.getAddressLaw())) {                      currntAddress.add(lawEligibleForParliamentaryApproval.getLaws().getLaws().get(0));                  }             }         }           return currntAddress;     } }","package International_Trade_Union.vote;  import International_Trade_Union.governments.Director; import International_Trade_Union.governments.Directors; import com.fasterxml.jackson.core.JsonProcessingException; import International_Trade_Union.entity.DtoTransaction.DtoTransaction; import International_Trade_Union.entity.blockchain.block.Block; import International_Trade_Union.setings.Seting; import International_Trade_Union.model.Account; import International_Trade_Union.utils.UtilsFileSaveRead; import International_Trade_Union.utils.UtilsJson; import International_Trade_Union.utils.UtilsUse;   import java.io.File; import java.io.IOException; import java.security.InvalidKeyException; import java.security.NoSuchAlgorithmException; import java.security.NoSuchProviderException; import java.security.SignatureException; import java.security.spec.InvalidKeySpecException; import java.util.*; import java.util.stream.Collectors;  public class UtilsLaws {     public static void saveLaws(List<Laws> laws, String filename) throws IOException {         int fileLimit = Seting.SIZE_FILE_LIMIT * 1024 * 1024;          //папка чтобы проверить есть ли         File folder = new File(filename);         List<String> files = new ArrayList<>();         for (File file : folder.listFiles()) {             if(!file.isDirectory()){                 files.add(file.getAbsolutePath());             }         }          int count = 0;         files = files.stream().sorted().collect(Collectors.toList());         String nextFile = \"\";          if (files.size() > 0) {             nextFile = files.get(files.size()-1);              count = Integer.parseInt(nextFile.replaceAll(\"[^\\\\d]\", \"\"));           }          File file = new File(nextFile);          if(file.length() >= fileLimit){             count++;          }          nextFile = filename + count + \".txt\";          List<String> jsons = new ArrayList<>();         for (Laws laws1: laws) {             String json = UtilsJson.objToStringJson(laws1);             jsons.add(json);         }  //        String json = UtilsJson.objToStringJson(minerAccount); //        UtilsFileSaveRead.save(json + \"\\n\", nextFile);         UtilsFileSaveRead.saves(jsons, nextFile, true);     }     public static void saveLaw(Laws laws, String filename) throws IOException, NoSuchAlgorithmException, SignatureException, InvalidKeySpecException, NoSuchProviderException, InvalidKeyException {         int fileLimit = Seting.SIZE_FILE_LIMIT * 1024 * 1024;          //папка чтобы проверить есть ли         File folder = new File(filename);         List<String> files = new ArrayList<>();         for (File file : folder.listFiles()) {             if (!file.isDirectory()) {                 files.add(file.getAbsolutePath());             }         }          int count = 0;         files = files.stream().sorted().collect(Collectors.toList());         String nextFile = \"\";          if (files.size() > 0) {             nextFile = files.get(files.size() - 1);              count = Integer.parseInt(nextFile.replaceAll(\"[^\\\\d]\", \"\"));           }          File file = new File(nextFile);          if (file.length() >= fileLimit) {             count++;          }          nextFile = filename + count + \".txt\";          String json = UtilsJson.objToStringJson(laws);         UtilsFileSaveRead.save(json + \"\\n\", nextFile);      }      public static void saveCurrentsLaws(List<LawEligibleForParliamentaryApproval> lawEligibleForParliamentaryApprovals, String filename) throws IOException {         int fileLimit = Seting.SIZE_FILE_LIMIT * 1024 * 1024;          //папка чтобы проверить есть ли         File folder = new File(filename);         List<String> files = new ArrayList<>();         for (File file : folder.listFiles()) {             if(!file.isDirectory()){                 files.add(file.getAbsolutePath());             }         }          int count = 0;         files = files.stream().sorted().collect(Collectors.toList());         String nextFile = \"\";          if (files.size() > 0) {             nextFile = files.get(files.size()-1);              count = Integer.parseInt(nextFile.replaceAll(\"[^\\\\d]\", \"\"));           }          File file = new File(nextFile);          if(file.length() >= fileLimit){             count++;          }          nextFile = filename + count + \".txt\";          List<String> jsons = new ArrayList<>();         for (LawEligibleForParliamentaryApproval lawEligibleForParliamentaryApproval : lawEligibleForParliamentaryApprovals) {             String json = UtilsJson.objToStringJson(lawEligibleForParliamentaryApproval);             jsons.add(json);         }  //        String json = UtilsJson.objToStringJson(minerAccount); //        UtilsFileSaveRead.save(json + \"\\n\", nextFile);         UtilsFileSaveRead.saves(jsons, nextFile, true);     }     public static void saveCurrentLaw(LawEligibleForParliamentaryApproval lawEligibleForParliamentaryApproval, String filename) throws IOException, NoSuchAlgorithmException, SignatureException, InvalidKeySpecException, NoSuchProviderException, InvalidKeyException {         int fileLimit = Seting.SIZE_FILE_LIMIT * 1024 * 1024;          //папка чтобы проверить есть ли         File folder = new File(filename);         List<String> files = new ArrayList<>();         for (File file : folder.listFiles()) {             if (!file.isDirectory()) {                 files.add(file.getAbsolutePath());             }         }          int count = 0;         files = files.stream().sorted().collect(Collectors.toList());         String nextFile = \"\";          if (files.size() > 0) {             nextFile = files.get(files.size() - 1);              count = Integer.parseInt(nextFile.replaceAll(\"[^\\\\d]\", \"\"));           }          File file = new File(nextFile);          if (file.length() >= fileLimit) {             count++;          }          nextFile = filename + count + \".txt\";          String json = UtilsJson.objToStringJson(lawEligibleForParliamentaryApproval);         UtilsFileSaveRead.save(json + \"\\n\", nextFile);      }      public static List<Laws> readLineLaws(String filename) throws IOException, NoSuchAlgorithmException, InvalidKeySpecException, SignatureException, NoSuchProviderException, InvalidKeyException {         List<Laws> laws = new ArrayList<>();         File folder = new File(filename);         for (final File fileEntry : folder.listFiles()) {             if (fileEntry.isDirectory()) {                 System.out.println(\"is directory \" + fileEntry.getAbsolutePath());             } else {                 List<String> list = UtilsFileSaveRead.reads(fileEntry.getAbsolutePath());                 for (String s : list) {                      Laws laws1 = UtilsJson.jsonToLaw(s);                     laws.add(laws1);                 }              }         }         laws = laws                 .stream()                 .sorted(Comparator.comparing(Laws::getPacketLawName))                 .collect(Collectors.toList());          return laws;     }      public static List<LawEligibleForParliamentaryApproval> readLineCurrentLaws(String filename) throws JsonProcessingException {         List<LawEligibleForParliamentaryApproval> laws = new ArrayList<>();         File folder = new File(filename);         for (final File fileEntry : folder.listFiles()) {             if (fileEntry.isDirectory()) {                 System.out.println(\"is directory \" + fileEntry.getAbsolutePath());             } else {                 List<String> list = UtilsFileSaveRead.reads(fileEntry.getAbsolutePath());                 for (String s : list) {                      LawEligibleForParliamentaryApproval laws1 = UtilsJson.jsonToCurrentLaw(s);                     laws.add(laws1);                 }              }         }          return laws;     }       //возвращает все счета законов     public static List<Account> allPackegeLaws(Map<String, Account> balances) {         List<Account> laws = new ArrayList<>();         laws = balances.entrySet()                 .stream()                 .map(t -> t.getValue())                 .filter(t -> t.getAccount().startsWith(Seting.NAME_LAW_ADDRESS_START))                 .collect(Collectors.toList());         return laws;     }      //возвращает пакет законов и их счета     public static Map<String, Laws> getPackageLaws(List<Block> blocks) throws IOException, NoSuchAlgorithmException, SignatureException, InvalidKeySpecException, NoSuchProviderException, InvalidKeyException {         Map<String, Laws> laws = new HashMap<>();         for (Block block : blocks) {             for (DtoTransaction dtoTransaction : block.getDtoTransactions()) {                 if (dtoTransaction.verify()) {                     if (dtoTransaction.getCustomer().startsWith(Seting.NAME_LAW_ADDRESS_START) && dtoTransaction.getBonusForMiner() >= Seting.COST_LAW) {                         if(dtoTransaction.getLaws() != null && !laws.containsKey(dtoTransaction.getCustomer())){                             laws.put(dtoTransaction.getCustomer(), dtoTransaction.getLaws());                         }                      }                 }             }          }         return laws;     }      //проверяет валидность закона     public static boolean isValidHashLaw(Laws laws) throws IOException {         String hash = laws.getHashLaw();         String hashLaw = Seting.NAME_LAW_ADDRESS_START + UtilsUse.sha256hash(UtilsJson.objToStringJson(laws));         System.out.println(\"UtilsLaw: isValidHashLaw: \" + hash.equals(hashLaw));         System.out.println(\"hash: \" + hash);         System.out.println(\"hashLaw: \" + hashLaw);         return hash.equals(hashLaw);     }        public static List<Account> allPackageLaws(List<Account> accounts){         List<Account> currentLaws = accounts.stream()                 .filter(t -> t.getAccount().startsWith(Seting.NAME_LAW_ADDRESS_START))                 .collect(Collectors.toList());         return currentLaws;     }      //возвращяет список всех законов, как действующих, так и не действующих, если закон новый то автоматически сохраняет его     public static Map<String, Laws> getLaws(List<Block> blocks, String fileLaws) throws IOException, NoSuchAlgorithmException, InvalidKeySpecException, SignatureException, NoSuchProviderException, InvalidKeyException {         List<Laws> lawsForSave = new ArrayList<>();         Map<String, Laws> lawsMap = new HashMap<>();         File file = new File(fileLaws);         List<Laws> lawsList = new ArrayList<>();         if (file.exists()) {             lawsList = readLineLaws(fileLaws);         }         lawsMap = getPackageLaws(blocks);          for (Map.Entry<String, Laws> map : lawsMap.entrySet()) {             if (!lawsList.contains(map.getValue())) {                 if( map.getValue() != null &&                         map.getValue().packetLawName != null&&                         map.getValue().getLaws() != null                         && !map.getValue().getHashLaw().isEmpty()                         && (map.getValue().getLaws().size() > 0)){                          lawsForSave.add(map.getValue());                 }              }          }         saveLaws(lawsForSave, fileLaws);         return lawsMap;     }     public static List<LawEligibleForParliamentaryApproval> getCurrentLaws(Map<String, Laws> lawsMap, Map<String, Account> balances, String fileCurrentLaws) throws IOException, NoSuchAlgorithmException, SignatureException, InvalidKeySpecException, NoSuchProviderException, InvalidKeyException {         List<Account> lawsBalances = allPackegeLaws(balances);           List<LawEligibleForParliamentaryApproval> lawEligibleForParliamentaryApprovals = new ArrayList<>();         LawEligibleForParliamentaryApproval lawEligibleForParliamentaryApproval = null;         File file = new File(fileCurrentLaws);         if (file.exists()) {             lawEligibleForParliamentaryApprovals = readLineCurrentLaws(fileCurrentLaws);         }          for (LawEligibleForParliamentaryApproval eligibleForParliamentaryApproval : lawEligibleForParliamentaryApprovals) {             if(lawsBalances.contains(eligibleForParliamentaryApproval.getAccount())){                 eligibleForParliamentaryApproval.getAccount().                         setDigitalStockBalance(balances.get(eligibleForParliamentaryApproval.getAccount().getAccount()).getDigitalStockBalance());                 eligibleForParliamentaryApproval.getAccount().                         setDigitalDollarBalance(balances.get(eligibleForParliamentaryApproval.getAccount().getAccount()).getDigitalDollarBalance());             }          }           List<LawEligibleForParliamentaryApproval> temporary = new ArrayList<>();         for (Account account : lawsBalances) {             lawEligibleForParliamentaryApproval = new LawEligibleForParliamentaryApproval(account, lawsMap.get(account.getAccount()));             temporary.add(lawEligibleForParliamentaryApproval);         }           lawEligibleForParliamentaryApprovals.addAll(temporary);           lawEligibleForParliamentaryApprovals = lawEligibleForParliamentaryApprovals.stream()                 .filter(t->Objects.nonNull(t.getLaws()))                 .filter(t->Objects.nonNull(t.getAccount()))                 .filter(t->Objects.nonNull(t.getLaws().getHashLaw()))                 .filter(t->Objects.nonNull(t.getLaws().getLaws()))                 .filter(t->Objects.nonNull(t.getName()))                 .filter(t->Objects.nonNull(t.getLaws().getPacketLawName()))                 .filter(t->t != null).                 filter(UtilsUse.distinctByKey(LawEligibleForParliamentaryApproval::getName)).collect(Collectors.toList());          return lawEligibleForParliamentaryApprovals;      }         //отбирает позицию вакансий     public static List<LawEligibleForParliamentaryApproval> getPossions(List<LawEligibleForParliamentaryApproval> lawEligibleForParliamentaryApprovals, Director higherSpecialPositions){          List<LawEligibleForParliamentaryApproval> temporary = new ArrayList<>();         temporary = lawEligibleForParliamentaryApprovals.stream()                 .filter(t->Objects.nonNull(t))                 .filter(t->Objects.nonNull(t.getLaws()))                 .filter(t->Objects.nonNull(t.getLaws().getLaws()))                 .filter(t->Objects.nonNull(t.getLaws().getPacketLawName()))                 .filter(t->Objects.nonNull(t.getName()))                 .filter(t->Objects.nonNull(t.getLaws().getHashLaw()))                 .sorted((f1, f2) -> Double.compare(f2.getAccount().getDigitalStockBalance(), f1.getAccount().getDigitalStockBalance()))                 .filter(t-> t.getLaws().getPacketLawName().equals(higherSpecialPositions.getName()))                 .limit(higherSpecialPositions.getCount())                 .collect(Collectors.toList());         return temporary;      }       //удаляет из списка не лигитимные должности     public static List<LawEligibleForParliamentaryApproval> deletePossions(List<LawEligibleForParliamentaryApproval> lawEligibleForParliamentaryApprovals, List<LawEligibleForParliamentaryApproval> forDeleted, Directors higherSpecialPositions){         List<LawEligibleForParliamentaryApproval> temporary = new ArrayList<>();         for (LawEligibleForParliamentaryApproval lawEligibleForParliamentaryApproval : forDeleted) {             if(lawEligibleForParliamentaryApproval != null &&                     lawEligibleForParliamentaryApproval.getLaws() != null &&                     lawEligibleForParliamentaryApproval.getLaws().getPacketLawName() != null &&                     lawEligibleForParliamentaryApproval.getLaws().getHashLaw() != null &&                     lawEligibleForParliamentaryApproval.getLaws().getHashLaw() != null &&                     lawEligibleForParliamentaryApproval.getLaws().getPacketLawName().equals(higherSpecialPositions.getNames())){                 if(lawEligibleForParliamentaryApprovals.contains(lawEligibleForParliamentaryApproval)){                     temporary.add(lawEligibleForParliamentaryApproval);                 }else {                     continue;                 }             }             temporary.add(lawEligibleForParliamentaryApproval);         }         return temporary;     }   }","package International_Trade_Union.vote;  public enum VoteEnum {     YES,     NO }","package International_Trade_Union;  import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication;   @SpringBootApplication public class UnitedStatesApplication { \tpublic static void main(String[] args) { \t\tSpringApplication.run(UnitedStatesApplication.class, args); \t}  }","","",""],"hashLaw":"LIBERc64d89a86abe0627ed5d0210c417e80a848eee1f1a958299fe8cc4ebf6201030"},"bonusForMiner":5.0,"voteEnum":"YES","sign":"MEQCIF8ziewXBr2BCVRwSeLH3fc/R/Vw065tk8+gvJSieTDMAiA+0V0r1Kt99HEWtRp02p8TbXTVTRYE9FYk4XrCj0zbVQ=="}
{"sender":"stExZb8ifLfnFoq4JJuTifpAcscegATH8znhwW26zyTa","customer":"LIBERdcef42ee1882e08e599887b744a88220de839f42246fd89c2caba7c924c9a6cb","digitalDollar":0.0,"digitalStockBalance":0.0,"laws":{"packetLawName":"","laws":[],"hashLaw":""},"bonusForMiner":5.0,"voteEnum":"NO","sign":"MEUCIQDTqpw+bdjXnnLkhUBW0MCG0VJsR0F8MV45LRqdO9U7cAIgagkSdyaEpcZnxPPPRHn2SvfZpCIiFqre50kaV660RnE="}
{"sender":"stExZb8ifLfnFoq4JJuTifpAcscegATH8znhwW26zyTa","customer":"LIBERb867962d8c3c78c1bc0a8bdcf61db37ca3358d30748b8a732a9d1ffc01e3a3b7","digitalDollar":0.0,"digitalStockBalance":0.0,"laws":{"packetLawName":"","laws":[],"hashLaw":""},"bonusForMiner":5.0,"voteEnum":"YES","sign":"MEYCIQCG7kJCYOU5KY7n+Obs2zkc5QfJGzeADmUGB0fwG5c/uQIhAOOGzbOjV6nBERyUqhluD8ZCa6c2tRNDFdZ5qAp5vtL3"}
{"sender":"stExZb8ifLfnFoq4JJuTifpAcscegATH8znhwW26zyTa","customer":"25TzGfMpAygvuFvXujL4seof4LHpzC92crCTydGC9RmZP","digitalDollar":200.0,"digitalStockBalance":200.0,"laws":{"packetLawName":"","laws":[],"hashLaw":""},"bonusForMiner":2.0,"voteEnum":"YES","sign":"MEUCIQDLFMMaRFd0bBPBzjnCA2WlwBlJqhPohrpLs5QuKiD5tQIgDrXM0aRsLmBEtb1OMpzJl3YygDAzzNRvL759z/W938Q="}
{"sender":"stExZb8ifLfnFoq4JJuTifpAcscegATH8znhwW26zyTa","customer":"25TzGfMpAygvuFvXujL4seof4LHpzC92crCTydGC9RmZP","digitalDollar":200.0,"digitalStockBalance":200.0,"laws":{"packetLawName":"","laws":[],"hashLaw":""},"bonusForMiner":1.0,"voteEnum":"YES","sign":"MEUCIFyIirrXFlmq60DnvxlsGYp02BldntpYlL0x12s/OOHkAiEA/eX9sgKvu5ffAhpWDPBWsDbMTlPMdSuy1t/0F6CXQOc="}
{"sender":"stExZb8ifLfnFoq4JJuTifpAcscegATH8znhwW26zyTa","customer":"25TzGfMpAygvuFvXujL4seof4LHpzC92crCTydGC9RmZP","digitalDollar":50.0,"digitalStockBalance":50.0,"laws":{"packetLawName":"","laws":[],"hashLaw":""},"bonusForMiner":0.0,"voteEnum":"YES","sign":"MEUCIQCh19agueUE6qzo7rVf4fic/4ZOLKkcXJTA7WBRnT9hWQIgBf8VlAocHuvjkamc1pcmRI/6w/bqzOG7OkUAEAHR22s="}
{"sender":"stExZb8ifLfnFoq4JJuTifpAcscegATH8znhwW26zyTa","customer":"25TzGfMpAygvuFvXujL4seof4LHpzC92crCTydGC9RmZP","digitalDollar":50.0,"digitalStockBalance":50.0,"laws":{"packetLawName":"","laws":[],"hashLaw":""},"bonusForMiner":0.0,"voteEnum":"YES","sign":"MEUCIFsqG7FcGKnqOGQE0drwvJQqvo8ZCb5LoL7v1JLV+36XAiEAySQi4BLXepxLYY3yL/nulV9khI+pWnvLarKTqVgvFM0="}
{"sender":"stExZb8ifLfnFoq4JJuTifpAcscegATH8znhwW26zyTa","customer":"27MkHGZZnYkNtQMevRqBfAU2Pnu7LJEWC61AzMvAC31V3","digitalDollar":50.0,"digitalStockBalance":50.0,"laws":{"packetLawName":"","laws":[],"hashLaw":""},"bonusForMiner":1.0,"voteEnum":"YES","sign":"MEUCIQCM8GQbJj0hN2T0uybAW7Ktb1eBYSF3lvmk7LJeYwYcYwIgM2f9nQJ2y4034QL9qEcCjqP5+5pFB+FEPyV0ged5kZI="}
{"sender":"stExZb8ifLfnFoq4JJuTifpAcscegATH8znhwW26zyTa","customer":"27MkHGZZnYkNtQMevRqBfAU2Pnu7LJEWC61AzMvAC31V3","digitalDollar":100.0,"digitalStockBalance":50.0,"laws":{"packetLawName":"","laws":[],"hashLaw":""},"bonusForMiner":0.0,"voteEnum":"YES","sign":"MEQCIENxCCXieT4H5r+fxvRwLlA7X5MEYhYO6VOZWFrQQOP7AiBTPahy7f+4fM1uGdN8moV5+XotqU46ai95aBI+GMNWBQ=="}
