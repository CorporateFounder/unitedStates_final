{"name":"LIBER16887e98f0e84969013fc56a015b49a00d9626f66691092d11e6f2101ce958f3","account":{"account":"LIBER16887e98f0e84969013fc56a015b49a00d9626f66691092d11e6f2101ce958f3","digitalDollarBalance":0.0,"digitalStockBalance":0.0},"laws":{"packetLawName":"ORIGINAL_CHARTER_CURRENT_LAW_PACKAGE_NAME","laws":["ДАТА УТВЕРЖДЕНИЯ УСТАВА ПЯТОГО АПРЕЛЯ 2023 ГОДА. THE DATE OF APPROVAL OF THE CHARTER IS APRIL 5, 2023.","OriginalPreamble.ARTICLE_0 (By mistake, I added a draft to the bylaws, which has not yet been finalized, but not from scratch to mine blocks, I add here the original constitution-charter. This charter is signed by the founder and it is this statute that is valid) International Trade Union Corporation is a cryptocurrency organization whose goal is to create a unified trading eco-system that allows people from different parts of the world to sell, as well as acquire high-quality goods and services, at the most affordable prices, while respecting human rights. International Trade Union Corporation uses a divisional product organizational structure. If there are any conflicts between the English version and the Russian version, take the Russian version as a basisCharter, as the translation was carried out from the Russian to the English version.","OriginalCHARTER_ENG.POWERS_OF_THE_BOARD_OF_DIRECTORS: Powers of the Board of Directors. The Board of Directors may approve that they have been appointed to positions from the list of Directors Also by law package names start with ADD_DIRECTOR which are packages which are packages List of new phenomena to be managed by differentiated product lines. Data each line that starts with ADD_DIRECTOR will be added to the list of Directors as a new to be expected.which starts with BUDGET is the budget and can only be decided by the Implementation Board.The current budget can be only one. The council also confirmed the serious plan STRATEGIC_PLAN. Strategic There can only be one plan.The Council is also involved in the practice all members of the corporation), as well as participation in the meeting of amendments to the charter AMENDMENT_TO_THE_CHARTER.The Council has the right to exist and collects a commission from sales within the platforms of holding Corporations Measuring the Trade Union, when calculating the coverage will not exceed twenty percent (20%). All fees must and are allocated to expenditures that are set in the budget.Also, income is income from the sale of their goods and services, for this there are Office Directors who are withdrawnCouncil for Accounting and Sales of Products of the Industrial Union Corporation","OriginalCHARTER_ENG.HOW_LAWS_ARE_CHOSEN: HOW LAWS ARE CHOSENNo law has retroactive effect. No law should violate the current charter or contradict other laws in force. If there is a conflict between several laws from one set of laws, then the current one is the one that is higher in the index. Example: a package for the sale of alcohol the law under index 3 contradicts the law from index 17, in this case the law under index three will be valid.if the laws contradict from different packages, then the package that received more votes is valid from the Board of Shareholders, if there is parity, then the one that received more votes from the Board of Directors, if here too there is parity, then this dispute must be decided by the Chief Justice, if he also did not determine which of the two packageswhere the laws contradict each other, the laws of one of the packages are more valid, then the priority becomes the one that began to operate earlier, the countdown is determined precisely from the last moment of entry into force. All ordinary laws are valid if they are voted in this way ONE_VOTE by the Board of Shareholders, the Board of Directors and possibly The Chief Justice. For a law to be valid, it must receive equal to or more than 100 of the remaining votes of the Board of Shareholders, 15 remaining votes of the Board of Directors and one vote of the Chief Justice, but if the Chief Justice does not vote or votes against then it is possible to override the veto of the supreme judge by obtaining 200 of the remainder of the votes of the Board of Shareholders and 30 of the remainder of the votes of the Board of Directors. A law is valid as long as it matches the number of votes as described above. Every time someone loses their officealso lost are all his votes for all the laws that he voted. Example code in LawsController current law: //laws that don't get enough votes that can only pass if the supreme judge approves List<CurrentLawVotesEndBalance> notEnoughVotes = current.stream() .filter(t -> !directors.contains(t.getPackageName())) .filter(t->!Seting.AMENDMENT_TO_THE_CHARTER.equals(t.getPackageName())) .filter(t->!directors.isCabinets(t.getPackageName())) .filter(t -> !Seting.ORIGINAL_CHARTER_CURRENT_LAW_PACKAGE_NAME.equals(t.getPackageName())) .filter(t -> t.getVotesBoardOfShareholders() >= Seting.ORIGINAL_LIMIT_MIN_VOTE_BOARD_OF_SHAREHOLDERS) .filter(t -> t.getVotesBoardOfDirectors() >= Seting.ORIGINAL_LIMIT_MIN_VOTE_BOARD_OF_DIRECTORS) .filter(t -> t.getVoteHightJudge() >= Seting.ORIGINAL_LIMIT_MIN_VOTE_HIGHT_JUDGE) .sorted(Comparator.comparing(CurrentLawVotesEndBalance::getVotes).reversed()).collect(Collectors.toList()); //laws that have received enough votes and do not require the approval of the supreme judge List<CurrentLawVotesEndBalance> powerfulVotes = current.stream() .filter(t -> !directors.contains(t.getPackageName())) .filter(t-> !Seting.AMENDMENT_TO_THE_CHARTER.equals(t.getPackageName())) .filter(t-> !directors.isCabinets(t.getPackageName())) .filter(t -> !Seting.ORIGINAL_CHARTER_CURRENT_LAW_PACKAGE_NAME.equals(t.getPackageName())) .filter(t -> t.getVotesBoardOfShareholders() >= (Seting.ORIGINAL_LIMIT_MIN_VOTE_BOARD_OF_SHAREHOLDERS * Seting.POWERFUL_VOTE)) .filter(t -> t.getVotesBoardOfDirectors() >= (Seting.ORIGINAL_LIMIT_MIN_VOTE_BOARD_OF_DIRECTORS * Seting.POWERFUL_VOTE)) .sorted(Comparator.comparing(CurrentLawVotesEndBalance::getVotes).reversed()).collect(Collectors.toList());","OriginalCHARTER_ENG.HOW_THE_BOARD_OF_DIRECTORS_IS_ELECTED: How the Board of Directors is elected. The board of directors consists of 301 BOARD_OF_DIRECTORS accounts. each member of the network can apply for the position of the board of directors by creating a package of law, where the package name BOARD_OF_DIRECTORS and the sender's account must match the account specified in the first line of the law that is contained in the list of this package The 301 account with the most remainder of the votes gets the position.the cost of filing for the creation of a law (position) is worth five digital dollars (5) as a reward to the earnerThe voting process is described in VOTE_STOCK Code example: LawController: method currentLaw: code section responsible for the election of the board of directors //minimum number of positive votes for the law to be valid, //positions elected by shares of the board of directors List<CurrentLawVotesEndBalance> electedByStockBoardOfDirectors = current.stream() .filter(t -> directors.isElectedByStocks(t.getPackageName())) .filter(t -> t.getPackageName().equals(NamePOSITION.BOARD_OF_DIRECTORS.toString())) .filter(t -> t.getVotes() >= Seting.ORIGINAL_LIMIT_MIN_VOTE) .sorted(Comparator.comparing(CurrentLawVotesEndBalance::getVotes).reversed()) .limit(directors.getDirector(NamePOSITION.BOARD_OF_DIRECTORS.toString()).getCount()) .collect(Collectors.toList());","OriginalCHARTER_ENG.POWERS_OF_THE_BOARD_OF_SHAREHOLDERS: Powers of the Board of Shareholders The Council of Shareholders Participates in the approval of Laws (rules that all members of this corporation must comply with) Also, the Board of Shareholders participates in the approval of amendments to the charter of the Corporation of the International Trade Union AMENDMENT_TO_THE_CHARTER The Board of Shareholders may also participate in voting when electing candidates CORPORATE_COUNCIL_OF_REFEREES and BOARD_OF_DIRECTORS using these rules to vote for VOTE_STOCK candidates.","OriginalCHARTER_ENG.HOW_SHAREHOLDERS_BOARD_IS_ELECTED: HOW THE BOARD OF SHAREHOLDERS IS ELECTED The Board of Shareholders consists of one thousand five hundred accounts (1500) with the largest number of shares, but only those accounts are taken into account from whose activity more than a year has not passed. formula: the current year is one year, and if the account was active in this range, it is taken into account. All accounts are sorted in descending order of the number of digital shares, and 1500 accounts with the largest number of shares. Recalculation occurs every block. An example of a section of code how the Board of Shareholders is elected: class UtilsGovernment method findBoardOfShareholders: //determining the board of shareholders public static List<Account> findBoardOfShareholders(Map<String, Account> balances, List<Block> blocks, int limit) { List<Block> minersHaveMoreStock = null; if (blocks.size() > limit) { minersHaveMoreStock = blocks.subList(blocks.size() - limit, blocks.size()); } else { minersHaveMoreStock = blocks; } List<Account> boardAccounts = minersHaveMoreStock.stream().map( t -> new Account(t.getMinerAddress(), 0, 0)) .collect(Collectors.toList()); for (Block block : minersHaveMoreStock) { for (DtoTransaction dtoTransaction : block.getDtoTransactions()) { boardAccounts.add(new Account(dtoTransaction.getSender(), 0, 0)); } } CompareObject compareObject = new CompareObject(); List<Account> boardOfShareholders = balances.entrySet().stream() .filter(t -> boardAccounts.contains(t.getValue())) .map(t -> t.getValue()).collect(Collectors.toList()); boardOfShareholders = boardOfShareholders .stream() .filter(t -> !t.getAccount().startsWith(Seting.NAME_LAW_ADDRESS_START)) .filter(t -> t.getDigitalStockBalance() > 0) .sorted(Comparator.comparing(Account::getDigitalStockBalance).reversed()) .collect(Collectors.toList()); boardOfShareholders = boardOfShareholders .stream() .limit(Setting.BOARD_OF_SHAREHOLDERS) .collect(Collectors.toList()); return boardOfShareholders; }","OriginalCHARTER_ENG.VOTE_STOCK: How shares vote. all shares held by the account are equal to the same number of votes. every time someone makes a transaction to an account that is the address of the given packet that begins LIBER he votes for this package. Only those votes from which more than four years have not passed are taken into account. if the transaction was made VoteEnum.YES then this account receives votes for according to the formula yesV = number of votes equal to the sender's shares. yesN = how many laws this account voted for with VoteEnum.YES resultYES = yesV / math.pow(yesN, 3). Example: A score voted for three scores that start with LIBER,100 shares in the account means 100 votes. 100 / math.pow(3, 3) = 3.7 means each account gets 3.7 votes. if the transaction was made with VoteEnum.NO then the same formula is used, but now all bills for which he voted against are taken into account Example the same account voted for two scores against, it has the same one hundred shares. resultNO = noV / math.pow(noN, 3) = 100/ math.pow(2,3) = 12.5 means every score he voted for, against will get 12.5 votes against. then each score counts all the votes given to it FOR (VoteEnum.YES) and AGAINST (VoteEnum.NO). then this formula is used remainder = resultYES - resultNO. First, these positions are selected for all accounts that received more than or equal to fourteen thousandfour hundred votes of the remainder (14400) remainder >= 14400. Further, all accounts are sorted in descending order by remainder and from there the number of accounts on these positions, as much as it is stipulated in this position. Example: For the Board of Directors, that's the 301 accounts with the most balances. At any time you can change your voice, but only to the opposite, which means if you voted for the candidate YES then you can only change to NO and vice versa. There is no limit to how many times you can change your voice.With every block there is a recalculation of votes, if you lose your shares, your candidatesare also losing their votes. This measure is specifically implemented so that elected positionswere interested in seeing you prosper.Only CORPORATE_COUNCIL_OF_REFEREES and BOARD_OF_DIRECTORS are elected this way Only the last transaction given for each account counts if you haven't updated your vote, then after four years it is annulled.","OriginalCHARTER_ENG.CODE_VOTE_STOCK: class CurrentLawVotes method: votesLaw public double votesLaw(Map<String, Account> balances, Map<String, Integer> yesAverage, Map<String, Integer> noAverage) { double yes = 0.0; double no = 0.0; // for (String s : YES) { int count = 1; count = yesAverage.get(s) > 0 ? yesAverage.get(s) : 1; yes += balances.get(s).getDigitalStockBalance() / Math.pow(count, Seting.POWERING_FOR_VOTING); } // for (String s : NO) { int count = 1; count = noAverage.get(s) > 0 ? noAverage.get(s) : 1; no += balances.get(s).getDigitalStockBalance() / Math.pow(count, Seting.POWERING_FOR_VOTING); } return yes - no; }","OriginalCHARTER_ENG.POWERS_OF_DIRECTORS_IN_THE_OFFICE: POWERS OF DIRECTORS TO THE OFFICE Office directors are senior directors who are directors of their divisions. The powers of each director must be described by the laws in force. But each director must manage only by his division. Coordination of all directors should be the General Executive Director GENERAL_EXECUTIVE_DIRECTOR. Board of Directors, CORPORATE_COUNCIL_OF_REFEREES, HIGH_JUDGE, Board of Shareholders and GENERAL_EXECUTIVE_DIRECTOR can be either individuals and legal entities, but one account will be counted as one vote.","OriginalCHARTER_ENG.HOW_OFFICE_DIRECTORS_ARE_CHOSEN: HOW OFFICE DIRECTORS ARE CHOSEN All Directors of the office, these are the top directors who manage their divisions, are elected only by the Board of Directors. Each member of the network can apply for the position of supreme director by creating a law with a package name that matches the allowed positions, where the address of the sender of this transaction must match the first line from the list of laws in this package. The cost of the law is five digital dollars as a reward to the earner. the score with the most remaining votes wins the position. The voting mechanism is described by ONE_VOTE. An example of a piece of code how positions are elected class LawsController: method currentLaw: //positions created by the board of directors List<CurrentLawVotesEndBalance> createdByBoardOfDirectors = current.stream() .filter(t->t.getPackageName().startsWith(Seting.ADD_DIRECTOR)) .filter(t->t.getVotesBoardOfDirectors() >= Seting.ORIGINAL_LIMIT_MIN_VOTE_BOARD_OF_DIRECTORS) .collect(Collectors.toList()); //adding positions created by the board of directors for (CurrentLawVotesEndBalance currentLawVotesEndBalance : createdByBoardOfDirectors) { directors.addAllByBoardOfDirectors(currentLawVotesEndBalance.getLaws()); } //positions elected only by the board of directors List<CurrentLawVotesEndBalance> electedByBoardOfDirectors = current.stream() .filter(t -> directors.isElectedByBoardOfDirectors(t.getPackageName()) || directors.isCabinets(t.getPackageName())) .filter(t -> t.getVotesBoardOfDirectors() >= Seting.ORIGINAL_LIMIT_MIN_VOTE_BOARD_OF_DIRECTORS) .sorted(Comparator.comparing(CurrentLawVotesEndBalance::getVotesBoardOfDirectors).reversed()) .collect(Collectors.toList());","OriginalCHARTER_ENG.ONE_VOTE: ONE VOTE when these positions are voted counts as one count = one vote. CORPORATE_COUNCIL_OF_REFEREES, BOARD_OF_DIRECTORS, GENERAL_EXECUTIVE_DIRECTOR, HIGH_JUDGE and Board of Shareholders. every score that starts with LIBER counts all votes FOR (VoteEnum.YES) and AGAINST (VoteEnum.NO) for it further subtracted subtracted from FOR - AGAINST = if the balances are above the threshold, then it becomes valid. Votes are recalculated every block. After voting, the vote can only be changed to the opposite. There are no restrictions on the number of times you can change your vote. Only those votes that are given by accounts are taken into account in their position, for example, if the account has ceased to be in the Board of Directors, his vote as a The Board of Directors does not and will not count in the voting. All votes are valid until the accounts those who voted are in their positions. Only those votes from which no more than four years, but each participant can at any time renew his vote.","OriginalCHARTER_ENG.CODE_VOTE_ONE: CODE class CurrentLawVotes: method voteGovernment public int voteGovernment( Map<String, Account> balances, List<String>governments ) { int yes = 0; int no = 0; List<String> addressGovernment = governments; for (String s : YES) { if (addressGovernment.contains(s)) { yes += Seting.VOTE_GOVERNMENT; } } for (String s : NO) { if (addressGovernment.contains(s)) { no += Seting.VOTE_GOVERNMENT; } } return yes - no; }","OriginalCHARTER_ENG.MECHANISM_FOR_REDUCING_THE_NUMBER_OF_SHARES: MECHANISM_FOR_REDUCING_THE_NUMBER_OF_SHARES Every time one account sends a digital share to another account, but uses VoteEnum.NO, the account the recipient's digital shares are reduced by the amount sent by the share sender. Example account A sent 100 VoteEnum.NO digital shares to account B, then account A and account B both lose 100 digital shares. This measure is needed so that there is a mechanism to remove some account from the Board of Shareholders. This mechanism is valid only for digital shares and only if the sender sent with the sign VoteEnum.NO","OriginalCHARTER_ENG.WHO_HAS_THE_RIGHT_TO_CREATE_LAWS: Create Laws in Cryptocurrency International Trade Union Corporations have the right all network members who have at least five digital dollars. To create a law through the mechanism of the International Trade Union Corporation's cryptocurrency Inside this cryptocurrency, Create an object of the Laws class, where packetLawName- is the name of the law package. List<String> laws is a list of laws, String hashLaw is the address of this law package and starts with LIBER. In order for a law to be included in the pool of laws, you need to create a transaction where the recipient is the hashLaw of this law and the reward miner equals five digital dollars (5) of this cryptocurrency. After that, as the law gets into the block, it will be in the pool laws and it will be possible to vote for him. The number of lines in a package of laws can be as many as needed and there are no restrictions.","OriginalCHARTER_ENG.POWERS_OF_THE_CORPORATE_COUNCIL_OF_JUDGES: POWERS OF THE CORPORATE COUNCIL OF JUDGESApproves the Chief Justice. Participates in voting on the implementation of amendments. The judicial power of the Corporation of the International Trade Union belongsto one Supreme Court and such inferior courts as the Corporation InternationalThe Merchant Union may issue and establish from time to time.Judges of both the supreme and inferior courts hold their offices in good conduct andThey receive remuneration for their services within the stipulated time.Judicial power extends to all cases of law and justice,including those initiated by members to challenge the misappropriation of funds,arising under these Articles, the laws of the International Trade Union Corporation and treaties,prisoners or who will be imprisoned according to their authority.to disputes,in which the International Trade Union will be a party; to a disagreement between two or more members of the network.No trial should be secret, but justice should be administered openly and free of charge, completely and without delay,and every person shall have legal remedy against injury to life, liberty, or property. Supreme Court CORPORATE_COUNCIL_OF_REFEREES and Chief Justice HIGH_JUDGE","OriginalCHARTER_ENG.HOW_THE_CORPORATE_BOARD_OF_JUDGES_IS_ELECTED: HOW THE CORPORATE BOARD OF JUDGES IS ELECTED CORPORATE_COUNCIL_OF_REFEREES consists of 55 accounts. each member of the network can apply for the CORPORATE_COUNCIL_OF_REFEREES position by creating a law package, where the name of the package CORPORATE_COUNCIL_OF_REFEREES and the sender's account must match the account specified in the first line of the law that is contained in the list of this package The 55th score with the most remainder of the votes gets the position.the cost of filing for the creation of a law (position) is worth five digital dollars (5) as a reward to the earner The voting process is described in VOTE_STOCK Code snippet example: class LawsController: method currentLaw: //minimum number of positive votes for the law to be valid, //positions elected by shares CORPORATE_COUNCIL_OF_REFEREES List<CurrentLawVotesEndBalance> electedByStockCorporateCouncilOfReferees = current.stream() .filter(t -> directors.isElectedByStocks(t.getPackageName())) .filter(t -> t.getPackageName().equals(NamePOSITION.CORPORATE_COUNCIL_OF_REFEREES.toString())) .filter(t -> t.getVotes() >= Seting.ORIGINAL_LIMIT_MIN_VOTE) .sorted(Comparator.comparing(CurrentLawVotesEndBalance::getVotes).reversed()) .limit(directors.getDirector(NamePOSITION.CORPORATE_COUNCIL_OF_REFEREES.toString()).getCount()) .collect(Collectors.toList());","OriginalCHARTER_ENG.HOW_THE_CHIEF_JUDGE_IS_CHOSEN: HOW HIGH_JUDGE IS CHOSEN The Chief Justice is elected by CORPORATE_COUNCIL_OF_REFEREES. Each member of the network can apply for the position of Chief Justice by creating a law with a package name that matches the allowed position, where the address of the sender of this transaction must match the first line from the list of laws in this package. The cost of the law is five digital dollars as a reward to the earner. the score with the most remaining votes wins the position. The voting mechanism is described by ONE_VOTE. Code example as stated by the Chief Justice. class LawsController: method currentLaw. Code snippet //positions elected by the board of corporate chief judges List<CurrentLawVotesEndBalance> electedByCorporateCouncilOfReferees = current.stream() .filter(t -> directors.isElectedBYCorporateCouncilOfReferees(t.getPackageName())) .filter(t -> t.getVotesCorporateCouncilOfReferees() >= Seting.ORIGINAL_LIMIT_MIN_VOTE_CORPORATE_COUNCIL_OF_REFEREES) .sorted(Comparator.comparing(CurrentLawVotesEndBalance::getVotesCorporateCouncilOfReferees)).collect(Collectors.toList());","OriginalCHARTER_ENG.POWERS_OF_THE_CHIEF_JUDGE: POWERS OF THE CHIP JUDGE.The Chief Justice participates in the approval of laws and in the approval of amendments to the charter, as well as can participate in resolving disputes within network members like CORPORATE_COUNCIL_OF_REFEREES but his vote is higher than that of CORPORATE_COUNCIL_OF_REFEREES.","OriginalCHARTER_ENG.HOW_IS_THE_PROCESS_OF_AMENDING_THE_CHARTER: HOW DOES THE PROCESS FOR AMENDING THE CHARTER to make amendments, you need to create a law with the package name AMENDMENT_TO_THE_CHARTER. Further this law must be voted on by the method described in VOTE_ONE Board of Shareholders and the balance of votes must be equal to or higher than 300 members, the Board of Directors must also vote and the balance of votes must be 60 or more, should also vote corporate chief judges (CORPORATE_COUNCIL_OF_REFEREES) and The remainder of the votes must be equal to or greater than 5.But the amendments should not concern the way in which the rules of existing laws are established, and also election of the Board of Directors, Board of Shareholders, General Executive Director, Council of Corporate Judges and Chief Justice. Amendments may change the code if the rules are preserved election of current positions (including voting rules), laws and money mining (mining digital dollars and digital stocks),No amendment should give any of the above positions more power.Also, the amendments must not infringe on Natural Human Rights. Code example. class LawsController: method currentLaw: code section that approves current amendments //introduction of amendments to the charter List<CurrentLawVotesEndBalance> chapter_amendment = current.stream() .filter(t -> !directors.contains(t.getPackageName())) .filter(t->Seting.AMENDMENT_TO_THE_CHARTER.equals(t.getPackageName())) .filter(t->!directors.isCabinets(t.getPackageName())) .filter(t -> t.getVotesBoardOfShareholders() >= Seting.ORIGINAL_LIMIT_MINT_VOTE_BOARD_OF_SHAREHOLDERS_AMENDMENT) .filter(t -> t.getVotesBoardOfDirectors() >= Seting.ORIGINAL_LIMIT_MIN_VOTE_BOARD_OF_DIRECTORS_AMENDMENT) .filter(t -> t.getVotesCorporateCouncilOfReferees() >= Seting.ORIGINAL_LIMIT_MIN_VOTE_CORPORATE_COUNCIL_OF_REFEREES_AMENDMENT) .sorted(Comparator.comparing(CurrentLawVotesEndBalance::getVotesBoardOfDirectors).reversed()).collect(Collectors.toList());","OriginalCHARTER_ENG.HOW_THE_BUDGET_IS_APPROVED: HOW IS THE BUDGET APPROVED. There can be only one effective budget. Only the Board of Directors approves the budget. To approve the budget, you need to get the method described in VOTE_ONE 15 or more votes. the process itself goes like this: 1. First, all packages of laws are selected where the name of the package matches BUDGET. 2. Next, all the packages that received 15 or more votes are selected. 3. Then all these packages are sorted in descending order, with the most votes. 4. Then the very first one with the most votes is selected. Budget approving code example. class LawsController: method: currentLaw. //the budget is approved only by the board of directors. List<CurrentLawVotesEndBalance>budjet = current.stream() .filter(t-> !directors.contains(t.getPackageName())) .filter(t->Seting.BUDGET.equals(t.getPackageName())) .filter(t->!directors.isCabinets(t.getPackageName())) .filter(t-> t.getVotesBoardOfDirectors() >= Seting.ORIGINAL_LIMIT_MIN_VOTE_BOARD_OF_DIRECTORS) .sorted(Comparator.comparing(CurrentLawVotesEndBalance::getVotesBoardOfDirectors).reversed()) .limit(1) .collect(Collectors.toList());","OriginalCHARTER_ENG.HOW_IS_THE_STRATEGIC: AS THE STRATEGIC PLAN IS APPROVED. The strategic plan is approved by the Board of Directors, the strategic plan may be valid only in a single copy. For the Strategic Plan to be valid, a balance of votes is needed Board of Directors 15 or more. Voting method VOTE_ONE. You can cancel at any time The Board of Directors can cancel the Strategic Plan at any time. The Strategic Plan is in effect as long as the number of votes is 15 or more. The Strategic Plan may include a general direction Corporations, and what needs to be implemented.a section of code that shows how the Strategic Plan is being approved. class LawsController: method currentLaw: //the plan is approved only by the chamber Board of Directors List<CurrentLawVotesEndBalance> planFourYears = current.stream() .filter(t->!directors.contains(t.getPackageName())) .filter(t->Seting.STRATEGIC_PLAN.equals(t.getPackageName())) .filter(t->!directors.isCabinets(t.getPackageName())) .filter(t->t.getVotesBoardOfDirectors() >= Seting.ORIGINAL_LIMIT_MIN_VOTE_BOARD_OF_DIRECTORS) .sorted(Comparator.comparing(CurrentLawVotesEndBalance::getVotesBoardOfDirectors).reversed()) .limit(1) .collect(Collectors.toList());","OriginalCHARTER_ENG.HOW_NEW_POSITIONS_ARE_ADDED: HOW ARE NEW POSITIONS ADDED. in this way, only top management, subordinates of each leader, are added are hired without the use of the blockchain, they can be hired by the director himself, or otherwise as described by applicable laws. Top management is added to the list of class Directors.all newly added positions are valid as long as their laws that create these positions work. Only the Board of Directors can add new positions. Every package of laws that starts with ADD_DIRECTOR is defined as adding a position. the list of laws that are inside this package are positions if the name is in line starts with ADD_DIRECTOR. Example: package name ADD_DIRECTOR_PACKAGE the name of the first third and fourth line ADD_DIRECTOR_FIRST ADD_DIRECTOR_THIRD ADD_DIRECTOR_FOUR this will create three positions for the position. But if the line starts with ADD_DIRECTOR then the job title must be large letters and underscores, also there should be only one position in one line and no more words. Those lines where there is no position added are used to describe permissions of the added positions. In order for new positions to be added to the list, the Board of Directors must vote by the VOTE_ONE 15 or more votes.Once new positions are created, each member of the network will be able to apply for these positions. an example of a piece of code that creates new posts. class LawsController: method currentLaw: //adds laws that create new directorships List<CurrentLawVotesEndBalance> addDirectors = current.stream() .filter(t->t.getPackageName().startsWith(Seting.ADD_DIRECTOR)) .filter(t->t.getVotesBoardOfDirectors() >= Seting.ORIGINAL_LIMIT_MIN_VOTE_BOARD_OF_DIRECTORS) .collect(Collectors.toList());","OriginalCHARTER_ENG.PROPERTY_OF_THE_CORPORATION: PROPERTY OF THE CORPORATION. All property owned by the International Trade Union Corporation cannot be sold without a valid law, where the sale process will be described and at what price the property will be sold. The account of the founder, and the account of other participants is not corporate account, the Board of Directors should create a separate account which will be managed as a budget by the current members Board of directors.","OriginalCHARTER_ENG.INTERNET_STORE_DIRECTOR: this director is engaged in the development, promotion and management of an online store in which they must sell goods for a digital dollar or digital shares. Detailed authority must be given either through applicable laws or issued by the CEO or the Board of Directors. The name of the Store must be determined by either the Board of Directors or the CEO.","OriginalCHARTER_ENG.GENERAL_EXECUTIVE_DIRECTOR: this Director coordinates the actions of other senior directors to implement the strategic plan or the tasks assigned to him by the laws in force. All powers must be issued to him through the laws in force.","OriginalCHARTER_ENG.DIRECTOR_OF_THE_DIGITAL_EXCHANGE: This Director is the development, promotion and management of the Internet exchange. The authority must be issued to him either by applicable law or by the Board of Directors or by the Chief Executive Officer.","OriginalCHARTER_ENG.DIRECTOR_OF_DIGITAL_BANK: This Director is in charge of Internet Banking. All powers must be issued either by applicable law or by the Board of Directorsor the Chief Executive Officer.","OriginalCHARTER_ENG.DIRECTOR_OF_THE_COMMERCIAL_COURT: The director of a private commercial court must provide leadership to a private court, all powers must be Issued either by applicable law or by the Board of Directors or the Chief Executive Officer.","OriginalCHARTER_ENG.MEDIA_DIRECTOR: This Director directs the media, all powers must be issued by applicable laws, or by the Board of Directors or CEO.","OriginalCHARTER_ENG.DIRECTOR_OF_THE_DEVELOPMENT_OF_THE_IMPLEMENTATION_OF_CRYPTOCURRENCY_TECHNOLOGIES_OF_THE_INTERNATIONAL_TRADE_UNION_CORPORATION: This Director manages the development and implementation of new code in this cryptocurrency, all powers must be issued only through current laws, but may also be issued by either the Board of Directors if the current laws have given such powers to the Board of Directors. Also, no code change should be contrary to the current charter or applicable laws. Also, powers can be issued by the Chief Executive Officer, if such authority is granted to the Chief Executive Officer by applicable law.","OriginalCHARTER_ENG.EXPLANATION_WHY_MONEY_DEMURAGE_IS_USED_HERE: EXPLANATION WHY MONEY DEMURAGE IS USED HERE.. Negative rates are now used in many countries, this encourages money holders when the price is excessively high, saturate the market with money. The amount of money mined for each block is 200 digital dollars and 200 digital shares, also 2% of each mining reward to the founder, which is 4 digital dollars and 4 digital Shares for each block mining. Here it is used as the Theories of Silvio Gesell, as well as the school of monetarism (in a modified form with Silvio Gesell, the negative rate was 1% per month, which would just kill the economy, under monetarism, the growth of the money supply should have been proportional to the growth of GDP, but since in this system it is not possible to calculate the real GDP growth, I set a fixed growth, also if the money growth will be equal to GDP, there is a high probability of Hyperinflation. Money must be hard in order to business could predict its long-term investments and from monetarism, only that part was taken that the money supply should grow linearly, but in general there is a mix of different economic schools, including the Austrian one economic school.). With a negative rate of 0.1% every six months for digital dollars and 0.2% for digital stocks, we avoid the consequences of a severe economic crisis for this currency. Such a mechanism creates a price corridor, where the lower limit of the value of these digital currencies is the total number of digital currencies issued dollars and digital stocks, and the upper limit is the real value. As soon as the value becomes higher than the real value, it becomes more profitable for holders to sell digital dollars and digital shares at inflated prices, thereby saturating the market with money and creating a correction in the market.The main source of monetary crises is between rapid changes in commodity prices and slow changes in wages. Example: Imagine that the value of the currency has risen sharply by 30%, it becomes more profitable for holders not to invest money, since revenues from holding currency are higher than what is now paid for more expensive employees, because of this, the money stopsto invest, people do not receive wages, which leads to the fact that a huge number of goods are not sold,which leads to the fact that some manufacturers go bankrupt and lay off many workers, which further reduces wagespay the rest, as the labor market becomes surplus. Which in turn causes even more fear among the holdersmoney to invest and this process continues until the moment when the value of money begins to decline due to the factthat the total number of production chains has shrunk and so have the goods. Example: Let's imagine that we had inflation and the value of money fell by 40% within a month, the cost of goods rises sharply, but wages have not risen, so many goods will not be bought, resulting in the closure of production chains, which, in turn, due to an excess of workers in the labor market, reduces wages, which also further reduces the number of goods sold. The first case A deflationary spiral occurs due to a sharp reduction in money in the market, the second The case of stagflation often occurs when a sharply excess amount of money enters the market. So that such crises do not arise, in this cryptocurrency, money grows in the same predictable amount. 204 (4 - reward to the founder, 200 - reward to the earner) digital dollars and shares per block, there are about 576 blocks per day. And the negative rate adjusts the cost of coins every six months. It is also forbidden to use fractional reserve banking for these coins, since their number grows linearly, and will not be able to cover the debts incurred due to fractional reserve banking, due to absence due to a lack of cash, because with fractional reserve banking, the growth in debt will be much higher than this protocol will create money. also if you increase the money supply by changing the settings, and making the growth of the money supply much higher, it can cause hyperinflation or even galloping inflation. If it is necessary to increase the growth of the money supply, this should only happen through amendments, while keeping the founder's reward percentage at two percent. And the mining per block should not increase more than 5% for twenty years, each subsequent increase that may be made must pass at least twenty years through amendments, and no more than 5% per block from the reward of the last block. (Example: if we changed through the amendments, then the extraction should not be higher than 210 coins, but each subsequent one will be no more than five percent of the last.Thus, the next increase made through the amendments will be 220.5 coins. But this amendment will be made only after twenty years after the first correction for production change) If the money supply is deficient, if the number of mined coins has not been changed through the amendment, you can add a few additional zeros after the decimal point, so it will simply increase the value of the coins, without increasing the total money supply. Negative rates should not be higher than 0.5% per annum and lower than 0.2% per annum. Negative rates can only be changed through amendments.","OriginalCHARTER_ENG.FREEDOM_OF_SPEECH: No authority of this corporation or entity shall prohibit free practice any religion; or restrict freedom of speech, conscience, or the press; or the right of people to peacefully assemble or associate with each other, or not associate with each other, and apply to the management of the Corporation of the International Trade Union and to this corporation with a request for satisfaction of complaints; or violate the right to the fruits of one's labor or the right to a peaceful life of one's choice. Freedoms of speech and conscience include the freedom to contribute to political campaigns or nominations for corporate office and shall be interpreted as applying equally to any means of communication.","OriginalCHARTER_ENG.RIGHTS: All members of the network must respect the Natural Human Rights and not violate them. The presumption of innocence must also be respected and each member of the network must have the right to an honest independent litigation. Each participant has the right to a lawyer or to be his own lawyer. International Trade Union Corporation should not regulate the cost of goods and services of network members who sell through this platform. Also, the Corporation should not ban individual brands on its site, but may prohibit the sale of entire groups of goods that fall within the characteristics described by applicable laws, if this prohibition does not violate Natural Human Rights. As a source of rights, you can take it as a precedentand the jurisprudence of the United States and England. Among the natural inalienable human rights include the right to life,freedom, security, property, physical and mental integrity, personal dignity, personal and family secrets, etc. No law in force should be interpreted in such a way as to violate the natural rights of man. The Corporate Supreme Court may use precedents as judgments, as long as those decisions do not contradict the current charter and current laws. The Corporate Supreme Court can create precedents in the same way as in England, but apply You can if these precedents do not violate the current charter or current laws of the Corporation of the International Trade Union.","OriginalPreamble.ARTICLE_0 (По ошибке я добавил в устав черновик, который не был еще доработан, но чтобы с нуля не добывать блоки я добавляю сюда оригинальную конституцию-устав. Данный устав подписан основателем и именно этот устав является действительным) Корпорация Международный Торговый Союз это криптовалютная организация целью которой является создание единой торговой эко-системы, позволяющая людям из разных уголков земли продавать, а также приобретать высококачественные товары и услуги, по самым доступным ценам, при этом соблюдая права человека. Корпорация Международный Торговый Союз использует дивизионную продуктовую организационную структуру. В случае если возникли противоречия в Английской версии и Русской, брать за основу русскую версию Устава, так как перевод был осуществлен из Русской в Английскую версию.","OriginalCHARTER.POWERS_OF_THE_BOARD_OF_DIRECTORS: Полномочия Совета Директоров. Совет Директоров может утверждать счета которые подали на должности из списка Directors. Также Законы название пакетов начинаются с ADD_DIRECTOR являются пакетами которые содержать список новых директоров которые должны управлять новыми линейками продукции. Данные Законы может утверждать только Совет директоров и оттуда будет взять список законов, где каждая строка которая начинается ADD_DIRECTOR будет добавлена в список Directors в качестве новой должности на которую можно подать. пакет который начинается BUDGET является бюджетом и может его утвердить только Совет директоров. Действующий бюджет может быть только один. Совет директоров также утверждает стратегический план STRATEGIC_PLAN. Стратегический план может быть только один действующим. Совет директоров также участвует в утверждении законов (правил по которым должны действовать все участники корпорации), а также участвует в утверждении внедрения поправок в устав AMENDMENT_TO_THE_CHARTER. Совет имеет право устанавливать и собирать комиссию от продаж внутри платформ принадлежащих Корпорации Международного Торгового Союза, при условии что данная комиссия не будет выше двадцати процентов (20%). Все сборы должны и направлены на расходы которые установлены бюджетом. Также источником дохода является продажа своих товаров и услуг, для этого есть Директора офисов которые избираются советом директоров и они должны реализовать продукцию Корпорации Международного Торгового Союза.","OriginalCHARTER.HOW_LAWS_ARE_CHOSEN: КАК ИЗБИРАЮТСЯ ЗАКОНЫ. Ни один закон не имеет обратной силы. Ни один закон не должен нарушать действующий устав или противоречит другим действующим законам. Если есть противотечение между несколькими законами из одного пакета законов, то действующим является тот который списке находится выше по индексу. Пример: пакет об продаже алкоголя закон под индексом 3 противоречит закону из индекса 17, в даном случае закон под индексом три будет действующим. если законы противоречат из разных пакетов, то действующим является тот пакет, который получил больше голосов от Совета акционеров, если есть паритет, то тот который получил больше голосов Совета Директоров, если и здесь есть паритет то данный спор должен решить Верховный Судья, если он также не определил который из двух пакетов где законы противоречат друг другу является законы одно из пакетов более действующими, то в приоритете становиться тот который начал действовать раньше, отсчет определяется именно с последнего момента вступления в силу. Все обычные законы являются действующими если за них проголосовали таким способом ONE_VOTE Совет Акционеров, Совет Директоров и возможно Верховный Судья. Чтобы закон был действующим он должен получить равно или больше 100 остатка голосов Совета Акционеров, 15 остатка голосов Совета Директоров и Один голос Верховного Судьи, но если Верховный Судья не проголосовал или проголосовал против то можно обойти вето верховного судьи получив 200 остаток голосов Совета Акционеров и 30 остаток голосов Совета Директоров. Закон является действующим пока он соответствует количеству голосов как описано выше. Каждый раз как кто то теряет свою должность также теряется все его голоса за все законы которые он проголосовал. Пример кода в LawsController current law: //законы которые получили не достаточно голосов которые могут пройти только если верховный судья одобрит List<CurrentLawVotesEndBalance> notEnoughVotes = current.stream() .filter(t -> !directors.contains(t.getPackageName())) .filter(t->!Seting.AMENDMENT_TO_THE_CHARTER.equals(t.getPackageName())) .filter(t->!directors.isCabinets(t.getPackageName())) .filter(t -> !Seting.ORIGINAL_CHARTER_CURRENT_LAW_PACKAGE_NAME.equals(t.getPackageName())) .filter(t -> t.getVotesBoardOfShareholders() >= Seting.ORIGINAL_LIMIT_MIN_VOTE_BOARD_OF_SHAREHOLDERS) .filter(t -> t.getVotesBoardOfDirectors() >= Seting.ORIGINAL_LIMIT_MIN_VOTE_BOARD_OF_DIRECTORS) .filter(t -> t.getVoteHightJudge() >= Seting.ORIGINAL_LIMIT_MIN_VOTE_HIGHT_JUDGE) .sorted(Comparator.comparing(CurrentLawVotesEndBalance::getVotes).reversed()).collect(Collectors.toList()); //законы которые получили достаточно голосов и не требуют одобрения верховного судьи List<CurrentLawVotesEndBalance> powerfulVotes = current.stream() .filter(t -> !directors.contains(t.getPackageName())) .filter(t-> !Seting.AMENDMENT_TO_THE_CHARTER.equals(t.getPackageName())) .filter(t-> !directors.isCabinets(t.getPackageName())) .filter(t -> !Seting.ORIGINAL_CHARTER_CURRENT_LAW_PACKAGE_NAME.equals(t.getPackageName())) .filter(t -> t.getVotesBoardOfShareholders() >= (Seting.ORIGINAL_LIMIT_MIN_VOTE_BOARD_OF_SHAREHOLDERS * Seting.POWERFUL_VOTE)) .filter(t -> t.getVotesBoardOfDirectors() >= (Seting.ORIGINAL_LIMIT_MIN_VOTE_BOARD_OF_DIRECTORS * Seting.POWERFUL_VOTE)) .sorted(Comparator.comparing(CurrentLawVotesEndBalance::getVotes).reversed()).collect(Collectors.toList());","OriginalCHARTER.HOW_THE_BOARD_OF_DIRECTORS_IS_ELECTED: Как избирается Совет директоров. Совет директоров состоит из 301 счетов BOARD_OF_DIRECTORS. каждый участник сети может подать на должность совета директоров, создав пакет закона, где название пакета BOARD_OF_DIRECTORS и счет отправителя должен совпадать счетом который указан в первой строке закона который содержится в списке данного пакета 301 счет с наибольшим количеством остатка из голосов получает должность. стоимость подачи на создание закона(должность) стоит пять цифровых долларов (5) в качестве вознаграждения добытчику Процесс голосования описан в VOTE_STOCK Пример кода: LawController: method currentLaw: участок кода отвечающий за избрание совета директоров //минимальное значение количество положительных голосов для того чтобы закон действовал, //позиции избираемые акциями совета директоров List<CurrentLawVotesEndBalance> electedByStockBoardOfDirectors = current.stream() .filter(t -> directors.isElectedByStocks(t.getPackageName())) .filter(t -> t.getPackageName().equals(NamePOSITION.BOARD_OF_DIRECTORS.toString())) .filter(t -> t.getVotes() >= Seting.ORIGINAL_LIMIT_MIN_VOTE) .sorted(Comparator.comparing(CurrentLawVotesEndBalance::getVotes).reversed()) .limit(directors.getDirector(NamePOSITION.BOARD_OF_DIRECTORS.toString()).getCount()) .collect(Collectors.toList());","OriginalCHARTER.POWERS_OF_THE_BOARD_OF_SHAREHOLDERS: Полномочия совета акционеров Совет Акционеров Участвует в утверждении Законов (правил которые должны соблюдать все участники данной корпорации) Также Совет Акционеров участвует в утверждении поправок в устав Корпорации Международного Торгового Союза AMENDMENT_TO_THE_CHARTER Совет Акционеров также может участвовать в голосовании при избрании кандидатов CORPORATE_COUNCIL_OF_REFEREES и BOARD_OF_DIRECTORS используя эти правила для голосования за кандидатов VOTE_STOCK.","OriginalCHARTER.HOW_SHAREHOLDERS_BOARD_IS_ELECTED: КАК ИЗБИРАЕТСЯ СОВЕТ АКЦИОНЕРОВ Совет Акционеров состоит из тысячи пятьсот счетов (1500) с наибольшим количеством акций, но учитываются только те счета от чьей активности не прошло больше года. формула: текущий год - один год, и если счет был активен в этом диапазоне он учитывается. Все счета сортируются по убыванию количества цифровых акций, и отбираются 1500 счетов с наибольшим количеством акций. Перерасчет происходит Каждый блок. Пример участка кода как избирается Совет Акционеров: class UtilsGovernment method findBoardOfShareholders: //определение совета акционеров public static List<Account> findBoardOfShareholders(Map<String, Account> balances, List<Block> blocks, int limit) { List<Block> minersHaveMoreStock = null; if (blocks.size() > limit) { minersHaveMoreStock = blocks.subList(blocks.size() - limit, blocks.size()); } else { minersHaveMoreStock = blocks; } List<Account> boardAccounts = minersHaveMoreStock.stream().map( t -> new Account(t.getMinerAddress(), 0, 0)) .collect(Collectors.toList()); for (Block block : minersHaveMoreStock) { for (DtoTransaction dtoTransaction : block.getDtoTransactions()) { boardAccounts.add(new Account(dtoTransaction.getSender(), 0, 0)); } } CompareObject compareObject = new CompareObject(); List<Account> boardOfShareholders = balances.entrySet().stream() .filter(t -> boardAccounts.contains(t.getValue())) .map(t -> t.getValue()).collect(Collectors.toList()); boardOfShareholders = boardOfShareholders .stream() .filter(t -> !t.getAccount().startsWith(Seting.NAME_LAW_ADDRESS_START)) .filter(t -> t.getDigitalStockBalance() > 0) .sorted(Comparator.comparing(Account::getDigitalStockBalance).reversed()) .collect(Collectors.toList()); boardOfShareholders = boardOfShareholders .stream() .limit(Seting.BOARD_OF_SHAREHOLDERS) .collect(Collectors.toList()); return boardOfShareholders; }","OriginalCHARTER.VOTE_STOCK: Как с помощью акций происходит голосование. все акции которым счет владеет приравниваются такому же количеству голосов. каждый раз когда кто то делает транзакцию на счет который является адресом данного пакета который начинается LIBER он голосует за данный пакет. Учитываются только те голоса, с которых не прошло больше четырех лет. если транзакция была совершена VoteEnum.YES то данный счет получает голоса за по формуле yesV = количество голосов равные количеству акций отправителя. yesN = за сколько законов данный счет проголосовал с VoteEnum.YES resultYES = yesV / math.pow(yesN, 3). Пример: счет проголосовал за три счета которые начинаются с LIBER, на счету сто акций, значит сто голосов. 100 / math.pow(3, 3) = 3.7 значит каждый счет получит по 3.7 голоса. если транзакция была совершена с VoteEnum.NO то используется такая же формула, но учитываются теперь все счета за которые он проголосовал против пример тот же счет проголосовал за два счет против, у него те же сто акций. resultNO = noV / math.pow(noN, 3) = 100/ math.pow(2,3) = 12.5 значит каждый счет за который он проголосовал, против получит 12.5 голосов против. дальше каждый счет подсчитывает все отданные ему голоса ЗА (VoteEnum.YES) и ПРОТИВ (VoteEnum.NO). потом используется данная формула remainder = resultYES - resultNO. сначала данные должности отбираются все счета которые получили больше или равно четырнадцать тысяч четыреста голосов остатка (14400) remainder >= 14400. Дальше все счета сортируются по убыванию remainder и оттуда отбираются то количество счетов на данные должности, сколько это оговорено в данной должности. Пример: Для Совета Директоров это 301 счет с наибольшим количеством остатка. В любой момент можно изменить свой голос, но только на противоположный, что значит если вы проголосовали за кандидата YES то вы можете изменить только на NO и обратно. количество раз сколько вы можете изменить свой голос не ограничено. С каждым блоком происходит перерасчет голосов, если вы теряете свои акции, ваши кандидаты также теряют свои голоса. Данная мера специально так реализовано чтобы избираемые должности были заинтересованы в том чтобы вы процветали. Таким способом избираются Только CORPORATE_COUNCIL_OF_REFEREES и BOARD_OF_DIRECTORS Учитывается только последняя транзакция отданная за каждый счет, если вы не обновляли свой голос, то по прошествии четырех лет он аннулируется.","OriginalCHARTER.CODE_VOTE_STOCK: class CurrentLawVotes method: votesLaw public double votesLaw(Map<String, Account> balances, Map<String, Integer> yesAverage, Map<String, Integer> noAverage) { double yes = 0.0; double no = 0.0; // for (String s : YES) { int count = 1; count = yesAverage.get(s) > 0 ? yesAverage.get(s) : 1; yes += balances.get(s).getDigitalStockBalance() / Math.pow(count, Seting.POWERING_FOR_VOTING); } // for (String s : NO) { int count = 1; count = noAverage.get(s) > 0 ? noAverage.get(s) : 1; no += balances.get(s).getDigitalStockBalance() / Math.pow(count, Seting.POWERING_FOR_VOTING); } return yes - no; }","OriginalCHARTER.POWERS_OF_DIRECTORS_IN_THE_OFFICE: ПОЛНОМОЧИЯ ДИРЕКТОРОВ В ОФИС директорами офиса называются высшие директора которые являются директорами своих дивизионов. Полномочия каждого директора должны быть описаны действующими законами. Но каждый директор должен управлять только своим дивизионом. Координацией всех директоров должен Генеральный Исполнительный Директор GENERAL_EXECUTIVE_DIRECTOR. Совет Директоров, CORPORATE_COUNCIL_OF_REFEREES, HIGH_JUDGE, Совет Акционеров и GENERAL_EXECUTIVE_DIRECTOR могут быть как физическими лицами, так и юридическими лицами, но один счет будет учитываться как один голос.","OriginalCHARTER.HOW_OFFICE_DIRECTORS_ARE_CHOSEN: КАК ИЗБИРАЮТСЯ ОФИСНЫЕ ДИРЕКТОРА Все Директора офиса, это высшие директора которые управляют своими дивизионами, избираются только Советом Директоров. Каждый участник сети может подать на должность высшего директора, создав закон, с названием пакета который совпадает с допустимыми должностями, где адрес отправителя данной транзакции должен совпадать с первой строкой из списка законов данного пакета. стоимость закона пять цифровых долларов в качестве вознаграждения добытчику. счет с наибольшим количеством голосов остатка получает данную должность. Механизм голосования описан ONE_VOTE. Пример участка кода как избирается должности class LawsController: method currentLaw: //позиции созданные советом директоров List<CurrentLawVotesEndBalance> createdByBoardOfDirectors = current.stream() .filter(t->t.getPackageName().startsWith(Seting.ADD_DIRECTOR)) .filter(t->t.getVotesBoardOfDirectors() >= Seting.ORIGINAL_LIMIT_MIN_VOTE_BOARD_OF_DIRECTORS) .collect(Collectors.toList()); //добавление позиций созданных советом директоров for (CurrentLawVotesEndBalance currentLawVotesEndBalance : createdByBoardOfDirectors) { directors.addAllByBoardOfDirectors(currentLawVotesEndBalance.getLaws()); } //позиции избираемые только советом директоров List<CurrentLawVotesEndBalance> electedByBoardOfDirectors = current.stream() .filter(t -> directors.isElectedByBoardOfDirectors(t.getPackageName()) || directors.isCabinets(t.getPackageName())) .filter(t -> t.getVotesBoardOfDirectors() >= Seting.ORIGINAL_LIMIT_MIN_VOTE_BOARD_OF_DIRECTORS) .sorted(Comparator.comparing(CurrentLawVotesEndBalance::getVotesBoardOfDirectors).reversed()) .collect(Collectors.toList());","OriginalCHARTER.ONE_VOTE: ОДИН ГОЛОС когда голосуют данные должности, учитывается как один счет = один голос. CORPORATE_COUNCIL_OF_REFEREES, BOARD_OF_DIRECTORS, GENERAL_EXECUTIVE_DIRECTOR, HIGH_JUDGE и Совет Акционеров. каждый счет который начинается с LIBER учитывает все голоса ЗА (VoteEnum.YES) и ПРОТИВ (VoteEnum.NO) за него дальше отнимается отнимается от ЗА - ПРОТИВ = если остатков выше порога, то он становиться действующим. Перерасчет голосов происходит каждый блок. После голосования голос можно поменять только на противоположный. Ограничений на количество сколько раз можно поменять свой голос нет. Учитываются только те голоса которые даны счетами находящимися в своей должности, к примеру если счет перестал быть в Совете Директор, его голос как в качестве Совета Директоров не учитывается, и не будет учитываться в голосовании. Все голоса действуют, пока счета проголосовавшие находятся в своих должностях. Учитываются также только те голоса, от которых прошло не более четырех лет, но каждый участник, может в любой момент времени обновить свой голос.","OriginalCHARTER.CODE_VOTE_ONE: КОД class CurrentLawVotes: method voteGovernment public int voteGovernment( Map<String, Account> balances, List<String> governments ) { int yes = 0; int no = 0; List<String> addressGovernment = governments; for (String s : YES) { if (addressGovernment.contains(s)) { yes += Seting.VOTE_GOVERNMENT; } } for (String s : NO) { if (addressGovernment.contains(s)) { no += Seting.VOTE_GOVERNMENT; } } return yes - no; }","OriginalCHARTER.MECHANISM_FOR_REDUCING_THE_NUMBER_OF_SHARES: МЕХАНИЗМ СНИЖЕНИЯ КОЛИЧЕСТВА АКЦИЙ Каждый раз когда один счет отправляет на другой счет цифровую акцию, но использует VoteEnum.NO, счет цифровых акций получателя снижается на то количество которое отправил отправитель акций. Пример счет А отправил на счет Б 100 цифровых акций VoteEnum.NO, тогда счет А и счет Б оба теряют 100 цифровых акций. Данная мера нужна чтобы был механизм какой нибудь счет снять с Совета акционеров. Данный механизм действует только на цифровые акции и только в том случае, что отправитель отправил с знаком VoteEnum.NO","OriginalCHARTER.WHO_HAS_THE_RIGHT_TO_CREATE_LAWS: Создавать законы в криптовалюте Корпорации Международный Торговый Союз имеют права все участники сети, которые имеют минимум пять цифровых доллара. Для создания закона через механизм криптовалюты Корпорации Международного торгового Союза Нужно внутри данной криптовалюты Создать объект класса Laws где packetLawName- является названием пакета законов. List<String> laws - является списком законов, String hashLaw - является адресом данного пакета законов и начинается с LIBER. Чтобы Закон попал в пул законов нужно создать транзакцию где получателем является hashLaw данного закона и вознаграждение майнера равно пять цифровых доллара (5) данной криптовалюты. После этого как закон попадет в блок, он окажется в пуле законов и за него можно будет голосовать. Количество строк в пакете законов может быть столько, сколько понадобиться и нет никаких ограничений.","OriginalCHARTER.POWERS_OF_THE_CORPORATE_COUNCIL_OF_JUDGES: ПОЛНОМОЧИЯ КОРПОРАТИВНОГО СОВЕТА СУДЕЙ Утверждает Верховного судью. Участвует в голосовании внедрения поправок. Судебная власть Корпорации Международного Торгового Союза принадлежит одному Верховному суду и таким нижестоящим судам, которые Корпорация Международный Торговый Союз может время от времени издавать и учреждать. Судьи как верховных, так и нижестоящих судов занимают свои должности при хорошем поведении и в установленные сроки получают за свои услуги вознаграждение. Судебная власть распространяется на все дела по закону и справедливости, в том числе инициированные членами для оспаривания незаконного расходования средств, возникающего в соответствии с настоящем Уставом, законами Корпорации Международного Торгового Союза и договорами, заключенными или которые будут заключены в соответствии с их авторитетом. к спорам, в которых Международный Торговый Союз будут стороной; к разногласиям между двумя или более участников сети. Ни один суд не должен быть тайным, но правосудие должно вершиться открыто и бесплатно, полностью и безотлагательно, и каждый человек должен иметь правовую правовую защиту от вреда, причиненного жизни, свободе или имуществу. Верховный Суд CORPORATE_COUNCIL_OF_REFEREES и верховный судья HIGH_JUDGE","OriginalCHARTER.HOW_THE_CORPORATE_BOARD_OF_JUDGES_IS_ELECTED: КАК ИЗБИРАЮТСЯ КОРПОРАТИВНЫЙ СОВЕТ СУДЕЙ CORPORATE_COUNCIL_OF_REFEREES состоит из 55 счетов. каждый участник сети может подать на должность CORPORATE_COUNCIL_OF_REFEREES , создав пакет закона, где название пакета CORPORATE_COUNCIL_OF_REFEREES и счет отправителя должен совпадать счетом который указан в первой строке закона который содержится в списке данного пакета 55 счет с наибольшим количеством остатка из голосов получает должность. стоимость подачи на создание закона(должность) стоит пять цифровых долларов (5) в качестве вознаграждения добытчику Процесс голосования описан в VOTE_STOCK Пример участка кода: class LawsController: method currentLaw: //минимальное значение количество положительных голосов для того чтобы закон действовал, //позиции избираемые акциями CORPORATE_COUNCIL_OF_REFEREES List<CurrentLawVotesEndBalance> electedByStockCorporateCouncilOfReferees = current.stream() .filter(t -> directors.isElectedByStocks(t.getPackageName())) .filter(t -> t.getPackageName().equals(NamePOSITION.CORPORATE_COUNCIL_OF_REFEREES.toString())) .filter(t -> t.getVotes() >= Seting.ORIGINAL_LIMIT_MIN_VOTE) .sorted(Comparator.comparing(CurrentLawVotesEndBalance::getVotes).reversed()) .limit(directors.getDirector(NamePOSITION.CORPORATE_COUNCIL_OF_REFEREES.toString()).getCount()) .collect(Collectors.toList());","OriginalCHARTER.HOW_THE_CHIEF_JUDGE_IS_CHOSEN: КАК ИЗБИРАЕТСЯ ВЕРХОВНЫЙ СУДЬЯ HIGH_JUDGE Верховный Судья избирается CORPORATE_COUNCIL_OF_REFEREES. Каждый участник сети может подать на должность Верховного Судьи, создав закон, с названием пакета который совпадает с допустимым должностью, где адрес отправителя данной транзакции должен совпадать с первой строкой из списка законов данного пакета. стоимость закона пять цифровых долларов в качестве вознаграждения добытчику. счет с наибольшим количеством голосов остатка получает данную должность. Механизм голосования описан ONE_VOTE. Пример кода как утверждается верховный судья. class LawsController: method currentLaw. Участок кода //позиции избираемые советом корпоративных верховных судей List<CurrentLawVotesEndBalance> electedByCorporateCouncilOfReferees = current.stream() .filter(t -> directors.isElectedBYCorporateCouncilOfReferees(t.getPackageName())) .filter(t -> t.getVotesCorporateCouncilOfReferees() >= Seting.ORIGINAL_LIMIT_MIN_VOTE_CORPORATE_COUNCIL_OF_REFEREES) .sorted(Comparator.comparing(CurrentLawVotesEndBalance::getVotesCorporateCouncilOfReferees)).collect(Collectors.toList());","OriginalCHARTER.POWERS_OF_THE_CHIEF_JUDGE: ПОЛНОМОЧИЯ ВЕРХОВНОГО СУДЬИ. Верховный судья участвует в утверждении законов и в утверждении поправок в устав, а также может участвовать в решении споров внутри членов сети как и CORPORATE_COUNCIL_OF_REFEREES но его голос выше чем голос CORPORATE_COUNCIL_OF_REFEREES.","OriginalCHARTER.HOW_IS_THE_PROCESS_OF_AMENDING_THE_CHARTER: КАК ПРОИСХОДИТ ПРОЦЕСС ВНЕСЕНИЯ ПОПРАВОК В УСТАВ. для внесения поправок нужно создать закон с названием пакета AMENDMENT_TO_THE_CHARTER. Дальше за этот закон должны проголосовать методом описанным в VOTE_ONE Совет Акционеров и остаток голосов должен быть равен или выше 300 участников, также должны проголосовать Совет Директоров и остаток голосов должен быть 60 или больше, также должны проголосовать корпоративные верховные судьи (CORPORATE_COUNCIL_OF_REFEREES) и остаток голосов должен быть равен или больше 5. Но поправки не должны касаться способа установления правил действующих законов, а также избрания Совета Директоров, Совета Акционеров, Генерального Исполнительного Директора, Совета Корпоративных Судей и Верховного Судьи. Поправки могут изменять код, если сохраняются правила избрания действующих должностей (включая правил голосования), законов и добычи денег (добыча цифровых долларов и цифровых акции), Ни одна поправка не должна наделять из выше перечисленных должностей большей властью. Также поправки не должны ущемлять Естественные Права Человека. Пример кода. class LawsController: method currentLaw: участок кода утверждающий действующие поправки //внедрение поправок в устав List<CurrentLawVotesEndBalance> chapter_amendment = current.stream() .filter(t -> !directors.contains(t.getPackageName())) .filter(t-> Seting.AMENDMENT_TO_THE_CHARTER.equals(t.getPackageName())) .filter(t->!directors.isCabinets(t.getPackageName())) .filter(t -> t.getVotesBoardOfShareholders() >= Seting.ORIGINAL_LIMIT_MINT_VOTE_BOARD_OF_SHAREHOLDERS_AMENDMENT) .filter(t -> t.getVotesBoardOfDirectors() >= Seting.ORIGINAL_LIMIT_MIN_VOTE_BOARD_OF_DIRECTORS_AMENDMENT) .filter(t -> t.getVotesCorporateCouncilOfReferees() >= Seting.ORIGINAL_LIMIT_MIN_VOTE_CORPORATE_COUNCIL_OF_REFEREES_AMENDMENT) .sorted(Comparator.comparing(CurrentLawVotesEndBalance::getVotesBoardOfDirectors).reversed()).collect(Collectors.toList());","OriginalCHARTER.HOW_THE_BUDGET_IS_APPROVED: КАК УТВЕРЖДАЕТСЯ БЮДЖЕТ. Действующий бюджет может быть только один. Бюджет утверждает только Совет Директоров. Для утверждения бюджета нужно получить методом описанным в VOTE_ONE 15 и больше голосов. сам процесс происходит так: 1. Сначала отбираются все пакеты законов где название пакета совпадает с BUDGET. 2. Дальше отбираются все пакеты которые остаток голосов получили 15 или больше. 3. Дальше все эти пакеты сортируются по убыванию, с наибольшим количеством голосов. 4. Дальше отбирается самый первый с наибольшим количеством голосов. Пример кода утверждающий бюджет. class LawsController: method: currentLaw. //бюджет утверждается только советом директоров. List<CurrentLawVotesEndBalance> budjet = current.stream() .filter(t-> !directors.contains(t.getPackageName())) .filter(t->Seting.BUDGET.equals(t.getPackageName())) .filter(t->!directors.isCabinets(t.getPackageName())) .filter(t-> t.getVotesBoardOfDirectors() >= Seting.ORIGINAL_LIMIT_MIN_VOTE_BOARD_OF_DIRECTORS) .sorted(Comparator.comparing(CurrentLawVotesEndBalance::getVotesBoardOfDirectors).reversed()) .limit(1) .collect(Collectors.toList());","OriginalCHARTER.HOW_IS_THE_STRATEGIC: КАК УТВЕРЖДАЕТСЯ СТРАТЕГИЧЕСКИЙ ПЛАН. Стратегический план утверждает Совет Директоров, стратегический план может быть действующим только в единственном экземпляре. Чтобы Стратегический План был действующим, нужно остаток голосов Совета Директоров 15 или больше. Способ голосования VOTE_ONE. В любой момент можно отменить Совет Директоров в любой момент может отменить Стратегический План. Стратегический План действует пока количество голосов 15 или больше. Стратегический План может включать в себя общее направление Корпорации, а также что нужно реализовать. участок кода который показывает как утверждается Стратегический План. class LawsController: method currentLaw: //план утверждается только палатой Советом Директоров List<CurrentLawVotesEndBalance> planFourYears = current.stream() .filter(t->!directors.contains(t.getPackageName())) .filter(t->Seting.STRATEGIC_PLAN.equals(t.getPackageName())) .filter(t->!directors.isCabinets(t.getPackageName())) .filter(t->t.getVotesBoardOfDirectors() >= Seting.ORIGINAL_LIMIT_MIN_VOTE_BOARD_OF_DIRECTORS) .sorted(Comparator.comparing(CurrentLawVotesEndBalance::getVotesBoardOfDirectors).reversed()) .limit(1) .collect(Collectors.toList());","OriginalCHARTER.HOW_NEW_POSITIONS_ARE_ADDED: КАК ДОБАВЛЯЮТСЯ НОВЫЕ ДОЛЖНОСТИ. таким способом добавляются только высшее руководство, подчиненные каждого руководителя нанимают без использования блокчейна, их может нанять сам директор, или иным способом как описано действующими законами. Высшее руководство добавляется в список class Directors. все новые добавленные должности действуют пока их законы которые создают данные должности действуют. Добавлять новые должности может только Совет директоров. Каждый пакет законов который начинается с ADD_DIRECTOR определяется как добавление должности. список законов который находиться внутри данного пакета являются должностями если название в строке начинается с ADD_DIRECTOR. Пример: название пакета ADD_DIRECTOR_PACKAGE название первой третьей и четвертой строки ADD_DIRECTOR_FIRST ADD_DIRECTOR_THIRD ADD_DIRECTOR_FOUR таким образом будет созданы три места для должности. Но если строка начинается с ADD_DIRECTOR то название должности должно быть большими буквами и нижними подчеркиваниями, так же в одной строке должна быть только одна должность и больше никаких слов. Те строки где нет добавления должности, используются для описания полномочий добавленных должностей. Чтобы новые должности были добавлены в список, Совет Директоров должен проголосовать методом VOTE_ONE 15 или больше голосов. После как новые должности будут созданы, каждый участник сети сможет подавать себя на данные должности. пример участка кода который создает новые должности. class LawsController: method currentLaw: //добавляет законы, которые создают новые должности директоров List<CurrentLawVotesEndBalance> addDirectors = current.stream() .filter(t->t.getPackageName().startsWith(Seting.ADD_DIRECTOR)) .filter(t->t.getVotesBoardOfDirectors() >= Seting.ORIGINAL_LIMIT_MIN_VOTE_BOARD_OF_DIRECTORS) .collect(Collectors.toList());","OriginalCHARTER.PROPERTY_OF_THE_CORPORATION: СОБСТВЕННОСТЬ КОРПОРАЦИИ. Вся собственность которая принадлежит Корпорации Международного Торгового Союза, не может быть продана без действующего закона, где будет описан процесс продажи и по какой стоимости будет продана собственность. Счет основателя, и счета других участников не является счетом корпорации, Совет Директоров должен создать отдельный счет который будет как бюджет управляться долько членами действующих Совета Директоров.","OriginalCHARTER.INTERNET_STORE_DIRECTOR: данный директор занимается разработкой, продвижением и руководством интернет магазина, в котором должны продаваться товары за цифровой доллар или цифровые акции. Детальные полномочия должны быть данны или через действующие законы или выданы Генеральным исполнительным директором или Советом Директоров. Название Магазина должен определить либо Совет Директоров или Генеральный Исполнительный Директор.","OriginalCHARTER.GENERAL_EXECUTIVE_DIRECTOR: данный Директор координирует действия остальных высших директоров для реализации стратегического плана или поставленных перед ним задач действующими законами. Все полномочия должны быть ему выданы через действующие законы.","OriginalCHARTER.DIRECTOR_OF_THE_DIGITAL_EXCHANGE: Данный Директор разработкой, продвижением и руководством интернет биржа. Полномочия должны быть выданы ему или действующими законами, или Советом Директоров или или Генеральным Исполнительным Директором.","OriginalCHARTER.DIRECTOR_OF_DIGITAL_BANK: Данный Директор руководит интернет банком. Все полномочия должны быть выданы или действующими законами, или Советом директоров или Генеральным Исполнительным Директором.","OriginalCHARTER.DIRECTOR_OF_THE_COMMERCIAL_COURT: Директор частного коммерческого суда должен обеспечивать руководство частным судом, все полномочия должны быть Выданы или действующими законами или Советом Директоров или Генеральным Исполнительным Директором.","OriginalCHARTER.MEDIA_DIRECTOR: Данный Директор руководит сми, все полномочия должны быть выданы действующими законами, или Советом Директоров или генеральным исполнительным Директором.","OriginalCHARTER.DIRECTOR_OF_THE_DEVELOPMENT_OF_THE_IMPLEMENTATION_OF_CRYPTOCURRENCY_TECHNOLOGIES_OF_THE_INTERNATIONAL_TRADE_UNION_CORPORATION: Данный Директор руководит разработкой и внедрением нового кода в данную криптовалюту, все полномочия должны быть выданы только через действующие законы, но также могут быть выданы или Советом Директоров, если действующие законы дали такие полномочия Совету Директоров. Также ни одно изменение кода не должно противоречить действующему уставу или действующим законам, Также полномочия могут быть выданы Генеральным Исполнительным Директором, если генеральному исполнительному директору данные полномочия выданы действующим законами.","OriginalCHARTER.EXPLANATION_WHY_MONEY_DEMURAGE_IS_USED_HERE: ОБЯСНЕНИЕ ПОЧЕМУ ЗДЕСЬ ИСПОЛЬЗУЕТСЯ ДЕМЕРЕДЖ ДЕНЕГ.. Отрицательная ставка сейчас применяется во множестве стран, данная стимулирует держателей денег, когда цена чрезмерно завышена, насыщать рынок деньгами. Количество добываемых денег за каждый блок составляет 200 цифровых долларов и 200 цифровых акций, также 2% от каждой добычи вознаграждение основателю, что составляет 4 цифровых доллара и 4 цифровых Акций при каждой добыче блока. Здесь используется как Теории сильвио Гезеля, а также школы монетаризма (в измененном виде у сильвио Гезеля, отрицательная ставка составляла 1% в месяц, что просто убило бы экономику, при монетаризме рост денежной массы должен был быть пропорционален росту ВВП, но так как в данной системе не получиться посчитать реальный рост ВВП, я установил фиксированный рост, также если денежный рост будет равен ВВП, есть высокая вероятность Гиперинфляции. Деньги должны быть твердые, чтобы бизнес мог прогнозировать свои долгосрочные вложения и от монетаризма, взята только та часть что денежная масса должна расти линейно, но в целом здесь микс из разных экономических школ, включая Австрийскую экономическую школу.). При отрицательной ставке 0.1% каждые пол года для цифровых долларов и 0.2% для цифровых акций мы избегаем последствий тяжелого экономического кризиса для данной валюты. Такой механизм создает коридор цен, где нижняя граница стоимости данных цифровых валют является общее количество выпущенных цифровых долларов и цифровых акций, а верхняя граница является реальная стоимость. Так как только стоимость становиться выше реальной стоимости, держателям выгодней становиться продавать цифровые доллары и цифровые акции, по завышенным ценам, тем самым насыщая рынок деньгами и создавая коррекцию на рынке. Основным источником монетарных кризисов, является между быстрыми изменениями цен на товары и медленным изменением заработных плат. Пример: Представим что стоимость валюты резко подорожало на 30%, держателям выгодней становиться не инвестировать деньги, так как доходы от удерживания валюты, выше чем теперь уже оплачивать более дорогих сотрудников, из за того деньги перестают инвестироваться, люди не дополучают заработные платы, что приводит к тому, что огромное количество товаров не реализуется, что приводит к тому, часть производителей банкротится и увольняют множество рабочих, что еще больше снижает заработную плату у оставшихся, так как становиться профицитный рынок труда. Что в свою очередь еще больше вызывает страх у держателей денег инвестировать и данный процесс продолжается до того момента, пока стоимость денег не начинает сокращаться в связи с тем что общее количество производственных цепочек сократилось и также сократились товары. Пример: Представим что у нас произошла инфляция и стоимость денег упала на 40% в течение месяца, стоимость товаров резко возрастает, но заработные платы не выросли, таким образом множество товаров не будут куплены, что приводит к закрытию производственных цепочек, что в свою очередь из за избытка рабочих на рынке труда, снижает заработную плату, что также в свою очередь еще больше сокращает количество проданных товаров. Первый случай Дефляционная спираль возникает из за резкого сокращения денег на рынке, второй случай стагфляция чаще возникает когда на рынок поступает резко избыточное количество денег. Чтобы не возникали такие кризисы не возникали, в данной криптовалюте деньги прирастают в одинаковом предсказуемом количестве. 204 (4 - вознаграждение основателю, 200 - вознаграждение добытчику) цифровых долларов и акций за блок, в сутках около 576 блоков. А отрицательная ставка корректирует стоимость монет каждые пол года. Также запрещено использовать частичное банковское резервирование для данных монет, так как их количество растет линейно, и не сможет покрыть долги возникшие из за частичного банковского резервирования, в связи отсутствия с недостатком наличности, так как при частичном банковском резервировании рост долгов будет намного выше, чем данный протокол будет создавать денег. также если увеличить денежную массу изменив настройки, и сделав рост денежной массы значительно выше, может вызвать гиперинфляцию или даже галопирующую инфляцию. Если нужно будет увеличить рост денежной массы это должно происходить только через внесения поправок, сохраняя процент вознаграждения основателя в двух процентах. И добыча за блок не должна увеличиваться больше 5% в течение двадцати лет, каждое следующее увеличение которое может вноситься должно проходить не менее двадцати лет через поправки, и не более 5% за блок от вознаграждения последнего блока. (Пример: если мы изменили через поправки, то добыча не должна быть выше 210 монет, но каждые следующие будет не больше пяти процентов от последнего. Таким образом следующее увеличение внесенное через поправки составит 220.5 монет. Но Эту поправку внесут только через двадцать лет после первой поправки по изменению добычи) При недостатки денежной массы, если не было изменено количество добываемых монет через поправку, можно добавить несколько дополнительных нулей после запятой, таким образом это просто увеличит ценность монет, без увелечения общей выпущенной денежной массы. Отрицательные ставки не должны быть выше 0.5% годовых и ниже 0.2% годовых. Отрицательные ставки можно изменять только через внесения поправок.","OriginalCHARTER.FREEDOM_OF_SPEECH: Ни один орган данной корпорации или субъект не должен запрещать свободное исповедание какой-либо религии; или ограничивать свободу слова, совести или печати; или право людей мирно собираться или объединяться друг с другом, или не объединяться друг с другом, и обращаться к руководству Корпорации Международного Торгового Союза и к данной корпорации с ходатайством об удовлетворении жалоб; или нарушать право на плоды своего труда или право на мирную жизнь по своему выбору. Свободы слова и совести включают свободу вносить вклад в политические кампании или кандидатуры на корпоративные должности и должны толковаться как распространяющиеся в равной степени на любые средства коммуникации.","OriginalCHARTER.RIGHTS: Все члены сети, должны соблюдать Естественные Права Человека и не нарушать их. Также должно соблюдаться презумпция невиновности и каждый участник сети должен иметь права на честное независимое судебное разбирательство. Каждый участник имеет права на адвоката или быть самому себе адвокатом. Корпорация Международный Торговый Союз не должна регулировать стоимость товаров и услуг участников сети, которые продают через данную платформу. Также Корпорация не должна запрещать отдельные бренды на своей площадке, но может запрещать продавать целые группы товаров, которые попадают по характеристикам описанных действующими законами, если этот запрет не нарушает Естественные Права Человека. В качестве источника прав можно брать в качестве прецедента и юриспруденции США и Англии. К числу естественных неотчуждаемых прав человека относят право на жизнь, свободу, безопасность, собственность, физическую и психическую неприкосновенность, достоинство личности, личную и семейную тайну и т. п. Ни один действующий закон не должен интерпретироваться так, чтобы нарушать естественные права человека. Корпоративный верховный суд может использовать прецеденты в качестве судебных решений, если эти решения не противоречат действующему уставу и действующим законам. Корпоративный Верховный Суд может создавать прецеденты ано логично как в Ангии, но применять можно если эти прецеденты не нарушают действующий устав или действующие законы Корпорации Международного Торгового Союза.","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","",""],"hashLaw":"LIBER16887e98f0e84969013fc56a015b49a00d9626f66691092d11e6f2101ce958f3"}}
{"name":"LIBER0018e1c46e0aa2af0852bfbd72d2743638cd2ca8158a1cba75a8433284ef5dbc","account":{"account":"LIBER0018e1c46e0aa2af0852bfbd72d2743638cd2ca8158a1cba75a8433284ef5dbc","digitalDollarBalance":0.0,"digitalStockBalance":0.0},"laws":{"packetLawName":"ORIGINAL_CHARTER_CURRENT_LAW_PACKAGE_NAME","laws":["POWERS_OF_THE_BOARD_OF_DIRECTORS Совет Директоров может утверждать счета, которые подали на должности из списка Directors (Назначает должность). Также Законы название пакетов начинаются с ADD_DIRECTOR, являются пакетами, которые содержать список новых директоров. Этот список должны управлять новыми линейками продукции.    Данные Законы может утверждать только Совет директоров и оттуда будет взять список законов, где  каждая строка которая начинается ADD_DIRECTOR, будет добавлена в список Directors в качестве новой должности. Список DIRECTORS которую можно подать.   Пакет, который начинается с BUDGET, является бюджетом и может его утвердить только Совет директоров Действующий бюджет может быть только один.              Совет директоров также утверждает стратегический план STRATEGIC_PLAN. Действующим может быть только  один стратегический план.                Совет директоров также участвует в утверждении законов (правил по которым должны действовать  все участники корпорации), а также участвует в утверждении внедрения поправок в устав AMENDMENT_TO_THE_CHARTER.              Совет имеет право устанавливать и собирать комиссию от продаж внутри платформ принадлежащих Корпорации Международного Торгового Союза, при условии что данная комиссия не будет выше двадцати процентов (20%). Все сборы должны быть направлены на расходы которые установлены бюджетом. Также источником дохода является продажа своих товаров и услуг, для этого есть Директора офисов которые избираются советом директоров и они должны реализовать продукцию Корпорации Международного Торгового Союза. ","HOW_LAWS_ARE_CHOSEN Ни один закон не имеет обратной силы. Ни один закон не должен нарушать действующий устав или противоречит  другим действующим законам. Если есть противотечение между несколькими законами из одного пакета законов, то действующим является тот который списке находится выше по индексу. Пример: пакет по продаже алкоголя  закон под индексом 3 противоречит закону из индекса 17, в даном случае закон под индексом три будет действующим, так как он более выше по статусу.             Если законы противоречат из разных пакетов, то действующим является тот пакет, который получил больше голосов от Совета акционеров, если есть паритет, то тот который получил больше голосов Совета Директоров, если и здесь  есть паритет то данный спор должен решить Верховный Судья, если он также не определил который из двух пакетов где законы противоречат друг другу является законы одно из пакетов более действующими, то в приоритете становиться   тот, который начал действовать раньше, отсчет определяется именно с последнего момента вступления в силу.              Все обычные законы являются действующими если за них проголосовали таким способом ONE_VOTE Совет Акционеров, Совет Директоров и возможно  Верховный Судья.   Чтобы закон был действующим он должен получить равно или больше 100 остатка голосов Совета Акционеров, равно или больше 15 остатка голосов Совета Директоров и Один голос Верховного Судьи, но если Верховный Судья не проголосовал или проголосовал против то можно обойти вето верховного судьи получив 200 и более остаток голосов Совета Акционеров и 30 и более остаток голосов Совета Директоров.             или если закон получил более 100 тысяч голосов остатка как описано VOTE_STOCK также является действующим, и будет действовать пока сохраняет больше сто тысяч голосов. Закон является действующим, пока он соответствует количеству голосов как описано выше. Каждый раз как кто-то теряет свою должность  также теряется все его голоса за все законы которые он проголосовал, но не теряются голоса полученные с помощью акций.","HOW_THE_BOARD_OF_DIRECTORS_IS_ELECTED Как избирается Совет Директоров.  Совет директоров состоит из 301 счетов BOARD_OF_DIRECTORS.  Каждый участник сети может подать на должность совета директоров, создав пакет закона, где  название пакета BOARD_OF_DIRECTORS и счет отправителя должен совпадать счетом который указан  в первой строке закона который содержится в списке данного пакета.  301 счет с наибольшим количеством остатка голосов получает должность.  Стоимость подачи на создание закона(должность) стоит пять цифровых долларов (5) в качестве вознаграждения добытчику.  Процесс голосования описан в VOTE_STOCK.","POWERS_OF_THE_BOARD_OF_SHAREHOLDERS Полномочия совета акционеров. Совет Акционеров Участвует в утверждении Законов (правил сети, которые должны соблюдать все участники данной Корпорации). Также Совет Акционеров участвует в утверждении поправок в устав Корпорации Международного Торгового Союза AMENDMENT_TO_THE_CHARTER. Совет Акционеров также может участвовать в голосовании при избрании кандидатов CORPORATE_COUNCIL_OF_REFEREES и BOARD_OF_DIRECTORS используя эти правила для голосования за кандидатов VOTE_STOCK.","HOW_SHAREHOLDERS_BOARD_IS_ELECTED OriginalCHARTER.HOW_SHAREHOLDERS_BOARD_IS_ELECTED: КАК ИЗБИРАЕТСЯ СОВЕТ АКЦИОНЕРОВ.  Совет Акционеров состоит из тысячи пятьсот счетов (1500) с наибольшим количеством акций, но учитываются только те счета от чьей активности не прошло больше года (Активностью считается майнинг или отправка денег, создание закона, отправка штрафов, Подача на должность и Создание новой должности). формула: текущий год - один год, и если счет был активен в этом диапазоне, он учитывается. Все счета сортируются по убыванию количества цифровых акций, и отбираются 1500 счетов с наибольшим количеством акций. Перерасчет происходит Каждый блок. Пример участка кода как избирается Совет Акционеров:  //определение совета акционеров     public static List<Account> findBoardOfShareholders(Map<String, Account> balances, List<Block> blocks, int limit) {         List<Block> minersHaveMoreStock = null;         if (blocks.size() > limit) {             minersHaveMoreStock = blocks.subList(blocks.size() - limit, blocks.size());         } else {             minersHaveMoreStock = blocks;         }         List<Account> boardAccounts = minersHaveMoreStock.stream().map(                         t -> new Account(t.getMinerAddress(), 0, 0))                 .collect(Collectors.toList());          for (Block block : minersHaveMoreStock) {             for (DtoTransaction dtoTransaction : block.getDtoTransactions()) {                 boardAccounts.add(new Account(dtoTransaction.getSender(), 0, 0));             }          }           CompareObject compareObject = new CompareObject();          List<Account> boardOfShareholders = balances.entrySet().stream()                 .filter(t -> boardAccounts.contains(t.getValue()))                 .map(t -> t.getValue()).collect(Collectors.toList());           boardOfShareholders = boardOfShareholders                 .stream()                 .filter(t -> !t.getAccount().startsWith(Seting.NAME_LAW_ADDRESS_START))                 .filter(t -> t.getDigitalStockBalance() > 0)                 .sorted(Comparator.comparing(Account::getDigitalStockBalance).reversed())                 .collect(Collectors.toList());          boardOfShareholders = boardOfShareholders                 .stream()                 .limit(Seting.BOARD_OF_SHAREHOLDERS)                 .collect(Collectors.toList());          return boardOfShareholders;     }","VOTE_STOCK Как с помощью акций происходит голосование. Все акции которым счет владеет, приравниваются такому же количеству голосов. каждый раз когда кто то делает транзакцию на счет, который является адресом пакета который начинается с LIBER он голосует за данный пакет. Учитываются только те голоса, с которых не прошло больше четырех лет. если транзакция была совершена VoteEnum.YES то данный счет получает голоса за по формуле yesV = количество голосов равные количеству акций отправителя. yesN = за сколько законов данный счет проголосовал с VoteEnum.YES resultYES = yesV / yesN). Пример: счет проголосовал за три счета которые начинаются с LIBER, на счету сто акций, значит сто голосов. 100 / 3 = 33.3 значит каждый счет получит по 33.3 голоса.              если транзакция была совершена с VoteEnum.NO то используется такая же формула, но учитываются теперь все счета за которые он проголосовал против пример тот же счет проголосовал за два счет против, у него те же сто акций. resultNO = noV / noN = 50 = 50 значит каждый счет за который он проголосовал, против получит 50 голосов против. дальше каждый счет подсчитывает и суммирует все отданные ему голоса ЗА (VoteEnum.YES) и ПРОТИВ (VoteEnum.NO). Потом используется данная формула remainder = resultYES - resultNO. сначала данные должности отбираются все счета которые получили больше или равно одного голосов остатка (0) remainder >= 1. Дальше все счета сортируются по убыванию remainder и оттуда отбираются то количество счетов на данные должности, сколько это оговорено в данной должности. Для Совета Директоров это 301 счет с наибольшим количеством остатка.              В любой момент можно изменить свой голос, но только на противоположный, что значит если вы проголосовали за кандидата YES то вы можете изменить только на NO и обратно. Количество раз сколько вы можете изменить свой голос не ограничено. С каждым блоком происходит перерасчет голосов, если вы теряете свои акции, ваши кандидаты также теряют свои голоса. Данная мера специально так реализовано чтобы избираемые должности были заинтересованы в том чтобы вы процветали. Таким способом избираются Только CORPORATE_COUNCIL_OF_REFEREES и BOARD_OF_DIRECTORS Учитывается только последняя транзакция отданная за каждый счет, если вы не обновляли свой голос, то по прошествии четырех лет он аннулируется. Для Утверждения Закона нужно 100 тысяч голосов.","CODE_VOTE_STOCK class CurrentLawVotes method: votesLaw  public double votesLaw(Map<String, Account> balances, Map<String, Integer> yesAverage, Map<String, Integer> noAverage) {      \t\tdouble yes = 0.0;                     double no = 0.0;                                                      for (String s : YES) {                                      int count = 1;                        count = yesAverage.get(s) > 0 ? yesAverage.get(s) : 1;                        yes += balances.get(s).getDigitalStockBalance() /count;                                  }                                for (String s : NO) {                         int count = 1;                         count = noAverage.get(s) > 0 ? noAverage.get(s) : 1;                        no += balances.get(s).getDigitalStockBalance() / count;                                 }                                              return yes - no;                 } ","POWERS_OF_THE_CABINET_OF_DIRECTORS Полномочия Кабинета Директоров.  Директорами кабинета, называются высшие директора которые являются директорами своих дивизионов.  Полномочия каждого директора должны быть описаны действующими законами. Но каждый директор должен управлять  только своим дивизионом (пример: MEDIA_DIRECTOR руководит сми и его полномочия распространяются только на сми). Координацией всех директоров должен руководить Генеральный Исполнительный Директор GENERAL_EXECUTIVE_DIRECTOR.  Совет Директоров, CORPORATE_COUNCIL_OF_REFEREES, HIGH_JUDGE, Совет Акционеров и GENERAL_EXECUTIVE_DIRECTOR могут быть как физическими лицами, так и юридическими лицами, но один счет будет учитываться как один голос. ","HOW_CABINET_DIRECTORS_ARE_CHOSEN Все Директора Кабинета, это высшие директора которые управляют своими дивизионами, избираются только Советом Директоров. Каждый участник сети может подать на должность высшего директора, создав закон, с названием пакета который совпадает с допустимыми должностями, где адрес отправителя данной транзакции должен совпадать с первой строкой из списка законов данного пакета.  Стоимость закона пять цифровых долларов в качестве вознаграждения добытчику.  Счет с наибольшим количеством голосов остатка получает данную должность.  Механизм голосования описан ONE_VOTE.  Чтобы быть избранным советом директоров, должность должна получить не меньше 15 голосов (остатка голосов).        \t\tПример участка кода как избирается должности class LawsController: method currentLaw:                           //позиции созданные советом директоров                     List<CurrentLawVotesEndBalance> createdByBoardOfDirectors = current.stream()                           .filter(t->t.getPackageName().startsWith(Seting.ADD_DIRECTOR))                           .filter(t->t.getVotesBoardOfDirectors() >= Seting.ORIGINAL_LIMIT_MIN_VOTE_BOARD_OF_DIRECTORS)                           .collect(Collectors.toList());                     //добавление позиций созданных советом директоров                    for (CurrentLawVotesEndBalance currentLawVotesEndBalance : createdByBoardOfDirectors) {                         directors.addAllByBoardOfDirectors(currentLawVotesEndBalance.getLaws());                     }                                  //позиции избираемые только советом директоров                     List<CurrentLawVotesEndBalance> electedByBoardOfDirectors = current.stream()                            .filter(t -> directors.isElectedByBoardOfDirectors(t.getPackageName()) || directors.isCabinets(t.getPackageName()))                            .filter(t -> t.getVotesBoardOfDirectors() >= Seting.ORIGINAL_LIMIT_MIN_VOTE_BOARD_OF_DIRECTORS)                            .sorted(Comparator.comparing(CurrentLawVotesEndBalance::getVotesBoardOfDirectors).reversed())                            .collect(Collectors.toList());","ONE_VOTE ОДИН ГОЛОС. Когда голосуют данные должности, учитывается как один счет = один голос  (CORPORATE_COUNCIL_OF_REFEREES-Совет Корпоративных Судей,  BOARD_OF_DIRECTORS-Совет Директоров, GENERAL_EXECUTIVE_DIRECTOR-Генеральный Исполнительный Директор, HIGH_JUDGE-Верховный Судья и Совет Акционеров).   Каждый счет который начинается с LIBER, учитывает все голоса ЗА (VoteEnum.YES) и ПРОТИВ (VoteEnum.NO) за него  дальше отнимается от ЗА - ПРОТИВ = если остатков выше порога, то он становиться действующим законом. Но если избирается должности,  то после сортируется от наибольшего к наименьшим и отбираются то количество наибольших, которое описано для данной должности.  Перерасчет голосов происходит каждый блок.               После голосования голос можно поменять только на противоположный.  Ограничений на количество сколько раз можно поменять свой голос нет. Учитываются только те голоса которые даны счетами  находящимися в своей должности, к примеру если счет перестал быть в Совете Директор, его голос как в качестве  Совета Директоров не учитывается, и не будет учитываться в голосовании. Все голоса действуют, пока счета  проголосовавшие находятся в своих должностях. Учитываются также только те голоса, от которых прошло не более  четырех лет, но каждый участник, может в любой момент времени обновить свой голос.  ","CODE_VOTE_ONE КОД class CurrentLawVotes: method voteGovernment             public int voteGovernment(                    Map<String, Account> balances,                       List<String> governments) {                        int yes = 0;                        int no = 0;                                List<String> addressGovernment = governments;                   for (String s : YES) {                         if (addressGovernment.contains(s)) {                             yes += Seting.VOTE_GOVERNMENT;                        }                                 }                     for (String s : NO) {                       if (addressGovernment.contains(s)) {                             no += Seting.VOTE_GOVERNMENT;                        }                     }                    return yes - no;                } ","MECHANISM_FOR_REDUCING_THE_NUMBER_OF_SHARES МЕХАНИЗМ СНИЖЕНИЯ КОЛИЧЕСТВА АКЦИЙ.  Ввод штрафов. Каждый раз когда один счет отправляет на другой счет цифровую акцию, но использует VoteEnum.NO, счет  цифровых акций получателя снижается на то количество которое отправил отправитель акций.  Пример счет А отправил на счет Б 100 цифровых акций с VoteEnum.NO, тогда счет А и счет Б оба теряют 100  цифровых акций.  Данная мера нужна чтобы был механизм снять с должности Совета акционеров и также позволяет снижать голоса  деструктивных счетов, так как количество голосов, равно количеству акций, при Избрании Совета Директоров и  при избрании CORPORATE_COUNCIL_OF_REFEREES.   Данный механизм действует только на цифровые акции и только в том случае, что отправитель отправил с знаком VoteEnum.NO.","WHO_HAS_THE_RIGHT_TO_CREATE_LAWS то имеет Права Создавать Законы. Создавать законы в криптовалюте Корпорации Международный Торговый Союз имеют права  все участники сети, которые имеют минимум пять цифровых долларов.  Для создания закона через механизм криптовалюты Корпорации Международного торгового Союза  Нужно внутри данной криптовалюты Создать объект класса Laws, где packetLawName - является названием пакета законов. List<String> laws - является списком законов, String hashLaw - является адресом данного пакета законов и начинается с LIBER.  Чтобы Закон попал в пул законов нужно создать транзакцию где получателем является hashLaw данного закона и вознаграждение  майнера равно пять цифровых доллара (5)  данной криптовалюты. После этого как закон попадет в блок, он окажется в пуле законов и за него можно будет голосовать.  Количество строк в пакете законов может быть столько, сколько понадобиться и нет никаких ограничений.","POWERS_OF_THE_CORPORATE_COUNCIL_OF_JUDGES ПОЛНОМОЧИЯ КОРПОРАТИВНОГО СОВЕТА СУДЕЙ. Утверждает Верховного судью. Участвует в голосовании внедрения поправок.            Судебная власть Корпорации Международного Торгового Союза принадлежит одному Верховному суду и таким нижестоящим судам, которые Корпорация Международный  Торговый Союз может время от времени издавать и учреждать.  Судьи как верховных, так и нижестоящих судов занимают свои должности, при хорошем поведении и в установленные сроки получают за свои услуги вознаграждение.  Вознаграждение должно даваться с бюджета, установленными законами. Судебная власть распространяется на все дела по закону и справедливости,  в том числе инициированные членами для оспаривания незаконного расходования средств,  возникающего в соответствии с настоящем Уставом, законами Корпорации Международного Торгового Союза и договорами,  заключенными или которые будут заключены в соответствии с их авторитетом. К спорам, в которых Международный Торговый Союз будут стороной к разногласиям между двумя или более участников сети.  Ни один суд не должен быть тайным, но правосудие должно вершиться открыто и бесплатно, полностью и безотлагательно,  и каждый человек должен иметь правовую защиту от вреда, причиненного жизни, свободе или имуществу. Верховный Суд CORPORATE_COUNCIL_OF_REFEREES и верховный судья HIGH_JUDGE.","HOW_THE_CORPORATE_BOARD_OF_JUDGES_IS_ELECTED КАК ИЗБИРАЮТСЯ КОРПОРАТИВНЫЙ СОВЕТ СУДЕЙ.              CORPORATE_COUNCIL_OF_REFEREES состоит из 55 счетов. Каждый участник сети может подать на должность CORPORATE_COUNCIL_OF_REFEREES, создав пакет закона, где название пакета CORPORATE_COUNCIL_OF_REFEREES и счет отправителя должен совпадать счетом который указан в первой строке закона который содержится в списке данного пакета 55 счет с наибольшим количеством остатка голосов получает должность.              Стоимость подачи на создание закона(должность) стоит пять цифровых долларов (5) в качестве вознаграждения добытчику. Процесс голосования описан в VOTE_STOCK.                            Пример участка кода: class LawsController: method currentLaw:               //минимальное значение количество положительных голосов для того чтобы закон действовал,                  //позиции избираемые акциями CORPORATE_COUNCIL_OF_REFEREES                    List<CurrentLawVotesEndBalance> electedByStockCorporateCouncilOfReferees = current.stream()                             .filter(t -> directors.isElectedByStocks(t.getPackageName()))                             .filter(t -> t.getPackageName().equals(NamePOSITION.CORPORATE_COUNCIL_OF_REFEREES.toString()))                             .filter(t -> t.getVotes() >= Seting.ORIGINAL_LIMIT_MIN_VOTE)                             .sorted(Comparator.comparing(CurrentLawVotesEndBalance::getVotes).reversed())                             .limit(directors.getDirector(NamePOSITION.CORPORATE_COUNCIL_OF_REFEREES.toString()).getCount())                             .collect(Collectors.toList());","HOW_THE_CHIEF_JUDGE_IS_CHOSEN КАК ИЗБИРАЕТСЯ ВЕРХОВНЫЙ СУДЬЯ HIGH_JUDGE. Верховный Судья избирается CORPORATE_COUNCIL_OF_REFEREES.  Каждый участник сети может подать на должность Верховного Судьи, создав закон, с названием пакета который совпадает с допустимым  должностью, где адрес отправителя данной транзакции должен совпадать с первой строкой из списка законов данного пакета.  стоимость закона пять цифровых долларов в качестве вознаграждения добытчику.   счет с наибольшим количеством голосов остатка получает данную должность. Механизм голосования описан ONE_VOTE.                           Пример кода как утверждается верховный судья. class LawsController: method currentLaw. Участок кода                //позиции избираемые советом корпоративных верховных судей                     List<CurrentLawVotesEndBalance> electedByCorporateCouncilOfReferees = current.stream()                             .filter(t -> directors.isElectedBYCorporateCouncilOfReferees(t.getPackageName()))                             .filter(t -> t.getVotesCorporateCouncilOfReferees() >= Seting.ORIGINAL_LIMIT_MIN_VOTE_CORPORATE_COUNCIL_OF_REFEREES)                             .sorted(Comparator.comparing(CurrentLawVotesEndBalance::getVotesCorporateCouncilOfReferees)).collect(Collectors.toList());","POWERS_OF_THE_CHIEF_JUDGE ПОЛНОМОЧИЯ ВЕРХОВНОГО СУДЬИ. Верховный судья участвует в утверждении законов, а также  может участвовать в решении споров внутри членов сети, как и CORPORATE_COUNCIL_OF_REFEREES,  но его голос выше чем голос CORPORATE_COUNCIL_OF_REFEREES.","HOW_IS_THE_PROCESS_OF_AMENDING_THE_CHARTER КАК ПРОИСХОДИТ ПРОЦЕСС ВНЕСЕНИЯ ПОПРАВОК В УСТАВ. Для внесения поправок, нужно создать закон с названием пакета AMENDMENT_TO_THE_CHARTER,  дальше за этот закон должны проголосовать методом описанным в VOTE_ONE Совет Акционеров и остаток голосов должен быть равен или выше 300 участников, также должны проголосовать Совет Директоров и остаток голосов должен быть 60 или больше,  также должны проголосовать корпоративные верховные судьи (CORPORATE_COUNCIL_OF_REFEREES) и остаток голосов должен быть равен или больше 5. Но поправки не должны касаться способа установления правил действующих законов, а также  избрания Совета Директоров, Совета Акционеров, Генерального Исполнительного Директора,  Совета Корпоративных Судей и Верховного Судьи. Поправки могут изменять код, если сохраняются правила избрания действующих должностей (включая правил голосования), законов и добычи денег (добыча цифровых долларов и цифровых акции), Ни одна поправка не должна наделять из выше перечисленных должностей большей властью. Также поправки не должны ущемлять Естественные Права Человека.              \t\t Пример кода. class LawsController: method currentLaw: участок кода утверждающий действующие поправки             //внедрение поправок в устав                     List<CurrentLawVotesEndBalance> chapter_amendment = current.stream()                             .filter(t -> !directors.contains(t.getPackageName()))                             .filter(t-> Seting.AMENDMENT_TO_THE_CHARTER.equals(t.getPackageName()))                             .filter(t->!directors.isCabinets(t.getPackageName()))                             .filter(t -> t.getVotesBoardOfShareholders() >= Seting.ORIGINAL_LIMIT_MINT_VOTE_BOARD_OF_SHAREHOLDERS_AMENDMENT)                             .filter(t -> t.getVotesBoardOfDirectors() >= Seting.ORIGINAL_LIMIT_MIN_VOTE_BOARD_OF_DIRECTORS_AMENDMENT)                             .filter(t -> t.getVotesCorporateCouncilOfReferees() >= Seting.ORIGINAL_LIMIT_MIN_VOTE_CORPORATE_COUNCIL_OF_REFEREES_AMENDMENT)                             .sorted(Comparator.comparing(CurrentLawVotesEndBalance::getVotesBoardOfDirectors).reversed()).collect(Collectors.toList());","HOW_THE_BUDGET_IS_APPROVED КАК УТВЕРЖДАЕТСЯ БЮДЖЕТ.  Действующий бюджет может быть только один. Бюджет утверждает только Совет Директоров.  Для утверждения бюджета нужно получить методом описанным в VOTE_ONE 15 и больше голосов.  Сам процесс происходит так: 1. Сначала отбираются все пакеты законов, где название пакета совпадает с BUDGET.  2. Дальше отбираются все пакеты которые остаток голосов получили 15 или больше.  3. Дальше все эти пакеты сортируются по убыванию, с наибольшим количеством голосов.  4. Дальше отбирается самый первый с наибольшим количеством голосов.                           Пример кода утверждающий бюджет. class LawsController: method: currentLaw.                 //бюджет утверждается только советом директоров.                     List<CurrentLawVotesEndBalance> budjet = current.stream()                             .filter(t-> !directors.contains(t.getPackageName()))                             .filter(t->Seting.BUDGET.equals(t.getPackageName()))                             .filter(t->!directors.isCabinets(t.getPackageName()))                             .filter(t-> t.getVotesBoardOfDirectors() >= Seting.ORIGINAL_LIMIT_MIN_VOTE_BOARD_OF_DIRECTORS)                             .sorted(Comparator.comparing(CurrentLawVotesEndBalance::getVotesBoardOfDirectors).reversed())                             .limit(1)                             .collect(Collectors.toList());","HOW_IS_THE_STRATEGIC Стратегический план утверждает Совет Директоров, стратегический план может быть действующим  только в единственном экземпляре. Чтобы Стратегический План был действующим, нужно остаток голосов  Совета Директоров 15 или больше. Способ голосования VOTE_ONE.               Совет Директоров в любой момент может отменить Стратегический План. Стратегический План действует  пока количество голосов 15 или больше. Стратегический План может включать в себя общее направление  Корпорации, а также что нужно реализовать.               Участок кода который показывает как утверждается Стратегический План.    \t\tclass LawsController: method currentLaw:                                  //план утверждается только палатой Советом Директоров                     List<CurrentLawVotesEndBalance> planFourYears = current.stream()                             .filter(t->!directors.contains(t.getPackageName()))                             .filter(t->Seting.STRATEGIC_PLAN.equals(t.getPackageName()))                             .filter(t->!directors.isCabinets(t.getPackageName()))                             .filter(t->t.getVotesBoardOfDirectors() >= Seting.ORIGINAL_LIMIT_MIN_VOTE_BOARD_OF_DIRECTORS)                             .sorted(Comparator.comparing(CurrentLawVotesEndBalance::getVotesBoardOfDirectors).reversed())                             .limit(1)                             .collect(Collectors.toList());","HOW_NEW_POSITIONS_ARE_ADDED Таким способом добавляются только высшее руководство, подчиненные каждого руководителя  нанимают без использования блокчейна, их может нанять сам директор, или иным способом как  описано действующими законами. Высшее руководство добавляется в список class Directors.  Все новые добавленные должности действуют пока их законы, которые создают, данные должности действуют.               Добавлять новые должности может только Совет директоров.  Каждый пакет законов который начинается с ADD_DIRECTOR, определяется как добавление должности. Список законов который находиться внутри данного пакета являются должностями если название в  строке начинается с ADD_DIRECTOR.              Пример: название пакета ADD_DIRECTOR_PACKAGE название первой третьей и четвертой строки ADD_DIRECTOR_FIRST ADD_DIRECTOR_THIRD  ADD_DIRECTOR_FOUR таким образом будет созданы три места для должности.               Но если строка начинается с ADD_DIRECTOR, то название должности должно быть большими  буквами и нижними подчеркиваниями, так же в одной строке должна быть только одна должность  и больше никаких слов.              Те строки, где нет добавления должности (ADD_DIRECTOR), используются для описания  полномочий добавленных должностей.               Чтобы новые должности были добавлены в список, Совет Директоров должен проголосовать методом  VOTE_ONE 15 или больше голосов.  После как новые должности будут созданы, каждый участник сети сможет подавать себя на данные должности.              class LawsController: method currentLaw:                                                //добавляет законы, которые создают новые должности директоров                     List<CurrentLawVotesEndBalance> addDirectors = current.stream()                            .filter(t->t.getPackageName().startsWith(Seting.ADD_DIRECTOR))                            .filter(t->t.getVotesBoardOfDirectors() >= Seting.ORIGINAL_LIMIT_MIN_VOTE_BOARD_OF_DIRECTORS)                            .collect(Collectors.toList());","PROPERTY_OF_THE_CORPORATION СОБСТВЕННОСТЬ КОРПОРАЦИИ. Вся собственность которая принадлежит Корпорации Международного Торгового Союза, не может быть продана без действующего закона,  где будет описан процесс продажи и по какой стоимости будет продана собственность. Счет основателя, и счета других участников не является счетом корпорации, Совет Директоров должен создать отдельный счет который будет бюджетом и управляться только членами действующих членов Совета Директоров.","INTERNET_STORE_DIRECTOR Директор интернет магазина Данный директор занимается разработкой, продвижением и руководством интернет магазина, в котором должны  продаваться товары за цифровой доллар или цифровые акции.  Детальные полномочия должны быть даны или через действующие законы или  выданы Генеральным исполнительным директором или Советом Директоров.  Название Магазина должен определить либо Совет Директоров или Генеральный Исполнительный Директор.","GENERAL_EXECUTIVE_DIRECTOR Генеральный Исполнительный директор Данный Директор координирует действия остальных высших директоров для реализации стратегического плана или  поставленных перед ним задач действующими законами.  Все полномочия должны быть ему выданы через действующие законы.  Это самая высокая должность избираемая Корпорацией и является по своей сути аналогом премьер-министра.","DIRECTOR_OF_THE_DIGITAL_EXCHANGE Директор Цифровой биржи Данный Директор занимается разработкой, продвижением и руководством интернет биржи. Полномочия должны быть выданы ему или действующими законами,  или Советом Директоров, или Генеральным Исполнительным Директором.","DIRECTOR_OF_DIGITAL_BANK Директор Цифрового  банка Данный Директор руководит интернет банком. Все полномочия должны быть выданы  или действующими законами, или Советом директоров, или Генеральным Исполнительным Директором.","DIRECTOR_OF_THE_COMMERCIAL_COURT Директор частного коммерческого суда  Должен обеспечивать руководство частным судам, все полномочия  должны быть Выданы или действующими законами, или Советом Директоров,  или Генеральным Исполнительным Директором.   В данных судах судьями могут быть как члены Совета Верховных Судей (CORPORATE_COUNCIL_OF_REFEREES) так и Верховный Судья, или ниже стоящие судьи избранные CORPORATE_COUNCIL_OF_REFEREES. ","MEDIA_DIRECTOR Директор СМИ Данный Директор руководит СМИ, все полномочия должны быть выданы действующими законами,  или, Советом Директоров или генеральным исполнительным Директором.              Данный Директор занимается руководством СМИ принадлежащих непосредственно Корпорации Международного Торгового Союза. ","DIRECTOR_OF_THE_DEVELOPMENT_OF_THE_IMPLEMENTATION_OF_CRYPTOCURRENCY_TECHNOLOGIES_OF_THE_INTERNATIONAL_TRADE_UNION_CORPORATION  Данный Директор руководит разработкой и внедрением нового кода в данную криптовалюту, все полномочия должны быть выданы только через  действующие законы, но также могут быть выданы или Советом Директоров, если действующие законы дали такие полномочия Совету Директоров.  Также ни одно изменение кода не должно противоречить действующему уставу или действующим законам, Также полномочия могут быть выданы Генеральным Исполнительным Директором, если генеральному исполнительному директору данные полномочия выданы действующим законами.","EXPLANATION_WHY_MONEY_DEMURAGE_IS_USED_HERE ОБЯСНЕНИЕ ПОЧЕМУ ЗДЕСЬ ИСПОЛЬЗУЕТСЯ  ДЕМЕРЕДЖ ДЕНЕГ Отрицательная ставка сейчас применяется во множестве стран, данная мера стимулирует держателей денег, когда цена чрезмерно завышена,  насыщать рынок деньгами. Количество добываемых денег за каждый блок составляет 200 цифровых долларов и 200 цифровых акций,  также 2% от каждой добычи вознаграждение основателю, что составляет 4 цифровых доллара и 4 цифровых Акций при каждой добыче блока.  Здесь используется как Теории Сильвио Гезеля, а также школы монетаризма в измененном виде.              У Сильвио Гезеля, отрицательная ставка составляла 1% в месяц, что просто убило бы экономику, при монетаризме рост, денежной массы должен был быть пропорционален росту ВВП, но так как в данной системе не получиться посчитать реальный рост ВВП, я установил фиксированный рост, также если денежный рост  будет равен ВВП, есть высокая вероятность Гиперинфляции, так как ВВП не всегда отражает реальный экономический рост.  Деньги должны быть твердые, чтобы бизнес мог прогнозировать свои долгосрочные вложения и от монетаризма, взята только та часть что  денежная масса должна расти линейно, но в целом здесь микс из разных экономических школ, включая Австрийскую экономическую школу.               При отрицательной ставке 0.1% каждые пол года для цифровых долларов и 0.2% для цифровых акций мы избегаем последствий тяжелого экономического кризиса для данной валюты.               Такой механизм создает коридор цен, где нижняя граница стоимости данных цифровых валют является общее количество выпущенных цифровых  долларов и цифровых акций, а верхняя граница является реальная стоимость. Так как только стоимость становиться выше реальной стоимости,  держателям выгодней становиться продавать цифровые доллары и цифровые акции, по завышенным ценам, тем самым насыщая рынок деньгами  и создавая коррекцию на рынке.               Основным источником монетарных кризисов, является быстрыми изменениями цен на товары и медленным изменением заработных плат.  Пример: Представим что стоимость валюты резко подорожало на 30%, держателям выгодней становиться не инвестировать деньги, так как  доходы от удерживания валюты, выше чем теперь уже оплачивать более дорогих сотрудников, из-за того деньги перестают  инвестироваться. Люди не дополучают заработные платы, что приводит к тому, что огромное количество товаров не реализуется,  и это приводит к тому, часть производителей банкротится и увольняют множество рабочих, что еще больше снижает заработную  плату у оставшихся, так как становиться профицитный рынок труда.         Что в свою очередь еще больше вызывает страх у держателей денег инвестировать и данный процесс продолжается до того момента,  пока стоимость денег не начинает сокращаться в связи с тем что общее количество производственных цепочек сократилось и также сократились товары.              Пример: Представим что у нас произошла инфляция и стоимость денег упала на 40% в течение месяца, стоимость товаров резко возрастает, но заработные платы не выросли, таким образом множество товаров не будут куплены, что приводит к закрытию производственных цепочек, что в свою очередь из-за избытка рабочих на рынке труда, снижает заработную плату, что также в свою очередь еще больше сокращает  количество проданных товаров. Первый случай Дефляционная спираль возникает из-за резкого сокращения денег на рынке, второй  случай стагфляция чаще возникает когда на рынок поступает резко избыточное количество денег.  И это оба явления две стороны одной медали, в одном случае мы получаем дефляционную спираль в другом стагфляцию.                         Чтобы не возникали такие кризисы, в данной криптовалюте деньги прирастают в одинаковом предсказуемом количестве.  204 (4 - вознаграждение основателю, 200 - вознаграждение добытчику) цифровых долларов и акций за блок, в сутках около 576 блоков. А отрицательная ставка корректирует стоимость монет каждые пол года.  Также запрещено использовать частичное банковское резервирование для данных монет, так как их количество растет линейно, и  не сможет покрыть долги возникшие из-за частичного банковского резервирования, в связи отсутствия с недостатком  наличности, так как при частичном банковском резервировании рост долгов будет намного выше, чем данный протокол будет создавать денег.   Также если увеличить денежную массу изменив настройки, и сделав прирост денежной массы значительно выше, может вызвать гиперинфляцию или  даже галопирующую инфляцию. Если нужно будет увеличить прирост денежной массы это должно происходить только через внесения поправок, сохраняя процент вознаграждения основателя в двух процентах. И добыча за блок не должна увеличиваться больше 5% в течение десяти лет, каждое следующее увеличение которое может вноситься должно проходить не менее десяти лет через поправки,  и не более 5% за блок от вознаграждения последнего блока. (Пример: если мы изменили через поправки, то добыча не должна быть выше 210 монет, но каждые следующие будет не больше пяти процентов от последнего.  Таким образом следующее увеличение внесенное через поправки составит 220.5 монет. Но Эту поправку внесут только через десять лет после первой поправки по изменению добычи)              При недостатке денежной массы, если не было изменено количество добываемых монет через поправку, можно добавить несколько  дополнительных нулей после запятой, таким образом это просто увеличит ценность монет, без увелечения общей выпущенной денежной массы.              Отрицательные ставки не должны быть выше 0.5% годовых и ниже 0.2% годовых. Отрицательные ставки можно изменять только через внесения поправок.","FREEDOM_OF_SPEECH Ни один орган данной корпорации или субъект не должен запрещать свободное исповедание  какой-либо религии; или ограничивать свободу слова, совести или печати или право людей мирно собираться или объединяться друг с другом, или не объединяться друг с другом, и  обращаться к руководству Корпорации Международного Торгового Союза и к данной корпорации с ходатайством об удовлетворении жалоб;  или нарушать право на плоды своего труда или право на мирную жизнь по своему выбору.  Свободы слова и совести включают свободу вносить вклад в политические кампании или кандидатуры на корпоративные должности и должны толковаться как  распространяющиеся в равной степени на любые средства коммуникации.","RIGHTS Естественные Права Все члены сети, должны соблюдать Естественные Права Человека и не нарушать их.  Также должно соблюдаться презумпция невиновности и каждый участник сети должен иметь права на честное независимое  судебное разбирательство.  Каждый участник имеет права на адвоката или быть самому себе адвокатом.              Корпорация Международный Торговый Союз не должна регулировать стоимость товаров и услуг участников сети, которые  продают через данную платформу. Также Корпорация не должна запрещать отдельные бренды на своей площадке, но может  запрещать продавать целые группы товаров, которые попадают по характеристикам описанных действующими законами, если  этот запрет не нарушает Естественные Права Человека. В качестве источника прав можно брать  в качестве прецедента Страны признанные демократическими странами.                Детальный список есть в Организации Объединенных Наций (ООН)              Право на жизнь Право на свободу и личную неприкосновенность Право на неприкосновенность частной жизни Право определять и указывать свою национальную принадлежность Право на пользование родным языком Право на свободу передвижения и выбора места пребывания и жительства Право на свободу совести              Свобода мысли и слова Свобода информации Право на создание общественных объединений Право на проведение публичных мероприятий Право на участие в управлении делами Корпорации Международного Торгового Союза Право на обращение в органы Корпорации Международного Торгового Союза и органы местного самоуправления. К числу естественных неотчуждаемых прав человека относят право на жизнь, свободу, безопасность, собственность, физическую и психическую неприкосновенность, достоинство личности, личную и семейную тайну и т. п.              Ни один действующий закон не должен интерпретироваться так, чтобы нарушать естественные права человека.  Корпоративный верховный суд может использовать прецеденты в качестве судебных решений, если эти решения не противоречат  действующему уставу и действующим законам. Корпоративный Верховный Суд может создавать прецеденты аналогичные странам с прецедентным правом, но применять можно если эти прецеденты не нарушают действующий устав или действующие законы Корпорации Международного Торгового Союза. ","POWERS_OF_THE_BOARD_OF_DIRECTORS The Board of Directors can approve invoices that have applied for positions on the Directors list. Also Laws package names start with ADD_DIRECTOR, are packages that contain a list of new directors. This list should drive new product lines.   These Laws can only be approved by the Board of Directors and from there they will take a list of laws where every line that starts with ADD_DIRECTOR will be added to the Directors list as a new line positions. List of DIRECTORS that can be filed.  A package that starts with BUDGET is a budget and can only be approved by the Board of Directors There can be only one current budget.              The Board of Directors also approves the STRATEGIC_PLAN. Only valid one strategic plan.              The board of directors also participates in the approval of laws (rules on which all members of the corporation), and also participates in the approval of the implementation of amendments to the charter AMENDMENT_TO_THE_CHARTER.              The Council has the right to set and collect a commission from sales within the platforms owned by the Corporation of the International Trade Union, provided that this commission will not exceed twenty percent (20%). All fees must be allocated to expenses that are established by the budget. Also, a source of income is the sale of their goods and services, for this there are Office Directors who are elected Board of Directors and they must sell the products of the Corporation of the International Trade Union.","HOW_LAWS_ARE_CHOSEN No laws are retroactive. No law shall violate the existing statute or be inconsistent with other applicable laws. If there is a contradiction between several laws from one set of laws, then the current one is the one that is higher in the index. Example: alcohol sales package the law under index 3 contradicts the law from index 17, in this case the law under index three will be valid, because he is higher in status.            If the laws contradict from different packages, then the package that received the most votes is valid. from the Board of Shareholders, if there is parity, then the one that received more votes from the Board of Directors, if here too there is parity, then the dispute must be decided by the Chief Justice, if he also did not determine which of the two packages where the laws contradict each other, if the laws of one of the packages are more effective, then the priority becomes the one that began to operate earlier, the countdown is determined precisely from the last moment of entry into force.             All ordinary laws are valid if they are voted in this way ONE_VOTE The Board of Shareholders, the Board of Directors and possibly Supreme Judge.  For a law to be valid, it must receive equal to or more than 100 of the remaining votes of the Board of Shareholders, equal to or greater than 15 remaining votes of the Board of Directors and One vote of the Chief Justice, but if the Chief Justice did not vote or voted against then it is possible to override the veto of the supreme judge by obtaining 200 or more of the remainder of the votes of the Board of Shareholders and 30 or more of the remainder of the votes of the Board of Directors.             or if the law received more than 100 thousand remainder votes as described by VOTE_STOCK is also in force, and will act while retaining more than one hundred thousand votes. A law is valid as long as it matches the number of votes as described above. Every time someone loses their position all his votes for all the laws he voted are also lost, but the votes received with the help of shares are not lost.","HOW_THE_BOARD_OF_DIRECTORS_IS_ELECTED How the Board of Directors is elected.  The Board of Directors consists of 301 BOARD_OF_DIRECTORS accounts. Each member of the network can apply for the position of the board of directors by creating a package of law, where the package name BOARD_OF_DIRECTORS and the sender's account must match the account specified in the first line of the law which is contained in the list of this package. The 301 account with the most remaining votes receives the position. The cost of filing for the creation of a law (position) is worth five digital dollars (5) as a reward to the earner. The voting process is described in VOTE_STOCK.","POWERS_OF_THE_BOARD_OF_SHAREHOLDERS Powers of the board of shareholders. The Council of Shareholders Participates in the approval of the Laws (network rules that all members of this Corporation must comply with). The Council of Shareholders also participates in the approval of amendments to the charter of the Corporation of the International Trade Union AMENDMENT_TO_THE_CHARTER. The Council of Shareholders can also participate in voting when electing candidates CORPORATE_COUNCIL_OF_REFEREES and BOARD_OF_DIRECTORS using these rules for voting for VOTE_STOCK candidates.","HOW_SHAREHOLDERS_BOARD_IS_ELECTED OriginalCHARTER.HOW_SHAREHOLDERS_BOARD_IS_ELECTED: HOW SHAREHOLDERS ARE ELECTED. The Board of Shareholders consists of one thousand five hundred accounts (1500) with the largest number of shares, but only those accounts are taken into account from whose activity more than a year has not passed (Activity is mining or sending money, creating a law, sending fines, Applying for a position and Creating a new position). formula: the current year is one year, and if the account was active in this range, it is taken into account. All accounts are sorted in descending order of the number of digital shares, and 1500 accounts with the most shares are selected. Recalculation occurs every block. An example of a section of code how the Board of Shareholders is elected:  //determining the board of shareholders      public static List<Account> findBoardOfShareholders(Map<String, Account> balances, List<Block> blocks, int limit) {          List<Block> minersHaveMoreStock = null;          if (blocks.size() > limit) {              minersHaveMoreStock = blocks.subList(blocks.size() - limit, blocks.size());          } else {              minersHaveMoreStock = blocks;          }          List<Account> boardAccounts = minersHaveMoreStock.stream().map(                          t -> new Account(t.getMinerAddress(), 0, 0))                  .collect(Collectors.toList());           for (Block block : minersHaveMoreStock) {              for (DtoTransaction dtoTransaction : block.getDtoTransactions()) {                  boardAccounts.add(new Account(dtoTransaction.getSender(), 0, 0));              }           }            CompareObject compareObject = new CompareObject();           List<Account> boardOfShareholders = balances.entrySet().stream()                  .filter(t -> boardAccounts.contains(t.getValue()))                  .map(t -> t.getValue()).collect(Collectors.toList());            boardOfShareholders = boardOfShareholders                  .stream()                  .filter(t -> !t.getAccount().startsWith(Seting.NAME_LAW_ADDRESS_START))                  .filter(t -> t.getDigitalStockBalance() > 0)                  .sorted(Comparator.comparing(Account::getDigitalStockBalance).reversed())                  .collect(Collectors.toList());           boardOfShareholders = boardOfShareholders                  .stream()                  .limit(Setting.BOARD_OF_SHAREHOLDERS)                  .collect(Collectors.toList());           return boardOfShareholders;      }","VOTE_STOCK How shares are voted. All shares held by the account are equal to the same number of votes. every time someone makes a transaction to an account that is the address of a batch that starts with LIBER, they vote for that batch. Only those votes from which no more than four years have passed are taken into account. if the transaction was made VoteEnum.YES then this account receives votes for according to the formula yesV = number of votes equal to the number of shares of the sender. yesN = how many laws this account voted for with VoteEnum.YES resultYES = yesV / yesN). Example: an account voted for three accounts that start with LIBER, there are 100 shares in the account, which means 100 votes. 100 / 3 = 33.3 means each account will receive 33.3 votes.              if the transaction was made with VoteEnum.NO then the same formula is used, but now all accounts for which he voted against are taken into account. example, the same account voted for two against, he has the same one hundred shares. resultNO = noV / noN = 50 = 50 means every bill he voted against will get 50 votes against. then each score counts and sums up all votes given to it FOR (VoteEnum.YES) and AGAINST (VoteEnum.NO). Then this formula is used remainder = resultYES - resultNO. first, these positions are selected all accounts that received more than or equal to one vote of the remainder (0) remainder >= 1. Then all accounts are sorted in descending order by remainder and from there the number of accounts for these positions is selected, as specified in this position. For the Board of Directors, this is the 301 accounts with the most balances.              At any time, you can change your vote, but only to the opposite, which means if you voted for a YES candidate, you can only change to NO and vice versa. The number of times you can change your voice is not limited. With each block there is a recalculation of votes, if you lose your shares, your candidates also lose their votes. This measure is specifically implemented so that the elected positions are interested in you to prosper. Only CORPORATE_COUNCIL_OF_REFEREES and BOARD_OF_DIRECTORS are elected in this way. Only the last transaction given for each account is taken into account, if you have not renewed your vote, then after four years it will be canceled. 100,000 votes are needed to approve the Law.","CODE_VOTE_STOCK class CurrentLawVotes method: votesLaw public double votesLaw(Map<String, Account> balances, Map<String, Integer> yesAverage, Map<String, Integer> noAverage) {       double yes = 0.0;                      double no = 0.0;                                                       for (String s : YES) {                                       int count = 1;                         count = yesAverage.get(s) > 0 ? yesAverage.get(s) : 1;                         yes += balances.get(s).getDigitalStockBalance() /count;                                   }                                 for (String s : NO) {                          int count = 1;                          count = noAverage.get(s) > 0 ? noAverage.get(s) : 1;                         no += balances.get(s).getDigitalStockBalance() / count;                                  }                                               return yes - no;                  }","POWERS_OF_THE_CABINET_OF_DIRECTORS Powers of the Cabinet of Directors. Cabinet directors are senior directors who are directors of their divisions. The powers of each director must be described by applicable law. But every director must manage only its own division (example: MEDIA_DIRECTOR manages the media and its powers apply only to the media). The coordination of all directors must be led by the General Executive Director GENERAL_EXECUTIVE_DIRECTOR.  Board of Directors, CORPORATE_COUNCIL_OF_REFEREES, HIGH_JUDGE, Board of Shareholders and GENERAL_EXECUTIVE_DIRECTOR can be either individuals and legal entities, but one account will be counted as one vote.","HOW_CABINET_DIRECTORS_ARE_CHOSEN All Cabinet Directors are the top directors who manage their divisions, elected only by the Board of Directors. Each member of the network can apply for the position of supreme director by creating a law with a package name that matches the allowed positions, where the address of the sender of this transaction must match the first line from the list of laws of this package. The cost of the law is five digital dollars as a reward to the earner. The account with the most remaining votes receives the position. The voting mechanism is described by ONE_VOTE. To be elected by the board of directors, a position must receive at least 15 votes (the remainder of the votes).        An example of a code section of how positions are elected class LawsController: method currentLaw:                            //positions created by the board of directors                      List<CurrentLawVotesEndBalance> createdByBoardOfDirectors = current.stream()                            .filter(t->t.getPackageName().startsWith(Seting.ADD_DIRECTOR))                            .filter(t->t.getVotesBoardOfDirectors() >= Seting.ORIGINAL_LIMIT_MIN_VOTE_BOARD_OF_DIRECTORS)                            .collect(Collectors.toList());                      //adding positions created by the board of directors                     for (CurrentLawVotesEndBalance currentLawVotesEndBalance : createdByBoardOfDirectors) {                          directors.addAllByBoardOfDirectors(currentLawVotesEndBalance.getLaws());                      }                                   //positions elected only by the board of directors                      List<CurrentLawVotesEndBalance> electedByBoardOfDirectors = current.stream()                             .filter(t -> directors.isElectedByBoardOfDirectors(t.getPackageName()) || directors.isCabinets(t.getPackageName()))                             .filter(t -> t.getVotesBoardOfDirectors() >= Seting.ORIGINAL_LIMIT_MIN_VOTE_BOARD_OF_DIRECTORS)                             .sorted(Comparator.comparing(CurrentLawVotesEndBalance::getVotesBoardOfDirectors).reversed())                             .collect(Collectors.toList());","ONE_VOTE ONE VOTE. When these positions are voted count as one score = one vote (CORPORATE_COUNCIL_OF_REFEREES-Council of Corporate Judges, BOARD_OF_DIRECTORS-Board of Directors, GENERAL_EXECUTIVE_DIRECTOR-General Executive Director, HIGH_JUDGE - Supreme Judge and Board of Shareholders).  Each score that starts with LIBER counts all votes FOR (VoteEnum.YES) and AGAINST (VoteEnum.NO) for it further deducted from FOR - AGAINST = if the balances are above the threshold, then it becomes the current law. But if a position is elected, then after that it is sorted from largest to smallest and the largest number that is described for this position is selected. Recalculation of votes occurs every block.              After voting, the vote can only be changed to the opposite one. There is no limit on the number of times you can change your voice. Only those votes that are given by accounts are taken into account in office, for example, if the account ceases to be on the Board of Directors, his vote as The Board of Directors does not, and will not, count in voting. All votes are valid until the bills voters are in their positions. Only those votes from which no more than four years, but each participant may at any time renew their vote.","CODE_VOTE_ONE CODE class CurrentLawVotes: method voteGovernment             public int voteGovernment(                    Map<String, Account> balances,                       List<String> governments) {                        int yes = 0;                        int no = 0;                                List<String> addressGovernment = governments;                   for (String s : YES) {                         if (addressGovernment.contains(s)) {                             yes += Seting.VOTE_GOVERNMENT;                        }                                 }                     for (String s : NO) {                       if (addressGovernment.contains(s)) {                             no += Seting.VOTE_GOVERNMENT;                        }                     }                    return yes - no;                } ","MECHANISM_FOR_REDUCING_THE_NUMBER_OF_SHARES Entering penalties. Every time one account sends a digital share to another account but uses VoteEnum.NO, the account recipient's digital shares are reduced by the amount sent by the share sender. Example account A sent to account B 100 digital shares with VoteEnum.NO, then account A and account B both lose 100 digital shares. This measure is needed so that there is a mechanism to dismiss the Board of Shareholders and also allows you to lower your votes destructive accounts, since the number of votes is equal to the number of shares in the Election of the Board of Directors and when electing CORPORATE_COUNCIL_OF_REFEREES.   This mechanism works only for digital shares and only if the sender sent with the sign VoteEnum.NO.","WHO_HAS_THE_RIGHT_TO_CREATE_LAWS then has the Right to Create Laws. Create Laws in Cryptocurrency International Trade Union Corporations Have the Rights all network members who have at least five digital dollars. To create law through the International Trade Union Corporation's cryptocurrency mechanism It is necessary to create an object of the Laws class inside this cryptocurrency, where packetLawName is the name of the law package. List<String> laws - is a list of laws, String hashLaw - is the address of this package of laws and starts with LIBER. For a law to be included in the pool of laws, you need to create a transaction where the recipient is the hashLaw of this law and the reward miner is equal to five digital dollars (5) of this cryptocurrency. After that, once the law gets into the block, it will be in the pool of laws and it will be possible to vote for it. The number of lines in a package of laws can be as many as needed and there are no restrictions.","POWERS_OF_THE_CORPORATE_COUNCIL_OF_JUDGES POWERS OF THE CORPORATE COUNCIL OF JUDGES. Approves the Chief Justice. Participates in the voting on the introduction of amendments.           The judicial power of the International Trade Union Corporation is vested in one Supreme Court and such inferior courts as the Corporation International The Merchant Union may issue and establish from time to time. Judges of both the supreme and inferior courts hold their offices, with good conduct and in due time receive remuneration for their services. Remuneration must be given from the budget established by laws. Judicial power extends to all cases of law and justice, including those initiated by members to challenge the misappropriation of funds, arising under these Articles, the laws of the International Trade Union Corporation and treaties, imprisoned or to be imprisoned according to their authority. Disputes in which the International Trade Union will be party to a dispute between two or more members of the network. No judgment shall be secret, but justice shall be administered openly and free of charge, completely and without delay, and every person shall have legal protection against injury to life, liberty, or property. Supreme Court CORPORATE_COUNCIL_OF_REFEREES and Chief Justice HIGH_JUDGE.","HOW_THE_CORPORATE_BOARD_OF_JUDGES_IS_ELECTED HOW THE CORPORATE BOARD OF JUDGES IS ELECTED.              CORPORATE_COUNCIL_OF_REFEREES consists of 55 accounts. Each network member can apply for the CORPORATE_COUNCIL_OF_REFEREES position, by creating a law package where the package name CORPORATE_COUNCIL_OF_REFEREES and the sender's account must match the account which is indicated in the first line of the law which is contained in the list of this package The 55th score with the most remaining votes wins the office.              The cost of filing for the creation of a law (position) is worth five digital dollars (5) as a reward to the earner. The voting process is described in VOTE_STOCK.                            Code snippet example: class LawsController: method currentLaw:               //minimum value for the number of positive votes for the law to be valid,                   //positions elected by shares CORPORATE_COUNCIL_OF_REFEREES                     List<CurrentLawVotesEndBalance> electedByStockCorporateCouncilOfReferees = current.stream()                              .filter(t -> directors.isElectedByStocks(t.getPackageName()))                              .filter(t -> t.getPackageName().equals(NamePOSITION.CORPORATE_COUNCIL_OF_REFEREES.toString()))                              .filter(t -> t.getVotes() >= Seting.ORIGINAL_LIMIT_MIN_VOTE)                              .sorted(Comparator.comparing(CurrentLawVotesEndBalance::getVotes).reversed())                              .limit(directors.getDirector(NamePOSITION.CORPORATE_COUNCIL_OF_REFEREES.toString()).getCount())                              .collect(Collectors.toList());","HOW_THE_CHIEF_JUDGE_IS_CHOSEN HOW HIGH_JUDGE IS CHOSEN. The Chief Justice is elected by CORPORATE_COUNCIL_OF_REFEREES. Each member of the network can apply for the position of Chief Justice by creating a law with a package name that matches the allowed position, where the address of the sender of this transaction must match the first line from the list of laws of this package. the cost of the law is five digital dollars as a reward to the earner. the score with the most remainder votes wins the position. The voting mechanism is described by ONE_VOTE.                           Sample code as stated by the supreme judge. class LawsController: method currentLaw. Code section                 //positions elected by the board of corporate chief judges                      List<CurrentLawVotesEndBalance> electedByCorporateCouncilOfReferees = current.stream()                              .filter(t -> directors.isElectedBYCorporateCouncilOfReferees(t.getPackageName()))                              .filter(t -> t.getVotesCorporateCouncilOfReferees() >= Seting.ORIGINAL_LIMIT_MIN_VOTE_CORPORATE_COUNCIL_OF_REFEREES)                              .sorted(Comparator.comparing(CurrentLawVotesEndBalance::getVotesCorporateCouncilOfReferees)).collect(Collectors.toList());","POWERS_OF_THE_CHIEF_JUDGE THE POWERS OF THE CHIP JUDGE. The Chief Justice participates in the approval of laws, as well as can participate in resolving disputes within network members, like CORPORATE_COUNCIL_OF_REFEREES, but his vote is higher than that of CORPORATE_COUNCIL_OF_REFEREES.","HOW_IS_THE_PROCESS_OF_AMENDING_THE_CHARTER HOW IS THE CHARTER AMENDING PROCESS. To amend, you need to create a law with the package name AMENDMENT_TO_THE_CHARTER, further this law must be voted by the method described in VOTE_ONE Board of Shareholders and the balance of votes must be equal to or greater than 300 members, the Board of Directors must also vote and the balance of votes must be 60 or more, corporate chief judges must also vote (CORPORATE_COUNCIL_OF_REFEREES) and The remainder of the votes must be equal to or greater than 5. But amendments should not concern the way in which the rules of existing laws are established, as well as election of the Board of Directors, Board of Shareholders, General Executive Director, Council of Corporate Judges and Chief Justice. Amendments can change the code if the rules are kept electing current positions (including voting rules), laws and money mining (mining digital dollars and digital stocks), No amendment should give any of the above positions more power. Also, the amendments must not infringe upon the Natural Rights of Man.             Code example. class LawsController: method currentLaw: section of code that approves current amendments              //introduction of amendments to the charter                      List<CurrentLawVotesEndBalance> chapter_amendment = current.stream()                              .filter(t -> !directors.contains(t.getPackageName()))                              .filter(t-> Seting.AMENDMENT_TO_THE_CHARTER.equals(t.getPackageName()))                              .filter(t->!directors.isCabinets(t.getPackageName()))                              .filter(t -> t.getVotesBoardOfShareholders() >= Seting.ORIGINAL_LIMIT_MINT_VOTE_BOARD_OF_SHAREHOLDERS_AMENDMENT)                              .filter(t -> t.getVotesBoardOfDirectors() >= Seting.ORIGINAL_LIMIT_MIN_VOTE_BOARD_OF_DIRECTORS_AMENDMENT)                              .filter(t -> t.getVotesCorporateCouncilOfReferees() >= Seting.ORIGINAL_LIMIT_MIN_VOTE_CORPORATE_COUNCIL_OF_REFEREES_AMENDMENT)                              .sorted(Comparator.comparing(CurrentLawVotesEndBalance::getVotesBoardOfDirectors).reversed()).collect(Collectors.toList());","HOW_THE_BUDGET_IS_APPROVED HOW THE BUDGET IS APPROVED. There can be only one current budget. The budget is approved only by the Board of Directors. To approve the budget, you need to get the method described in VOTE_ONE 15 or more votes. The process itself goes like this: 1. First, all packages of laws are selected, where the name of the package matches BUDGET. 2. Next, all packages are selected that have received 15 or more votes. 3. Then all these packages are sorted in descending order, with the most votes. 4. Then the very first one with the most votes is selected.                            Sample code for approving a budget. class LawsController: method: currentLaw.                 //the budget is approved only by the board of directors.                      List<CurrentLawVotesEndBalance> budjet = current.stream()                              .filter(t-> !directors.contains(t.getPackageName()))                              .filter(t->Seting.BUDGET.equals(t.getPackageName()))                              .filter(t->!directors.isCabinets(t.getPackageName()))                              .filter(t-> t.getVotesBoardOfDirectors() >= Seting.ORIGINAL_LIMIT_MIN_VOTE_BOARD_OF_DIRECTORS)                              .sorted(Comparator.comparing(CurrentLawVotesEndBalance::getVotesBoardOfDirectors).reversed())                              .limit(1)                              .collect(Collectors.toList());","HOW_IS_THE_STRATEGIC The strategic plan is approved by the Board of Directors, the strategic plan may be valid only in a single copy. For the Strategic Plan to be valid, a balance of votes is needed Board of Directors 15 or more. Voting method VOTE_ONE.              The Board of Directors may cancel the Strategic Plan at any time. Strategic Plan in effect while the number of votes is 15 or more. The Strategic Plan may include a general direction Corporations, as well as what needs to be implemented.              A section of code that shows how the Strategic Plan is being approved.    class LawsController: method currentLaw:                                  //the plan is approved only by the chamber Board of Directors                      List<CurrentLawVotesEndBalance> planFourYears = current.stream()                              .filter(t->!directors.contains(t.getPackageName()))                              .filter(t->Seting.STRATEGIC_PLAN.equals(t.getPackageName()))                              .filter(t->!directors.isCabinets(t.getPackageName()))                              .filter(t->t.getVotesBoardOfDirectors() >= Seting.ORIGINAL_LIMIT_MIN_VOTE_BOARD_OF_DIRECTORS)                              .sorted(Comparator.comparing(CurrentLawVotesEndBalance::getVotesBoardOfDirectors).reversed())                              .limit(1)                              .collect(Collectors.toList());","HOW_NEW_POSITIONS_ARE_ADDED This method adds only top management, reports of each manager are hired without using the blockchain, they can be hired by the director himself, or otherwise described by applicable law. The top management is added to the class Directors list. All newly added positions are valid as long as their laws that create these positions are in effect.              Only the Board of Directors can add new positions. Each package of laws that starts with ADD_DIRECTOR is defined as adding a position. The list of laws that are inside this package are positions if the title is in line starts with ADD_DIRECTOR.             Example: package name ADD_DIRECTOR_PACKAGE name of the first third and fourth line ADD_DIRECTOR_FIRST ADD_DIRECTOR_THIRD ADD_DIRECTOR_FOUR This will create three positions for the position.              But if the line starts with ADD_DIRECTOR, then the position name must be large letters and underscores, also there should be only one position in one line and no more words.              Those lines where there is no position added (ADD_DIRECTOR) are used to describe the powers of the added posts.              In order for new positions to be added to the list, the Board of Directors must vote by VOTE_ONE 15 or more votes. After new positions are created, each member of the network will be able to apply for these positions.              class LawsController: method currentLaw:                                                //adds laws that create new director positions                      List<CurrentLawVotesEndBalance> addDirectors = current.stream()                             .filter(t->t.getPackageName().startsWith(Seting.ADD_DIRECTOR))                             .filter(t->t.getVotesBoardOfDirectors() >= Seting.ORIGINAL_LIMIT_MIN_VOTE_BOARD_OF_DIRECTORS)                             .collect(Collectors.toList());","PROPERTY_OF_THE_CORPORATION PROPERTY OF A CORPORATION. All property owned by the International Trade Union Corporation, cannot be sold without a valid law, where the sale process will be described and at what price the property will be sold. The founder's account, and the accounts of other members are not corporate account, the Board of Directors must create a separate account which will be budgeted and managed only by members of the current members of the Board of Directors.","INTERNET_STORE_DIRECTOR Online store director This director is engaged in the development, promotion and management of an online store in which sell goods for a digital dollar or digital shares. Detailed powers must be given either through existing laws or issued by the CEO or the Board of Directors. The name of the Store must be determined by either the Board of Directors or the Chief Executive Officer.","GENERAL_EXECUTIVE_DIRECTOR General Executive Director This Director coordinates the actions of the other senior directors to implement the strategic plan or the tasks assigned to it by the laws in force. All powers must be given to him through existing laws. This is the highest position elected by the Corporation and is essentially the analogue of the prime minister.","DIRECTOR_OF_THE_DIGITAL_EXCHANGE Digital Exchange Director This Director is engaged in the development, promotion and management of the Internet exchange. The authority must be given to him or the laws in force, or the Board of Directors, or the Chief Executive Officer.","DIRECTOR_OF_DIGITAL_BANK Digital Bank Director This Director manages the Internet bank. All powers must be issued or applicable laws, or the Board of Directors, or the Chief Executive Officer.","DIRECTOR_OF_THE_COMMERCIAL_COURT Director of a private commercial court Must provide leadership to private courts, all powers must be issued either by applicable laws or by the Board of Directors, or General Executive Director.  In these courts, judges can be both members of the Council of Chief Justices (CORPORATE_COUNCIL_OF_REFEREES) so is the Chief Justice, or inferior judges elected by CORPORATE_COUNCIL_OF_REFEREES.","MEDIA_DIRECTOR Media director This Director directs the media, all powers must be issued by the laws in force, or, the Board of Directors or the CEO.              This Director is responsible for the management of media owned directly Corporations of the International Trade Union.","DIRECTOR_OF_THE_DEVELOPMENT_OF_THE_IMPLEMENTATION_OF_CRYPTOCURRENCY_TECHNOLOGIES_OF_THE_INTERNATIONAL_TRADE_UNION_CORPORATION This Director manages the development and implementation of new code in this cryptocurrency, all powers must be issued only through applicable laws, but may also be issued by either the Board of Directors if applicable laws have given such authority to the Board of Directors. Also, no code change should be contrary to the current charter or applicable laws. Also, powers can be issued by the Chief Executive Officer, if such authority is granted to the Chief Executive Officer by applicable law.","EXPLANATION_WHY_MONEY_DEMURAGE_IS_USED_HERE EXPLANATION WHY MONEY DEMURAGE IS USED HERE The negative rate is now applied in many countries, this measure stimulates money holders when the price is excessively high, saturate the market with money. The amount of money mined for each block is 200 digital dollars and 200 digital shares, also 2% of each mining reward to the founder, which is 4 digital dollars and 4 digital Shares for each block mining. Here it is used as the Theories of Silvio Gesell, as well as the school of monetarism in a modified form.              With Silvio Gezel, the negative rate was 1% per month, which would just kill the economy, under monetarism, the growth of the money supply had to be proportional to the growth of GDP, but since in this system fails to calculate the real GDP growth, I set a fixed growth, also if the monetary growth will equal GDP, there is a high probability of Hyperinflation, since GDP does not always reflect real economic growth. Money must be solid so that a business can predict its long-term investments and from monetarism, only the part that the money supply should grow linearly, but in general there is a mix of different economic schools, including the Austrian School of Economics.              With a negative rate of 0.1% every six months for digital dollars and 0.2% for digital stocks, we avoid the consequences of a severe economic crisis for this currency.              Such a mechanism creates a price corridor where the lower limit of the value of these digital currencies is the total number of issued digital currencies. dollars and digital stocks, and the upper limit is the real value. Since as soon as the value becomes higher than the real value, it becomes more profitable for holders to sell digital dollars and digital shares at inflated prices, thereby saturating the market with money and creating a correction in the market.              The main source of monetary crises is rapid changes in commodity prices and slow changes in wages. Example: Imagine that the value of the currency has risen sharply by 30%, it becomes more profitable for holders not to invest money, since income from holding currency, higher than now pay more expensive employees, because of the fact that the money stops invest. People do not receive wages, which leads to the fact that a huge number of goods are not sold, and this leads to the fact that some manufacturers go bankrupt and lay off many workers, which further reduces wages. wages from the rest, as the labor market becomes surplus.        Which, in turn, causes even more fear among money holders to invest, and this process continues until the moment when until the value of money starts to decline due to the fact that the total number of production chains has decreased and goods have also decreased.             Example: Let's imagine that we had inflation and the value of money fell by 40% within a month, the cost of goods increases sharply, but wages have not risen, so a lot of goods will not be bought, which leads to the closure of production chains, which, in turn, due to an excess of workers in the labor market, reduces wages, which also further reduces the number of goods sold. The first case A deflationary spiral occurs due to a sharp reduction in money in the market, the second stagflation occurs more often when a sharply excess amount of money enters the market. And these two phenomena are two sides of the same coin, in one case we get a deflationary spiral in the other stagflation.                         To avoid such crises, in this cryptocurrency, money grows in the same predictable amount. 204 (4 - founder reward, 200 - earner reward) digital dollars and shares per block, about 576 blocks per day. A negative rate adjusts the value of coins every six months. It is also forbidden to use fractional reserve banking for these coins, as their number grows linearly, and will not be able to cover the debts incurred due to fractional reserve banking, due to lack of cash, since with fractional reserve banking, the increase in debt will be much higher than this protocol will create money.  Also, if you increase the money supply by changing the settings, and making the money supply increase much higher, it can cause hyperinflation or even galloping inflation. If it is necessary to increase the growth of the money supply, this should only happen through amendments, keeping the founder's remuneration percentage at two percent. And mining per block should not increase more than 5% for ten years, each subsequent increase that may be made must pass at least ten years through amendments, and no more than 5% per block from the reward of the last block. (Example: if we change through amendments, then production should not be higher than 210 coins, but every next ie will not be more than five percent of the last. Thus, the next increase made through the amendments will be 220.5 coins. But this amendment will be introduced only in ten years after the first production adjustment)              With a lack of money supply, if the number of mined coins has not been changed through an amendment, you can add a few additional zeros after the decimal point, so it will simply increase the value of the coins, without increasing the total money supply.              Negative rates should not be higher than 0.5% per annum and lower than 0.2% per annum. Negative rates can only be changed through amendments.","FREEDOM_OF_SPEECH No body of this corporation or entity shall prohibit free practice any religion; or restrict freedom of speech, conscience or the press or the right of people to peacefully assemble or associate with one another, or not associate with one another, and apply to the management of the Corporation of the International Trade Union and to this corporation with a petition for satisfaction of complaints; or violate the right to the fruits of one's labor or the right to a peaceful life of one's choice. Freedoms of speech and conscience include the freedom to contribute to political campaigns or candidacy for corporate office and should be construed as extending equally to any means of communication.","RIGHTS Natural Rights All members of the network must respect the Natural Human Rights and not violate them. The presumption of innocence must also be respected and each member of the network must have the right to a fair and independent trial. Each participant has the right to a lawyer or to be his own lawyer.              The International Trade Union Corporation shall not regulate the cost of goods and services of network members that sell through this platform. Also, the Corporation should not ban individual brands on its site, but may prohibit the sale of entire groups of goods that fall within the characteristics described by applicable laws, if this prohibition does not violate Natural Human Rights. As a source of rights, you can take as a precedent Countries recognized as democratic countries.              A detailed list is at the United Nations (UN)              The right to live Right to liberty and security of person Right to privacy The right to determine and indicate one's nationality The right to use one's native language The right to freedom of movement and choice of place of stay and residence Right to freedom of conscience              Freedom of thought and speech Freedom of Information The right to form public associations The right to hold public events The right to participate in the management of the affairs of the Corporation of the International Trade Union The right to appeal to the bodies of the Corporation of the International Trade Union and local governments. Among the natural inalienable human rights include the right to life, freedom, security, property, physical and mental integrity, personal dignity, personal and family secrets, etc.              No existing law should be interpreted in such a way as to violate the natural rights of man. The corporate supreme court may use precedents as judgments, as long as these decisions do not contradict current charter and applicable laws. The Corporate Supreme Court can create precedents similar to countries with case law, but apply you can if these precedents do not violate the current charter or current laws of the Corporation of the International Trade Union.","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","",""],"hashLaw":"LIBER0018e1c46e0aa2af0852bfbd72d2743638cd2ca8158a1cba75a8433284ef5dbc"}}
{"name":"LIBERc64d89a86abe0627ed5d0210c417e80a848eee1f1a958299fe8cc4ebf6201030","account":{"account":"LIBERc64d89a86abe0627ed5d0210c417e80a848eee1f1a958299fe8cc4ebf6201030","digitalDollarBalance":0.0,"digitalStockBalance":0.0},"laws":{"packetLawName":"ORIGINAL_CHARTER_CURRENT_ALL_CODE","laws":["package International_Trade_Union.config;   import International_Trade_Union.entity.blockchain.Blockchain; import International_Trade_Union.setings.Seting;  import java.io.IOException; import java.security.InvalidKeyException; import java.security.NoSuchAlgorithmException; import java.security.NoSuchProviderException; import java.security.SignatureException; import java.security.spec.InvalidKeySpecException;  public class BLockchainFactory {      public static Blockchain getBlockchain(BlockchainFactoryEnum factoryEnum) throws NoSuchAlgorithmException, InvalidKeySpecException, IOException, SignatureException, NoSuchProviderException, InvalidKeyException {         switch (factoryEnum){             case TEST:                 return new Blockchain(                         Seting.BLOCK_GENERATION_INTERVAL_TEST,                         Seting.DIFFICULTY_ADJUSTMENT_INTERVAL_TEST,                         Seting.INTERVAL_TARGET_TEST,                         Seting.ADDRESS_FOUNDER_TEST);              case ORIGINAL:                 return new Blockchain(                         Seting.BLOCK_GENERATION_INTERVAL,                         Seting.DIFFICULTY_ADJUSTMENT_INTERVAL,                         Seting.INTERVAL_TARGET,                         Seting.ADDRESS_FOUNDER                 );             default: return null;         }     } }","package International_Trade_Union.config;  public enum BlockchainFactoryEnum {     TEST,     ORIGINAL }","package International_Trade_Union.controllers;  import International_Trade_Union.entity.AddressUrl; import International_Trade_Union.entity.SubBlockchainEntity; import org.json.JSONException;  import org.springframework.http.MediaType; import International_Trade_Union.entity.DtoTransaction.DtoTransaction; import International_Trade_Union.entity.blockchain.Blockchain; import International_Trade_Union.entity.blockchain.block.Block; import International_Trade_Union.config.BLockchainFactory; import International_Trade_Union.config.BlockchainFactoryEnum; import International_Trade_Union.entity.EntityChain; import International_Trade_Union.model.Account; import International_Trade_Union.model.Mining; import International_Trade_Union.model.User; import International_Trade_Union.network.AllTransactions; import International_Trade_Union.setings.Seting; import International_Trade_Union.utils.*; import International_Trade_Union.vote.*; import org.springframework.http.HttpStatus; import org.springframework.http.ResponseEntity; import org.springframework.stereotype.Controller; import org.springframework.ui.Model; import org.springframework.util.Assert; import org.springframework.web.bind.annotation.*; import org.springframework.web.context.request.RequestAttributes; import org.springframework.web.context.request.RequestContextHolder; import org.springframework.web.context.request.ServletRequestAttributes;  import javax.servlet.http.HttpServletRequest; import java.io.IOException;  import java.security.*; import java.security.spec.InvalidKeySpecException;  import java.util.*; import java.util.stream.Collectors;  @Controller public class BasisController {     private static Blockchain blockchain;      private static Set<String> excludedAddresses = new HashSet<>();      public static HttpServletRequest getCurrentRequest() {         RequestAttributes requestAttributes = RequestContextHolder.getRequestAttributes();         if(requestAttributes == null)             return null;         Assert.state(requestAttributes != null, \"Could not find current request via RequestContextHolder\");         Assert.isInstanceOf(ServletRequestAttributes.class, requestAttributes);         HttpServletRequest servletRequest = ((ServletRequestAttributes) requestAttributes).getRequest();         Assert.state(servletRequest != null, \"Could not find current HttpServletRequest\");         return servletRequest;     }       public static Set<String> getExcludedAddresses() {         HttpServletRequest request = getCurrentRequest();         if(request == null)             return excludedAddresses;          String scheme = request.getScheme();         String serverName = request.getServerName();         int serverPort = request.getServerPort();         String contextPath = request.getContextPath();  // includes leading forward slash          String localaddress = scheme + \"://\" + serverName + \":\" + serverPort;          excludedAddresses.add(localaddress);         return excludedAddresses;     }      public static void setExcludedAddresses(Set<String> excludedAddresses) {         BasisController.excludedAddresses = excludedAddresses;     }      private static Set<String> nodes = new HashSet<>(); //    private static Nodes nodes = new Nodes();       public static void setNodes(Set<String> nodes) {         BasisController.nodes = nodes;     }      /**Возвращает список хостов*/     public static Set<String> getNodes() throws IOException, NoSuchAlgorithmException, InvalidKeySpecException, SignatureException, NoSuchProviderException, InvalidKeyException {          nodes = new HashSet<>();          Set<String> temporary = UtilsAllAddresses.readLineObject(Seting.ORIGINAL_POOL_URL_ADDRESS_FILE);           nodes.addAll(temporary);           nodes = nodes.stream()                 .filter(t -> !t.isBlank())                 .filter(t -> t.startsWith(\"\\\"\"))                 .collect(Collectors.toSet());         nodes = nodes.stream().map(t -> t.replaceAll(\"\\\"\", \"\")).collect(Collectors.toSet());         nodes.addAll(Seting.ORIGINAL_ADDRESSES);         return nodes;     }       /**Возвращяет действующий блокчейн*/     public static Blockchain getBlockchain() {         return blockchain;     }      public static synchronized void setBlockchain(Blockchain blockchain) {         BasisController.blockchain = blockchain;     }       static {         try {             blockchain = BLockchainFactory.getBlockchain(BlockchainFactoryEnum.ORIGINAL);         } catch (NoSuchAlgorithmException e) {             throw new RuntimeException(e);         } catch (InvalidKeySpecException e) {             throw new RuntimeException(e);         } catch (IOException e) {             throw new RuntimeException(e);         } catch (SignatureException e) {             throw new RuntimeException(e);         } catch (NoSuchProviderException e) {             throw new RuntimeException(e);         } catch (InvalidKeyException e) {             throw new RuntimeException(e);         }     }       public BasisController() {     }      //TODO если вы прервали mine, то перед следующим вызовом перезапустите сервер и вызовите /addBlock перед mine     //TODO if you interrupted mine, restart the server before next call and call /addBlock before mine     //TODO иначе будет расождение в файле балансов     //TODO otherwise there will be a discrepancy in the balance file        /**Стартует добычу, начинает майнинг*/     @GetMapping(\"/mine\")     public synchronized String mine(Model model) throws NoSuchAlgorithmException, InvalidKeySpecException, IOException, SignatureException, NoSuchProviderException, InvalidKeyException, JSONException, CloneNotSupportedException {         String text = \"\";         //нахождение адрессов         findAddresses();         sendAddress();          //собирает класс список балансов из файла расположенного по пути Seting.ORIGINAL_BALANCE_FILE         Map<String, Account> balances = SaveBalances.readLineObject(Seting.ORIGINAL_BALANCE_FILE);         //собирает объект блокчейн из файла         blockchain = Mining.getBlockchain(                 Seting.ORIGINAL_BLOCKCHAIN_FILE,                 BlockchainFactoryEnum.ORIGINAL);          //если блокчейн работает то продолжить         if (!blockchain.validatedBlockchain()) {             text = \"wrong chain: неправильный блокчейн, добыча прекращена\";             model.addAttribute(\"text\", text);             return \"wrong blockchain\";         }          //Прежде чем добыть новый блок сначала в сети ищет самый длинный блокчейн         resolve_conflicts();          //если размер блокчейна меньше или равно единице, сохранить в файл генезис блок         long index = blockchain.sizeBlockhain();         if (blockchain.sizeBlockhain() <= 1) {             //сохранение генезис блока             if (blockchain.sizeBlockhain() == 1) {                 UtilsBlock.saveBLock(blockchain.getBlock(0), Seting.ORIGINAL_BLOCKCHAIN_FILE);             }              //получить список балансов из файла             balances = Mining.getBalances(Seting.ORIGINAL_BALANCE_FILE, blockchain, balances);             //удалить старые файлы баланса             Mining.deleteFiles(Seting.ORIGINAL_BALANCE_FILE);             //сохранить балансы             SaveBalances.saveBalances(balances, Seting.ORIGINAL_BALANCE_FILE);          }         //скачать список балансов из файла         balances = SaveBalances.readLineObject(Seting.ORIGINAL_BALANCE_FILE);          //получить счет майнера         Account miner = balances.get(User.getUserAddress());         if (miner == null) {             //если в блокчейне не было баланса, то баланс равен нулю             miner = new Account(User.getUserAddress(), 0, 0);         }          //транзакции которые мы добавили в блок и теперь нужно удалить из файла, в папке resources/transactions         List<DtoTransaction> temporaryDtoList = AllTransactions.getInstance();          //раз в три для очищяет файлы в папке resources/sendedTransaction данная папка         //хранит уже добавленые в блокчейн транзации, чтобы повторно не добавлять в         //в блок уже добавленные транзакции         AllTransactions.clearAllSendedTransaction(index);         AllTransactions.clearUsedTransaction(AllTransactions.getInsanceSended());         System.out.println(\"BasisController: start mine:\");          //Сам процесс Майнинга         //DIFFICULTY_ADJUSTMENT_INTERVAL как часто происходит коррекция         //BLOCK_GENERATION_INTERVAL как часто должен находить блок         //temporaryDtoList добавляет транзакции в блок         Block block = Mining.miningDay(                 miner,                 blockchain,                 Seting.BLOCK_GENERATION_INTERVAL,                 Seting.DIFFICULTY_ADJUSTMENT_INTERVAL,                 temporaryDtoList,                 balances,                 index         );         System.out.println(\"BasisController: finish mine:\");         //save sended transaction         //сохранить уже добавленные в блок транзакции,         //чтобы избежать повторного добавления         AllTransactions.addSendedTransaction(temporaryDtoList);          //нужна для корректировки сложности         int diff = Seting.DIFFICULTY_ADJUSTMENT_INTERVAL;         //Тестирование блока         List<Block> testingValidationsBlock = null;          if (blockchain.sizeBlockhain() > diff) {              testingValidationsBlock = blockchain.subBlock(blockchain.sizeBlockhain() - diff, blockchain.sizeBlockhain());         } else {             testingValidationsBlock = blockchain.clone();         }         //проверяет последние 288 блоков на валидность.         if (testingValidationsBlock.size() > 1) {             boolean validationTesting = UtilsBlock.validationOneBlock(                     blockchain.genesisBlock().getFounderAddress(),                     testingValidationsBlock.get(testingValidationsBlock.size() - 1),                     block,                     Seting.BLOCK_GENERATION_INTERVAL,                     diff,                     testingValidationsBlock);              if (validationTesting == false) {                 System.out.println(\"wrong validation block: \" + validationTesting);                 System.out.println(\"index block: \" + block.getIndex());                 text = \"wrong validation\";             }             testingValidationsBlock.add(block.clone());         }          //добавляет последний блок в блокчейн         blockchain.addBlock(block);         //сохраняет последний блок в файл         UtilsBlock.saveBLock(block, Seting.ORIGINAL_BLOCKCHAIN_FILE);          //перерасчет балансов, подсчитывает какие изменения произошли в балансах         balances = Mining.getBalances(Seting.ORIGINAL_BALANCE_FILE, blockchain, balances);         Mining.deleteFiles(Seting.ORIGINAL_BALANCE_FILE);         //сохраняет в файл уже заново посчитанные балансы.         SaveBalances.saveBalances(balances, Seting.ORIGINAL_BALANCE_FILE);          //получает все созданные когда либо законы         Map<String, Laws> allLaws = UtilsLaws.getLaws(blockchain.getBlockchainList(), Seting.ORIGINAL_ALL_CORPORATION_LAWS_FILE);          //возвращает все законы с голосами проголосовавшими за них         List<LawEligibleForParliamentaryApproval> allLawsWithBalance = UtilsLaws.getCurrentLaws(allLaws, balances, Seting.ORIGINAL_ALL_CORPORATION_LAWS_WITH_BALANCE_FILE);         //удаление устаревних законов         Mining.deleteFiles(Seting.ORIGINAL_ALL_CORPORATION_LAWS_WITH_BALANCE_FILE);         //записывает все законы в файл с их голосами.         UtilsLaws.saveCurrentsLaws(allLawsWithBalance, Seting.ORIGINAL_ALL_CORPORATION_LAWS_WITH_BALANCE_FILE);          //отправляет блокчейн во внешние сервера         sendAllBlocksToStorage(blockchain.getBlockchainList());          text = \"success: блок успешно добыт\";         model.addAttribute(\"text\", text);         return \"redirect:/mining\";      }       /**Возвращает EntityChain который хранит в себе размер блокчейна и список блоков*/     @GetMapping(\"/chain\")     @ResponseBody     public EntityChain full_chain() throws IOException, NoSuchAlgorithmException, InvalidKeySpecException, SignatureException, NoSuchProviderException, InvalidKeyException {         blockchain = Mining.getBlockchain(                 Seting.ORIGINAL_BLOCKCHAIN_FILE,                 BlockchainFactoryEnum.ORIGINAL);         return new EntityChain(blockchain.sizeBlockhain(), blockchain.getBlockchainList());     }      /**возвращяет размер локального блокчейна*/     @GetMapping(\"/size\")     @ResponseBody     public Integer sizeBlockchain() throws IOException, NoSuchAlgorithmException, InvalidKeySpecException, SignatureException, NoSuchProviderException, InvalidKeyException {         blockchain = Mining.getBlockchain(                 Seting.ORIGINAL_BLOCKCHAIN_FILE,                 BlockchainFactoryEnum.ORIGINAL);         return blockchain.sizeBlockhain();     }       /**Возвращает список блоков ОТ до ДО,*/     @PostMapping(\"/sub-blocks\")     @ResponseBody     public List<Block> subBlocks(@RequestBody SubBlockchainEntity entity) throws IOException, NoSuchAlgorithmException, InvalidKeySpecException, SignatureException, NoSuchProviderException, InvalidKeyException {         blockchain = Mining.getBlockchain(                 Seting.ORIGINAL_BLOCKCHAIN_FILE,                 BlockchainFactoryEnum.ORIGINAL);         return blockchain.getBlockchainList().subList(entity.getStart(), entity.getFinish());     }      /**Возвращяет блок по индексу*/     @PostMapping(\"/block\")     @ResponseBody     public Block getBlock(@RequestBody Integer index) throws IOException, NoSuchAlgorithmException, InvalidKeySpecException, SignatureException, NoSuchProviderException, InvalidKeyException {         blockchain = Mining.getBlockchain(                 Seting.ORIGINAL_BLOCKCHAIN_FILE,                 BlockchainFactoryEnum.ORIGINAL);         return blockchain.getBlock(index);     }      //TODO нужно чтобы передавался каждый раз не весь блокчейн а часть, как реализованно в биткоин     //TODO is necessary so that not the entire blockchain is transmitted each time, but a part, as implemented in bitcoin     //TODO need to optimization because now not best      @RequestMapping(\"/resolving\")     public String resolving() throws JSONException, NoSuchAlgorithmException, InvalidKeySpecException, IOException, SignatureException, NoSuchProviderException, InvalidKeyException {         resolve_conflicts();         return \"redirect:/\";     }     /**соединяется к внешним хостам, и скачивает самый длинный блокчейн,      * если, локальный блокчейн, меньше других */     @GetMapping(\"/nodes/resolve\")     public synchronized ResponseEntity resolve_conflicts() throws NoSuchAlgorithmException, InvalidKeySpecException, IOException, SignatureException, NoSuchProviderException, InvalidKeyException, JSONException {         Blockchain temporaryBlockchain = BLockchainFactory.getBlockchain(BlockchainFactoryEnum.ORIGINAL);         Blockchain bigBlockchain = BLockchainFactory.getBlockchain(BlockchainFactoryEnum.ORIGINAL);         blockchain = Mining.getBlockchain(                 Seting.ORIGINAL_BLOCKCHAIN_FILE,                 BlockchainFactoryEnum.ORIGINAL);         int blocks_current_size = blockchain.sizeBlockhain();         long hashCountZeroTemporary = 0;         long hashCountZeroBigBlockchain = 0;         EntityChain entityChain = null;          long hashCountZeroAll = 0;         //count hash start with zero all         for (Block block : blockchain.getBlockchainList()) {             hashCountZeroAll += UtilsUse.hashCount(block.getHashBlock());         }          Set<String> nodesAll = getNodes(); //        nodesAll.addAll(Seting.ORIGINAL_ADDRESSES_BLOCKCHAIN_STORAGE);         System.out.println(\"BasisController: resolve: size: \" + getNodes().size());         for (String s : nodesAll) {             System.out.println(\"BasisController: resove: address: \" + s);             String temporaryjson = null;              if (BasisController.getExcludedAddresses().contains(s)) {                 System.out.println(\"its your address or excluded address: \" + s);                 continue;             }             try {                 if(s.contains(\"localhost\") || s.contains(\"127.0.0.1\"))                     continue;                 String address = s + \"/chain\";                 System.out.println(\"BasisController:resolve conflicts: address: \" + s + \"/size\");                 String sizeStr = UtilUrl.readJsonFromUrl(s + \"/size\");                 Integer size = Integer.valueOf(sizeStr);                 if (size > blocks_current_size) {                     System.out.println(\"size from address: \" + s + \" upper than: \" + size + \":blocks_current_size \" + blocks_current_size);                     //Test start algorithm                     SubBlockchainEntity subBlockchainEntity = new SubBlockchainEntity(blocks_current_size, size);                     String subBlockchainJson = UtilsJson.objToStringJson(subBlockchainEntity);                      List<Block> emptyList = new ArrayList<>();                       List<Block> subBlocks = UtilsJson.jsonToListBLock(UtilUrl.getObject(subBlockchainJson, s + \"/sub-blocks\"));                     emptyList.addAll(subBlocks);                     emptyList.addAll(blockchain.getBlockchainList());                      emptyList = emptyList.stream().sorted(Comparator.comparing(Block::getIndex)).collect(Collectors.toList());                     temporaryBlockchain.setBlockchainList(emptyList);                     if (!temporaryBlockchain.validatedBlockchain()) {                         System.out.println(\"first algorithm not worked\");                         emptyList = new ArrayList<>();                         emptyList.addAll(subBlocks);                         for (int i = blockchain.sizeBlockhain() - 1; i > 0; i--) {                             Block block = UtilsJson.jsonToBLock(UtilUrl.getObject(UtilsJson.objToStringJson(i), s + \"/block\"));                             if (!blockchain.getBlock(i).getHashBlock().equals(block.getHashBlock())) {                                 emptyList.add(block);                             } else {                                 emptyList.add(block);                                 emptyList.addAll(blockchain.getBlockchainList().subList(0, i));                                 emptyList = emptyList.stream().sorted(Comparator.comparing(Block::getIndex)).collect(Collectors.toList());                                 temporaryBlockchain.setBlockchainList(emptyList);                                 break;                             }                         }                     }                     if (!temporaryBlockchain.validatedBlockchain()) {                         System.out.println(\"second algorith not worked\");                         temporaryjson = UtilUrl.readJsonFromUrl(address);                         entityChain = UtilsJson.jsonToEntityChain(temporaryjson);                         temporaryBlockchain.setBlockchainList(                                 entityChain.getBlocks().stream().sorted(Comparator.comparing(Block::getIndex)).collect(Collectors.toList()));                     }                 } else {                     System.out.println(\"BasisController: resove: size less: \" + size + \" address: \" + address);                     continue;                 }             } catch (IOException e) {                 e.printStackTrace();                 System.out.println(\"BasisController: resolve_conflicts: Error: \" + s);                 continue;             }               if (temporaryBlockchain.validatedBlockchain()) {                 for (Block block : temporaryBlockchain.getBlockchainList()) {                     hashCountZeroTemporary += UtilsUse.hashCount(block.getHashBlock());                 }                  if (blocks_current_size < temporaryBlockchain.sizeBlockhain() && hashCountZeroAll < hashCountZeroTemporary) {                     blocks_current_size = temporaryBlockchain.sizeBlockhain();                     bigBlockchain = temporaryBlockchain;                     hashCountZeroBigBlockchain = hashCountZeroTemporary;                 }                 hashCountZeroTemporary = 0;             }          }           if (bigBlockchain.sizeBlockhain() > blockchain.sizeBlockhain() && hashCountZeroBigBlockchain > hashCountZeroAll) {              blockchain = bigBlockchain;             UtilsBlock.deleteFiles();             addBlock(bigBlockchain.getBlockchainList(), BLockchainFactory.getBlockchain(BlockchainFactoryEnum.ORIGINAL));             System.out.println(\"BasisController: resolve: bigblockchain size: \" + bigBlockchain.sizeBlockhain());          }         return new ResponseEntity(HttpStatus.OK);     }       /**      * Перезаписывает весь список блоков, и делает перерасчет баланса, а также других данных      * таких как голоса, совет акционеров и т.д. заново записывает в файлы      */      public static void addBlock(List<Block> orignalBlocks, Blockchain blockchain) throws IOException, NoSuchAlgorithmException, SignatureException, InvalidKeySpecException, NoSuchProviderException, InvalidKeyException {          Map<String, Account> balances = new HashMap<>();         Blockchain temporaryForValidation = BLockchainFactory.getBlockchain(BlockchainFactoryEnum.ORIGINAL);         temporaryForValidation.setBlockchainList(orignalBlocks);         UtilsBlock.deleteFiles();         System.out.println(\"addBlock start\");         for (Block block : orignalBlocks) {             UtilsBlock.saveBLock(block, Seting.ORIGINAL_BLOCKCHAIN_FILE);         }          blockchain = Mining.getBlockchain(                 Seting.ORIGINAL_BLOCKCHAIN_FILE,                 BlockchainFactoryEnum.ORIGINAL);          //перерасчет после добычи         balances = UtilsBalance.calculateBalances(blockchain.getBlockchainList());         Mining.deleteFiles(Seting.ORIGINAL_BALANCE_FILE);         SaveBalances.saveBalances(balances, Seting.ORIGINAL_BALANCE_FILE);           //получение и отображение законов, а также сохранение новых законов         //и изменение действующих законов         Map<String, Laws> allLaws = UtilsLaws.getLaws(blockchain.getBlockchainList(), Seting.ORIGINAL_ALL_CORPORATION_LAWS_FILE);           //возвращает все законы с балансом         List<LawEligibleForParliamentaryApproval> allLawsWithBalance = UtilsLaws.getCurrentLaws(allLaws, balances, Seting.ORIGINAL_ALL_CORPORATION_LAWS_WITH_BALANCE_FILE);         //удаление устаревних законов         Mining.deleteFiles(Seting.ORIGINAL_ALL_CORPORATION_LAWS_WITH_BALANCE_FILE);         UtilsLaws.saveCurrentsLaws(allLawsWithBalance, Seting.ORIGINAL_ALL_CORPORATION_LAWS_WITH_BALANCE_FILE);          System.out.println(\"BasisController: addBlock: finish\");     }      /**Регистрирует новый внешний хост*/     @RequestMapping(method = RequestMethod.POST, value = \"/nodes/register\", consumes = MediaType.APPLICATION_JSON_VALUE)     public synchronized void register_node(@RequestBody AddressUrl urlAddrress) throws IOException, NoSuchAlgorithmException, InvalidKeySpecException, SignatureException, NoSuchProviderException, InvalidKeyException {           for (String s : BasisController.getNodes()) {             String original = s;             String url = s + \"/nodes/register\";              try {                 UtilUrl.sendPost(urlAddrress.getAddress(), url);                 sendAddress();               } catch (Exception e) {                 System.out.println(\"BasisController: register node: wrong node: \" + original);                 BasisController.getNodes().remove(original);                 continue;             }         }          Set<String> nodes = BasisController.getNodes();         nodes = nodes.stream()                 .map(t -> t.replaceAll(\"\\\"\", \"\"))                 .map(t -> t.replaceAll(\"\\\\\\\\\", \"\"))                 .collect(Collectors.toSet());         nodes.add(urlAddrress.getAddress());         BasisController.setNodes(nodes);          Mining.deleteFiles(Seting.ORIGINAL_POOL_URL_ADDRESS_FILE);         nodes.stream().forEach(t -> {             try {                 UtilsAllAddresses.saveAllAddresses(t, Seting.ORIGINAL_POOL_URL_ADDRESS_FILE);             } catch (IOException e) {                 throw new RuntimeException(e);             } catch (NoSuchAlgorithmException e) {                 throw new RuntimeException(e);             } catch (SignatureException e) {                 throw new RuntimeException(e);             } catch (InvalidKeySpecException e) {                 throw new RuntimeException(e);             } catch (NoSuchProviderException e) {                 throw new RuntimeException(e);             } catch (InvalidKeyException e) {                 throw new RuntimeException(e);             }         });      }      //TODO если происходить майнинг, то он возвращает false, пока не прекратиться майнинг.     //TODO if mining occurs, it returns false until mining stops.     /** выззывает метод addBlock который перезаписывает весь список блоков, и другие данные*/     @GetMapping(\"/addBlock\")     public ResponseEntity getBLock() throws IOException, NoSuchAlgorithmException, InvalidKeySpecException, SignatureException, NoSuchProviderException, InvalidKeyException {         blockchain = Mining.getBlockchain(                 Seting.ORIGINAL_BLOCKCHAIN_FILE,                 BlockchainFactoryEnum.ORIGINAL);         UtilsBlock.deleteFiles();         addBlock(blockchain.getBlockchainList(), BLockchainFactory.getBlockchain(BlockchainFactoryEnum.ORIGINAL));         return new ResponseEntity(HttpStatus.OK);     }      /**Возвращяет список хостов, сохраненных на локальном сервере*/     @GetMapping(\"/getNodes\")     public Set<String> getAllNodes() throws IOException, NoSuchAlgorithmException, InvalidKeySpecException, SignatureException, NoSuchProviderException, InvalidKeyException {         Set<String> temporary = UtilsAllAddresses.readLineObject(Seting.ORIGINAL_POOL_URL_ADDRESS_FILE);         nodes.addAll(temporary);         nodes.addAll(Seting.ORIGINAL_ADDRESSES);         nodes = nodes.stream().filter(t -> t.startsWith(\"\\\"\"))                 .collect(Collectors.toSet());         return nodes;     }      /**подключается к другим узлам и у них берет их списки хостов, которые храняться у них,      *  и сохраняет эти списки у себя*/     @GetMapping(\"/findAddresses\")     public void findAddresses() throws IOException, NoSuchAlgorithmException, InvalidKeySpecException, SignatureException, NoSuchProviderException, InvalidKeyException {         for (String s : Seting.ORIGINAL_ADDRESSES) {             Set<String> addressesSet = new HashSet<>();             try {                 String addresses = UtilUrl.readJsonFromUrl(s + \"/getDiscoveryAddresses\");                 addressesSet = UtilsJson.jsonToSetAddresses(addresses);             } catch (IOException e) {                 System.out.println(\"BasisController: findAddress: error\");                 continue;             } catch (JSONException e) {                 throw new RuntimeException(e);             }              for (String s1 : addressesSet) {                  register_node(new AddressUrl(s1));             }          }      }      /**Запускает автоматический цикл майнинга, цикл будет идти 2000 шагов*/     @GetMapping(\"/moreMining\")     public void moreMining() throws JSONException, IOException {         for (int i = 1; i < 2000; i++) {             System.out.println(\"block generate i: \" + i);             UtilUrl.readJsonFromUrl(\"http://localhost:8082/mine\");           }     }       /**Отправляет свой список хостов, другим узлам, и пытается автоматически регистрировать у них*/     public static void sendAddress() throws IOException, NoSuchAlgorithmException, InvalidKeySpecException, SignatureException, NoSuchProviderException, InvalidKeyException {         //лист временный для отправки аддресов          for (String s : Seting.ORIGINAL_ADDRESSES) {              String original = s;             String url = s + \"/nodes/register\";              if (BasisController.getExcludedAddresses().contains(url)) {                 System.out.println(\"MainController: its your address or excluded address: \" + url);                 continue;             }             try {                 for (String s1 : BasisController.getNodes()) {                       AddressUrl addressUrl = new AddressUrl(s1);                     String json = UtilsJson.objToStringJson(addressUrl);                     UtilUrl.sendPost(json, url);                 }             } catch (Exception e) {                 System.out.println(\"BasisController: sendAddress: wronge node: \" + original);                  continue;             }           }     }      //должен отправлять блокчейн в хранилище блокчейна     /**Отправляет список блоков в центральные хранилища (пример: http://194.87.236.238:80)*/     public static void sendAllBlocksToStorage(List<Block> blocks) throws IOException, NoSuchAlgorithmException, InvalidKeySpecException, SignatureException, NoSuchProviderException, InvalidKeyException {         String jsonDto;         System.out.println(\"BasisController: sendAllBlocksToStorage: start: \");         try {             jsonDto = UtilsJson.objToStringJson(blocks);         } catch (IOException e) {             throw new RuntimeException(e);         }         int blocks_current_size = blocks.size();         //отправка блокчейна на хранилище блокчейна         System.out.println(\"BasisController: sendAllBlocksToStorage: \");         getNodes().stream().forEach(System.out::println);         for (String s : getNodes()) {               if (BasisController.getExcludedAddresses().contains(s)) {                 System.out.println(\"its your address or excluded address: \" + s);                 continue;             }              try {                 System.out.println(\"BasisController:resolve conflicts: address: \" + s + \"/size\");                 String sizeStr = UtilUrl.readJsonFromUrl(s + \"/size\");                 Integer size =  0;                 if(Integer.valueOf(sizeStr) > 0)                     size = Integer.valueOf(sizeStr);                 System.out.println(\"BasisController: send size: \" + size);                 List<Block> fromToTempBlock = blocks.subList(size, blocks.size());                 String jsonFromTo = UtilsJson.objToStringJson(fromToTempBlock);                 //если блокчейн текущей больше чем в хранилище, то                 //отправить текущий блокчейн отправить в хранилище                 if (size < blocks_current_size) {                     int response = 0;                     //Test start algorithm                     String originalF = s;                     String urlFrom = s + \"/nodes/resolve_from_to_block\";                     try {                         response = UtilUrl.sendPost(jsonFromTo, urlFrom);                     }catch (Exception e){                         System.out.println(\"exception discover: \" + originalF);                         continue;                     }                      System.out.println(\"BasisController: sendAllBlocksStorage: response: \" + response);                      if(response != 0){                         System.out.println(\"BasisController: sendAllBlocks: need change all: \" + response);                         //Test start algorithm                         String original = s;                         String url = s + \"/nodes/resolve_all_blocks\";                         try {                             UtilUrl.sendPost(jsonDto, url);                          }catch (Exception e){                             System.out.println(\"exception discover: \" + original);                             continue;                          }                     }                  }              } catch (JSONException e) {                 e.printStackTrace();                 continue;              } catch (IOException e) {                 e.printStackTrace();                 continue;             }          }      } }","package International_Trade_Union.controllers;  import International_Trade_Union.config.BlockchainFactoryEnum; import International_Trade_Union.entity.blockchain.Blockchain; import International_Trade_Union.model.Mining; import International_Trade_Union.setings.Seting; import org.springframework.web.bind.annotation.GetMapping; import org.springframework.web.bind.annotation.RestController;  import java.io.IOException; import java.security.InvalidKeyException; import java.security.NoSuchAlgorithmException; import java.security.NoSuchProviderException; import java.security.SignatureException; import java.security.spec.InvalidKeySpecException;  @RestController public class BlockchainCheckController {      //TODO во время майнинга, если майнинг не остановлен, он почему то возвращает false, но после остановки true. Нужно исправить.     //TODO during mining, if mining is not stopped, for some reason it returns false, but after stopping it returns true. Need to fix.     //TODO worked after restart server, get true.     //TODO ошибка возникает если прервать mine,     //TODO error occurs if mine is interrupted,      /**Проверяет целостность блокчейна*/     @GetMapping(\"/checkValidation\")     public boolean checkValidation() throws IOException, NoSuchAlgorithmException, SignatureException, InvalidKeySpecException, NoSuchProviderException, InvalidKeyException {         try{             Blockchain blockchain = Mining.getBlockchain(                     Seting.ORIGINAL_BLOCKCHAIN_FILE,                     BlockchainFactoryEnum.ORIGINAL);             System.out.println(\"BlockchainCheckController: checkValidation: size: \" + blockchain.sizeBlockhain());             boolean check = blockchain.validatedBlockchain();             System.out.println(\"check: \" + check);             return check;}         catch (IOException e){             e.printStackTrace();             return false;         }     } }","package International_Trade_Union.controllers;  import International_Trade_Union.config.BlockchainFactoryEnum; import International_Trade_Union.entity.blockchain.Blockchain; import International_Trade_Union.governments.UtilsGovernment; import International_Trade_Union.model.Mining; import International_Trade_Union.utils.SaveBalances; import org.springframework.stereotype.Controller; import org.springframework.ui.Model; import org.springframework.web.bind.annotation.GetMapping; import International_Trade_Union.model.Account; import International_Trade_Union.setings.Seting;  import java.io.IOException; import java.security.InvalidKeyException; import java.security.NoSuchAlgorithmException; import java.security.NoSuchProviderException; import java.security.SignatureException; import java.security.spec.InvalidKeySpecException; import java.util.ArrayList; import java.util.HashMap; import java.util.List; import java.util.Map; import java.util.stream.Collectors;  @Controller public class BoardOfShareholdersController {      /**отображает список Совета Акционеров, отображается в браузере*/     @GetMapping(\"board-of-shareholders\")     public String boardOfShareHolders(Model model) throws NoSuchAlgorithmException, InvalidKeySpecException, IOException, SignatureException, NoSuchProviderException, InvalidKeyException {          Blockchain blockchain = Mining.getBlockchain(                 Seting.ORIGINAL_BLOCKCHAIN_FILE,                 BlockchainFactoryEnum.ORIGINAL);          //Получение баланса         Map<String, Account> balances = new HashMap<>();          balances = SaveBalances.readLineObject(Seting.ORIGINAL_BALANCE_FILE);         List<Account> boardOfShareholders = new ArrayList<>();          boardOfShareholders = UtilsGovernment.findBoardOfShareholders(balances, blockchain.getBlockchainList(), Seting.BOARDS_BLOCK);           model.addAttribute(\"title\", \"Board of shareholders quantity: \" + boardOfShareholders.size());         model.addAttribute(\"boardOfShareholders\", boardOfShareholders);         return \"board-of-shareholders\";     }   }","package International_Trade_Union.controllers;  import International_Trade_Union.originalCorporateCharter.OriginalCHARTER; import International_Trade_Union.originalCorporateCharter.OriginalCHARTER_ENG; import International_Trade_Union.originalCorporateCharter.OriginalPreamble; import International_Trade_Union.originalCorporateCharter.OriginalPreambleEng; import org.springframework.stereotype.Controller; import org.springframework.ui.Model; import org.springframework.web.bind.annotation.GetMapping;  import java.io.IOException; import java.security.InvalidKeyException; import java.security.NoSuchAlgorithmException; import java.security.NoSuchProviderException; import java.security.SignatureException; import java.security.spec.InvalidKeySpecException; import java.util.ArrayList; import java.util.List;  @Controller public class ConstitutionController {      /**Отображает устав в браузере*/     @GetMapping(\"corporate-charter\")     public String constutionRus(Model model) throws NoSuchAlgorithmException, InvalidKeySpecException, IOException, SignatureException, NoSuchProviderException, InvalidKeyException {          model.addAttribute(\"title\", \"corporate charter-корпоративный устав\");         List<String> eng = charterEngList();         List<String> rus = charterRusList();                model.addAttribute(\"rus\", rus);         model.addAttribute(\"eng\", eng);         return \"corporate-charter\";     }      public static String charterRus (){         String string = \"\";         for (String s : charterRusList()) {             string = s + \"\\n\";         }         return string;     }      public static String charterEng(){         String string = \"\";         for (String s : charterEngList()) {             string = s + \"\\n\";         }         return string;     }       public static List<String> charterRusList(){         List<String> rus = new ArrayList<>();           rus.add(\"OriginalPreamble.ARTICLE_0\\n\"+ OriginalPreamble.ARTICLE_0);         rus.add(\"OriginalCHARTER.HOW_LAWS_ARE_CHOSEN_1:\\n\"+ OriginalCHARTER.HOW_LAWS_ARE_CHOSEN_1);         rus.add(\"OriginalCHARTER.VOTE_STOCK_2:\\n\"+ OriginalCHARTER.VOTE_STOCK_2);         rus.add(\"OriginalCHARTER.ONE_VOTE_3:\\n\"+ OriginalCHARTER.ONE_VOTE_3);         rus.add(\"OriginalCHARTER.VOTE_FRACTION_4:\\n\"+ OriginalCHARTER.VOTE_FRACTION_4);         rus.add(\"OriginalCHARTER.Penalty_mechanism_5:\\n\"+ OriginalCHARTER.Penalty_mechanism_5);         rus.add(\"OriginalCHARTER.WHO_HAS_THE_RIGHT_TO_CREATE_LAWS_6:\\n\"+ OriginalCHARTER.WHO_HAS_THE_RIGHT_TO_CREATE_LAWS_6);         rus.add(\"OriginalCHARTER.POWERS_OF_THE_CORPORATE_COUNCIL_OF_JUDGES_7:\\n\"+ OriginalCHARTER.POWERS_OF_THE_CORPORATE_COUNCIL_OF_JUDGES_7);         rus.add(\"OriginalCHARTER.HOW_THE_CHIEF_JUDGE_IS_CHOSEN_8:\\n\"+ OriginalCHARTER.HOW_THE_CHIEF_JUDGE_IS_CHOSEN_8);         rus.add(\"OriginalCHARTER.PROPERTY_OF_THE_CORPORATION_9:\\n\"+ OriginalCHARTER.PROPERTY_OF_THE_CORPORATION_9);         rus.add(\"OriginalCHARTER.GENERAL_EXECUTIVE_DIRECTOR_10:\\n\"+ OriginalCHARTER.GENERAL_EXECUTIVE_DIRECTOR_10);         rus.add(\"OriginalCHARTER.EXPLANATION_WHY_MONEY_DEMURAGE_IS_USED_HERE_11:\\n\"+ OriginalCHARTER.EXPLANATION_WHY_MONEY_DEMURAGE_IS_USED_HERE_11);         rus.add(\"OriginalCHARTER.FREEDOM_OF_SPEECH_12:\\n\"+ OriginalCHARTER.FREEDOM_OF_SPEECH_12);         rus.add(\"OriginalCHARTER.RIGHTS_13:\\n\"+ OriginalCHARTER.RIGHTS_13);         rus.add(\"OriginalCHARTER.LEGISLATURE_14:\\n\"+ OriginalCHARTER.LEGISLATURE_14);          return rus;     }       public static List<String> charterEngList(){         List<String> eng = new ArrayList<>();           eng.add(\"OriginalPreamble.ARTICLE_0\\n\"+ OriginalPreambleEng.ARTICLE_0);         eng.add(\"OriginalCHARTER.HOW_LAWS_ARE_CHOSEN_1:\\n\"+ OriginalCHARTER_ENG.HOW_LAWS_ARE_CHOSEN_1);         eng.add(\"OriginalCHARTER.VOTE_STOCK_2:\\n\"+ OriginalCHARTER_ENG.VOTE_STOCK_2);         eng.add(\"OriginalCHARTER.ONE_VOTE_3:\\n\"+ OriginalCHARTER_ENG.ONE_VOTE_3);         eng.add(\"OriginalCHARTER.VOTE_FRACTION_4:\\n\"+ OriginalCHARTER_ENG.VOTE_FRACTION_4);         eng.add(\"OriginalCHARTER.Penalty_mechanism_5:\\n\"+ OriginalCHARTER_ENG.Penalty_mechanism_5);         eng.add(\"OriginalCHARTER.WHO_HAS_THE_RIGHT_TO_CREATE_LAWS_6:\\n\"+ OriginalCHARTER_ENG.WHO_HAS_THE_RIGHT_TO_CREATE_LAWS_6);         eng.add(\"OriginalCHARTER.POWERS_OF_THE_CORPORATE_COUNCIL_OF_JUDGES_7:\\n\"+ OriginalCHARTER_ENG.POWERS_OF_THE_CORPORATE_COUNCIL_OF_JUDGES_7);         eng.add(\"OriginalCHARTER.HOW_THE_CHIEF_JUDGE_IS_CHOSEN_8:\\n\"+ OriginalCHARTER_ENG.HOW_THE_CHIEF_JUDGE_IS_CHOSEN_8);         eng.add(\"OriginalCHARTER.PROPERTY_OF_THE_CORPORATION_9:\\n\"+ OriginalCHARTER_ENG.PROPERTY_OF_THE_CORPORATION_9);         eng.add(\"OriginalCHARTER.GENERAL_EXECUTIVE_DIRECTOR_10:\\n\"+ OriginalCHARTER_ENG.GENERAL_EXECUTIVE_DIRECTOR_10);         eng.add(\"OriginalCHARTER.EXPLANATION_WHY_MONEY_DEMURAGE_IS_USED_HERE_11:\\n\"+ OriginalCHARTER_ENG.EXPLANATION_WHY_MONEY_DEMURAGE_IS_USED_HERE_11);         eng.add(\"OriginalCHARTER.FREEDOM_OF_SPEECH_12:\\n\"+ OriginalCHARTER_ENG.FREEDOM_OF_SPEECH_12);         eng.add(\"OriginalCHARTER.RIGHTS_13:\\n\"+ OriginalCHARTER_ENG.RIGHTS_13);         eng.add(\"OriginalCHARTER.LEGISLATURE_14:\\n\"+ OriginalCHARTER_ENG.LEGISLATURE_14);          return eng;     } }","package International_Trade_Union.controllers;  import org.springframework.stereotype.Controller; import org.springframework.ui.Model; import org.springframework.web.bind.annotation.GetMapping; import org.springframework.web.bind.annotation.PostMapping; import org.springframework.web.servlet.mvc.support.RedirectAttributes; import International_Trade_Union.model.CreateAccount;  import java.security.InvalidAlgorithmParameterException; import java.security.NoSuchAlgorithmException; import java.security.NoSuchProviderException; import java.security.spec.InvalidKeySpecException; import java.util.Map;  @Controller public class CreateAccountController {       /**Позвалояет создавать счет, отображается в браузере*/     @GetMapping(\"create-account\")     public String createAccount(Model model) throws InvalidAlgorithmParameterException, NoSuchAlgorithmException, InvalidKeySpecException, NoSuchProviderException {         model.addAttribute(\"title\", \"create minerAccount\");         Map<String, String> newAccount = CreateAccount.create();          model.addAttribute(\"login\", newAccount.get(\"pubKey\"));         model.addAttribute(\"password\", newAccount.get(\"privKey\"));         return \"create-account\";     }       @PostMapping(\"create-account\")     public String createNewAccount(RedirectAttributes redirectAttrs) throws InvalidAlgorithmParameterException, NoSuchAlgorithmException, InvalidKeySpecException, NoSuchProviderException {         redirectAttrs.addFlashAttribute(\"title\", \"create minerAccount\");         Map<String, String> newAccount = CreateAccount.create();          redirectAttrs.addFlashAttribute(\"login\", newAccount.get(\"pubKey\"));         redirectAttrs.addFlashAttribute(\"password\", newAccount.get(\"privKey\"));          return \"redirect:/create-account\";     }  }","package International_Trade_Union.controllers;  import International_Trade_Union.config.BlockchainFactoryEnum; import International_Trade_Union.entity.blockchain.Blockchain; import International_Trade_Union.governments.*; import International_Trade_Union.model.Account; import International_Trade_Union.model.FIndPositonHelperData; import International_Trade_Union.model.Mining; import International_Trade_Union.setings.Seting; import International_Trade_Union.utils.SaveBalances; import International_Trade_Union.vote.CurrentLawVotesEndBalance; import International_Trade_Union.vote.LawEligibleForParliamentaryApproval; import International_Trade_Union.vote.UtilsLaws; import org.springframework.stereotype.Controller; import org.springframework.ui.Model; import org.springframework.web.bind.annotation.GetMapping;  import java.io.IOException; import java.security.InvalidKeyException; import java.security.NoSuchAlgorithmException; import java.security.NoSuchProviderException; import java.security.SignatureException; import java.security.spec.InvalidKeySpecException; import java.util.*; import java.util.stream.Collectors;  @Controller public class FractionController {      @GetMapping(\"/fractions\")     public String fractions(Model model) throws IOException, NoSuchAlgorithmException, SignatureException, InvalidKeySpecException, NoSuchProviderException, InvalidKeyException {         Directors directors = new Directors();         Blockchain blockchain = Mining.getBlockchain(                 Seting.ORIGINAL_BLOCKCHAIN_FILE,                 BlockchainFactoryEnum.ORIGINAL);          Map<String, Account> balances = new HashMap<>();         //считывать баланс         balances = SaveBalances.readLineObject(Seting.ORIGINAL_BALANCE_FILE);          List<LawEligibleForParliamentaryApproval> lawEligibleForParliamentaryApprovals =                 UtilsLaws.readLineCurrentLaws(Seting.ORIGINAL_ALL_CORPORATION_LAWS_WITH_BALANCE_FILE);          //получить совет акционеров из файла         List<Account> boardOfShareholders = UtilsGovernment.findBoardOfShareholders(balances, blockchain.getBlockchainList(), Seting.BOARDS_BLOCK);           //TODO доработать оптимизацию         //TODO избавиться от find position в данном методе         //отфильтровать по типам голосов         Map<Director, FIndPositonHelperData> fIndPositonHelperDataMap = new HashMap<>();         for (Director higherSpecialPositions : directors.getDirectors()) {             if (higherSpecialPositions.isElectedByCEO()) {                 fIndPositonHelperDataMap.put(higherSpecialPositions,                         new FIndPositonHelperData(higherSpecialPositions, false, false, true, false, false));             } else if (higherSpecialPositions.isElectedByBoardOfDirectors()) {                 fIndPositonHelperDataMap.put(higherSpecialPositions,                         new FIndPositonHelperData(higherSpecialPositions, false, false, false, true, false));             } else if (higherSpecialPositions.isElectedByCorporateCouncilOfReferees()) {                 fIndPositonHelperDataMap.put(higherSpecialPositions,                         new FIndPositonHelperData(higherSpecialPositions, false, false, false, false, true));             } else {                 fIndPositonHelperDataMap.put(higherSpecialPositions,                         new FIndPositonHelperData(higherSpecialPositions, true, true, false, false, false));              }          }         //подсчитать голоса за все проголосованные заканы         List<CurrentLawVotesEndBalance> current = UtilsGovernment.filtersVotes(                 lawEligibleForParliamentaryApprovals,                 balances,                 boardOfShareholders,                 blockchain.getBlockchainList(),                 Seting.LAW_YEAR_VOTE);  //избранные фракции         List<CurrentLawVotesEndBalance> electedFraction = current.stream()                 .filter(t -> directors.isElectedByStocks(t.getPackageName()))                 .filter(t -> t.getPackageName().equals(NamePOSITION.FRACTION.toString()))                 .filter(t -> t.getVotes() >= Seting.ORIGINAL_LIMIT_MIN_VOTE)                 .sorted(Comparator.comparing(CurrentLawVotesEndBalance::getVotes).reversed())                 .limit(directors.getDirector(NamePOSITION.FRACTION.toString()).getCount())                 .collect(Collectors.toList());          double sum = electedFraction.stream().map(t->t.getVotes())                 .reduce(0.0, Double::sum);         List<FractionPower> currentLaw = new ArrayList<>();         for (CurrentLawVotesEndBalance first : electedFraction) {              double fractionP = (first.getVotes()/sum) * Seting.HUNDRED_PERCENT;             FractionPower fractionPower = new FractionPower(                     first.getAddressLaw(),                     first.getVotes(),                     first.getVotesCorporateCouncilOfReferees(),                     first.getVotesBoardOfDirectors(),                     first.getVotesBoardOfShareholders(),                     first.getVoteGeneralExecutiveDirector(),                     first.getVoteHightJudge(),                     first.getFounderVote(),                     first.getPackageName(),                     first.getLaws(),                     first.getFractionVote(),                     fractionP              );             currentLaw.add(fractionPower);         }           model.addAttribute(\"title\", \"fractions end fractions power\");         model.addAttribute(\"currentLaw\", currentLaw);         return \"/fractions\";     } }","package International_Trade_Union.controllers;  import International_Trade_Union.config.BlockchainFactoryEnum; import International_Trade_Union.entity.DtoTransaction.DtoTransaction; import International_Trade_Union.entity.blockchain.Blockchain; import International_Trade_Union.governments.Director; import International_Trade_Union.governments.Directors; import International_Trade_Union.governments.NamePOSITION; import International_Trade_Union.model.FIndPositonHelperData; import International_Trade_Union.model.Mining; import International_Trade_Union.network.AllTransactions; import International_Trade_Union.utils.base.Base; import International_Trade_Union.utils.base.Base58; import org.springframework.stereotype.Controller; import org.springframework.ui.Model; import org.springframework.web.bind.annotation.GetMapping; import International_Trade_Union.governments.UtilsGovernment; import International_Trade_Union.model.Account; import International_Trade_Union.setings.Seting; import International_Trade_Union.utils.*; import International_Trade_Union.vote.*; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RequestMethod; import org.springframework.web.bind.annotation.RequestParam; import org.springframework.web.servlet.mvc.support.RedirectAttributes;  import java.io.IOException; import java.security.*; import java.security.spec.InvalidKeySpecException; import java.util.*; import java.util.stream.Collectors;  @Controller public class GovernmentController {      //TODO если происходит майнинг почему то происходят ошибки, и если вызвать данный метод, то может     //TODO прерываться сам процесс майнинга     //TODO if mining occurs for some reason, errors are observed, and this method appears, then it can     //TODO interrupt the mining process itself      /**Отображает в браузере список действующих должностей*/     @GetMapping(\"/governments\")     public String corporateSeniorpositions(Model model) throws NoSuchAlgorithmException, InvalidKeySpecException, IOException, SignatureException, NoSuchProviderException, InvalidKeyException {         Blockchain blockchain = Mining.getBlockchain(                 Seting.ORIGINAL_BLOCKCHAIN_FILE,                 BlockchainFactoryEnum.ORIGINAL);          //за сколько времени занимает подсчет         Date start = new Date();         //Получение баланса         Map<String, Account> balances = new HashMap<>();          balances = SaveBalances.readLineObject(Seting.ORIGINAL_BALANCE_FILE);          //Нахождение должности         List<LawEligibleForParliamentaryApproval> allGovernment =                 UtilsLaws.readLineCurrentLaws(Seting.ORIGINAL_ALL_CORPORATION_LAWS_WITH_BALANCE_FILE);          //список должностей         Map<Director, List<LawEligibleForParliamentaryApproval>> positionsListMap = new HashMap<>();          Directors directors = new Directors();         //добавление всех должностей         for (Director higherSpecialPositions : directors.getDirectors()) {             positionsListMap.put(higherSpecialPositions, UtilsLaws.getPossions(allGovernment, higherSpecialPositions));         }          //список акционеров         List<Account> BoardOfShareholders = UtilsGovernment.findBoardOfShareholders(balances, blockchain.getBlockchainList(), Seting.BOARDS_BLOCK);          //список законов с голосами         Map<String, List<CurrentLawVotesEndBalance>> curentLawVotesEndBalance = new HashMap<>();          //TODO доработать оптимизацию         //TODO избавиться от find position в данном методе         Map<Director, FIndPositonHelperData> fIndPositonHelperDataMap = new HashMap<>();         for (Director higherSpecialPositions : directors.getDirectors()) {             if(higherSpecialPositions.isElectedByCEO()){                 fIndPositonHelperDataMap.put(higherSpecialPositions,                         new FIndPositonHelperData(higherSpecialPositions, false, false, true, false, false));             }             else if(higherSpecialPositions.isElectedByBoardOfDirectors()){                 fIndPositonHelperDataMap.put(higherSpecialPositions,                         new FIndPositonHelperData(higherSpecialPositions, false, false, false, true, false));             }             else if(higherSpecialPositions.isElectedByCorporateCouncilOfReferees()){                 fIndPositonHelperDataMap.put(higherSpecialPositions,                         new FIndPositonHelperData(higherSpecialPositions, false, false, false, false, true));             }             else {                 fIndPositonHelperDataMap.put(higherSpecialPositions,                         new FIndPositonHelperData(higherSpecialPositions, true, true, false ,false, false));              }          }          List<CurrentLawVotesEndBalance> current = UtilsGovernment.filtersVotes(                 allGovernment,                 balances,                 BoardOfShareholders,                 blockchain.getBlockchainList(),                 Seting.LAW_YEAR_VOTE);            //минимальное значение количество положительных голосов для того чтобы закон действовал,         //позиции избираемые акциями в совет директоров         List<CurrentLawVotesEndBalance> electedByStockBoardOfDirectors = current.stream()                 .filter(t -> directors.isElectedByStocks(t.getPackageName()))                 .filter(t -> t.getPackageName().equals(NamePOSITION.BOARD_OF_DIRECTORS.toString()))                 .filter(t -> t.getVotes() >= Seting.ORIGINAL_LIMIT_MIN_VOTE)                 .sorted(Comparator.comparing(CurrentLawVotesEndBalance::getVotes).reversed())                 .limit(directors.getDirector(NamePOSITION.BOARD_OF_DIRECTORS.toString()).getCount())                 .collect(Collectors.toList());           //минимальное значение количество положительных голосов для того чтобы закон действовал,         //позиции избираемые акциями electedByStockCorporateCouncilOfReferees         List<CurrentLawVotesEndBalance> electedByStockCorporateCouncilOfReferees = current.stream()                 .filter(t -> directors.isElectedByStocks(t.getPackageName()))                 .filter(t -> t.getPackageName().equals(NamePOSITION.CORPORATE_COUNCIL_OF_REFEREES.toString()))                 .filter(t -> t.getVotes() >= Seting.ORIGINAL_LIMIT_MIN_VOTE)                 .sorted(Comparator.comparing(CurrentLawVotesEndBalance::getVotes).reversed())                 .limit(directors.getDirector(NamePOSITION.CORPORATE_COUNCIL_OF_REFEREES.toString()).getCount())                 .collect(Collectors.toList());            //позиции созданные советом директоров         List<CurrentLawVotesEndBalance> createdByBoardOfDirectors = current.stream()                 .filter(t->t.getPackageName().startsWith(Seting.ADD_DIRECTOR))                 .filter(t->t.getVotesBoardOfDirectors() >= Seting.ORIGINAL_LIMIT_MIN_VOTE_BOARD_OF_DIRECTORS                 && t.getVotesBoardOfShareholders() >= Seting.ORIGINAL_LIMIT_MIN_VOTE_BOARD_OF_SHAREHOLDERS                 && t.getFractionVote() >= Seting.ORIGINAL_LIMIT_MIN_VOTE_FRACTIONS                 && t.getVotes() >= Seting.ALL_STOCK_VOTE)                 .collect(Collectors.toList());         //добавление позиций созданных советом директоров         for (CurrentLawVotesEndBalance currentLawVotesEndBalance : createdByBoardOfDirectors) {             directors.addAllByBoardOfDirectors(currentLawVotesEndBalance.getLaws());         }          //позиции избираемые  только советом директоров в кабинет директоров         List<CurrentLawVotesEndBalance> electedByBoardOfDirectors = current.stream()                 .filter(t -> directors.isElectedByBoardOfDirectors(t.getPackageName()))                 .filter(t -> t.getVotesBoardOfDirectors() >= Seting.ORIGINAL_LIMIT_MIN_VOTE_BOARD_OF_DIRECTORS                 && t.getVotesBoardOfShareholders() >= Seting.ORIGINAL_LIMIT_MIN_VOTE_BOARD_OF_SHAREHOLDERS                 && t.getFractionVote() >= Seting.ORIGINAL_LIMIT_MIN_VOTE_FRACTIONS                 && t.getVotes() >= Seting.ALL_STOCK_VOTE)                 .sorted(Comparator.comparing(CurrentLawVotesEndBalance::getVotesBoardOfDirectors).reversed())                 .collect(Collectors.toList());          List<CurrentLawVotesEndBalance> addDirectors = current.stream()                 .filter(t->t.getPackageName().startsWith(Seting.ADD_DIRECTOR))                 .filter(t->t.getVotesBoardOfDirectors() >= Seting.ORIGINAL_LIMIT_MIN_VOTE_BOARD_OF_DIRECTORS                         && t.getVotesBoardOfShareholders() >= Seting.ORIGINAL_LIMIT_MIN_VOTE_BOARD_OF_SHAREHOLDERS                         && t.getFractionVote() >= Seting.ORIGINAL_LIMIT_MIN_VOTE_FRACTIONS                         && t.getVotes() >= Seting.ALL_STOCK_VOTE)                 .collect(Collectors.toList());          System.out.println(\"***************************************\");         System.out.println(\"GovernmentController: corporateSeniorpositions: elected by Board of Directors;\");         electedByBoardOfDirectors.stream().forEach(System.out::println);         System.out.println(\"***************************************\");          //групируем по списку         Map<String, List<CurrentLawVotesEndBalance>> group = electedByBoardOfDirectors.stream()                 .collect(Collectors.groupingBy(CurrentLawVotesEndBalance::getPackageName));          Map<Director, List<CurrentLawVotesEndBalance>> original_group = new HashMap<>();          //оставляем то количество которое описано в данной должности         for (Map.Entry<String, List<CurrentLawVotesEndBalance>> stringListEntry : group.entrySet()) {             List<CurrentLawVotesEndBalance> temporary = stringListEntry.getValue();             temporary = temporary.stream()                     .sorted(Comparator.comparing(CurrentLawVotesEndBalance::getVotesBoardOfDirectors))                     .limit(directors.getDirector(stringListEntry.getKey()).getCount())                     .collect(Collectors.toList());             original_group.put(directors.getDirector(stringListEntry.getKey()), temporary);         }          //позиции избираемые палатой верховных судей         List<CurrentLawVotesEndBalance> electedByChamberOfSupremeJudges = current.stream()                 .filter(t -> directors.isElectedBYCorporateCouncilOfReferees(t.getPackageName()))                 .filter(t -> t.getVotesCorporateCouncilOfReferees() >= Seting.ORIGINAL_LIMIT_MIN_VOTE_CORPORATE_COUNCIL_OF_REFEREES)                 .sorted(Comparator.comparing(CurrentLawVotesEndBalance::getVotesCorporateCouncilOfReferees)).collect(Collectors.toList());            //избираемые премьер министром         List<CurrentLawVotesEndBalance> GENERAL_EXECUTIVE_DIRECTOR = electedByBoardOfDirectors.stream()                 .filter(t -> directors.isElectedCEO(t.getPackageName()))                 .filter(t -> NamePOSITION.GENERAL_EXECUTIVE_DIRECTOR.toString().equals(t.getPackageName()))                 .filter(t -> t.getVoteGeneralExecutiveDirector() >= Seting.ORIGINAL_LIMIT_MIN_VOTE_GENERAL_EXECUTIVE_DIRECTOR)                 .sorted(Comparator.comparing(CurrentLawVotesEndBalance::getVoteGeneralExecutiveDirector))                 .collect(Collectors.toList());          //избираемые верховным судьей         List<CurrentLawVotesEndBalance> electedByHightJudge = electedByChamberOfSupremeJudges.stream()                 .filter(t -> directors.isElectedBYCorporateCouncilOfReferees(t.getPackageName()))                 .filter(t -> t.getVoteHightJudge() >= Seting.ORIGINAL_LIMIT_MIN_VOTE_HIGHT_JUDGE)                 .collect(Collectors.toList());          //избранные фракции         List<CurrentLawVotesEndBalance> electedFraction = current.stream()                 .filter(t -> directors.isElectedByStocks(t.getPackageName()))                 .filter(t -> t.getPackageName().equals(NamePOSITION.FRACTION.toString()))                 .filter(t -> t.getVotes() >= Seting.ORIGINAL_LIMIT_MIN_VOTE)                 .sorted(Comparator.comparing(CurrentLawVotesEndBalance::getVotes).reversed())                 .limit(directors.getDirector(NamePOSITION.FRACTION.toString()).getCount())                 .collect(Collectors.toList());          curentLawVotesEndBalance.put(\"elected by GENERAL_EXECUTIVE_DIRECTOR: \", GENERAL_EXECUTIVE_DIRECTOR);         curentLawVotesEndBalance.put(\"elected by hight judge: \", electedByHightJudge);         curentLawVotesEndBalance.put(NamePOSITION.BOARD_OF_DIRECTORS.toString(), electedByStockBoardOfDirectors);         curentLawVotesEndBalance.put(NamePOSITION.CORPORATE_COUNCIL_OF_REFEREES.toString(), electedByStockCorporateCouncilOfReferees);         curentLawVotesEndBalance.put(NamePOSITION.HIGH_JUDGE.toString(), electedByChamberOfSupremeJudges);         curentLawVotesEndBalance.put(\"ADD_DIRECTIORS_ \", addDirectors);         curentLawVotesEndBalance.put(NamePOSITION.FRACTION.toString(), electedFraction);          for (Map.Entry<Director, List<CurrentLawVotesEndBalance>> higherSpecialPositionsListMap : original_group.entrySet()) {             curentLawVotesEndBalance.put(higherSpecialPositionsListMap.getKey().toString(), higherSpecialPositionsListMap.getValue());         }           Date finish = new Date();         System.out.println(\"given time: \" + new Date(finish.getTime() - start.getTime()));          model.addAttribute(\"show\", curentLawVotesEndBalance);          model.addAttribute(\"title\", \"current guidance\");          return \"/governments\";     }      @GetMapping(\"/create-position\")     public String createPositionShow(Model model) throws IOException, NoSuchAlgorithmException, InvalidKeySpecException, SignatureException, NoSuchProviderException, InvalidKeyException {         Blockchain blockchain = Mining.getBlockchain(                 Seting.ORIGINAL_BLOCKCHAIN_FILE,                 BlockchainFactoryEnum.ORIGINAL);         Map<String, Account> balances = new HashMap<>();         //считывать баланс         balances = SaveBalances.readLineObject(Seting.ORIGINAL_BALANCE_FILE);          Directors directors = new Directors();          List<LawEligibleForParliamentaryApproval> lawEligibleForParliamentaryApprovals =                 UtilsLaws.readLineCurrentLaws(Seting.ORIGINAL_ALL_CORPORATION_LAWS_WITH_BALANCE_FILE);           List<Account> boardOfShareholders = UtilsGovernment.findBoardOfShareholders(balances, blockchain.getBlockchainList(), Seting.BOARDS_BLOCK);          List<CurrentLawVotesEndBalance> current = UtilsGovernment.filtersVotes(                 lawEligibleForParliamentaryApprovals,                 balances,                 boardOfShareholders,                 blockchain.getBlockchainList(),                 Seting.LAW_YEAR_VOTE);           List<String> positions = directors.getDirectors().stream().map(t->t.getName()).collect(Collectors.toList());         //позиции утвержденные всеми         List<CurrentLawVotesEndBalance> createdByBoardOfDirectors = current.stream()                 .filter(t->t.getPackageName().startsWith(Seting.ADD_DIRECTOR))                 .filter(t->t.getVotesBoardOfDirectors() >= Seting.ORIGINAL_LIMIT_MIN_VOTE_BOARD_OF_DIRECTORS                         && t.getVotesBoardOfShareholders() >= Seting.ORIGINAL_LIMIT_MIN_VOTE_BOARD_OF_SHAREHOLDERS                         && t.getFractionVote() >= Seting.ORIGINAL_LIMIT_MIN_VOTE_FRACTIONS                         && t.getVotes() >= Seting.ALL_STOCK_VOTE)                 .collect(Collectors.toList());         //добавление позиций созданных советом директоров         for (CurrentLawVotesEndBalance currentLawVotesEndBalance : createdByBoardOfDirectors) {             directors.addAllByBoardOfDirectors(currentLawVotesEndBalance.getLaws());         }           positions.addAll(directors.getNames());         positions = positions.stream().distinct().collect(Collectors.toList());         model.addAttribute(\"positions\", positions);         return \"create-position\";     }      /**Отображается в браузере, позволяет создавать новые должности*/     @RequestMapping(value = \"/create-position\", method = RequestMethod.POST, params = \"action=/send\")     public String createLaw(Model model,                             @RequestParam String sender,                             @RequestParam String reward,                             @RequestParam String nameLaw,                             @RequestParam String[] laws,                             @RequestParam String password,                             RedirectAttributes redirectAttrs) throws IOException, NoSuchAlgorithmException, SignatureException, NoSuchProviderException, InvalidKeyException, InvalidKeySpecException {           Laws law = new Laws(nameLaw, Arrays.asList(laws));         Base base = new Base58();          Double rewardD = Double.parseDouble(reward);           DtoTransaction dtoTransaction = new DtoTransaction(                 sender,                 law.getHashLaw(),                 0.0,                 0.0,                 law,                 rewardD,                 VoteEnum.valueOf(\"YES\"));         PrivateKey privateKey = UtilsSecurity.privateBytToPrivateKey(base.decode(password));         byte[] sign = UtilsSecurity.sign(privateKey, dtoTransaction.toSign());          redirectAttrs.addFlashAttribute(\"title\", \"sending result!!!\");         redirectAttrs.addFlashAttribute(\"sender\", sender);          redirectAttrs.addFlashAttribute(\"recipient\", law.getHashLaw());         redirectAttrs.addFlashAttribute(\"dollar\", 0.0);         redirectAttrs.addFlashAttribute(\"stock\", 0.0);         redirectAttrs.addFlashAttribute(\"reward\", rewardD);         redirectAttrs.addFlashAttribute(\"vote\", \"YES\");         dtoTransaction.setSign(sign);          if (dtoTransaction.verify() && UtilsGovernment.checkPostionSenderEqualsLaw(sender, law)) {             redirectAttrs.addFlashAttribute(\"sending\", \"success\");             AllTransactions.addTransaction(dtoTransaction);             String jsonDto = UtilsJson.objToStringJson(dtoTransaction);              for (String s : Seting.ORIGINAL_ADDRESSES) {                 String original = s;                 String url = s + \"/addTransaction\";                 if (BasisController.getExcludedAddresses().contains(url)) {                     System.out.println(\"its your address or excluded address: \" + url);                     continue;                 }                 try {                     UtilUrl.sendPost(jsonDto, url);                  } catch (Exception e) {                     System.out.println(\"exception discovery: \" + original);                  }             }         } else             redirectAttrs.addFlashAttribute(\"sending\", \"wrong transaction\");          return \"redirect:/result-sending\";      } }","package International_Trade_Union.controllers;  import International_Trade_Union.config.BLockchainFactory; import International_Trade_Union.config.BlockchainFactoryEnum; import International_Trade_Union.entity.blockchain.Blockchain; import International_Trade_Union.entity.blockchain.block.Block; import International_Trade_Union.governments.Director; import International_Trade_Union.governments.Directors; import International_Trade_Union.governments.NamePOSITION; import International_Trade_Union.model.FIndPositonHelperData; import International_Trade_Union.model.Mining; import org.springframework.stereotype.Controller; import org.springframework.ui.Model; import org.springframework.web.bind.annotation.*; import org.springframework.web.servlet.mvc.support.RedirectAttributes; import International_Trade_Union.entity.DtoTransaction.DtoTransaction; import International_Trade_Union.governments.UtilsGovernment; import International_Trade_Union.model.Account; import International_Trade_Union.network.AllTransactions; import International_Trade_Union.setings.Seting; import International_Trade_Union.utils.*; import International_Trade_Union.utils.base.Base; import International_Trade_Union.utils.base.Base58; import International_Trade_Union.vote.*;  import java.io.IOException; import java.security.*; import java.security.spec.InvalidKeySpecException; import java.util.*; import java.util.stream.Collectors;   @Controller public class LawsController {       @GetMapping(\"detail-laws\")     public String details(Model model) {         return \"detail-laws\";     }      //TODO реализовать голосвание       /**Отображается в браузере, позволяет увидеть содержимое пакета законов, список действующих законов*/     @GetMapping(\"/detail-laws-current/{addressLaw}\")     public String lawsDetail(@PathVariable(value = \"addressLaw\") String addressLaw, RedirectAttributes redirectAttrs) throws NoSuchAlgorithmException, InvalidKeySpecException, IOException, SignatureException, NoSuchProviderException, InvalidKeyException {         System.out.println(\"LawsController detail-laws-current/{addressLaw}: \" + addressLaw);         redirectAttrs.addAttribute(\"title\", \"detail laws\");         //Seting.ORIGINAL_CURRENT_FEDERAL_LAWS_FILE         List<LawEligibleForParliamentaryApproval> lawEligibleForParliamentaryApprovals =                 UtilsLaws.readLineCurrentLaws(Seting.ORIGINAL_ALL_CORPORATION_LAWS_WITH_BALANCE_FILE);          List<String> currntLaws = new ArrayList<>();         for (LawEligibleForParliamentaryApproval lawEligibleForParliamentaryApproval : lawEligibleForParliamentaryApprovals) {             int i = 0;             if (lawEligibleForParliamentaryApproval.getLaws().getHashLaw().equals(addressLaw)) {                  for (String str : lawEligibleForParliamentaryApproval.getLaws().getLaws()) {                      currntLaws.add(\"\" + i + \": \" + str);                     ++i;                 }              }         }          currntLaws.forEach(System.out::println);         redirectAttrs.addFlashAttribute(\"laws\", currntLaws);         return \"redirect:/detail-laws\";     }      /**Отображается в браузере, показывает содержимое пакета законов, из  списка всех законов*/     @GetMapping(\"/detail-laws-all/{addressLaw}\")     public String lawsDetailAll(@PathVariable(value = \"addressLaw\") String addressLaw, RedirectAttributes redirectAttrs) throws NoSuchAlgorithmException, InvalidKeySpecException, IOException, SignatureException, NoSuchProviderException, InvalidKeyException {         System.out.println(\"LawsController /detail-laws-all/{addressLaw}: \" + addressLaw);         redirectAttrs.addAttribute(\"title\", \"detail laws\");         //ORIGINAL_ALL_CORPORATION_LAWS_FILE         List<Laws> laws = UtilsLaws.readLineLaws(Seting.ORIGINAL_ALL_CORPORATION_LAWS_FILE);         List<String> allLaws = new ArrayList<>();         for (Laws laws1 : laws) {             int i = 0;             if (laws1.getHashLaw().equals(addressLaw)) {                  for (String s : laws1.getLaws()) {                     allLaws.add(\"\" + i + \": \" + s);                     ++i;                 }              }         }          redirectAttrs.addFlashAttribute(\"laws\", allLaws);         return \"redirect:/detail-laws\";     }       @GetMapping(\"/sanction\")     public String sanction(Model model){         return \"/sanction\";     }      @PostMapping(\"/sanction\")     public String sanction(             @RequestParam             String sender,             String recipient,             Double stock,             Double reward,             String password,             RedirectAttributes redirectAttrs      ) throws IOException, NoSuchAlgorithmException, SignatureException, InvalidKeySpecException, NoSuchProviderException, InvalidKeyException {         Base base = new Base58();          Laws laws =  new Laws();         laws.setLaws(new ArrayList<>());         laws.setHashLaw(\"\");         laws.setPacketLawName(\"\");         DtoTransaction dtoTransaction = new DtoTransaction(                 sender,                 recipient,                 0.0,                 stock,                 laws,                 reward,                 VoteEnum.NO);         PrivateKey privateKey = UtilsSecurity.privateBytToPrivateKey(base.decode(password));         byte[] sign = UtilsSecurity.sign(privateKey, dtoTransaction.toSign());         System.out.println(\"Main Controller: new transaction: vote: \" + VoteEnum.NO);         redirectAttrs.addFlashAttribute(\"title\", \"sending result!!!\");         redirectAttrs.addFlashAttribute(\"sender\", sender);         redirectAttrs.addFlashAttribute(\"recipient\", recipient);         redirectAttrs.addFlashAttribute(\"dollar\", 0.0);         redirectAttrs.addFlashAttribute(\"stock\", stock);         redirectAttrs.addFlashAttribute(\"reward\", reward);         redirectAttrs.addFlashAttribute(\"vote\", VoteEnum.NO);         dtoTransaction.setSign(sign);         Directors directors = new Directors();         if(dtoTransaction.verify()){              //если в названия закона совпадает с корпоративными должностями, то закон является действительным только когда             //отправитель совпадает с законом             List<String> corporateSeniorPositions = directors.getDirectors().stream()                     .map(t->t.getName()).collect(Collectors.toList());             System.out.println(\"LawsController: create_law: \" + laws.getPacketLawName() + \"contains: \" + corporateSeniorPositions.contains(laws.getPacketLawName()));             if(corporateSeniorPositions.contains(laws.getPacketLawName()) && !UtilsGovernment.checkPostionSenderEqualsLaw(sender, laws)){                 redirectAttrs.addFlashAttribute(\"sending\", \"wrong transaction: Position to be equals whith send\");                 return \"redirect:/result-sending\";             }             redirectAttrs.addFlashAttribute(\"sending\", \"success\");             System.out.println(\"dto MainController: \" + dtoTransaction);              AllTransactions.addTransaction(dtoTransaction);             String jsonDto = UtilsJson.objToStringJson(dtoTransaction);             for (String s : Seting.ORIGINAL_ADDRESSES) {                  String original = s;                 String url = s +\"/addTransaction\";                 //если адресс совпадает с внутреним хостом, то не отправляет самому себе                 if(BasisController.getExcludedAddresses().contains(url)){                     System.out.println(\"MainController: its your address or excluded address: \" + url);                     continue;                 }                 try {                     //отправка в сеть                     UtilUrl.sendPost(jsonDto, url);                  }catch (Exception e){                     System.out.println(\"exception discover: \" + original);                  }             }            }          else             redirectAttrs.addFlashAttribute(\"sending\", \"wrong transaction\");         return \"redirect:/result-sending\";     }     /**Голосование учитывает голоса как акций, так и голоса избраных представителей*/     @GetMapping(\"/voting\")     public String lawVoting(){         return \"/voting\";     }     @PostMapping(\"/voting\")     public String lawVoting(             @RequestParam             String sender,             String recipient,             Double reward,             String vote,             String password,             RedirectAttributes redirectAttrs      ) throws IOException, NoSuchAlgorithmException, SignatureException, InvalidKeySpecException, NoSuchProviderException, InvalidKeyException {         Base base = new Base58();         vote = vote.toUpperCase(Locale.ROOT);         Laws laws =  new Laws();         laws.setLaws(new ArrayList<>());         laws.setHashLaw(\"\");         laws.setPacketLawName(\"\");         System.out.println(\"LawController: Voting: \" + VoteEnum.valueOf(vote));         DtoTransaction dtoTransaction = new DtoTransaction(                 sender,                 recipient,                 0.0,                 0.0,                 laws,                 reward,                 VoteEnum.valueOf(vote));         PrivateKey privateKey = UtilsSecurity.privateBytToPrivateKey(base.decode(password));         byte[] sign = UtilsSecurity.sign(privateKey, dtoTransaction.toSign());         System.out.println(\"Main Controller: new transaction: vote: \" + vote);         redirectAttrs.addFlashAttribute(\"title\", \"sending result!!!\");         redirectAttrs.addFlashAttribute(\"sender\", sender);         redirectAttrs.addFlashAttribute(\"recipient\", recipient);         redirectAttrs.addFlashAttribute(\"dollar\", 0.0);         redirectAttrs.addFlashAttribute(\"stock\", 0.0);         redirectAttrs.addFlashAttribute(\"reward\", reward);         redirectAttrs.addFlashAttribute(\"vote\", vote);         dtoTransaction.setSign(sign);         Directors directors = new Directors();         if(dtoTransaction.verify()){              //если в названия закона совпадает с корпоративными должностями, то закон является действительным только когда             //отправитель совпадает с законом             List<String> corporateSeniorPositions = directors.getDirectors().stream()                     .map(t->t.getName()).collect(Collectors.toList());             System.out.println(\"LawsController: create_law: \" + laws.getPacketLawName() + \"contains: \" + corporateSeniorPositions.contains(laws.getPacketLawName()));             if(corporateSeniorPositions.contains(laws.getPacketLawName()) && !UtilsGovernment.checkPostionSenderEqualsLaw(sender, laws)){                 redirectAttrs.addFlashAttribute(\"sending\", \"wrong transaction: Position to be equals whith send\");                 return \"redirect:/result-sending\";             }             redirectAttrs.addFlashAttribute(\"sending\", \"success\");             System.out.println(\"dto MainController: \" + dtoTransaction);              AllTransactions.addTransaction(dtoTransaction);             String jsonDto = UtilsJson.objToStringJson(dtoTransaction);             for (String s : Seting.ORIGINAL_ADDRESSES) {                  String original = s;                 String url = s +\"/addTransaction\";                 //если адресс совпадает с внутреним хостом, то не отправляет самому себе                 if(BasisController.getExcludedAddresses().contains(url)){                     System.out.println(\"MainController: its your address or excluded address: \" + url);                     continue;                 }                 try {                     //отправка в сеть                     UtilUrl.sendPost(jsonDto, url);                  }catch (Exception e){                     System.out.println(\"exception discover: \" + original);                  }             }            }          else             redirectAttrs.addFlashAttribute(\"sending\", \"wrong transaction\");         return \"redirect:/result-sending\";     }     /**Отображается в браузере, список все действующих законов*/     @GetMapping(\"/current-laws\")     public String currentLaw(Model model) throws IOException, NoSuchAlgorithmException, InvalidKeySpecException, SignatureException, NoSuchProviderException, InvalidKeyException, CloneNotSupportedException {         Directors directors = new Directors();         Blockchain blockchain = Mining.getBlockchain(                 Seting.ORIGINAL_BLOCKCHAIN_FILE,                 BlockchainFactoryEnum.ORIGINAL);          Map<String, Account> balances = new HashMap<>();         //считывать баланс         balances = SaveBalances.readLineObject(Seting.ORIGINAL_BALANCE_FILE);          List<LawEligibleForParliamentaryApproval> lawEligibleForParliamentaryApprovals =                 UtilsLaws.readLineCurrentLaws(Seting.ORIGINAL_ALL_CORPORATION_LAWS_WITH_BALANCE_FILE);          //получить совет акционеров из файла         List<Account> boardOfShareholders = UtilsGovernment.findBoardOfShareholders(balances, blockchain.getBlockchainList(), Seting.BOARDS_BLOCK);           //TODO доработать оптимизацию         //TODO избавиться от find position в данном методе         //отфильтровать по типам голосов         Map<Director, FIndPositonHelperData> fIndPositonHelperDataMap = new HashMap<>();         for (Director higherSpecialPositions : directors.getDirectors()) {             if (higherSpecialPositions.isElectedByCEO()) {                 fIndPositonHelperDataMap.put(higherSpecialPositions,                         new FIndPositonHelperData(higherSpecialPositions, false, false, true, false, false));             } else if (higherSpecialPositions.isElectedByBoardOfDirectors()) {                 fIndPositonHelperDataMap.put(higherSpecialPositions,                         new FIndPositonHelperData(higherSpecialPositions, false, false, false, true, false));             } else if (higherSpecialPositions.isElectedByCorporateCouncilOfReferees()) {                 fIndPositonHelperDataMap.put(higherSpecialPositions,                         new FIndPositonHelperData(higherSpecialPositions, false, false, false, false, true));             } else {                 fIndPositonHelperDataMap.put(higherSpecialPositions,                         new FIndPositonHelperData(higherSpecialPositions, true, true, false, false, false));              }          }         //подсчитать голоса за все проголосованные заканы         List<CurrentLawVotesEndBalance> current = UtilsGovernment.filtersVotes(                 lawEligibleForParliamentaryApprovals,                 balances,                 boardOfShareholders,                 blockchain.getBlockchainList(),                 Seting.LAW_YEAR_VOTE);             //минимальное значение количество положительных голосов для того чтобы закон действовал,         //позиции избираемые акциями совета директоров         List<CurrentLawVotesEndBalance> electedByStockBoardOfDirectors = current.stream()                 .filter(t -> directors.isElectedByStocks(t.getPackageName()))                 .filter(t -> t.getPackageName().equals(NamePOSITION.BOARD_OF_DIRECTORS.toString()))                 .filter(t -> t.getVotes() >= Seting.ORIGINAL_LIMIT_MIN_VOTE)                 .sorted(Comparator.comparing(CurrentLawVotesEndBalance::getVotes).reversed())                 .limit(directors.getDirector(NamePOSITION.BOARD_OF_DIRECTORS.toString()).getCount())                 .collect(Collectors.toList());          //избранные фракции         List<CurrentLawVotesEndBalance> electedFraction = current.stream()                 .filter(t -> directors.isElectedByStocks(t.getPackageName()))                 .filter(t -> t.getPackageName().equals(NamePOSITION.FRACTION.toString()))                 .filter(t -> t.getVotes() >= Seting.ORIGINAL_LIMIT_MIN_VOTE)                 .sorted(Comparator.comparing(CurrentLawVotesEndBalance::getVotes).reversed())                 .limit(directors.getDirector(NamePOSITION.FRACTION.toString()).getCount())                 .collect(Collectors.toList());         //минимальное значение количество положительных голосов для того чтобы закон действовал,         //позиции избираемые акциями CORPORATE_COUNCIL_OF_REFEREES         List<CurrentLawVotesEndBalance> electedByStockCorporateCouncilOfReferees = current.stream()                 .filter(t -> directors.isElectedByStocks(t.getPackageName()))                 .filter(t -> t.getPackageName().equals(NamePOSITION.CORPORATE_COUNCIL_OF_REFEREES.toString()))                 .filter(t -> t.getVotes() >= Seting.ORIGINAL_LIMIT_MIN_VOTE)                 .sorted(Comparator.comparing(CurrentLawVotesEndBalance::getVotes).reversed())                 .limit(directors.getDirector(NamePOSITION.CORPORATE_COUNCIL_OF_REFEREES.toString()).getCount())                 .collect(Collectors.toList());            //позиции созданные всеми участниками         List<CurrentLawVotesEndBalance> createdByBoardOfDirectors = current.stream()                 .filter(t->t.getPackageName().startsWith(Seting.ADD_DIRECTOR))                 .filter(t->t.getVotesBoardOfDirectors() >= Seting.ORIGINAL_LIMIT_MIN_VOTE_BOARD_OF_DIRECTORS                 && t.getVotesBoardOfShareholders() >= Seting.ORIGINAL_LIMIT_MIN_VOTE_BOARD_OF_SHAREHOLDERS                 && t.getFractionVote() >= Seting.ORIGINAL_LIMIT_MIN_VOTE_FRACTIONS                 && t.getVotes() >= Seting.ALL_STOCK_VOTE)                 .collect(Collectors.toList());         //добавление позиций созданных советом директоров         for (CurrentLawVotesEndBalance currentLawVotesEndBalance : createdByBoardOfDirectors) {             directors.addAllByBoardOfDirectors(currentLawVotesEndBalance.getLaws());         }          //позиции избираемые только всеми участниками         List<CurrentLawVotesEndBalance> electedByBoardOfDirectors = current.stream()                 .filter(t -> directors.isElectedByBoardOfDirectors(t.getPackageName()) || directors.isCabinets(t.getPackageName()))                 .filter(t -> t.getVotesBoardOfDirectors() >= Seting.ORIGINAL_LIMIT_MIN_VOTE_BOARD_OF_DIRECTORS                 && t.getVotesBoardOfShareholders() >= Seting.ORIGINAL_LIMIT_MIN_VOTE_BOARD_OF_SHAREHOLDERS                 && t.getFractionVote() >= Seting.ORIGINAL_LIMIT_MIN_VOTE_FRACTIONS                 && t.getVotes() >= Seting.ALL_STOCK_VOTE)                 .sorted(Comparator.comparing(CurrentLawVotesEndBalance::getVotesBoardOfDirectors).reversed())                 .collect(Collectors.toList());           //групируем по списку         Map<String, List<CurrentLawVotesEndBalance>> group = electedByBoardOfDirectors.stream()                 .collect(Collectors.groupingBy(CurrentLawVotesEndBalance::getPackageName));          Map<Director, List<CurrentLawVotesEndBalance>> original_group = new HashMap<>();          //оставляем то количество которое описано в данной должности         for (Map.Entry<String, List<CurrentLawVotesEndBalance>> stringListEntry : group.entrySet()) {             List<CurrentLawVotesEndBalance> temporary = stringListEntry.getValue();             temporary = temporary.stream()                     .sorted(Comparator.comparing(CurrentLawVotesEndBalance::getVotesBoardOfDirectors))                     .limit(directors.getDirector(stringListEntry.getKey()).getCount())                     .collect(Collectors.toList());             original_group.put(directors.getDirector(stringListEntry.getKey()), temporary);         }            //позиции избираемые советом корпоративных верховных судей         List<CurrentLawVotesEndBalance> electedByCorporateCouncilOfReferees = current.stream()                 .filter(t -> directors.isElectedBYCorporateCouncilOfReferees(t.getPackageName()))                 .filter(t -> t.getVotesCorporateCouncilOfReferees() >= Seting.ORIGINAL_LIMIT_MIN_VOTE_CORPORATE_COUNCIL_OF_REFEREES)                 .sorted(Comparator.comparing(CurrentLawVotesEndBalance::getVotesCorporateCouncilOfReferees)).collect(Collectors.toList());           //избираемые GENERAL_EXECUTIVE_DIRECTOR         List<CurrentLawVotesEndBalance> electedByGeneralExecutiveDirector = electedByBoardOfDirectors.stream()                 .filter(t -> directors.isElectedCEO(t.getPackageName()))                 .filter(t -> NamePOSITION.GENERAL_EXECUTIVE_DIRECTOR.toString().equals(t.getPackageName()))                 .filter(t -> t.getVoteGeneralExecutiveDirector() >= Seting.ORIGINAL_LIMIT_MIN_VOTE_GENERAL_EXECUTIVE_DIRECTOR)                 .sorted(Comparator.comparing(CurrentLawVotesEndBalance::getVoteGeneralExecutiveDirector))                 .collect(Collectors.toList());          //голос верховного судьи         List<CurrentLawVotesEndBalance> electedByHightJudge = electedByCorporateCouncilOfReferees.stream()                 .filter(t -> directors.isElectedBYCorporateCouncilOfReferees(t.getPackageName()))                 .filter(t -> t.getVoteHightJudge() >= Seting.ORIGINAL_LIMIT_MIN_VOTE_HIGHT_JUDGE)                 .collect(Collectors.toList());           //законы должны быть одобрены всеми.         List<CurrentLawVotesEndBalance> notEnoughVotes = current.stream()                 .filter(t -> !directors.contains(t.getPackageName()))                 .filter(t->!Seting.AMENDMENT_TO_THE_CHARTER.equals(t.getPackageName()))                 .filter(t->!directors.isCabinets(t.getPackageName()))                 .filter(t -> !Seting.ORIGINAL_CHARTER_CURRENT_LAW_PACKAGE_NAME.equals(t.getPackageName()))                 .filter(t->!Seting.ORIGINAL_CHARTER_CURRENT_ALL_CODE.equals(t.getPackageName()))                 .filter(t -> t.getVotesBoardOfShareholders() >= Seting.ORIGINAL_LIMIT_MIN_VOTE_BOARD_OF_SHAREHOLDERS                 && t.getVotesBoardOfDirectors() >= Seting.ORIGINAL_LIMIT_MIN_VOTE_BOARD_OF_DIRECTORS                 && t.getVotes() >= Seting.ALL_STOCK_VOTE                 && t.getFractionVote() >= Seting.ORIGINAL_LIMIT_MIN_VOTE_FRACTIONS)                 .sorted(Comparator.comparing(CurrentLawVotesEndBalance::getVotes).reversed()).collect(Collectors.toList());            //внедрение поправок в устав         List<CurrentLawVotesEndBalance> chapter_amendment = current.stream()                 .filter(t -> !directors.contains(t.getPackageName()))                 .filter(t-> Seting.AMENDMENT_TO_THE_CHARTER.equals(t.getPackageName()))                 .filter(t->!directors.isCabinets(t.getPackageName()))                 .filter(t -> t.getVotesBoardOfShareholders() >= Seting.ORIGINAL_LIMIT_MINT_VOTE_BOARD_OF_SHAREHOLDERS_AMENDMENT                 && t.getVotesBoardOfDirectors() >= Seting.ORIGINAL_LIMIT_MIN_VOTE_BOARD_OF_DIRECTORS_AMENDMENT                 && t.getVotesCorporateCouncilOfReferees() >= Seting.ORIGINAL_LIMIT_MIN_VOTE_CORPORATE_COUNCIL_OF_REFEREES_AMENDMENT                 && t.getFractionVote() >= Seting.ORIGINAL_LIMIT_MIN_VOTE_FRACTIONS)                 .sorted(Comparator.comparing(CurrentLawVotesEndBalance::getVotesBoardOfDirectors).reversed()).collect(Collectors.toList());          //бюджет утверждается всеми         List<CurrentLawVotesEndBalance> budjet = current.stream()                 .filter(t-> !directors.contains(t.getPackageName()))                 .filter(t->Seting.BUDGET.equals(t.getPackageName()))                 .filter(t->!directors.isCabinets(t.getPackageName()))                 .filter(t->                         t.getVotesBoardOfDirectors() >= Seting.ORIGINAL_LIMIT_MIN_VOTE_BOARD_OF_DIRECTORS                         && t.getVotesBoardOfShareholders() >= Seting.ORIGINAL_LIMIT_MIN_VOTE_BOARD_OF_SHAREHOLDERS                         && t.getFractionVote() >= Seting.ORIGINAL_LIMIT_MIN_VOTE_FRACTIONS                         && t.getVotes() >= Seting.ALL_STOCK_VOTE)                 .sorted(Comparator.comparing(CurrentLawVotesEndBalance::getVotesBoardOfDirectors).reversed())                 .limit(1)                 .collect(Collectors.toList());           //добавляет законы, которые создают новые должности утверждается всеми         List<CurrentLawVotesEndBalance> addDirectors = current.stream()                 .filter(t->t.getPackageName().startsWith(Seting.ADD_DIRECTOR))                 .filter(t->t.getVotesBoardOfDirectors() >= Seting.ORIGINAL_LIMIT_MIN_VOTE_BOARD_OF_DIRECTORS                 && t.getVotesBoardOfShareholders() >= Seting.ORIGINAL_LIMIT_MIN_VOTE_BOARD_OF_SHAREHOLDERS                 && t.getFractionVote() >= Seting.ORIGINAL_LIMIT_MIN_VOTE_FRACTIONS                 && t.getVotes() >= Seting.ALL_STOCK_VOTE)                 .collect(Collectors.toList());          //план утверждается всеми         List<CurrentLawVotesEndBalance> planFourYears = current.stream()                 .filter(t->!directors.contains(t.getPackageName()))                 .filter(t->Seting.STRATEGIC_PLAN.equals(t.getPackageName()))                 .filter(t->!directors.isCabinets(t.getPackageName()))                 .filter(t->t.getVotesBoardOfDirectors() >= Seting.ORIGINAL_LIMIT_MIN_VOTE_BOARD_OF_DIRECTORS                         && t.getVotesBoardOfShareholders() >= Seting.ORIGINAL_LIMIT_MIN_VOTE_BOARD_OF_SHAREHOLDERS                         && t.getFractionVote() >= Seting.ORIGINAL_LIMIT_MIN_VOTE_FRACTIONS                         && t.getVotes() >= Seting.ALL_STOCK_VOTE)                 .sorted(Comparator.comparing(CurrentLawVotesEndBalance::getVotesBoardOfDirectors).reversed())                 .limit(1)                 .collect(Collectors.toList());           //устав всегда действующий он подписан основателем         List<CurrentLawVotesEndBalance> CHARTER_ORIGINAL = current.stream()                 .filter(t -> !directors.contains(t.getPackageName()) && Seting.ORIGINAL_CHARTER_CURRENT_LAW_PACKAGE_NAME.equals(t.getPackageName()))                 .filter(t->!directors.isCabinets(t.getPackageName()))                 .filter(t->t.getFounderVote()>=1)                 .sorted(Comparator.comparing(CurrentLawVotesEndBalance::getVotes).reversed())                 .limit(1)                 .collect(Collectors.toList());          //ИСХОДНЫЙ КОД СОЗДАННЫЙ ОСНОВАТЕЛЕМ         List<CurrentLawVotesEndBalance> CHARTER_ORIGINAL_CODE = current.stream()                 .filter(t -> !directors.contains(t.getPackageName()) && Seting.ORIGINAL_CHARTER_CURRENT_ALL_CODE.equals(t.getPackageName()))                 .filter(t->!directors.isCabinets(t.getPackageName()))                 .filter(t->t.getFounderVote()>=1)                 .sorted(Comparator.comparing(CurrentLawVotesEndBalance::getVotes).reversed())                 .limit(1)                 .collect(Collectors.toList());           int startBlock = 23660;         int finishBlock = 23670;         if(blockchain.sizeBlockhain() > finishBlock){             List<Block> blocksCharter = blockchain.subBlock(startBlock, finishBlock);             //учитывает отрезок блоков для выяснения подлиности устава             List<CurrentLawVotesEndBalance> charterBlocks = UtilsGovernment.filtersVotes(                     lawEligibleForParliamentaryApprovals,                     balances,                     boardOfShareholders,                     blocksCharter,                     Seting.LAW_YEAR_VOTE             );             List<CurrentLawVotesEndBalance> charterCheckBlock = charterBlocks.stream()                     .filter(t -> !directors.contains(t.getPackageName()) && Seting.ORIGINAL_CHARTER_CURRENT_LAW_PACKAGE_NAME.equals(t.getPackageName()))                     .filter(t->!directors.isCabinets(t.getPackageName()))                     .filter(t->t.getFounderVote()>=1)                     .sorted(Comparator.comparing(CurrentLawVotesEndBalance::getVotes).reversed())                     .limit(1)                     .collect(Collectors.toList());              CHARTER_ORIGINAL.addAll(charterCheckBlock);               List<CurrentLawVotesEndBalance> charterOriginalCode = charterBlocks.stream()                     .filter(t -> !directors.contains(t.getPackageName()) && Seting.ORIGINAL_CHARTER_CURRENT_ALL_CODE.equals(t.getPackageName()))                     .filter(t->!directors.isCabinets(t.getPackageName()))                     .filter(t->t.getFounderVote()>=1)                     .sorted(Comparator.comparing(CurrentLawVotesEndBalance::getVotes).reversed())                     .limit(1)                     .collect(Collectors.toList());              CHARTER_ORIGINAL_CODE.addAll(charterOriginalCode);         }           for (Map.Entry<Director, List<CurrentLawVotesEndBalance>> higherSpecialPositionsListMap : original_group.entrySet()) {             current.addAll(higherSpecialPositionsListMap.getValue());         }           current = new ArrayList<>();         current.addAll(addDirectors);         current.addAll(budjet);         current.addAll(electedFraction);         current.addAll(planFourYears);         current.addAll(electedByStockBoardOfDirectors);         current.addAll(electedByStockCorporateCouncilOfReferees);         current.addAll(electedByBoardOfDirectors);         current.addAll(electedByCorporateCouncilOfReferees);         current.addAll(electedByGeneralExecutiveDirector);         current.addAll(electedByHightJudge);         current.addAll(notEnoughVotes);         current.addAll(CHARTER_ORIGINAL);         current.addAll(CHARTER_ORIGINAL_CODE);         current.addAll(chapter_amendment);         current = current.stream()                 .filter(UtilsUse.distinctByKey(CurrentLawVotesEndBalance::getAddressLaw))                 .collect(Collectors.toList());         System.out.println(\"notEnoughVotes: \" + notEnoughVotes);          model.addAttribute(\"title\", \"How the current laws are made is described in the charter.\" +                 \" \");         model.addAttribute(\"currentLaw\", current);         return \"current-laws\";     }      /**Отображается в браузере, список всех пакета законов*/     @GetMapping(\"/all-laws\")     public String allLaws(Model model) throws IOException, NoSuchAlgorithmException, InvalidKeySpecException, SignatureException, NoSuchProviderException, InvalidKeyException {         Blockchain blockchain = Mining.getBlockchain(                 Seting.ORIGINAL_BLOCKCHAIN_FILE,                 BlockchainFactoryEnum.ORIGINAL);          Map<String, Account> balances = new HashMap<>();         balances = SaveBalances.readLineObject(Seting.ORIGINAL_BALANCE_FILE);           List<Account> boardOfShareholders = UtilsGovernment.findBoardOfShareholders(balances, blockchain.getBlockchainList(), Seting.BOARDS_BLOCK);           List<LawEligibleForParliamentaryApproval> lawEligibleForParliamentaryApprovals =                 UtilsLaws.readLineCurrentLaws(Seting.ORIGINAL_ALL_CORPORATION_LAWS_WITH_BALANCE_FILE);         //данные для отображения           Directors directors = new Directors();         //TODO доработать оптимизацию         //TODO избавиться от find position в данном методе         //TODO доработать оптимизацию         //TODO избавиться от find position в данном методе         Map<Director, FIndPositonHelperData> fIndPositonHelperDataMap = new HashMap<>();         for (Director higherSpecialPositions : directors.getDirectors()) {             if (higherSpecialPositions.isElectedByCEO()) {                 fIndPositonHelperDataMap.put(higherSpecialPositions,                         new FIndPositonHelperData(higherSpecialPositions, false, false, true, false, false));             } else if (higherSpecialPositions.isElectedByBoardOfDirectors()) {                 fIndPositonHelperDataMap.put(higherSpecialPositions,                         new FIndPositonHelperData(higherSpecialPositions, false, false, false, true, false));             } else if (higherSpecialPositions.isElectedByCorporateCouncilOfReferees()) {                 fIndPositonHelperDataMap.put(higherSpecialPositions,                         new FIndPositonHelperData(higherSpecialPositions, false, false, false, false, true));             } else if (higherSpecialPositions.isElectedByStocks()) {                 fIndPositonHelperDataMap.put(higherSpecialPositions,                         new FIndPositonHelperData(higherSpecialPositions, true, true, false, false, false));              }          }           List<CurrentLawVotesEndBalance> current = UtilsGovernment.filtersVotes(                 lawEligibleForParliamentaryApprovals,                 balances,                 boardOfShareholders,                 blockchain.getBlockchainList(),                 Seting.LAW_YEAR_VOTE);           current = current.stream().distinct().collect(Collectors.toList());          current = current.stream().sorted(Comparator.comparing(CurrentLawVotesEndBalance::getVotes).reversed()).collect(Collectors.toList());         model.addAttribute(\"allLaws\", current);         return \"all-laws\";     }       /**Создать новую должность*/     @GetMapping(\"/add_position\")     public String addPostion(Model model){         model.addAttribute(\"title\", \"Create a new position\");         return \"add_position\";     }      @PostMapping(\"/add_position\")     public String addPosition( @RequestParam String sender,                                @RequestParam String reward,                                @RequestParam String nameLaw,                                @RequestParam String[] laws,                                @RequestParam String password,                                RedirectAttributes redirectAttrs) throws IOException, NoSuchAlgorithmException, SignatureException, InvalidKeySpecException, NoSuchProviderException, InvalidKeyException {          nameLaw = Seting.ADD_DIRECTOR + nameLaw;         String[] lawsAdd = new String[laws.length];         for (int i = 0; i < laws.length; i++) {             lawsAdd[i] = Seting.ADD_DIRECTOR + laws[i];         }         laws = lawsAdd;          Laws law = new Laws(nameLaw, Arrays.asList(laws));         Base base = new Base58();          Double rewardD = Double.parseDouble(reward);           DtoTransaction dtoTransaction = new DtoTransaction(                 sender,                 law.getHashLaw(),                 0.0,                 0.0,                 law,                 rewardD,                 VoteEnum.valueOf(\"YES\"));         PrivateKey privateKey = UtilsSecurity.privateBytToPrivateKey(base.decode(password));         byte[] sign = UtilsSecurity.sign(privateKey, dtoTransaction.toSign());          redirectAttrs.addFlashAttribute(\"title\", \"sending result!!!\");         redirectAttrs.addFlashAttribute(\"sender\", sender);          redirectAttrs.addFlashAttribute(\"recipient\", law.getHashLaw());         redirectAttrs.addFlashAttribute(\"dollar\", 0.0);         redirectAttrs.addFlashAttribute(\"stock\", 0.0);         redirectAttrs.addFlashAttribute(\"reward\", rewardD);         redirectAttrs.addFlashAttribute(\"vote\", \"YES\");         dtoTransaction.setSign(sign);          Directors directors = new Directors();         if (dtoTransaction.verify()) {              //если в названия закона совпадает с корпоративными должностями, то закон является действительным только когда             //отправитель совпадает с законом             List<Director> enumPosition = directors.getDirectors();             List<String> corporateSeniorPositions = enumPosition.stream()                     .map(t->t.getName())                     .collect(Collectors.toList());              if (corporateSeniorPositions.contains(law.getPacketLawName()) && !UtilsGovernment.checkPostionSenderEqualsLaw(sender, law)) {                 redirectAttrs.addFlashAttribute(\"sending\", \"wrong transaction: Position to be equals whith send\");                 return \"redirect:/result-sending\";             }              redirectAttrs.addFlashAttribute(\"sending\", \"success\");             AllTransactions.addTransaction(dtoTransaction);             String jsonDto = UtilsJson.objToStringJson(dtoTransaction);              for (String s : Seting.ORIGINAL_ADDRESSES) {                 String original = s;                 String url = s + \"/addTransaction\";                 if (BasisController.getExcludedAddresses().contains(url)) {                     System.out.println(\"its your address or excluded address: \" + url);                     continue;                 }                 try {                     UtilUrl.sendPost(jsonDto, url);                  } catch (Exception e) {                     System.out.println(\"exception discovery: \" + original);                  }             }         } else             redirectAttrs.addFlashAttribute(\"sending\", \"wrong transaction\");          return \"redirect:/result-sending\";      }      /**Отображается в браузере, позволяет создать новый пакет законов*/     @GetMapping(\"/create-law\")     public String createLawsShow(Model model) {         return \"create-law\";     }       @RequestMapping(value = \"/create-law\", method = RequestMethod.POST, params = \"action=/send\")     public String createLaw(Model model,                             @RequestParam String sender,                             @RequestParam String reward,                             @RequestParam String nameLaw,                             @RequestParam String[] laws,                             @RequestParam String password,                             RedirectAttributes redirectAttrs) throws IOException, NoSuchAlgorithmException, SignatureException, NoSuchProviderException, InvalidKeyException, InvalidKeySpecException {           Laws law = new Laws(nameLaw, Arrays.asList(laws));         Base base = new Base58();          Double rewardD = Double.parseDouble(reward);           DtoTransaction dtoTransaction = new DtoTransaction(                 sender,                 law.getHashLaw(),                 0.0,                 0.0,                 law,                 rewardD,                 VoteEnum.valueOf(\"YES\"));         PrivateKey privateKey = UtilsSecurity.privateBytToPrivateKey(base.decode(password));         byte[] sign = UtilsSecurity.sign(privateKey, dtoTransaction.toSign());          redirectAttrs.addFlashAttribute(\"title\", \"sending result!!!\");         redirectAttrs.addFlashAttribute(\"sender\", sender);          redirectAttrs.addFlashAttribute(\"recipient\", law.getHashLaw());         redirectAttrs.addFlashAttribute(\"dollar\", 0.0);         redirectAttrs.addFlashAttribute(\"stock\", 0.0);         redirectAttrs.addFlashAttribute(\"reward\", rewardD);         redirectAttrs.addFlashAttribute(\"vote\", \"YES\");         dtoTransaction.setSign(sign);          Directors directors = new Directors();         if (dtoTransaction.verify()) {              //если в названия закона совпадает с корпоративными должностями, то закон является действительным только когда             //отправитель совпадает с законом             List<Director> enumPosition = directors.getDirectors();             List<String> corporateSeniorPositions = enumPosition.stream()                     .map(t->t.getName())                     .collect(Collectors.toList());              if (corporateSeniorPositions.contains(law.getPacketLawName()) && !UtilsGovernment.checkPostionSenderEqualsLaw(sender, law)) {                 redirectAttrs.addFlashAttribute(\"sending\", \"wrong transaction: Position to be equals whith send\");                 return \"redirect:/result-sending\";             }              redirectAttrs.addFlashAttribute(\"sending\", \"success\");             AllTransactions.addTransaction(dtoTransaction);             String jsonDto = UtilsJson.objToStringJson(dtoTransaction);              for (String s : Seting.ORIGINAL_ADDRESSES) {                 String original = s;                 String url = s + \"/addTransaction\";                 if (BasisController.getExcludedAddresses().contains(url)) {                     System.out.println(\"its your address or excluded address: \" + url);                     continue;                 }                 try {                     UtilUrl.sendPost(jsonDto, url);                  } catch (Exception e) {                     System.out.println(\"exception discovery: \" + original);                  }             }         } else             redirectAttrs.addFlashAttribute(\"sending\", \"wrong transaction\");          return \"redirect:/result-sending\";      }  }","package International_Trade_Union.controllers;  import International_Trade_Union.about_us_engDraft.AboutUsEngDraft; import International_Trade_Union.governments.Director; import International_Trade_Union.governments.Directors; import International_Trade_Union.governments.UtilsGovernment; import International_Trade_Union.originalCorporateCharter.OriginalPreamble; import International_Trade_Union.originalCorporateCharter.OriginalPreambleEng;  import org.json.JSONException; import org.springframework.http.HttpStatus; import org.springframework.http.ResponseEntity; import org.springframework.stereotype.Controller; import org.springframework.ui.Model; import org.springframework.web.bind.annotation.GetMapping; import org.springframework.web.bind.annotation.PostMapping; import org.springframework.web.bind.annotation.RequestParam; import org.springframework.web.servlet.mvc.support.RedirectAttributes; import International_Trade_Union.entity.DtoTransaction.DtoTransaction; import International_Trade_Union.model.Account; import International_Trade_Union.model.User; import International_Trade_Union.network.AllTransactions; import International_Trade_Union.setings.Seting; import International_Trade_Union.utils.*; import International_Trade_Union.utils.base.Base; import International_Trade_Union.utils.base.Base58; import International_Trade_Union.vote.Laws; import International_Trade_Union.vote.VoteEnum;   import java.io.IOException; import java.net.http.WebSocket; import java.security.*; import java.security.spec.InvalidKeySpecException; import java.util.*; import java.util.stream.Collectors;  @Controller public class MainController {      @GetMapping(\"/\")     public String home(Model model) throws IOException, NoSuchAlgorithmException, InvalidKeySpecException, SignatureException, NoSuchProviderException, InvalidKeyException {           model.addAttribute(\"title\", \"Corporation International Trade Union.\");         Map<String, Account> balances = new HashMap<>();          //догрузить блокчейн //        List<Block> blocks = UtilsBlock.readLineObject(Seting.ORIGINAL_BLOCKCHAIN_FILE); //        balances = UtilsBalance.calculateBalances(blocks);         balances = SaveBalances.readLineObject(Seting.ORIGINAL_BALANCE_FILE);           Account account = UtilsBalance.getBalance(User.getUserAddress(), balances);         model.addAttribute(\"account\", account);          return \"home\";     }       @PostMapping(\"/setMinner\")     public String setMinnerAddress(@RequestParam(value = \"setMinner\") String setMinner, RedirectAttributes redirectAttrs){         System.out.println(\"MainController:  \" + setMinner);         UtilsFileSaveRead.save(setMinner, Seting.ORIGINAL_ACCOUNT, false);         return \"redirect:/home\";     }        @GetMapping(\"about\")     public String aboutUs(Model model){         model.addAttribute(\"title\", \"ABOUT US\");         model.addAttribute(\"eng\", OriginalPreambleEng.ARTICLE_0);         model.addAttribute(\"rus\", OriginalPreamble.ARTICLE_0);         return \"about\";     }     @GetMapping(\"result-sending\")     public String resultSending(Model model){          return \"result-sending\";     }      @PostMapping(\"/\")     public String new_transaction(             @RequestParam  String sender,             @RequestParam  String recipient,                                    Double dollar,                                    Double stock,                                    Double reward,                                    @RequestParam  String password,                                   RedirectAttributes redirectAttrs) throws IOException, NoSuchAlgorithmException, SignatureException, InvalidKeySpecException, NoSuchProviderException, InvalidKeyException {         Base base = new Base58();          Laws laws =  new Laws();         laws.setLaws(new ArrayList<>());         laws.setHashLaw(\"\");         laws.setPacketLawName(\"\");         DtoTransaction dtoTransaction = new DtoTransaction(                 sender,                 recipient,                 dollar,                 stock,                 laws,                 reward,                 VoteEnum.YES);         PrivateKey privateKey = UtilsSecurity.privateBytToPrivateKey(base.decode(password));         byte[] sign = UtilsSecurity.sign(privateKey, dtoTransaction.toSign());         System.out.println(\"Main Controller: new transaction: vote: \" +VoteEnum.YES);         redirectAttrs.addFlashAttribute(\"title\", \"sending result!!!\");         redirectAttrs.addFlashAttribute(\"sender\", sender);         redirectAttrs.addFlashAttribute(\"recipient\", recipient);         redirectAttrs.addFlashAttribute(\"dollar\", dollar);         redirectAttrs.addFlashAttribute(\"stock\", stock);         redirectAttrs.addFlashAttribute(\"reward\", reward);         redirectAttrs.addFlashAttribute(\"vote\", VoteEnum.YES);         dtoTransaction.setSign(sign);         Directors directors = new Directors();         if(dtoTransaction.verify()){              //если в названия закона совпадает с корпоративными должностями, то закон является действительным только когда             //отправитель совпадает с законом             List<String> corporateSeniorPositions = directors.getDirectors().stream()                     .map(t->t.getName()).collect(Collectors.toList());             System.out.println(\"LawsController: create_law: \" + laws.getPacketLawName() + \"contains: \" + corporateSeniorPositions.contains(laws.getPacketLawName()));             if(corporateSeniorPositions.contains(laws.getPacketLawName()) && !UtilsGovernment.checkPostionSenderEqualsLaw(sender, laws)){                 redirectAttrs.addFlashAttribute(\"sending\", \"wrong transaction: Position to be equals whith send\");                 return \"redirect:/result-sending\";             }             redirectAttrs.addFlashAttribute(\"sending\", \"success\");             System.out.println(\"dto MainController: \" + dtoTransaction);              AllTransactions.addTransaction(dtoTransaction);             String jsonDto = UtilsJson.objToStringJson(dtoTransaction);             for (String s : Seting.ORIGINAL_ADDRESSES) {                  String original = s;                 String url = s +\"/addTransaction\";                 //если адресс совпадает с внутреним хостом, то не отправляет самому себе                 if(BasisController.getExcludedAddresses().contains(url)){                     System.out.println(\"MainController: its your address or excluded address: \" + url);                     continue;                 }                 try {                     //отправка в сеть                     UtilUrl.sendPost(jsonDto, url);                  }catch (Exception e){                     System.out.println(\"exception discover: \" + original);                  }             }            }          else             redirectAttrs.addFlashAttribute(\"sending\", \"wrong transaction\");         return \"redirect:/result-sending\";     }       @GetMapping(\"/seting\")     public String seting(Model model){         model.addAttribute(\"title\", \"Settings\");         return \"seting\";     }   }","package International_Trade_Union.controllers;  import International_Trade_Union.config.BLockchainFactory; import International_Trade_Union.config.BlockchainFactoryEnum; import International_Trade_Union.entity.blockchain.Blockchain; import International_Trade_Union.model.Account; import International_Trade_Union.model.User; import International_Trade_Union.setings.Seting; import International_Trade_Union.utils.SaveBalances; import International_Trade_Union.utils.UtilsBalance; import org.springframework.stereotype.Controller; import org.springframework.ui.Model; import org.springframework.web.bind.annotation.GetMapping; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RestController;  import java.io.IOException; import java.security.InvalidKeyException; import java.security.NoSuchAlgorithmException; import java.security.NoSuchProviderException; import java.security.SignatureException; import java.security.spec.InvalidKeySpecException; import java.util.HashMap; import java.util.Map;  @Controller public class MineController {     private static Blockchain blockchain;     static {         try {             blockchain = BLockchainFactory.getBlockchain(BlockchainFactoryEnum.ORIGINAL);         } catch (NoSuchAlgorithmException e) {             throw new RuntimeException(e);         } catch (InvalidKeySpecException e) {             throw new RuntimeException(e);         } catch (IOException e) {             throw new RuntimeException(e);         } catch (SignatureException e) {             throw new RuntimeException(e);         } catch (NoSuchProviderException e) {             throw new RuntimeException(e);         } catch (InvalidKeyException e) {             throw new RuntimeException(e);         }     }      @RequestMapping(\"/mining\")     public String miming(Model model) throws IOException, NoSuchAlgorithmException, InvalidKeySpecException, SignatureException, NoSuchProviderException, InvalidKeyException {         model.addAttribute(\"title\", \"Corporation International Trade Union.\");          return \"mining\";     }    }","package International_Trade_Union.controllers;  import International_Trade_Union.entity.DtoTransaction.DtoTransaction; import International_Trade_Union.network.AllTransactions; import org.springframework.http.MediaType; import org.springframework.web.bind.annotation.RequestBody; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RequestMethod; import org.springframework.web.bind.annotation.RestController;  import java.io.IOException; import java.security.InvalidKeyException; import java.security.NoSuchAlgorithmException; import java.security.NoSuchProviderException; import java.security.SignatureException; import java.security.spec.InvalidKeySpecException;  @RestController public class TransactionController {     @RequestMapping(method = RequestMethod.POST, value = \"/addTransaction\", consumes = MediaType.APPLICATION_JSON_VALUE)     public  void add(@RequestBody DtoTransaction data) throws IOException, NoSuchAlgorithmException, SignatureException, InvalidKeySpecException, NoSuchProviderException, InvalidKeyException {         System.out.println(\"add transaction: \" + data);         AllTransactions.getInstance();         AllTransactions.addTransaction(data);         System.out.println(\"TransactionController: add: \" + AllTransactions.getInstance().size());     }  }","package International_Trade_Union.entity.blockchain.block;  import International_Trade_Union.entity.DtoTransaction.DtoTransaction; import International_Trade_Union.exception.NotValidTransactionException; import International_Trade_Union.utils.UtilsJson; import International_Trade_Union.utils.UtilsUse; import com.fasterxml.jackson.annotation.JsonAutoDetect;  import lombok.Data;  import java.io.IOException; import java.security.InvalidKeyException; import java.security.NoSuchAlgorithmException; import java.security.NoSuchProviderException; import java.security.SignatureException; import java.security.spec.InvalidKeySpecException; import java.sql.Timestamp; import java.util.List; import java.util.Objects;  @JsonAutoDetect @Data public final class Block implements Cloneable {     private List<DtoTransaction> dtoTransactions;     private String previousHash;     private String minerAddress;     private String founderAddress;     private long randomNumberProof;     private double minerRewards;     private int hashCompexity;     private Timestamp timestamp;     private long index;     private String hashBlock;      public Block(List<DtoTransaction> dtoTransactions,  String previousHex, String minerAddress, String founderAddress, int hashCompexity, long index) throws IOException, NoSuchAlgorithmException, SignatureException, NoSuchProviderException, InvalidKeyException, InvalidKeySpecException {         this.dtoTransactions = dtoTransactions;         this.previousHash = previousHex;         this.minerAddress = minerAddress;         this.minerRewards = miningRewardsCount();         this.hashCompexity = hashCompexity;         this.founderAddress = founderAddress;         this.timestamp = new Timestamp(System.currentTimeMillis());         this.index = index;         this.hashBlock = findHash(hashCompexity);      }      public Block(List<DtoTransaction> dtoTransactions, String previousHash, String minerAddress, String founderAddress, long randomNumberProof, double minerRewards, int hashCompexity, Timestamp timestamp, long index, String hashBlock) {         this.dtoTransactions = dtoTransactions;         this.previousHash = previousHash;         this.minerAddress = minerAddress;         this.founderAddress = founderAddress;         this.randomNumberProof = randomNumberProof;         this.minerRewards = minerRewards;         this.hashCompexity = hashCompexity;         this.timestamp = timestamp;         this.index = index;         this.hashBlock = hashBlock;     }      @JsonAutoDetect     @Data     private class BlockForHash{         private List<DtoTransaction> transactions;         private String previousHash;         private String minerAddress;         private String founderAddress;         private long randomNumberProof;         private double minerRewards;         private int hashCompexity;         private Timestamp timestamp;         private long index;           public BlockForHash() {         }           public BlockForHash(List<DtoTransaction> transactions,                             String previousHash,                             String minerAddress,                             String founderAddress,                             long randomNumberProof,                             double minerRewards,                             int hashCompexity,                             Timestamp timestamp,                             long index) {             this.transactions = transactions;             this.previousHash = previousHash;             this.minerAddress = minerAddress;             this.founderAddress = founderAddress;             this.randomNumberProof = randomNumberProof;             this.minerRewards = minerRewards;             this.hashCompexity = hashCompexity;             this.timestamp = timestamp;             this.index = index;          }          public String hashForTransaction() throws IOException {             return UtilsUse.sha256hash(jsonString());         }          public String jsonString() throws IOException {             return UtilsJson.objToStringJson(this);         }     }      public Block() {     }      public String hashForBlockchain()             throws             IOException{         return this.hashBlock;     }       public boolean verifyesTransSign() throws IOException, NoSuchAlgorithmException, SignatureException, NoSuchProviderException, InvalidKeyException, InvalidKeySpecException {         for (DtoTransaction dtoTransaction : dtoTransactions) {             if(!dtoTransaction.verify())                 return false;         }         return true;     }      private double miningRewardsCount(){         double rewards = 0.0;         for (DtoTransaction dtoTransaction : dtoTransactions) {              rewards += dtoTransaction.getBonusForMiner();         }          return rewards;     }      public String jsonString() throws IOException {         return UtilsJson.objToStringJson(this);     }     //TODO     public String findHash(int hashCoplexity) throws IOException, NoSuchAlgorithmException, SignatureException, NoSuchProviderException, InvalidKeyException, InvalidKeySpecException {         if (!verifyesTransSign()){             throw new NotValidTransactionException();         }          this.randomNumberProof = 0;         String hash = \"\";         while (true){             this.randomNumberProof++;             BlockForHash block = new BlockForHash(this.dtoTransactions,                     this.previousHash, this.minerAddress, this.founderAddress,                     this.randomNumberProof, this.minerRewards, this.hashCompexity, this.timestamp, this.index);             hash = block.hashForTransaction();             if(UtilsUse.hashComplexity(hash.substring(0, hashCoplexity), hashCoplexity))             {                 break;             }          }         return hash;     }      @Override     public boolean equals(Object o) {           if (this == o) return true;         if (!(o instanceof Block)) return false;         Block block = (Block) o;         return getRandomNumberProof() == block.getRandomNumberProof() && Double.compare(block.getMinerRewards(), getMinerRewards()) == 0 && getHashCompexity() == block.getHashCompexity() && getIndex() == block.getIndex() && Objects.equals(getDtoTransactions(), block.getDtoTransactions()) && Objects.equals(getPreviousHash(), block.getPreviousHash()) && Objects.equals(getMinerAddress(), block.getMinerAddress()) && Objects.equals(getFounderAddress(), block.getFounderAddress()) && Objects.equals(getTimestamp(), block.getTimestamp()) && Objects.equals(getHashBlock(), block.getHashBlock());     }      @Override     public int hashCode() {         return Objects.hash(getDtoTransactions(), getPreviousHash(), getMinerAddress(), getFounderAddress(), getRandomNumberProof(), getMinerRewards(), getHashCompexity(), getTimestamp(), getIndex(), getHashBlock());     }      @Override     public Block clone() throws CloneNotSupportedException {         return new Block(this.dtoTransactions, this.previousHash, this.minerAddress, this.founderAddress,                 this.randomNumberProof, this.minerRewards, this.hashCompexity, this.timestamp, this.index,                 this.hashBlock);     } }","package International_Trade_Union.entity.blockchain;  import International_Trade_Union.entity.DtoTransaction.DtoTransaction; import International_Trade_Union.entity.blockchain.block.Block; import International_Trade_Union.setings.Seting; import International_Trade_Union.utils.UtilsBlock; import International_Trade_Union.utils.UtilsJson; import International_Trade_Union.utils.UtilsSecurity; import International_Trade_Union.utils.UtilsUse; import International_Trade_Union.utils.base.Base; import International_Trade_Union.utils.base.Base58; import International_Trade_Union.vote.Laws; import International_Trade_Union.vote.VoteEnum; import com.fasterxml.jackson.annotation.JsonAutoDetect;  import lombok.Data;  import java.io.IOException; import java.security.*; import java.security.spec.InvalidKeySpecException; import java.util.ArrayList; import java.util.List; import java.util.Objects;   @JsonAutoDetect @Data public class Blockchain implements Cloneable{     private List<Block> blockchainList;     //как часто должно создаваться блок в миллисекундах 1000 миллисекунд = 1 секунд     private long BLOCK_GENERATION_INTERVAL;     //каждые сколько блоков должен происходить перерасчет сложности     private int DIFFICULTY_ADJUSTMENT_INTERVAL;     //блок действителен, если значение блока меньше данного занчения в миллисекунда     private long INTERVAL_TARGET;     private String ADDRESS_FOUNDER;     public int sizeBlockhain(){          return blockchainList.size();     }      public void setBlockchainList(List<Block> blockchainList) throws IOException, NoSuchAlgorithmException, InvalidKeySpecException, SignatureException, NoSuchProviderException, InvalidKeyException {         this.blockchainList = blockchainList;      }      public Blockchain(long BLOCK_GENERATION_INTERVAL, int DIFFICULTY_ADJUSTMENT_INTERVAL, long INTERVAL_TARGET, String ADDRESS_FOUNDER) throws NoSuchAlgorithmException, InvalidKeySpecException, NoSuchProviderException, IOException, SignatureException, InvalidKeyException {         this(new ArrayList<>(), BLOCK_GENERATION_INTERVAL, DIFFICULTY_ADJUSTMENT_INTERVAL, INTERVAL_TARGET, ADDRESS_FOUNDER);      }     public Blockchain(List<Block> blockchainList, long BLOCK_GENERATION_INTERVAL, int DIFFICULTY_ADJUSTMENT_INTERVAL, long INTERVAL_TARGET,String ADDRESS_FOUNDER) throws IOException, NoSuchAlgorithmException, InvalidKeySpecException, SignatureException, NoSuchProviderException, InvalidKeyException {         this.blockchainList = blockchainList;         this.BLOCK_GENERATION_INTERVAL = BLOCK_GENERATION_INTERVAL;         this.DIFFICULTY_ADJUSTMENT_INTERVAL = DIFFICULTY_ADJUSTMENT_INTERVAL;         this.INTERVAL_TARGET = INTERVAL_TARGET;         this.ADDRESS_FOUNDER = ADDRESS_FOUNDER;         Block block = genesisBlock();         addBlock(block);     }      public void addBlock(Block newBlock) throws IOException, NoSuchAlgorithmException, SignatureException, InvalidKeySpecException, NoSuchProviderException, InvalidKeyException { //        if(blockchainList.size() > 2){ //            boolean time = UtilsBlock.isValidTimestamp(blockchainList.get(blockchainList.size()-1), newBlock, INTERVAL_TARGET); //            if(!time){ //                System.out.println(\"time out block add \" + time); //               return; //            } //        }         blockchainList.add(newBlock);       }      public Block genesisBlock() throws IOException, NoSuchAlgorithmException, InvalidKeySpecException, NoSuchProviderException, SignatureException, InvalidKeyException {         Base base = new Base58();         //dto sign         //pub byte keys         //transactions         List<DtoTransaction> transactions = new ArrayList<>();          DtoTransaction gold = new DtoTransaction(Seting.BASIS_ADDRESS, ADDRESS_FOUNDER,                 Seting.FOUNDERS_REMUNERATION_DIGITAL_DOLLAR, Seting.FOUNDERS_REMNUNERATION_DIGITAL_STOCK, new Laws(), 0.0, VoteEnum.YES);         PrivateKey privateKey = UtilsSecurity.privateBytToPrivateKey(base.decode(Seting.BASIS_PASSWORD));         byte[] signGold = UtilsSecurity.sign(privateKey, gold.toSign());         gold.setSign(signGold);         transactions.add(gold);          String genesisHash = genesisPrevHash();         Block block = new Block(transactions,  genesisHash, ADDRESS_FOUNDER, ADDRESS_FOUNDER,  Seting.HASH_COMPLEXITY_GENESIS, blockchainList.size());         return block;     }        public String genesisPrevHash() throws IOException {         return UtilsUse.hashComplexityStr(Seting.CORPORATE_CHARTER_DRAFT, Seting.HASH_COMPLEXITY_GENESIS);     }      public String getHashBlock(int index) throws IOException {         return blockchainList.get(index).hashForBlockchain();     }     public Block getBlock(int index){         return blockchainList.get(index);     }        public boolean validatedBlockchain() throws IOException, NoSuchAlgorithmException, SignatureException, InvalidKeySpecException, NoSuchProviderException, InvalidKeyException {        return UtilsBlock.validation(blockchainList, BLOCK_GENERATION_INTERVAL, DIFFICULTY_ADJUSTMENT_INTERVAL);     }      public String jsonString() throws IOException {         return UtilsJson.objToStringJson(blockchainList);     }     @Override     public boolean equals(Object o) {         if (this == o) return true;         if (!(o instanceof Blockchain)) return false;         Blockchain that = (Blockchain) o;         return getBlockchainList().equals(that.getBlockchainList());     }      @Override     public int hashCode() {         return Objects.hash(getBlockchainList());     }      public  List<Block> subBlock(int startIndex, int finishIndex) throws CloneNotSupportedException {         List<Block> temporary = this.getBlockchainList().subList(startIndex, finishIndex);         List<Block> result = new ArrayList<>();         for (Block block : temporary) {             result.add(block.clone());         }         return result;     }       @Override     public List<Block> clone() throws CloneNotSupportedException {         List<Block> result = new ArrayList<>();         for (Block block : blockchainList) {             result.add(block.clone());         }         return result;      } }","package International_Trade_Union.entity.DtoTransaction;  import org.bouncycastle.jcajce.provider.asymmetric.ec.BCECPublicKey; import International_Trade_Union.setings.Seting; import International_Trade_Union.utils.UtilsJson; import International_Trade_Union.utils.UtilsSecurity; import International_Trade_Union.utils.UtilsUse; import International_Trade_Union.utils.base.Base; import International_Trade_Union.utils.base.Base58; import International_Trade_Union.vote.Laws; import International_Trade_Union.vote.VoteEnum; import com.fasterxml.jackson.annotation.JsonAutoDetect;  import lombok.Data;   import java.io.IOException; import java.security.*; import java.security.spec.InvalidKeySpecException; import java.util.Arrays; import java.util.Objects;   @JsonAutoDetect @Data public class DtoTransaction {     private String sender;     private String customer;     private double digitalDollar;     private double digitalStockBalance;     private Laws laws;     private double bonusForMiner;     private VoteEnum voteEnum;     private byte[] sign;        public DtoTransaction(String sender, String customer, double digitalDollar, double digitalStockBalance, Laws laws, double bonusForMiner, VoteEnum voteEnum) {         this.sender = sender;         this.customer = customer;         this.digitalDollar = digitalDollar;         this.digitalStockBalance = digitalStockBalance;         this.laws = laws;         this.bonusForMiner = bonusForMiner;         this.voteEnum = voteEnum;     }      public DtoTransaction() {     }      //TODO возможно стоит перевести проверку подписи в отдельный utils, под вопросом!!     public boolean verify() throws IOException, NoSuchAlgorithmException, SignatureException, NoSuchProviderException, InvalidKeyException, InvalidKeySpecException {         Base base = new Base58();         byte[] pub = base.decode(sender);         BCECPublicKey publicKey = (BCECPublicKey) UtilsSecurity.decodeKey(pub); //        PublicKey publicKey = UtilsSecurity.publicByteToPublicKey(pub);         String sha = sender + customer + digitalDollar + digitalStockBalance + laws + bonusForMiner;         sha = UtilsUse.sha256hash(sha);         if(sender.isBlank() || customer.isBlank() || digitalDollar < 0 || digitalStockBalance < 0 || bonusForMiner < 0 || laws == null){             System.out.println(\"wrong dto transaction sender or customer blank? or dollar, reputation or reward less then 0\");             return false;         }         if(Seting.BASIS_ADDRESS.equals(publicKey))             return true;         return UtilsSecurity.verify(sha, sign, publicKey);     }      public String toSign(){         String sha = sender + customer + digitalDollar + digitalStockBalance + laws + bonusForMiner;         return UtilsUse.sha256hash(sha);     }  //    public String hashForBlock() throws IOException { //        return UtilsUse.sha256hash(jsonString()); //    }      public String jsonString() throws IOException {         return UtilsJson.objToStringJson(this);     }      @Override     public boolean equals(Object o) {         if (this == o) return true;         if (!(o instanceof DtoTransaction)) return false;         DtoTransaction that = (DtoTransaction) o;         return Double.compare(that.getDigitalDollar(), getDigitalDollar()) == 0 && Double.compare(that.getDigitalStockBalance(), getDigitalStockBalance()) == 0 && Double.compare(that.getBonusForMiner(), getBonusForMiner()) == 0 && getSender().equals(that.getSender()) && getCustomer().equals(that.getCustomer()) && getLaws().equals(that.getLaws()) && getVoteEnum() == that.getVoteEnum() && Arrays.equals(getSign(), that.getSign());     }      @Override     public int hashCode() {         int result = Objects.hash(getSender(), getCustomer(), getDigitalDollar(), getDigitalStockBalance(), getLaws(), getBonusForMiner(), getVoteEnum());         result = 31 * result + Arrays.hashCode(getSign());         return result;     } }","package International_Trade_Union.entity;  import lombok.Data;  @Data public class AddressUrl {     private String address;      public AddressUrl() {     }      public AddressUrl(String address) {         this.address = address;     } }","package International_Trade_Union.entity;   import lombok.Data; import International_Trade_Union.entity.blockchain.block.Block;  import java.util.List;  @Data public class EntityChain {      private int size;     private List<Block> blocks;      public EntityChain() {     }      public EntityChain(int sizeBlockhain, List<Block> blockchainList) {         this.size = sizeBlockhain;         this.blocks = blockchainList;     } }","package International_Trade_Union.entity;   import lombok.Data; import International_Trade_Union.entity.blockchain.Blockchain; import International_Trade_Union.entity.blockchain.block.Block; import International_Trade_Union.model.Account;  import java.util.List; import java.util.Map;  @Data public class ResultMiningData {     private Map<String, Account> balance;     private Blockchain blockchain;     private Block miningBlock;     private List<Block> lastBlock;     private Account governments;  }","package International_Trade_Union.entity;  import lombok.Data;  @Data public class SubBlockchainEntity {     private int start;     private int finish;      public SubBlockchainEntity(int start, int finish) {         this.start = start;         this.finish = finish;     }      public SubBlockchainEntity() {     } }","package International_Trade_Union.governments;   import International_Trade_Union.model.Account;  public class CompareObject {      public int compare(Account o1, Account o2) {         double x1 = o1.getDigitalStockBalance();         double x2 = o2.getDigitalStockBalance();         int power = Double.compare(x1, x2);         if (power != 0)             return power;         double gold1 = o1.getDigitalDollarBalance();         double gold2 = o2.getDigitalDollarBalance();         int gold = Double.compare(gold1, gold2);         if(gold != 0)             return gold;         double first = x1 + gold1;         double second = x2 + gold2;         return Double.compare(first, second);     }      @Override     public boolean equals(Object obj) {         return false;     } }","package International_Trade_Union.governments;  import lombok.AllArgsConstructor; import lombok.Data; import lombok.NoArgsConstructor;  import java.util.Arrays; import java.util.List; import java.util.Locale; import java.util.Objects; import java.util.stream.Collectors;  @Data @NoArgsConstructor @AllArgsConstructor public class Director {     //количество юридических или физических лиц в данной должности     //количество юридических или физических лиц в данной должности     private String name;     private  int count;      private boolean electedByCEO;     private boolean electedByBoardOfDirectors;       private boolean electedByCorporateCouncilOfReferees;     private boolean electedByStocks;     private boolean officeOfDirectors;       @Override     public boolean equals(Object o) {         if (this == o) return true;         if (!(o instanceof Director)) return false;         Director director = (Director) o;         return getName().equals(director.getName());     }      @Override     public int hashCode() {         return Objects.hash(getName());     }      public boolean isAppointedByTheGovernment(){         if(electedByCEO || electedByBoardOfDirectors || electedByCorporateCouncilOfReferees)             return true;         else return false;     }     public int getCount() {         return count;     }     }","package International_Trade_Union.governments;  import International_Trade_Union.setings.Seting; import International_Trade_Union.utils.UtilsUse; import lombok.Data;  import java.util.ArrayList; import java.util.List; import java.util.Locale; import java.util.stream.Collectors;  @Data  public class Directors {     public Directors() {          directors = new ArrayList<>();         Director CORPORATE_COUNCIL_OF_REFEREES = new Director(\"CORPORATE_COUNCIL_OF_REFEREES\", 55, false, false, false, true, false);         Director BOARD_OF_DIRECTORS = new Director(\"BOARD_OF_DIRECTORS\", 301, false, false, false, true, false);          Director GENERAL_EXECUTIVE_DIRECTOR = new Director(\"GENERAL_EXECUTIVE_DIRECTOR\", 1, false, true, false, false, true);         Director HIGH_JUDGE = new Director(\"HIGH_JUDGE\",1, false, false, true, false, false);         Director FRACTION = new Director(\"FRACTION\", 100, false, false, false, true, false);         directors.add(CORPORATE_COUNCIL_OF_REFEREES);         directors.add(BOARD_OF_DIRECTORS);         directors.add(FRACTION);          directors.add(GENERAL_EXECUTIVE_DIRECTOR);         directors.add(HIGH_JUDGE);      }       public Director getDirector(String str){        List<Director> director = directors                .stream()                .filter(t->t.getName().equals(str))                .collect(Collectors.toList());        return director.get(0);      }     private List<Director> directors;      public boolean contains(String str) {         str = str.toUpperCase();         directors = directors.stream().filter(UtilsUse.distinctByKey(Director::getName)).collect(Collectors.toList());         List<String> strings = directors.stream().map(t->t.getName()).collect(Collectors.toList());        return strings.contains(str);     }      public boolean isCabinets(String str) {         List<String> list = directors.stream()                 .filter(t->t.isOfficeOfDirectors())                 .filter(UtilsUse.distinctByKey(Director::getName))                 .map(t->t.getName())                 .collect(Collectors.toList());         return list.contains(str.toUpperCase(Locale.ROOT));     }       //должности которые добавляются только советом директоров     public void addByBoardOfDirectors(String str) {         if (str.startsWith(Seting.ADD_DIRECTOR)) {             Director director = new Director(str, 1, false, true, false, false, true);             directors.add(director);             directors = directors.stream().filter(UtilsUse.distinctByKey(Director::getName)).collect(Collectors.toList());         }      }      public void addAllByBoardOfDirectors(List<String> strings) {         strings = strings.stream()                 .filter(t -> t.startsWith(Seting.ADD_DIRECTOR))                 .distinct()                 .collect(Collectors.toList());         for (String s : strings) {             Director director = new Director(s, 1, false, true, false, false, true);             directors.add(director);         }         directors = directors.stream().filter(UtilsUse.distinctByKey(Director::getName)).collect(Collectors.toList());      }       public List<String> getNames() {         return directors.stream().map(t -> t.getName()).collect(Collectors.toList());     }       public  boolean isElectedByStocks(String str){         List<String> list = directors.stream()                 .filter(t->t.isElectedByStocks())                 .map(t->t.getName())                 .collect(Collectors.toList());          return list.contains(str.toUpperCase(Locale.ROOT));     }     public boolean isElectedCEO(String str){         List<String> list = directors.stream()                 .filter(t->t.isElectedByCEO())                 .map(t->t.getName())                 .collect(Collectors.toList());          return list.contains(str.toUpperCase(Locale.ROOT));     }      public  boolean isElectedByBoardOfDirectors(String  str){         List<String> list = directors.stream()                 .filter(t->t.isElectedByBoardOfDirectors())                 .map(t->t.getName())                 .collect(Collectors.toList());          return list.contains(str.toUpperCase(Locale.ROOT));     }      public boolean isElectedBYCorporateCouncilOfReferees(String  str){         List<String> list = directors.stream()                 .filter(t->t.isElectedByCorporateCouncilOfReferees())                 .map(t->t.getName())                 .collect(Collectors.toList());          return list.contains(str.toUpperCase(Locale.ROOT));     }      public boolean isofficeOfDirectors(String str){         List<String> list = directors.stream()                 .filter(t->t.isOfficeOfDirectors())                 .map(t->t.getName())                 .collect(Collectors.toList());          return list.contains(str.toUpperCase(Locale.ROOT));     } }","package International_Trade_Union.governments;  import lombok.Data;  import java.util.List;  @Data public class FractionPower {     public FractionPower() {     }      public FractionPower(String addressLaw,                          double votes,                          int votesCorporateCouncilOfReferees,                          int votesBoardOfDirectors,                          int votesBoardOfShareholders,                          int voteGeneralExecutiveDirector,                          int voteHightJudge,                          int founderVote,                          String packageName,                          List<String> laws,                          double fractionVote,                          double fractionPower) {         this.addressLaw = addressLaw;         this.votes = votes;         this.votesCorporateCouncilOfReferees = votesCorporateCouncilOfReferees;         this.votesBoardOfDirectors = votesBoardOfDirectors;         this.votesBoardOfShareholders = votesBoardOfShareholders;         this.voteGeneralExecutiveDirector = voteGeneralExecutiveDirector;         this.voteHightJudge = voteHightJudge;         this.founderVote = founderVote;         this.packageName = packageName;         this.laws = laws;         this.fractionVote = fractionVote;         this.fractionPower = fractionPower;      }      private String addressLaw;     private double votes;     //CORPORATE_COUNCIL_OF_REFEREES     private int votesCorporateCouncilOfReferees;      //BOARD_OF_DIRECTORS     private int votesBoardOfDirectors;     private int votesBoardOfShareholders;      //GENERAL_EXECUTIVE_DIRECTOR     private int voteGeneralExecutiveDirector;     private int voteHightJudge;      private int founderVote;     private String packageName;     private List<String> laws;     private double fractionVote;     private double fractionPower;  }","package International_Trade_Union.governments;  public enum NamePOSITION {     BOARD_OF_DIRECTORS,     CORPORATE_COUNCIL_OF_REFEREES,     GENERAL_EXECUTIVE_DIRECTOR,     HIGH_JUDGE,     FRACTION }","package International_Trade_Union.governments;   import International_Trade_Union.entity.DtoTransaction.DtoTransaction; import International_Trade_Union.entity.blockchain.block.Block; import International_Trade_Union.model.Account; import International_Trade_Union.setings.Seting; import International_Trade_Union.vote.*;  import java.io.IOException; import java.security.InvalidKeyException; import java.security.NoSuchAlgorithmException; import java.security.NoSuchProviderException; import java.security.SignatureException; import java.security.spec.InvalidKeySpecException; import java.util.*; import java.util.stream.Collectors;  public class UtilsGovernment {      //для корпоративных позиций, адресс отправителя должен совпадать с первой строкой закона     public static boolean checkPostionSenderEqualsLaw(String addressSender, Laws laws) {         Directors directors = new Directors();         List<Director> enumPosition = directors.getDirectors();         List<String> corporateSeniorPositions = enumPosition.stream().map(t->t.getName()).collect(Collectors.toList());         if (corporateSeniorPositions.contains(laws.getPacketLawName())) {             if (laws.getLaws().get(0) != null && addressSender.equals(laws.getLaws().get(0))) {                 System.out.println(\"UtilsBogernment: checkPostionSenderEqualsLaw: \" + laws.getLaws().get(0) + \" true:\");                 return true;             } else {                 System.out.println(\"UtilsBogernment: checkPostionSenderEqualsLaw: \" + laws.getLaws().get(0) + \" false:\");                 return false;             }         }         System.out.println(\"UtilsBogernment: checkPostionSenderEqualsLaw: \" + laws.getLaws().get(0) + \" not position:\");         return true;     }       //определение совета акционеров     public static List<Account> findBoardOfShareholders(Map<String, Account> balances, List<Block> blocks, int limit) {         List<Block> minersHaveMoreStock = null;         if (blocks.size() > limit) {             minersHaveMoreStock = blocks.subList(blocks.size() - limit, blocks.size());         } else {             minersHaveMoreStock = blocks;         }         List<Account> boardAccounts = minersHaveMoreStock.stream().map(                         t -> new Account(t.getMinerAddress(), 0, 0))                 .collect(Collectors.toList());          for (Block block : minersHaveMoreStock) {             for (DtoTransaction dtoTransaction : block.getDtoTransactions()) {                 boardAccounts.add(new Account(dtoTransaction.getSender(), 0, 0));             }          }           CompareObject compareObject = new CompareObject();          List<Account> boardOfShareholders = balances.entrySet().stream()                 .filter(t -> boardAccounts.contains(t.getValue()))                 .map(t -> t.getValue()).collect(Collectors.toList());           boardOfShareholders = boardOfShareholders                 .stream()                 .filter(t -> !t.getAccount().startsWith(Seting.NAME_LAW_ADDRESS_START))                 .filter(t -> t.getDigitalStockBalance() > 0)                 .sorted(Comparator.comparing(Account::getDigitalStockBalance).reversed())                 .collect(Collectors.toList());          boardOfShareholders = boardOfShareholders                 .stream()                 .limit(Seting.BOARD_OF_SHAREHOLDERS)                 .collect(Collectors.toList());          return boardOfShareholders;     }       public static List<CurrentLawVotesEndBalance> filtersVotes(             List<LawEligibleForParliamentaryApproval> approvalList,             Map<String, Account> balances,             List<Account> BoardOfShareholders,             List<Block> blocks,             int limitBlocks     ) throws IOException, NoSuchAlgorithmException, SignatureException, InvalidKeySpecException, NoSuchProviderException, InvalidKeyException {         //действующие законы чьи голоса больше ORIGINAL_LIMIT_MIN_VOTE         List<CurrentLawVotesEndBalance> current = new ArrayList<>();         Map<String, CurrentLawVotes> votesMap = null;         List<Account> accounts = balances.entrySet().stream().map(t -> t.getValue()).collect(Collectors.toList());         if (blocks.size() > limitBlocks) {             votesMap = UtilsCurrentLaw.calculateVotes(accounts, blocks.subList(blocks.size() - limitBlocks, blocks.size()));         } else {             votesMap = UtilsCurrentLaw.calculateVotes(accounts, blocks);         }          //подсчитать средннее количество раз сколько он проголосовал за         Map<String, Integer> yesAverage = UtilsCurrentLaw.calculateAverageVotesYes(votesMap);         //подсчитать среднее количество раз сколько он проголосовал против         Map<String, Integer> noAverage = UtilsCurrentLaw.calculateAverageVotesNo(votesMap);           //подсчитываем голоса для для обычных законов и законов позиций         for (LawEligibleForParliamentaryApproval lawEligibleForParliamentaryApproval : approvalList) {             if (votesMap.containsKey(lawEligibleForParliamentaryApproval.getLaws().getHashLaw())) {                 String address = lawEligibleForParliamentaryApproval.getLaws().getHashLaw();                 String packageName = lawEligibleForParliamentaryApproval.getLaws().getPacketLawName();                 List<String> laws = lawEligibleForParliamentaryApproval.getLaws().getLaws();                 double vote = 0;                 int supremeVotes = 0;                 int boafdOfShareholderVotes = 0;                 int houseOfRepresentativiesVotes = 0;                 int primeMinisterVotes = 0;                 int hightJudgesVotes = 0;                 int founderVote = 0;                 double fraction = 0;                  //для законов подсчитываем специальные голоса                 vote = votesMap.get(lawEligibleForParliamentaryApproval.getLaws().getHashLaw()).votesLaw(balances, yesAverage, noAverage);                 List<String> boardOfShareholdersAddress = BoardOfShareholders.stream().map(t -> t.getAccount()).collect(Collectors.toList());                 boafdOfShareholderVotes = votesMap.get(lawEligibleForParliamentaryApproval.getLaws().getHashLaw()).voteGovernment(balances, boardOfShareholdersAddress);                  List<String> founder = List.of(Seting.ADDRESS_FOUNDER);                 founderVote = votesMap.get(lawEligibleForParliamentaryApproval.getLaws().getHashLaw()).voteGovernment(balances, founder);                 CurrentLawVotesEndBalance currentLawVotesEndBalance = new CurrentLawVotesEndBalance(                         address,                         packageName,                         vote,                         supremeVotes,                         houseOfRepresentativiesVotes,                         boafdOfShareholderVotes,                         primeMinisterVotes,                         hightJudgesVotes,                         founderVote,                         fraction,                         laws);                 current.add(currentLawVotesEndBalance);              }         }          List<String> houseOfRepresentativies = new ArrayList<>();         List<String> chamberOfSumpremeJudges = new ArrayList<>();         Map<String, Double> fractions = new HashMap<>();          for (CurrentLawVotesEndBalance currentLawVotesEndBalance: current) {             if(currentLawVotesEndBalance.getPackageName().equals(NamePOSITION.BOARD_OF_DIRECTORS.toString())){                 if(currentLawVotesEndBalance.getVotes() >= Seting.ORIGINAL_LIMIT_MIN_VOTE){                     houseOfRepresentativies.add(currentLawVotesEndBalance.getLaws().get(0));                 }              }             if(currentLawVotesEndBalance.getPackageName().equals(NamePOSITION.CORPORATE_COUNCIL_OF_REFEREES.toString())){                 if(currentLawVotesEndBalance.getVotes() >= Seting.ORIGINAL_LIMIT_MIN_VOTE){                     chamberOfSumpremeJudges.add(currentLawVotesEndBalance.getLaws().get(0));                 }              }               if(currentLawVotesEndBalance.getPackageName().equals(NamePOSITION.FRACTION.toString())){                 if(currentLawVotesEndBalance.getVotes() >= Seting.ORIGINAL_LIMIT_MIN_VOTE){                     fractions.put(currentLawVotesEndBalance.getLaws().get(0), currentLawVotesEndBalance.getVotes());                 }             }          }            for (CurrentLawVotesEndBalance currentLawVotesEndBalance : current) {             if(votesMap.containsKey(currentLawVotesEndBalance.getAddressLaw())){                   double vote = votesMap.get(currentLawVotesEndBalance.getAddressLaw()).votesLaw(balances, yesAverage, noAverage);                 int supremeVotes  = votesMap.get(currentLawVotesEndBalance.getAddressLaw()).voteGovernment(balances, chamberOfSumpremeJudges);                 int houseOfRepresentativiesVotes = votesMap.get(currentLawVotesEndBalance.getAddressLaw()).voteGovernment(balances, houseOfRepresentativies);                 double fractionsVotes = votesMap.get(currentLawVotesEndBalance.getAddressLaw()).voteFractions(fractions);                  currentLawVotesEndBalance.setVotes(vote);                 currentLawVotesEndBalance.setVotesBoardOfDirectors(houseOfRepresentativiesVotes);                 currentLawVotesEndBalance.setVotesCorporateCouncilOfReferees(supremeVotes);                 currentLawVotesEndBalance.setFractionVote(fractionsVotes);             }          }          //изирается Генеральный исполнительный директор         List<String> primeMinister = new ArrayList<>();         List<String> hightJudge = new ArrayList<>();         for (CurrentLawVotesEndBalance currentLawVotesEndBalance : current) {             if(currentLawVotesEndBalance.getPackageName().equals(NamePOSITION.GENERAL_EXECUTIVE_DIRECTOR.toString())){                 if(currentLawVotesEndBalance.getVotesBoardOfDirectors() >= Seting.ORIGINAL_LIMIT_MIN_VOTE_BOARD_OF_DIRECTORS                 && currentLawVotesEndBalance.getFractionVote() >= Seting.ORIGINAL_LIMIT_MIN_VOTE_FRACTIONS                 && currentLawVotesEndBalance.getVotesBoardOfShareholders() >= Seting.ORIGINAL_LIMIT_MIN_VOTE_BOARD_OF_SHAREHOLDERS                 && currentLawVotesEndBalance.getVotes() >= Seting.ALL_STOCK_VOTE){                     primeMinister.add(currentLawVotesEndBalance.getLaws().get(0));                 }             }              if(currentLawVotesEndBalance.getPackageName().equals(NamePOSITION.HIGH_JUDGE.toString())){                 if(currentLawVotesEndBalance.getVotesCorporateCouncilOfReferees() >= Seting.ORIGINAL_LIMIT_MIN_VOTE_CORPORATE_COUNCIL_OF_REFEREES){                     hightJudge.add(currentLawVotesEndBalance.getLaws().get(0));                 }             }         }         for (CurrentLawVotesEndBalance currentLawVotesEndBalance : current) {             if(votesMap.containsKey(currentLawVotesEndBalance.getAddressLaw())){                 int primeMinisterVotes = votesMap.get(currentLawVotesEndBalance.getAddressLaw()).voteGovernment(balances, primeMinister);                 int hightJudgeVotes = votesMap.get(currentLawVotesEndBalance.getAddressLaw()).voteGovernment(balances, hightJudge);                  currentLawVotesEndBalance.setVoteGeneralExecutiveDirector(primeMinisterVotes);                 currentLawVotesEndBalance.setVoteHightJudge(hightJudgeVotes);             }          }           return current;      }          //без учета палаты представителей     public static List<CurrentLawVotesEndBalance> filters(List<LawEligibleForParliamentaryApproval> approvalList, Map<String, Account> balances,                                                           List<Account> BoardOfShareholders, List<Block> blocks, int limitBlocks) throws IOException, NoSuchAlgorithmException, InvalidKeySpecException, SignatureException, NoSuchProviderException, InvalidKeyException {         //действующие законы чьи голоса больше ORIGINAL_LIMIT_MIN_VOTE         List<CurrentLawVotesEndBalance> current = new ArrayList<>();         Map<String, CurrentLawVotes> votesMap = null;         List<Account> accounts = balances.entrySet().stream().map(t -> t.getValue()).collect(Collectors.toList());         if (blocks.size() > limitBlocks) {             votesMap = UtilsCurrentLaw.calculateVotes(accounts, blocks.subList(blocks.size() - limitBlocks, blocks.size()));         } else {             votesMap = UtilsCurrentLaw.calculateVotes(accounts, blocks);         }          //подсчитать средннее количество раз сколько он проголосовал за         Map<String, Integer> yesAverage = UtilsCurrentLaw.calculateAverageVotesYes(votesMap);         //подсчитать среднее количество раз сколько он проголосовал против         Map<String, Integer> noAverage = UtilsCurrentLaw.calculateAverageVotesNo(votesMap);          for (LawEligibleForParliamentaryApproval lawEligibleForParliamentaryApproval : approvalList) {             if (votesMap.containsKey(lawEligibleForParliamentaryApproval.getLaws().getHashLaw())) {                 String address = lawEligibleForParliamentaryApproval.getLaws().getHashLaw();                 String packageName = lawEligibleForParliamentaryApproval.getLaws().getPacketLawName();                 List<String> laws = lawEligibleForParliamentaryApproval.getLaws().getLaws();                 double vote = votesMap.get(lawEligibleForParliamentaryApproval.getLaws().getHashLaw()).votes(balances, yesAverage, noAverage);                  CurrentLawVotesEndBalance currentLawVotesEndBalance = new CurrentLawVotesEndBalance(address, packageName, vote, 0, 0, 0, 0, 0, 0, 0,  laws);                 current.add(currentLawVotesEndBalance);              }         }         return current;     }   }","package International_Trade_Union.model;   import lombok.Data; import International_Trade_Union.entity.DtoTransaction.DtoTransaction; import International_Trade_Union.utils.UtilsSecurity; import International_Trade_Union.utils.base.Base; import International_Trade_Union.utils.base.Base58; import International_Trade_Union.vote.Laws; import International_Trade_Union.vote.VoteEnum;  import java.io.IOException; import java.security.*; import java.security.spec.InvalidKeySpecException; import java.util.Objects;   @Data public class Account {     private String account;     private double digitalDollarBalance;     private double digitalStockBalance;       public Account(String account, double digitalDollarBalance) {         this(account, digitalDollarBalance, 0.0);      }      public Account(String account, double digitalDollarBalance, double digitalStockBalance) {         this.account = account;         this.digitalDollarBalance = digitalDollarBalance;         this.digitalStockBalance = digitalStockBalance;     }      public Account() {     }      @Override     public boolean equals(Object o) {         if (this == o) return true;         if (!(o instanceof Account)) return false;         Account account1 = (Account) o;         return getAccount().equals(account1.getAccount());     }      @Override     public int hashCode() {         return Objects.hash(getAccount());     }      private DtoTransaction sendMoney(String recipient, String privatekey, double digitalDollar, double digitalStock, Laws laws, double minerRewards, VoteEnum voteEnum) throws NoSuchAlgorithmException, InvalidKeySpecException, NoSuchProviderException, SignatureException, IOException, InvalidKeyException {          DtoTransaction transaction = null;         if (account.equals(recipient)){             System.out.println(\"sender %s, recipient %s cannot be equals! Error!\".format(account,recipient));             return transaction;         }              if(digitalDollarBalance < digitalDollar + minerRewards  ){                 System.out.println(\"sender don't have digitalDollar\");                 return transaction;             }             if(digitalStockBalance < digitalStock){                 System.out.println(\"sender don't have digitalReputation\");                 return transaction;             }             else{                 Base base = new Base58();                 PrivateKey privateKey = UtilsSecurity.privateBytToPrivateKey(base.decode(privatekey));                  transaction = new DtoTransaction(this.getAccount(), recipient, digitalDollar, digitalStock, laws, minerRewards, voteEnum);                 byte[] signGold = UtilsSecurity.sign(privateKey, transaction.toSign());                 transaction.setSign(signGold);             }         return transaction;     }  //      recipient - получатель //      gold сумма отправки, last Block - это послдний блок.     public DtoTransaction send(String recipient, String privateKey, double digitalDollar, double digitalReputation, Laws laws,  double minerRewards, VoteEnum voteEnum) throws NoSuchAlgorithmException, InvalidKeySpecException, SignatureException, IOException, NoSuchProviderException, InvalidKeyException {          return sendMoney(recipient,privateKey, digitalDollar, digitalReputation, laws, minerRewards, voteEnum);     }      }","package International_Trade_Union.model;  import International_Trade_Union.utils.UtilsSecurity; import International_Trade_Union.utils.base.Base; import International_Trade_Union.utils.base.Base58;  import java.security.InvalidAlgorithmParameterException; import java.security.NoSuchAlgorithmException; import java.security.NoSuchProviderException; import java.security.spec.InvalidKeySpecException; import java.util.HashMap; import java.util.Map;  public class CreateAccount {     public static Map<String, String> create() throws InvalidAlgorithmParameterException, NoSuchAlgorithmException, InvalidKeySpecException, NoSuchProviderException {         Map<String, String> create = new HashMap<>();         Base base = new Base58();         Keys keyPair = UtilsSecurity.generateKeyPair();         String pubkey = keyPair.getPubkey();         String privKey = keyPair.getPrivkey();         System.out.println(\"pubkey: \" + pubkey);         System.out.println(\"privKey: \" + privKey);         create.put(\"pubKey\", pubkey);         create.put(\"privKey\", privKey);         return create;     } }","package International_Trade_Union.model;  import International_Trade_Union.governments.Director; import lombok.AllArgsConstructor; import lombok.Data; import lombok.NoArgsConstructor;  @Data @AllArgsConstructor @NoArgsConstructor public class FIndPositonHelperData {     Director addressPosition;     boolean withLimited;     boolean electedWithStock;     boolean electedWithPrimeMinister;     boolean electedWithHousOfRepresentativies;     boolean electedWithChamberOfHightJudjes;  }","package International_Trade_Union.model;  import lombok.Data;  @Data public class Keys {     private String pubkey;     private String privkey;      public Keys(String pubkey, String privkey) {         this.pubkey = pubkey;         this.privkey = privkey;     } }","package International_Trade_Union.model;    import International_Trade_Union.config.BLockchainFactory; import International_Trade_Union.config.BlockchainFactoryEnum; import International_Trade_Union.entity.DtoTransaction.DtoTransaction; import International_Trade_Union.entity.blockchain.Blockchain; import International_Trade_Union.entity.blockchain.block.Block; import International_Trade_Union.governments.Director; import International_Trade_Union.governments.Directors; import International_Trade_Union.governments.UtilsGovernment; import International_Trade_Union.setings.Seting; import International_Trade_Union.utils.base.Base; import International_Trade_Union.utils.base.Base58; import International_Trade_Union.vote.Laws; import International_Trade_Union.vote.VoteEnum; import International_Trade_Union.utils.*;  import java.io.File; import java.io.IOException; import java.security.*; import java.security.spec.InvalidKeySpecException; import java.util.*; import java.util.stream.Collectors;  public class Mining {      public static Blockchain getBlockchain(String filename, BlockchainFactoryEnum factoryEnum) throws IOException, NoSuchAlgorithmException, InvalidKeySpecException, SignatureException, NoSuchProviderException, InvalidKeyException {          List<Block> blocks = UtilsBlock.readLineObject(filename);         Blockchain blockchain = null;         blockchain = BLockchainFactory.getBlockchain(factoryEnum);          if (blocks.size() != 0) {            blockchain.setBlockchainList(blocks);         }         return blockchain;     }      public static Map<String, Account> getBalances(String filename, Blockchain blockchain, Map<String, Account> balances) throws IOException, NoSuchAlgorithmException, SignatureException, InvalidKeySpecException, NoSuchProviderException, InvalidKeyException {         //start test           //папка чтобы проверить есть ли         File folder = new File(filename);         List<String> files = new ArrayList<>();         for (File file : folder.listFiles()) {             if(!file.isDirectory()){                 files.add(file.getAbsolutePath());             }         }          if (files.size() > 0 ){             File file = new File(files.get(files.size()-1));             if(file.exists() && file.length() > 0){                 balances = SaveBalances.readLineObject(filename);             }          }          if (balances == null) {             balances = new HashMap<>();         }          Block block;         if(blockchain != null && blockchain.sizeBlockhain() > 0){             block = blockchain.getBlock(blockchain.sizeBlockhain() - 1);             balances = UtilsBalance.calculateBalance(balances, block);           }           return balances;     }      public static void deleteFiles(String fileDelit) {         UtilsFileSaveRead.deleteAllFiles(fileDelit);     }       public static Block miningDay(             Account minner,             Blockchain blockchain,             long blockGenerationInterval,             int DIFFICULTY_ADJUSTMENT_INTERVAL,             List<DtoTransaction> transactionList,             Map<String, Account> balances,             long index     ) throws IOException, NoSuchAlgorithmException, SignatureException, InvalidKeySpecException, NoSuchProviderException, InvalidKeyException {         Directors directors = new Directors();         //получение транзакций с сети         List<DtoTransaction> listTransactions = transactionList;          //определение валидных транзакций         List<DtoTransaction> forAdd = new ArrayList<>();          //проверяет целостность транзакции, что они подписаны правильно         cicle:         for (DtoTransaction transaction : listTransactions) {             if (transaction.verify()) {                  Account account = balances.get(transaction.getSender());                 if (account == null) {                     System.out.println(\"minerAccount null\");                     continue cicle;                 }                 //NAME_LAW_ADDRESS_START если адресс  означает правила выбранные сетью                 if(transaction.getCustomer().startsWith(Seting.NAME_LAW_ADDRESS_START) && !balances.containsKey(transaction.getCustomer())){                     //если в названия закона совпадает с корпоративными должностями, то закон является действительным только когда                     //отправитель совпадает с законом //                    List<Director> enumPosition = directors.getDirectors();                     List<String> corporateSeniorPositions = directors.getDirectors().stream()                             .map(t->t.getName()).collect(Collectors.toList());                     System.out.println(\"LawsController: create_law: \" + transaction.getLaws().getPacketLawName()                             + \"contains: \" + corporateSeniorPositions.contains(transaction.getLaws().getPacketLawName()));                     if(corporateSeniorPositions.contains(transaction.getLaws().getPacketLawName())                             && !UtilsGovernment.checkPostionSenderEqualsLaw(transaction.getSender(), transaction.getLaws())){                         System.out.println(\"if your create special corporate position, you need \" +                                 \"sender to be equals with first law: now its wrong\");                         continue cicle;                     }                 }                 if(transaction.getLaws() == null){                     System.out.println(\"law cannot to be null: \");                     continue cicle;                 }                  if (account != null) {                     if(transaction.getSender().equals(Seting.BASIS_ADDRESS)){                         System.out.println(\"only this miner can input basis adress in this block\");                         continue cicle;                     }                     if(transaction.getCustomer().equals(Seting.BASIS_ADDRESS)){                         System.out.println(\"basis address canot to be customer(recipient)\");                         continue cicle;                     }                      if( account.getDigitalDollarBalance() < transaction.getDigitalDollar() + transaction.getBonusForMiner()){                         System.out.println(\"sender don't have digital dollar: \" + account.getAccount() + \" balance: \" + account.getDigitalDollarBalance() );                         System.out.println(\"digital dollar for send: \" + (transaction.getDigitalDollar() + transaction.getBonusForMiner()));                         continue cicle;                     }                     if (account.getDigitalStockBalance() < transaction.getDigitalStockBalance()){                         System.out.println(\"sender don't have digital reputation: \" + account.getAccount() + \" balance: \" + account.getDigitalStockBalance());                         System.out.println(\"digital reputation for send: \" + (transaction.getDigitalDollar() + transaction.getBonusForMiner()));                         continue cicle;                     }                     if(transaction.getSender().equals(transaction.getCustomer()) ){                         System.out.println(\"sender end recipient equals \" + transaction.getSender() + \" : recipient: \" + transaction.getCustomer());                         continue cicle;                     }                     forAdd.add(transaction);                 }              }         }           //доход майнера         double minerRewards = Seting.DIGITAL_DOLLAR_REWARDS_BEFORE;         double digitalReputationForMiner = Seting.DIGITAL_STOCK_REWARDS_BEFORE;          //доход основателя         double founderReward = Seting.DIGITAL_DOLLAR_FOUNDER_REWARDS_BEFORE;         double founderDigigtalReputationReward = Seting.DIGITAL_REPUTATION_FOUNDER_REWARDS_BEFORE;          Base base = new Base58();          //суммирует все вознаграждения майнеров         PrivateKey privateKey = UtilsSecurity.privateBytToPrivateKey(base.decode(Seting.BASIS_PASSWORD));         double sumRewards = forAdd.stream().collect(Collectors.summingDouble(DtoTransaction::getBonusForMiner));          //вознаграждения майнера         DtoTransaction minerRew = new DtoTransaction(Seting.BASIS_ADDRESS, minner.getAccount(),                 minerRewards, digitalReputationForMiner, new Laws(), sumRewards, VoteEnum.YES );          //подписывает         byte[] signGold = UtilsSecurity.sign(privateKey, minerRew.toSign());         minerRew.setSign(signGold);          //вознаграждение основателя         DtoTransaction founderRew = new DtoTransaction(Seting.BASIS_ADDRESS, blockchain.getADDRESS_FOUNDER(),                 founderReward, founderDigigtalReputationReward, new Laws(), 0.0, VoteEnum.YES);         byte[] signFounder = UtilsSecurity.sign(privateKey, founderRew.toSign());          founderRew.setSign(signFounder);           forAdd.add(minerRew);         forAdd.add(founderRew);           //определение сложности и создание блока         int difficulty = UtilsBlock.difficulty(blockchain.getBlockchainList(), blockGenerationInterval, DIFFICULTY_ADJUSTMENT_INTERVAL);          System.out.println(\"Mining: miningBlock: difficulty: \" + difficulty + \" index: \" + index);           //blockchain.getHashBlock(blockchain.sizeBlockhain() - 1)         Block block = new Block(                 forAdd,                 blockchain.getHashBlock(blockchain.sizeBlockhain() - 1),                 minner.getAccount(),                 blockchain.getADDRESS_FOUNDER(),                 difficulty,                 index);          return block;     } }","package International_Trade_Union.model;  import International_Trade_Union.setings.Seting; import International_Trade_Union.utils.UtilsFileSaveRead;  import java.io.FileNotFoundException;   public class User {     private static String addressMiner=\"\";      public static void setUserAddress(String addressMiner) { //        System.out.println(\"change minerAccount: \" + addressMiner); //        UtilsFileSaveRead.save(addressMiner, Seting.ORIGINAL_ACCOUNT, false);         User.addressMiner = addressMiner;     }      public static String getUserAddress() throws FileNotFoundException {         addressMiner = UtilsFileSaveRead.read(Seting.ORIGINAL_ACCOUNT);         System.out.println(\"user: \" + addressMiner);         if(addressMiner.isEmpty() || addressMiner == null)             addressMiner = \"empty \";         return addressMiner;     } }","package International_Trade_Union.network;  import International_Trade_Union.entity.DtoTransaction.DtoTransaction; import International_Trade_Union.model.Mining; import International_Trade_Union.setings.Seting; import International_Trade_Union.utils.*; import org.json.JSONException;  import java.io.File; import java.io.IOException; import java.security.InvalidKeyException; import java.security.NoSuchAlgorithmException; import java.security.NoSuchProviderException; import java.security.SignatureException; import java.security.spec.InvalidKeySpecException; import java.util.ArrayList; import java.util.List; import java.util.stream.Collectors;  public class AllTransactions {     private static List<DtoTransaction> instance = new ArrayList<>();     //все транзакции которые уже добавлены в блок, нужно чтобы повторно     //не добавлялись в блок если они скачены с дисковери.     private static List<DtoTransaction> sendedTransaction = new ArrayList<>();      public static List<DtoTransaction> readFrom() throws IOException, NoSuchAlgorithmException, InvalidKeySpecException, SignatureException, NoSuchProviderException, InvalidKeyException {         return UtilsTransaction.readLineObject(Seting.ORGINAL_ALL_TRANSACTION_FILE);     }      public static synchronized List<DtoTransaction> getInstance() throws IOException, NoSuchAlgorithmException, InvalidKeySpecException, SignatureException, NoSuchProviderException, InvalidKeyException {         if (instance == null) {             instance = new ArrayList<>();         }         instance = new ArrayList<>();          //считываем с пула транзакции из дисковери.         for (String s : Seting.ORIGINAL_ADDRESSES) {             try {                 String json = UtilUrl.readJsonFromUrl(s + \"/getTransactions\");                 List<DtoTransaction> list = UtilsJson.jsonToDtoTransactionList(json);                  instance.addAll(list);               } catch (IOException | JSONException e) {                  System.out.println(\"AllTransaction: getInstance: Error\");                 continue;             }           }          instance.addAll(UtilsTransaction.readLineObject(Seting.ORGINAL_ALL_TRANSACTION_FILE));         instance = instance.stream().distinct().collect(Collectors.toList());          sendedTransaction = getInsanceSended();          instance.removeAll(sendedTransaction);         return instance;     }      public static synchronized void clearAllTransaction() {         instance = new ArrayList<>();         Mining.deleteFiles(Seting.ORGINAL_ALL_TRANSACTION_FILE);     }      public static synchronized void clearAllSendedTransaction(long index) {         if(index % (Seting.COUNT_BLOCK_IN_DAY * Seting.DAY_DELETED_SENDED_FILE) == 0){             sendedTransaction = new ArrayList<>();             Mining.deleteFiles(Seting.ORIGINAL_ALL_SENDED_TRANSACTION_FILE);             System.out.println(\"clear delete sended transaction\");         }      }      public static synchronized void clearUsedTransaction(List<DtoTransaction> transactions) throws IOException, NoSuchAlgorithmException, SignatureException, InvalidKeySpecException, NoSuchProviderException, InvalidKeyException {         instance = getInstance();         List<DtoTransaction> temporaryDto = new ArrayList<>();          instance = temporaryDto;         instance.removeAll(transactions);         Mining.deleteFiles(Seting.ORGINAL_ALL_TRANSACTION_FILE);         for (DtoTransaction dtoTransaction : instance) {              UtilsTransaction.saveAllTransaction(dtoTransaction, Seting.ORGINAL_ALL_TRANSACTION_FILE);         }       }      public static synchronized void addTransaction(DtoTransaction transaction) throws IOException, NoSuchAlgorithmException, SignatureException, InvalidKeySpecException, NoSuchProviderException, InvalidKeyException {          instance = getInstance();         instance.add(transaction);         Mining.deleteFiles(Seting.ORGINAL_ALL_TRANSACTION_FILE);         instance = instance.stream().filter(UtilsUse.distinctByKey(DtoTransaction::toSign)).collect(Collectors.toList());         for (DtoTransaction dtoTransaction : instance) {             UtilsTransaction.saveAllTransaction(dtoTransaction, Seting.ORGINAL_ALL_TRANSACTION_FILE);         }       }      public static synchronized void addSendedTransaction(List<DtoTransaction> transactions) throws IOException, NoSuchAlgorithmException, InvalidKeySpecException, SignatureException, NoSuchProviderException, InvalidKeyException {         sendedTransaction = getInsanceSended();         sendedTransaction.addAll(transactions);          Mining.deleteFiles(Seting.ORIGINAL_ALL_SENDED_TRANSACTION_FILE);         for (DtoTransaction dtoTransaction : sendedTransaction) {             UtilsTransaction.saveAllTransaction(dtoTransaction, Seting.ORIGINAL_ALL_SENDED_TRANSACTION_FILE);         }          System.out.println(\"AllTransaction: addSendedTransaction: \" + sendedTransaction.size());      }      public static List<DtoTransaction> getInsanceSended() throws IOException, NoSuchAlgorithmException, InvalidKeySpecException, SignatureException, NoSuchProviderException, InvalidKeyException {         if (sendedTransaction == null) {             sendedTransaction = new ArrayList<>();         }         sendedTransaction = UtilsTransaction.readLineObject(Seting.ORIGINAL_ALL_SENDED_TRANSACTION_FILE);         sendedTransaction = sendedTransaction.stream().distinct().collect(Collectors.toList());         return sendedTransaction;     }  }","package International_Trade_Union.network;    import International_Trade_Union.entity.DtoTransaction.DtoTransaction;  import java.util.ArrayList; import java.util.List;  public class Transactions {     public  List<DtoTransaction> getTransactions() {         List<DtoTransaction> transactions = new ArrayList<>();         return transactions;     } }","package International_Trade_Union.node;  import java.util.HashSet; import java.util.Set;  public class Nodes {      public int size(){         return urlAddress.size();     }      public Nodes() {         this.urlAddress = new HashSet<>();     }      public Nodes(Set<String> urlAddress) {         this.urlAddress = urlAddress;     }      private  Set<String> urlAddress = new HashSet<>();      public  void setUrlAddress(Set<String> urlAddress) {         this.urlAddress = urlAddress;     }     public void addAddress(String addressUrl){         urlAddress.add(addressUrl);     }      public  Set<String> getUrlAddresses() {         return urlAddress;     }      public void clear(){         urlAddress = new HashSet<>();     } }","package International_Trade_Union.setings;  import International_Trade_Union.about_usDraft.AboutUsDraft; import International_Trade_Union.about_us_engDraft.AboutUsEngDraft; import International_Trade_Union.CorporateCharterEngDraft.CorporateCharter; import International_Trade_Union.governments.Directors; import International_Trade_Union.governments.NamePOSITION; import International_Trade_Union.utils.UtilsUse;  import java.util.Set;  public interface Seting {     // значение используется для вычисления процентов     int HUNDRED_PERCENT = 100;     // значение используется как константа года,     // в данной системе отсутствует високосный год     int YEAR = 360;      Directors directors = new Directors();       //используется для очистки из файла, где хранятся отправленные транзакции,     //чтобы предотвратить добавление повторно уже отправленных транзакций     int DAY_DELETED_SENDED_FILE = 3;        //За какой период последних блоков учитывать для отбора акционеров.     //Акционерами могут быть только с наибольшим количеством баланса     //отправители и майнеры.     int BOARDS_BLOCK = (int) (Seting.COUNT_BLOCK_IN_DAY * YEAR);       //минимальное значение количество положительных голосов, для того чтобы избрать     // Совет Директоров и Совет Корпоративных Верховных Судей,     int ORIGINAL_LIMIT_MIN_VOTE = 1; //(int) (200 * Seting.COUNT_BLOCK_IN_DAY * 1 / 8);       //прямая демократия, сколько голосов нужно, чтобы правило вступило в силу,     //без необходимости правительства     double ALL_STOCK_VOTE = 1.0;        //Минимальное значение чтобы Совет Корпоративных Верховных Судей могла избрать Верховного Судью     int ORIGINAL_LIMIT_MIN_VOTE_CORPORATE_COUNCIL_OF_REFEREES = 2;      //Минимальное значение остатка голосов чтобы Совет директоров утверждал бюджет,     //стратегический план, в создании новых должностей и назначении новых должностей,     //и т.д. Также участвовал в утверждении законов, вместе с другими участниками.     int ORIGINAL_LIMIT_MIN_VOTE_BOARD_OF_DIRECTORS = 10;      //Минимальное количество остатка голосов чтобы Совет Акционеров     //утверждал вместе с остальными участниками в утверждении законов.     int ORIGINAL_LIMIT_MIN_VOTE_BOARD_OF_SHAREHOLDERS = 10; //100;      //голос Генерального Исполнительного Директора     int ORIGINAL_LIMIT_MIN_VOTE_GENERAL_EXECUTIVE_DIRECTOR = 1;      //фракционный голос минимум 10.0     double ORIGINAL_LIMIT_MIN_VOTE_FRACTIONS = 10.0;      //голос Верховного Судьи     int ORIGINAL_LIMIT_MIN_VOTE_HIGHT_JUDGE = 1;      //для преодоления верховного судьи, если Верховный Судья не одобрил закон     //то нужно получить в два раза больше голосов, чтобы преодолеть вето Верховного Судьи     int POWERFUL_VOTE = 2;      //данная мера нужна чтобы если один счет голосует за несколько кандидатов,     //его голос не делился равномерно, а становился значительно сильнее,     //чтобы не допустить монополии, если очень богатый человек захочет должностные лица поставить к власти     //то он не сможет пример: счет X проголосовал ЗА = 2 закона и ПРОТИВ = 3 закона     //100 = voteYES, 100 = voteNO, voteYES / (2^3) = 12.5 , voteNO / (3^3) = 3.7     //таким образом чем больше голосует, тем меньше голосов остается для избрания     //должностных лиц, это защита от сверхбогатых участников Совета Акционеров     int POWERING_FOR_VOTING = 3;       //голос должностных лиц,     int VOTE_GOVERNMENT = 1;     //голос должностных лиц вместо акций учитывается только один     //голос, как будто у них одна акция     double STOCK_VOTE_GOVERNMENT = 1;      //    процент который получает основатель от добычи     Double FOUNDERS_REWARD = 2.0;      //address for send rewards     String BASIS_ADDRESS = \"faErFrDnBhfSfNnj1hYjxydKNH28cRw1PBwDQEXH3QsJ\";     String BASIS_PASSWORD = \"3hupFSQNWwiJuQNc68HiWzPgyNpQA2yy9iiwhytMS7rZyfPddNRwtvExeevhayzN6xL2YmTXN6NCA8jBhV9ge1w8KciHedGUMgZyq2T7rDdvekVNwEgf5pQrELv8VAEvQ4Kb5uviXJFuMyuD1kRAGExrZym5nppyibEVnTC9Uiw8YzUh2JmVT9iUajnVV3wJ5foMs\";      //сложность коррекция каждые n блоков     int DIFFICULTY_ADJUSTMENT_INTERVAL = (int) (Seting.COUNT_BLOCK_IN_DAY / 2);     int DIFFICULTY_ADJUSTMENT_INTERVAL_TEST = 10;      long BLOCK_GENERATION_INTERVAL = Seting.BLOCK_TIME * 1000;// after Seting.BLOCK_TIME     long BLOCK_GENERATION_INTERVAL_TEST = 0 * 1000;       long INTERVAL_TARGET = 600000;     long INTERVAL_TARGET_TEST = 25000;      // плата за обслуживание каждые 6 месяцев.     Double ANNUAL_MAINTENANCE_FREE_DIGITAL_DOLLAR_YEAR = 0.2;     //отрицательная ставка для цифровой акции     double ANNUAL_MAINTENANCE_FREE_DIGITAL_STOCK_YEAR = 0.4;     //каждые сколько месяцев снимать     int HALF_YEAR = 2;      //стоимость создания закона 5     double COST_LAW = 5;     //с чего начинается адрес пакета закона     //сокращенно корпорация     String NAME_LAW_ADDRESS_START = \"LIBER\";      int HASH_COMPLEXITY_GENESIS = 1;      //совет акционеров    int BOARD_OF_SHAREHOLDERS = 1500;      //ПОПРАВКА В УСТАВЕ    //требования к поправкам     String AMENDMENT_TO_THE_CHARTER = \"AMENDMENT_TO_THE_CHARTER\";      //директора созданные Советом директоров     String ADD_DIRECTOR = \"ADD_DIRECTOR_\";        //бюджет должен формировать только палата представителей     String BUDGET = \"BUDGET\";      //план также утверждается на четыре года и утверждается только палатой представителей     //каждый план обязан содержать дату начала планирования с какого числа вступает в силу.     //FOUR-YEAR PLAN     String STRATEGIC_PLAN = \"STRATEGIC_PLAN\";       //лимиты для ведения поправок     //палата судей минимум 5 голосов     int ORIGINAL_LIMIT_MIN_VOTE_CORPORATE_COUNCIL_OF_REFEREES_AMENDMENT = 5;// 5;     //палата представителей 20% голосов     int ORIGINAL_LIMIT_MIN_VOTE_BOARD_OF_DIRECTORS_AMENDMENT =            directors.getDirector(NamePOSITION.BOARD_OF_DIRECTORS.toString()).getCount() * 20 / 100;      //Совет акционеров минимум 20% голосов     int ORIGINAL_LIMIT_MINT_VOTE_BOARD_OF_SHAREHOLDERS_AMENDMENT = BOARD_OF_SHAREHOLDERS * 20 / 100;         //    адресс основателя: здесь будет мой адрес. Сейчас заглушка     String ADDRESS_FOUNDER_TEST = \"stExZb8ifLfnFoq4JJuTifpAcscegATH8znhwW26zyTa\";     String ADDRESS_FOUNDER = \"stExZb8ifLfnFoq4JJuTifpAcscegATH8znhwW26zyTa\";      String CORPORATE_CHARTER_DRAFT = International_Trade_Union.CorporateCharterDraft.CorporateCharter.getAllConstitution() + \"\\n\" + CorporateCharter.getAllConstitution() + AboutUsDraft.getAboutUs()             + AboutUsEngDraft.getAboutUs();      //КЛЮЧЕВОЕ НАЗВАНИЕ ПАКЕТА ЧТО ЭТО УСТАВ, ДЕЙСТВУЮЩИЙ УСТАВ ПОДПИСАН ОСНОВАТЕЛЕМ.     String ORIGINAL_CHARTER_CURRENT_LAW_PACKAGE_NAME = \"ORIGINAL_CHARTER_CURRENT_LAW_PACKAGE_NAME\";      //КЛЮЧЕВОЕ НАЗВАНИЕ ДЛЯ КОДА КОТОРЫЙ СОПРОВОЖДАЕТСЯ С УСТАВОМ     String ORIGINAL_CHARTER_CURRENT_ALL_CODE = \"ORIGINAL_CHARTER_CURRENT_ALL_CODE\";      //начальная сумма основателя     Double FOUNDERS_REMUNERATION_DIGITAL_DOLLAR = 30000000.0;     double FOUNDERS_REMNUNERATION_DIGITAL_STOCK = 30000000.0;       // сколько секунд в сутках     int DAY_SECOND = 86400;      //    за сколько секунд добывается каждый блок     int BLOCK_TIME = 150;       //сколько блоков добывается в сутки     double COUNT_BLOCK_IN_DAY = (DAY_SECOND / BLOCK_TIME);      //подсчет голосов для должности в годах, учитываются только те голоса     //которые не позже четырех лет для законов и должностей,     //голоса отданные за законы должны обновляться каждые четыре года     //как и за должности     int POSITION_YEAR_VOTE = (int) Seting.COUNT_BLOCK_IN_DAY * YEAR * 4;     //подсчет голосов для законов в годах     int LAW_YEAR_VOTE = (int) Seting.COUNT_BLOCK_IN_DAY * YEAR * 4;      String ORIGINAL_BLOCKCHAIN_FILE = \"C:\\\\resources\\\\blockchain\\\\\";     String ORIGINAL_BALANCE_FILE = \"C:\\\\resources\\\\balance\\\\\";     String ORIGINAL_BOARD_0F_SHAREHOLDERS_FILE = \"C:\\\\resources\\\\federalGovernment\\\\federalGovernment.txt\";     String ORIGINAL_ALL_CORPORATION_LAWS_FILE = \"C:\\\\resources\\\\federalLaws\\\\\";     String ORIGINAL_ACCOUNT = \"C:\\\\resources\\\\minerAccount\\\\minerAccount.txt\";     String ORIGINAL_CORPORATE_VOTE_FILE = \"C:\\\\resources\\\\vote\\\\\";      String ORIGINAL_ALL_CORPORATION_LAWS_WITH_BALANCE_FILE = \"C:\\\\resources\\\\allLawsWithBalance\\\\\";     String ORGINAL_ALL_TRANSACTION_FILE = \"C:\\\\resources\\\\transactions\\\\\";     String ORIGINAL_ALL_SENDED_TRANSACTION_FILE = \"C:\\\\resources\\\\sendedTransaction\\\\\";     String ORIGINAL_POOL_URL_ADDRESS_FILE = \"C:\\\\resources\\\\poolAddress\\\\\";      //адресса внешних сервисов     Set<String> ORIGINAL_ADDRESSES = Set.of(\"http://194.87.236.238:80\");       int SIZE_FILE_LIMIT = 100;      //папки файла для тестирования с сохранениям файла     String TEST_LAST_BLOCK = \".\\\\src\\\\test\\\\java\\\\unitted_states_of_mankind\\\\resourceTestingFileSaved\\\\lastBlock\\\\\";     String INDEX_TEST = \".\\\\src\\\\test\\\\java\\\\unitted_states_of_mankind\\\\resourceTestingFileSaved\\\\index\\\\index.txt\";     String TEST_BLOCKCHAIN_SAVED = \".\\\\src\\\\test\\\\java\\\\unitted_states_of_mankind\\\\resourceTestingFileSaved\\\\network\\\\\";     String TEST_BLOCKCHAIN_BALANCES = \".\\\\src\\\\test\\\\java\\\\unitted_states_of_mankind\\\\resourceTestingFileSaved\\\\balances\\\\\";     String TEST_FEDERAL_GOVERNMENT = \".\\\\src\\\\test\\\\java\\\\unitted_states_of_mankind\\\\resourceTestingFileSaved\\\\federal government\\\\federalGovernment.txt\";     String TEST_FEDERAL_LAWS = \".\\\\src\\\\test\\\\java\\\\unitted_states_of_mankind\\\\resourceTestingFileSaved\\\\laws\\\\\";     String TEST_CURRENT_LAWS = \".\\\\src\\\\test\\\\java\\\\unitted_states_of_mankind\\\\resourceTestingFileSaved\\\\current laws\\\\\";     String TEST_FEDERAL_VOTE = \".\\\\src\\\\test\\\\java\\\\unitted_states_of_mankind\\\\resourceTestingFileSaved\\\\vote\\\\\";     String TEST_ALL_FEDERAL_LAWS_WITH_BALANCE_FILE = \".\\\\src\\\\test\\\\java\\\\unitted_states_of_mankind\\\\resourceTestingFileSaved\\\\allLawsWithBalance\\\\\";      //Временный блокчейн для тестирования     String TEST_LAST_BLOCK_TEMPORARY = \".\\\\src\\\\test\\\\java\\\\unitted_states_of_mankind\\\\resourceTestingFileWithoutSave\\\\lastBlock\\\\\";     String TEST_INDEX_TEMPORARY = \".\\\\src\\\\test\\\\java\\\\unitted_states_of_mankind\\\\resourceTestingFileWithoutSave\\\\index\\\\index.txt\";     String TEST_TEMPORARY_BLOCKCHAIN = \".\\\\src\\\\test\\\\java\\\\unitted_states_of_mankind\\\\resourceTestingFileWithoutSave\\\\temporary blockchain\\\\\";     String TEST_BLOCKCHAIN_BALANCES_TEMPORARY = \".\\\\src\\\\test\\\\java\\\\unitted_states_of_mankind\\\\resourceTestingFileWithoutSave\\\\balances\\\\\";     String TEST_FEDERAL_GOVERNMENT_TEMPORARY = \".\\\\src\\\\test\\\\java\\\\unitted_states_of_mankind\\\\resourceTestingFileWithoutSave\\\\federal government\\\\federalGovernment.txt\";     String TEST_FEDERAL_LAWS_TEMPORARY = \".\\\\src\\\\test\\\\java\\\\unitted_states_of_mankind\\\\resourceTestingFileWithoutSave\\\\laws\\\\\";     String TEST_CURRENT_LAWS_TEMPORARY = \".\\\\src\\\\test\\\\java\\\\unitted_states_of_mankind\\\\resourceTestingFileWithoutSave\\\\current laws\\\\\";     String TEST_FEDERAL_VOTE_TEMPORARY = \".\\\\src\\\\test\\\\java\\\\unitted_states_of_mankind\\\\resourceTestingFileSaved\\\\vote\\\\\";     String TEST_ALL_FEDERAL_LAWS_WITH_BALANCE_TEMPORARY = \".\\\\unitedStates\\\\src\\\\test\\\\java\\\\unitted_states_of_mankind\\\\resourceTestingFileWithoutSave\\\\allLawsWithBalance\\\\\";      String TEST_FILE_WRITE_INFO = \".\\\\src\\\\test\\\\java\\\\unitted_states_of_mankind\\\\blockchainTwentyYearTest\\\\\";     double DIGITAL_DOLLAR_REWARDS_BEFORE = 200.0;     double DIGITAL_STOCK_REWARDS_BEFORE = 200.0;     double DIGITAL_DOLLAR_FOUNDER_REWARDS_BEFORE = Math.round(UtilsUse.countPercents(Seting.DIGITAL_DOLLAR_REWARDS_BEFORE, Seting.FOUNDERS_REWARD));     double DIGITAL_REPUTATION_FOUNDER_REWARDS_BEFORE = Math.round(UtilsUse.countPercents(Seting.DIGITAL_STOCK_REWARDS_BEFORE, Seting.FOUNDERS_REWARD));    }","package International_Trade_Union.utils.base;  public interface Base {     String encode(byte[] input);     byte[] decode(String input); }","package International_Trade_Union.utils.base;    /*  * Copyright 2011 Google Inc.  * Copyright 2018 Andreas Schildbach  *  * From https://github.com/bitcoinj/bitcoinj/blob/master/core/src/main/java/org/bitcoinj/core/Base58.java  *  * Licensed under the Apache License, Version 2.0 (the \"License\");  * you may not use this file except in compliance with the License.  * You may obtain a copy of the License at  *  *    http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an \"AS IS\" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */  import java.math.BigInteger; import java.util.Arrays;  /**  * Base58 is a way to encode Bitcoin addresses (or arbitrary data) as alphanumeric strings.  * <p>  * Note that this is not the same base58 as used by Flickr, which you may find referenced around the Internet.  * <p>  * Satoshi explains: why base-58 instead of standard base-64 encoding?  * <ul>  * <li>Don't want 0OIl characters that look the same in some fonts and  *     could be used to create visually identical looking minerAccount numbers.</li>  * <li>A string with non-alphanumeric characters is not as easily accepted as an minerAccount number.</li>  * <li>E-mail usually won't line-break if there's no punctuation to break at.</li>  * <li>Doubleclicking selects the whole number as one word if it's all alphanumeric.</li>  * </ul>  * <p>  * However, note that the encoding/decoding runs in O(n&sup2;) time, so it is not useful for large data.  * <p>  * The basic idea of the encoding is to treat the data bytes as a large number represented using  * base-256 digits, convert the number to be represented using base-58 digits, preserve the exact  * number of leading zeros (which are otherwise lost during the mathematical operations on the  * numbers), and finally represent the resulting base-58 digits as alphanumeric ASCII characters.  */ public class Base58 implements Base {     public static final char[] ALPHABET = \"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz\".toCharArray();     private static final char ENCODED_ZERO = ALPHABET[0];     private static final int[] INDEXES = new int[128];     static {         Arrays.fill(INDEXES, -1);         for (int i = 0; i < ALPHABET.length; i++) {             INDEXES[ALPHABET[i]] = i;         }     }      /**      * Encodes the given bytes as a base58 string (no checksum is appended).      *      * @param input the bytes to encode      * @return the base58-encoded string      */     public String encode(byte[] input) {         if (input.length == 0) {             return \"\";         }         // Count leading zeros.         int zeros = 0;         while (zeros < input.length && input[zeros] == 0) {             ++zeros;         }         // Convert base-256 digits to base-58 digits (plus conversion to ASCII characters)         input = Arrays.copyOf(input, input.length); // since we modify it in-place         char[] encoded = new char[input.length * 2]; // upper bound         int outputStart = encoded.length;         for (int inputStart = zeros; inputStart < input.length; ) {             encoded[--outputStart] = ALPHABET[divmod(input, inputStart, 256, 58)];             if (input[inputStart] == 0) {                 ++inputStart; // optimization - skip leading zeros             }         }         // Preserve exactly as many leading encoded zeros in output as there were leading zeros in input.         while (outputStart < encoded.length && encoded[outputStart] == ENCODED_ZERO) {             ++outputStart;         }         while (--zeros >= 0) {             encoded[--outputStart] = ENCODED_ZERO;         }         // Return encoded string (including encoded leading zeros).         return new String(encoded, outputStart, encoded.length - outputStart);     }      /**      * Decodes the given base58 string into the original data bytes.      *      * @param input the base58-encoded string to decode      * @return the decoded data bytes      */     public byte[] decode(String input) {         if (input.length() == 0) {             return new byte[0];         }         // Convert the base58-encoded ASCII chars to a base58 byte sequence (base58 digits).         byte[] input58 = new byte[input.length()];         for (int i = 0; i < input.length(); ++i) {             char c = input.charAt(i);             int digit = c < 128 ? INDEXES[c] : -1;             if (digit < 0) {                 throw new IllegalStateException(\"InvalidCharacter in base 58\");             }             input58[i] = (byte) digit;         }         // Count leading zeros.         int zeros = 0;         while (zeros < input58.length && input58[zeros] == 0) {             ++zeros;         }         // Convert base-58 digits to base-256 digits.         byte[] decoded = new byte[input.length()];         int outputStart = decoded.length;         for (int inputStart = zeros; inputStart < input58.length; ) {             decoded[--outputStart] = divmod(input58, inputStart, 58, 256);             if (input58[inputStart] == 0) {                 ++inputStart; // optimization - skip leading zeros             }         }         // Ignore extra leading zeroes that were added during the calculation.         while (outputStart < decoded.length && decoded[outputStart] == 0) {             ++outputStart;         }         // Return decoded data (including original number of leading zeros).         return Arrays.copyOfRange(decoded, outputStart - zeros, decoded.length);     }      public  BigInteger decodeToBigInteger(String input) {         return new BigInteger(1, decode(input));     }      /**      * Divides a number, represented as an array of bytes each containing a single digit      * in the specified base, by the given divisor. The given number is modified in-place      * to contain the quotient, and the return value is the remainder.      *      * @param number the number to divide      * @param firstDigit the index within the array of the first non-zero digit      *        (this is used for optimization by skipping the leading zeros)      * @param base the base in which the number's digits are represented (up to 256)      * @param divisor the number to divide by (up to 256)      * @return the remainder of the division operation      */     private byte divmod(byte[] number, int firstDigit, int base, int divisor) {         // this is just long division which accounts for the base of the input digits         int remainder = 0;         for (int i = firstDigit; i < number.length; i++) {             int digit = (int) number[i] & 0xFF;             int temp = remainder * base + digit;             number[i] = (byte) (temp / divisor);             remainder = temp % divisor;         }         return (byte) remainder;     } }","package International_Trade_Union.utils;    import International_Trade_Union.setings.Seting; import International_Trade_Union.model.Account;  import java.io.File; import java.io.IOException; import java.security.InvalidKeyException; import java.security.NoSuchAlgorithmException; import java.security.NoSuchProviderException; import java.security.SignatureException; import java.security.spec.InvalidKeySpecException; import java.util.ArrayList; import java.util.List; import java.util.Map; import java.util.stream.Collectors;  public class SaveBalances {      public static void saveBalances(Map<String, Account> balances, String filename) throws IOException, NoSuchAlgorithmException, SignatureException, InvalidKeySpecException, NoSuchProviderException, InvalidKeyException {         int fileLimit = Seting.SIZE_FILE_LIMIT * 1024 * 1024;          //папка чтобы проверить есть ли         File folder = new File(filename);         List<String> files = new ArrayList<>();         for (File file : folder.listFiles()) {             if(!file.isDirectory()){                 files.add(file.getAbsolutePath());             }         }          int count = 0;         files = files.stream().sorted().collect(Collectors.toList());         String nextFile = \"\";          if (files.size() > 0) {             nextFile = files.get(files.size()-1);              count = Integer.parseInt(nextFile.replaceAll(\"[^\\\\d]\", \"\"));           }          File file = new File(nextFile);          if(file.length() >= fileLimit){             count++;          }          nextFile = filename + count + \".txt\";          List<String> jsons = new ArrayList<>();         for (Map.Entry<String, Account> stringAccountEntry : balances.entrySet()) {             String json = UtilsJson.objToStringJson(stringAccountEntry.getValue());             jsons.add(json);         }  //        String json = UtilsJson.objToStringJson(minerAccount); //        UtilsFileSaveRead.save(json + \"\\n\", nextFile);         UtilsFileSaveRead.saves(jsons, nextFile, true);      }      public static Map<String, Account> readLineObject(String filename ) throws IOException, NoSuchAlgorithmException, InvalidKeySpecException, SignatureException, NoSuchProviderException, InvalidKeyException {         List<Account> accounts = new ArrayList<>();         File folder = new File(filename);         for (final File fileEntry : folder.listFiles()) {             if (fileEntry.isDirectory()) {                 System.out.println(\"is directory \" + fileEntry.getAbsolutePath());             } else {                 List<String> list = UtilsFileSaveRead.reads(fileEntry.getAbsolutePath());                 for (String s : list) {                    Account account = UtilsJson.jsonToAccount(s);                     accounts.add(account);                 }              }         }         Map<String, Account> balances = accounts                 .stream()                 .collect(Collectors.toMap(Account::getAccount, t->t, (v1, v2) -> v1));         return balances;     } }","package International_Trade_Union.utils;    import International_Trade_Union.model.Account; import International_Trade_Union.setings.Seting;  import java.util.ArrayList; import java.util.List;  public class UtilAccounts {  //    поиск аккаунта по адрессу     public static Account serchAccountByAddress(List<Account> accountList, String address){         Account result = null;         for (Account account : accountList) {             if(account.getAccount().equals(address)){                 result = account; //                System.out.println(String.format(\"find minerAccount: %s, address %s\", minerAccount.getAccount(), address));                 return result;             }         }         return result;     } //    возвращает список счетов чья наличность больше n     public static List<Account> allAccountsRemnantUpperLimit(              List<Account> accountList, double bottomLineMoney){         List<Account> accounts = new ArrayList<>();                  for (Account account : accountList) {                      if(account.getDigitalDollarBalance()>bottomLineMoney)                         accounts.add(account);                 }               return accounts;     }  //    подсчитывает общий баланс всех участников     public static double getAllBalance( List<Account> accountList){         double allBalance = 0.0;              for (Account account : accountList) {                 if(!account.getAccount().equals(Seting.BASIS_ADDRESS))                     allBalance+=account.getDigitalDollarBalance();             }           return allBalance;     }     }","package International_Trade_Union.utils;  import International_Trade_Union.entity.DtoTransaction.DtoTransaction; import International_Trade_Union.setings.Seting;  import java.io.File; import java.io.IOException; import java.security.InvalidKeyException; import java.security.NoSuchAlgorithmException; import java.security.NoSuchProviderException; import java.security.SignatureException; import java.security.spec.InvalidKeySpecException; import java.util.ArrayList; import java.util.HashSet; import java.util.List; import java.util.Set; import java.util.stream.Collectors;  public class UtilsAllAddresses {     public static void saveAllAddresses(String adress, String filename) throws IOException, NoSuchAlgorithmException, SignatureException, InvalidKeySpecException, NoSuchProviderException, InvalidKeyException {         int fileLimit = Seting.SIZE_FILE_LIMIT * 1024 * 1024;          //папка чтобы проверить есть ли         File folder = new File(filename);         List<String> files = new ArrayList<>();         for (File file : folder.listFiles()) {             if(!file.isDirectory()){                 files.add(file.getAbsolutePath());             }         }           int count = 0;         files = files.stream().sorted().collect(Collectors.toList());         String nextFile = \"\";          if (files.size() > 0) {             nextFile = files.get(files.size()-1);              count = Integer.parseInt(nextFile.replaceAll(\"[^\\\\d]\", \"\"));           }          File file = new File(nextFile);          if(file.length() >= fileLimit){             count++;          }          nextFile = filename + count + \".txt\";          String json = UtilsJson.objToStringJson(adress);         UtilsFileSaveRead.save(json + \"\\n\", nextFile);      }      public static Set<String> readLineObject(String filename ) throws IOException, NoSuchAlgorithmException, InvalidKeySpecException, SignatureException, NoSuchProviderException, InvalidKeyException {         Set<String> allAddresses = new HashSet<>();         File folder = new File(filename);         for (final File fileEntry : folder.listFiles()) {             if (fileEntry.isDirectory()) {                 System.out.println(\"is directory \" + fileEntry.getAbsolutePath());             } else {                 Set<String> list = UtilsFileSaveRead.readSet(fileEntry.getAbsolutePath())                         .stream().collect(Collectors.toSet());                 for (String s : list) {                     allAddresses.add(s);                 }              }         }          allAddresses = allAddresses                 .stream()                 .collect(Collectors.toSet());           return allAddresses;     }  }","package International_Trade_Union.utils;    import International_Trade_Union.entity.DtoTransaction.DtoTransaction; import International_Trade_Union.entity.blockchain.Blockchain; import International_Trade_Union.entity.blockchain.block.Block; import International_Trade_Union.setings.Seting; import International_Trade_Union.model.Account; import International_Trade_Union.vote.VoteEnum;  import java.io.IOException; import java.security.*; import java.security.spec.InvalidKeySpecException; import java.util.*;   public class UtilsBalance {      //подсчет по штучно баланса     public  static Map<String, Account> calculateBalance(Map<String, Account> balances, Block block) throws IOException, NoSuchAlgorithmException, SignatureException, InvalidKeySpecException, NoSuchProviderException, InvalidKeyException {           double percent = Seting.ANNUAL_MAINTENANCE_FREE_DIGITAL_DOLLAR_YEAR / Seting.HALF_YEAR;         double digitalReputationPercent = Seting.ANNUAL_MAINTENANCE_FREE_DIGITAL_STOCK_YEAR / Seting.HALF_YEAR;             int i = (int) block.getIndex();               for (int j = 0; j < block.getDtoTransactions().size(); j++) {                 int BasisSendCount = 0;                   DtoTransaction transaction = block.getDtoTransactions().get(j);                  if(transaction.getSender().startsWith(Seting.NAME_LAW_ADDRESS_START)){                     System.out.println(\"law balance cannot be sender\");                     continue;                 }                 if (transaction.verify()) {                     if(transaction.getSender().equals(Seting.BASIS_ADDRESS))                         BasisSendCount++;                       Account sender = getBalance(transaction.getSender(), balances);                     Account customer = getBalance(transaction.getCustomer(), balances);                      boolean sendTrue = true;                     if(sender.getAccount().equals(Seting.BASIS_ADDRESS) && BasisSendCount > 2){                         System.out.println(\"Basis address can send only two the base address can send no more than two times per block:\" + Seting.BASIS_ADDRESS);                         continue;                     }                      double minerRewards = Seting.DIGITAL_DOLLAR_REWARDS_BEFORE;                     double digitalReputationForMiner = Seting.DIGITAL_STOCK_REWARDS_BEFORE;                        if(sender.getAccount().equals(Seting.BASIS_ADDRESS) ){                        if(i > 1 && (transaction.getDigitalDollar() > minerRewards || transaction.getDigitalStockBalance() > digitalReputationForMiner )){                            System.out.println(\"rewards cannot be upper than \" + minerRewards);                            continue;                        }                         if(!customer.getAccount().equals(block.getFounderAddress()) && !customer.getAccount().equals(block.getMinerAddress())){                             System.out.println(\"Basis address can send only to founder or miner\");                             continue;                         }                     }                     sendTrue = UtilsBalance.sendMoney(sender, customer, transaction.getDigitalDollar(), transaction.getDigitalStockBalance(), transaction.getBonusForMiner(), transaction.getVoteEnum());                      //если транзация валидная то записать данн иыезменения в баланс                     if(sendTrue){                         balances.put(sender.getAccount(), sender);                         balances.put(customer.getAccount(), customer);                     }                  }              }           if (i != 0 && i / Seting.COUNT_BLOCK_IN_DAY % (Seting.YEAR / Seting.HALF_YEAR) == 0.0) {              for (Map.Entry<String, Account> changeBalance : balances.entrySet()) {                 Account change = changeBalance.getValue();                 change.setDigitalStockBalance(change.getDigitalStockBalance() - UtilsUse.countPercents(change.getDigitalStockBalance(), digitalReputationPercent));                 change.setDigitalDollarBalance(change.getDigitalDollarBalance() - UtilsUse.countPercents(change.getDigitalDollarBalance(), percent));             }         }           return balances;      }     //подсчет целиком баланса     public static Map<String, Account> calculateBalances(List<Block> blocks) throws IOException, NoSuchAlgorithmException, SignatureException, InvalidKeySpecException, NoSuchProviderException, InvalidKeyException {         Map<String, Account> balances = new HashMap<>();         for (Block block :  blocks) {             calculateBalance(balances, block);         }          return balances;      }        public static Account getBalance(String address, Map<String, Account> balances) {         if (balances.containsKey(address)) {             return balances.get(address);         } else {             Account account = new Account(address, 0.0, 0.0);             return account;         }     }       public static Account findAccount(Blockchain blockList, String address) throws IOException, NoSuchAlgorithmException, SignatureException, InvalidKeySpecException, NoSuchProviderException, InvalidKeyException {         Map<String, Account> accountMap = calculateBalances(blockList.getBlockchainList());         Account account = accountMap.get(address);         return account != null? account: new Account(address, 0.0, 0.0);     }      public static boolean sendMoney(Account senderAddress, Account recipientAddress, double digitalDollar, double digitalReputation, double minerRewards) throws NoSuchAlgorithmException, InvalidKeySpecException, IOException, SignatureException, NoSuchProviderException, InvalidKeyException {         return sendMoney(senderAddress, recipientAddress, digitalDollar, digitalReputation, minerRewards, VoteEnum.YES);     }      public static boolean sendMoney(Account senderAddress, Account recipientAddress, double digitalDollar, double digitalReputation, double minerRewards, VoteEnum voteEnum) throws NoSuchAlgorithmException, InvalidKeySpecException, NoSuchProviderException, IOException, SignatureException, InvalidKeyException {         double remnantDigitalDollar = 0.0;         double remnantDigitalReputation = 0.0;         boolean sendTrue = true;         if (senderAddress.getAccount().equals(recipientAddress.getAccount())) {             System.out.println(\"sender %s, recipient %s cannot be equals! Error!\".format(senderAddress.getAccount(), recipientAddress.getAccount()));             sendTrue = false;         }          remnantDigitalDollar = senderAddress.getDigitalDollarBalance();         remnantDigitalReputation = senderAddress.getDigitalStockBalance();          if (!senderAddress.getAccount().equals(Seting.BASIS_ADDRESS)) {             if(remnantDigitalDollar < digitalDollar + minerRewards){                 sendTrue = false;             }             else if(remnantDigitalReputation < digitalReputation){                     System.out.printf(\"sender power %f, les than powerSend:  %f\\n\",                             senderAddress.getDigitalStockBalance(), digitalReputation);                     sendTrue = false;              } else if (recipientAddress.getAccount().equals(Seting.BASIS_ADDRESS)) {                 System.out.println(\"Basis canot to be recipient;\");                 sendTrue = false;             } else {                  senderAddress.setDigitalDollarBalance(senderAddress.getDigitalDollarBalance() - digitalDollar);                 senderAddress.setDigitalStockBalance(senderAddress.getDigitalStockBalance() - digitalReputation);                 recipientAddress.setDigitalDollarBalance(recipientAddress.getDigitalDollarBalance() + digitalDollar);                 //сделано чтобы можно было увеличить или отнять власть                 if (voteEnum.equals(VoteEnum.YES)) {                     recipientAddress.setDigitalStockBalance(recipientAddress.getDigitalStockBalance() + digitalReputation);                 } else if (voteEnum.equals(VoteEnum.NO)) {                     //политика сдерживания.                     recipientAddress.setDigitalStockBalance(recipientAddress.getDigitalStockBalance() - digitalReputation);                 }              }           }  else if (senderAddress.getAccount().equals(Seting.BASIS_ADDRESS)) {              recipientAddress.setDigitalDollarBalance(recipientAddress.getDigitalDollarBalance() + digitalDollar);             recipientAddress.setDigitalStockBalance(recipientAddress.getDigitalStockBalance() + digitalReputation);          }         return sendTrue;     } }","package International_Trade_Union.utils;   import com.fasterxml.jackson.core.JsonProcessingException; import International_Trade_Union.config.BLockchainFactory; import International_Trade_Union.config.BlockchainFactoryEnum; import International_Trade_Union.entity.DtoTransaction.DtoTransaction; import International_Trade_Union.entity.blockchain.Blockchain; import International_Trade_Union.entity.blockchain.block.Block; import International_Trade_Union.setings.Seting;   import java.io.*; import java.security.*; import java.security.spec.InvalidKeySpecException; import java.util.*; import java.util.stream.Collectors;  public class UtilsBlock {      public static void saveBlocks(List<Block> blocks, String filename) throws IOException {         int fileLimit = Seting.SIZE_FILE_LIMIT * 1024 * 1024;          //папка чтобы проверить есть ли         File folder = new File(filename);         List<String> files = new ArrayList<>();         for (File file : folder.listFiles()) {             if(!file.isDirectory()){                 files.add(file.getAbsolutePath());             }         }          int count = 0;         files = files.stream().sorted().collect(Collectors.toList());         String nextFile = \"\";          if (files.size() > 0) {             nextFile = files.get(files.size()-1);              count = Integer.parseInt(nextFile.replaceAll(\"[^\\\\d]\", \"\"));           }          File file = new File(nextFile);          if(file.length() >= fileLimit){             count++;          }          nextFile = filename + count + \".txt\";          List<String> jsons = new ArrayList<>();         for (Block block: blocks) {             String json = UtilsJson.objToStringJson(block);             jsons.add(json);         }  //        String json = UtilsJson.objToStringJson(minerAccount); //        UtilsFileSaveRead.save(json + \"\\n\", nextFile);         UtilsFileSaveRead.saves(jsons, nextFile, true);     }     public static void saveBLock(Block block, String filename) throws IOException, NoSuchAlgorithmException, SignatureException, InvalidKeySpecException, NoSuchProviderException, InvalidKeyException {         int fileLimit = Seting.SIZE_FILE_LIMIT * 1024 * 1024;          //папка чтобы проверить есть ли         File folder = new File(filename);         List<String> files = new ArrayList<>();         for (File file : folder.listFiles()) {             if(!file.isDirectory()){                 files.add(file.getAbsolutePath());             }         }           int count = 0;         files = files.stream().sorted().collect(Collectors.toList());         String nextFile = \"\";          if (files.size() > 0) {             nextFile = files.get(files.size()-1);              count = Integer.parseInt(nextFile.replaceAll(\"[^\\\\d]\", \"\"));           }          File file = new File(nextFile);          if(file.length() >= fileLimit){             count++;          }           nextFile = filename + count + \".txt\";          String json = UtilsJson.objToStringJson(block);         UtilsFileSaveRead.save(json + \"\\n\", nextFile);      }        public static List<Block> read(String nameFile) throws FileNotFoundException, JsonProcessingException {         return  UtilsJson.jsonToListBLock(UtilsFileSaveRead.read(nameFile));     }      public static List<Block> readLineObject(String filename ) throws IOException, NoSuchAlgorithmException, InvalidKeySpecException, SignatureException, NoSuchProviderException, InvalidKeyException {         List<Block> blocks = new ArrayList<>();         File folder = new File(filename);          for (final File fileEntry : folder.listFiles()) {             if (fileEntry.isDirectory()) {                 System.out.println(\"is directory \" + fileEntry.getAbsolutePath());             } else {                List<String> list = UtilsFileSaveRead.reads(fileEntry.getAbsolutePath());                 for (String s : list) {                      Block block = UtilsJson.jsonToBLock(s);                     blocks.add(block);                 }              }         }         blocks = blocks                 .stream()                 .sorted(Comparator.comparing(Block::getIndex))                 .collect(Collectors.toList());          return blocks;     }     public static Blockchain readBLock(String nameFile, long BLOCK_GENERATION_INTERVAL, int DIFFICULTY_ADJUSTMENT_INTERVAL, long INTERVAL_TARGET , String ADDRESS_FOUNDER) throws NoSuchAlgorithmException, InvalidKeySpecException, IOException, SignatureException, NoSuchProviderException, InvalidKeyException {         List<Block> blocks = null;         List<List<Block>> list = new ArrayList<>();          File folder = new File(nameFile);          for (final File fileEntry : folder.listFiles()) {             if (fileEntry.isDirectory()) {                 System.out.println(\"is directory \" + fileEntry.getAbsolutePath());             } else {                 blocks = UtilsJson.jsonToListBLock(UtilsFileSaveRead.read(fileEntry.getAbsolutePath()));                 list.add(blocks);             }         }          // new Blockchain(BLOCK_GENERATION_INTERVAL, DIFFICULTY_ADJUSTMENT_INTERVAL, INTERVAL_TARGET, ADDRESS_FOUNDER);         Blockchain blockchain = BLockchainFactory.getBlockchain(BlockchainFactoryEnum.ORIGINAL);         blockchain.setBlockchainList(new ArrayList<>());          for (List<Block> lists : list) {             for (int i = 0; i < lists.size(); i++) {                 blockchain.addBlock(lists.get(i));             }          }          List<Block> blockList = blockchain.getBlockchainList()                 .stream()                 .sorted(Comparator.comparing(Block::getIndex))                 .collect(Collectors.toList());         blockchain.setBlockchainList(blockList);          return blockchain;     }      public static Blockchain readBLock() throws IOException, NoSuchAlgorithmException, InvalidKeySpecException, SignatureException, NoSuchProviderException, InvalidKeyException {        return readBLock(Seting.TEST_FILE_WRITE_INFO, Seting.BLOCK_GENERATION_INTERVAL,  Seting.DIFFICULTY_ADJUSTMENT_INTERVAL, Seting.INTERVAL_TARGET, Seting.ADDRESS_FOUNDER );     }      public static boolean isValidTimestamp(Block newBlock, Block prevBLock, long timestamp){         return (prevBLock.getTimestamp().getTime() - timestamp <newBlock.getTimestamp().getTime())                 && newBlock.getTimestamp().getTime() < System.currentTimeMillis();     }      //https://lhartikk.github.io/jekyll/update/2017/07/13/chapter2.html     //сайт сложности     //https://lhartikk.github.io/jekyll/update/2017/07/13/chapter2.html     //https://tproger.ru/translations/blockchain-explained/      //new https://guicommits.com/building-blockchain-with-python/      /**определяет сложность, раз пол дня корректирует сложность. В сутках 576 блоков.      * каждый блок добывается примерно 2.3 минуты*/     public static int difficulty(List<Block> blocks, long BLOCK_GENERATION_INTERVAL, int  DIFFICULTY_ADJUSTMENT_INTERVAL ){          //секунды как часто создается блоки         int difficulty = 1;         Block latestBlock = blocks.get(blocks.size() -1);         if(latestBlock.getIndex() != 0 && latestBlock.getIndex() % DIFFICULTY_ADJUSTMENT_INTERVAL == 0){             difficulty = getAdjustedDifficulty(latestBlock, blocks, BLOCK_GENERATION_INTERVAL, DIFFICULTY_ADJUSTMENT_INTERVAL);             System.out.println(\"difficulty: change dificulty: \" + difficulty);         }         else {             difficulty =  latestBlock.getHashCompexity();         }         return difficulty == 0? 1: difficulty;     }       /**получить сложность*/     private static int getAdjustedDifficulty(Block latestBlock, List<Block> blocks, long BLOCK_GENERATION_INTERVAL, int DIFFICULTY_ADJUSTMENT_INTERVAL){         Block prevAdjustmentBlock = blocks.get(blocks.size() - DIFFICULTY_ADJUSTMENT_INTERVAL);          long timeExpected = BLOCK_GENERATION_INTERVAL * DIFFICULTY_ADJUSTMENT_INTERVAL;         long timeTaken = latestBlock.getTimestamp().getTime() - prevAdjustmentBlock.getTimestamp().getTime();          if(timeTaken < timeExpected / 2){              return prevAdjustmentBlock.getHashCompexity() + 1;         }else if(timeTaken > timeExpected * 2){              return prevAdjustmentBlock.getHashCompexity() - 1;         }else {             return prevAdjustmentBlock.getHashCompexity();         }     }      public static boolean validationOneBlock(             String addressFounder,             Block previusblock,             Block thisBlock,             long blockGenerationInterval,             int difficultyAdjustmentInterval,             List<Block> lastBlock) throws IOException, NoSuchAlgorithmException, SignatureException, InvalidKeySpecException, NoSuchProviderException, InvalidKeyException {          boolean addressFounderReward = false;         boolean addressMinerReward = false;         if(!addressFounder.equals(thisBlock.getFounderAddress())){             System.out.println(\"genesis address not equals block founder: \");             System.out.println(\"genesis address: \" + addressFounder);             System.out.println(\"block address: \" + thisBlock.getFounderAddress());             return false;          }               String actualPrevHash = previusblock.hashForBlockchain();             String recordedPrevHash = thisBlock.getPreviousHash();            boolean validated = true;         int countBasisSendFounder = 0;         int countBasisSendAll = 0;         finished:         for (DtoTransaction transaction : thisBlock.getDtoTransactions()) {             if(transaction.verify() && transaction.getSender().equals(Seting.BASIS_ADDRESS)){                 double minerReward = Seting.DIGITAL_DOLLAR_REWARDS_BEFORE;                 double minerPowerReward = Seting.DIGITAL_STOCK_REWARDS_BEFORE;                    if(transaction.getSender().equals(Seting.BASIS_ADDRESS)&&                         transaction.getCustomer().equals(thisBlock.getMinerAddress()) && transaction.getDigitalDollar() > minerReward                         && thisBlock.getIndex() > 1){                     System.out.println(\"wrong transaction: reward miner wrong digital dollar: \" + minerReward + \" index: \" + thisBlock.getIndex());                     System.out.println(\"sendmoney \" + transaction.getDigitalDollar());                     validated = false;                     break;                 }                 if(transaction.getSender().equals(Seting.BASIS_ADDRESS) &&                         transaction.getCustomer().equals(thisBlock.getMinerAddress()) && transaction.getDigitalStockBalance()                         > minerPowerReward                         && thisBlock.getIndex() > 1){                     System.out.println(\"wrong transaction: reward miner wrong digital stock: \" + minerPowerReward + \" need: \" + transaction.getDigitalStockBalance());                     System.out.println(transaction);                     validated = false;                     break;                 }                   if(transaction.getSender().equals(Seting.BASIS_ADDRESS)                         &&transaction.getCustomer().equals(addressFounder)){                     countBasisSendFounder += 1;                 }                  if(transaction.getSender().equals(Seting.BASIS_ADDRESS)&&!transaction.getCustomer().equals(addressFounder))                 {                     countBasisSendAll +=1;                 }                  if(countBasisSendFounder > 2 && thisBlock.getIndex() > 1){                     System.out.println(\"basis sender send for founder uper one: \" + countBasisSendFounder);                     validated = false;                     break;                 }                  if(countBasisSendAll > 1 && thisBlock.getIndex() > 1){                     System.out.println(\"basis sender send uper two: \" + countBasisSendAll + \" block index: \" + thisBlock.getIndex());                     validated = false;                     break;                 }             }             else if(!transaction.verify()){                 System.out.println(\"wrong transaction: \" + transaction + \" verify: \" + transaction.verify());                 validated = false;                 break finished;             }          }             if(!UtilsUse.hashComplexity(thisBlock.getHashBlock(), thisBlock.getHashCompexity())){                 System.out.println(\"does't start hash with 0\");                 System.out.println(\"this block hash: \" + thisBlock.getHashBlock());                 return false;             }              if(!actualPrevHash.equals(recordedPrevHash)){                 System.out.println(\"Blockchain is invalid, expected: \" + recordedPrevHash + \" actual: \" + actualPrevHash );                 System.out.println(\"index block: \" + thisBlock.getIndex());                 System.out.println(\"wrong chain hash\");                 return false;             }          return validated;     }      public static void deleteFiles(){         UtilsFileSaveRead.deleteAllFiles(Seting.ORIGINAL_BLOCKCHAIN_FILE);          UtilsFileSaveRead.deleteAllFiles(Seting.ORIGINAL_BALANCE_FILE);         UtilsFileSaveRead.deleteAllFiles(Seting.ORIGINAL_ALL_CORPORATION_LAWS_FILE);         UtilsFileSaveRead.deleteAllFiles(Seting.ORIGINAL_ALL_CORPORATION_LAWS_WITH_BALANCE_FILE);     }      public static boolean validation(List<Block> blocks, long BLOCK_GENERATION_INTERVAL, int DIFFICULTY_ADJUSTMENT_INTERVAL ) throws IOException, NoSuchAlgorithmException, SignatureException, InvalidKeySpecException, NoSuchProviderException, InvalidKeyException {         boolean validated = true;         List<Block> temporary = new ArrayList<>();         Block prevBlock  = null;         for (Block block : blocks) {             if(prevBlock == null){                 prevBlock = block;                 temporary.add(block);                 continue;             }              temporary.add(block);              validated = validationOneBlock(block.getFounderAddress(),                     prevBlock,                     block,                     BLOCK_GENERATION_INTERVAL,                     DIFFICULTY_ADJUSTMENT_INTERVAL,                     temporary );             if(validated == false){                  System.out.println(\"ERROR: UtilsBlock: validation: prevBLock.Hash():\" + prevBlock.getHashBlock());                 System.out.println(\"ERROR: UtilsBlock: validation: index:\" + block.getIndex());                 System.out.println(\"ERROR: UtilsBlock: validation: block.Hash():\" + block.getHashBlock());                 System.out.println(\"ERROR: UtilsBlock: validation: BLOCK_GENERATION_INTERVAL:\" + BLOCK_GENERATION_INTERVAL);                 System.out.println(\"ERROR: UtilsBlock: validation: DIFFICULTY_ADJUSTMENT_INTERVAL:\" + DIFFICULTY_ADJUSTMENT_INTERVAL);                 System.out.println(\"ERROR: UtilsBlock: validation: temporary:\" + temporary.size());                 return false;             }             prevBlock = block;         }         return validated;     } }","package International_Trade_Union.utils;  import java.io.*; import java.util.ArrayList; import java.util.HashSet; import java.util.List; import java.util.Set;  public class UtilsFileSaveRead {      public static void save(String object, String fileName) throws IOException {        save(object, fileName, true);     }     public static void save(String object, String fileName, boolean save){         try(BufferedWriter writer = new BufferedWriter(new FileWriter(fileName, save))) {             writer.write(object);             writer.flush();          }catch (IOException e){             e.printStackTrace();         }       }      public static void saves(List<String> objects, String fileName, boolean save){          try(BufferedWriter writer = new BufferedWriter(new FileWriter(fileName, save))) {              for (String s : objects) {                 writer.write(s + \"\\n\");             }             writer.flush();          }catch (IOException e){             e.printStackTrace();         }     }      public static String read(String file) throws FileNotFoundException {         String text = \"\";         File file1 = new File(file);         if(!file1.exists()){             System.out.println(\"file dosn't have\");             return text;         }         try( BufferedReader reader = new BufferedReader(new FileReader(file))){             while (reader.ready()){                 text += reader.readLine();             }         }catch (IOException e){             e.printStackTrace();         }         return text;     }     public static Set<String> readSet(String file){         Set<String> list = new HashSet<>();          try( BufferedReader reader = new BufferedReader(new FileReader(file))){             while (reader.ready()){                 list.add(reader.readLine());             }         }catch (IOException e){             e.printStackTrace();         }         return list;     }     public static List<String> reads(String file){         List<String> list = new ArrayList<>();          try( BufferedReader reader = new BufferedReader(new FileReader(file))){             while (reader.ready()){                 list.add(reader.readLine());             }         }catch (IOException e){             e.printStackTrace();         }         return list;     }         public static void deleteAllFiles(String path){         File folder = new File(path);         for (File file : folder.listFiles()) {             if(!file.isDirectory()){                 file.delete();             }         }     }      public static void deleteFile(String path){         File file = new File(path);         file.delete();     }  }","package International_Trade_Union.utils;  import com.fasterxml.jackson.core.JsonProcessingException; import com.fasterxml.jackson.core.type.TypeReference; import com.fasterxml.jackson.databind.ObjectMapper; import International_Trade_Union.entity.DtoTransaction.DtoTransaction; import International_Trade_Union.entity.EntityChain; import International_Trade_Union.entity.blockchain.block.Block; import International_Trade_Union.model.Account; import International_Trade_Union.vote.CurrentLawVotes; import International_Trade_Union.vote.LawEligibleForParliamentaryApproval; import International_Trade_Union.vote.Laws;   import java.io.IOException; import java.io.StringWriter; import java.util.List; import java.util.Set;  public class UtilsJson {     public static String objToStringJson(Object object) throws IOException {         ObjectMapper mapper = new ObjectMapper();         StringWriter writer = new StringWriter();         mapper.writeValue(writer, object);         return writer.toString();     }      public static Object jsonToListBLock(String json, Class cls) throws JsonProcessingException {         ObjectMapper mapper = new ObjectMapper();         return mapper.readValue(json, cls);     }      public static List<Block> jsonToListBLock(String json) throws JsonProcessingException {         ObjectMapper mapper = new ObjectMapper();         return mapper.readValue(json, new TypeReference<List<Block>>(){});     }     public static List<Account> jsonToListAccounts(String json) throws JsonProcessingException {         ObjectMapper mapper = new ObjectMapper();         return mapper.readValue(json, new TypeReference<List<Account>>(){});     }      public static Set<String> jsonToSetAddresses(String json) throws  JsonProcessingException{         ObjectMapper mapper = new ObjectMapper();         return mapper.readValue(json, new TypeReference<Set<String>>(){});     }     public static Block jsonToBLock(String json) throws JsonProcessingException {         ObjectMapper mapper = new ObjectMapper();         return mapper.readValue(json, Block.class);     }      public static Laws jsonToLaw(String json) throws JsonProcessingException {         ObjectMapper mapper = new ObjectMapper();         return mapper.readValue(json, Laws.class);     }      public static CurrentLawVotes jsonToVote(String json) throws  JsonProcessingException{         ObjectMapper mapper = new ObjectMapper();         return mapper.readValue(json, CurrentLawVotes.class);     }      public static LawEligibleForParliamentaryApproval jsonToCurrentLaw(String json) throws JsonProcessingException {         ObjectMapper mapper = new ObjectMapper();         return mapper.readValue(json, LawEligibleForParliamentaryApproval.class);     }     public static Account jsonToAccount(String json) throws JsonProcessingException {         ObjectMapper mapper = new ObjectMapper();         return mapper.readValue(json, Account.class);     }     public static EntityChain jsonToEntityChain(String json) throws  JsonProcessingException{         ObjectMapper mapper = new ObjectMapper();         return mapper.readValue(json, EntityChain.class);     }      public static DtoTransaction jsonToDtoTransaction(String json) throws  JsonProcessingException{         ObjectMapper mapper = new ObjectMapper();         return mapper.readValue(json, DtoTransaction.class);      }      public static List<DtoTransaction> jsonToDtoTransactionList(String json) throws  JsonProcessingException{         ObjectMapper mapper = new ObjectMapper();         return mapper.readValue(json, new TypeReference<List<DtoTransaction>>(){});     } }","package International_Trade_Union.utils;    import International_Trade_Union.model.Keys; import International_Trade_Union.utils.base.Base; import International_Trade_Union.utils.base.Base58;  import org.bouncycastle.asn1.ASN1ObjectIdentifier; import org.bouncycastle.asn1.x9.ECNamedCurveTable; import org.bouncycastle.asn1.x9.X9ECParameters; import org.bouncycastle.crypto.params.ECNamedDomainParameters; import org.bouncycastle.crypto.params.ECPublicKeyParameters; import org.bouncycastle.jcajce.provider.asymmetric.ec.BCECPublicKey; import org.bouncycastle.jce.provider.BouncyCastleProvider; import org.bouncycastle.jce.spec.ECNamedCurveParameterSpec; import org.bouncycastle.jce.spec.ECPublicKeySpec; import org.bouncycastle.math.ec.ECCurve; import org.bouncycastle.math.ec.ECPoint;  import java.io.IOException; import java.math.BigInteger; import java.nio.charset.StandardCharsets; import java.security.*; import java.security.interfaces.ECPublicKey; import java.security.spec.*;  //https://metamug.com/article/security/sign-verify-digital-signature-ecdsa-java.html //https://stackoverflow.com/questions/8451205/create-privatekey-and-publickey-having-a-byte-array-encoded-in-base-64 public class UtilsSecurity {     private static final String SPEC = \"secp256k1\";     private static final String ALGO_ECDSA = \"ECDSA\";     private static final String PROVIDER = \"BC\";      static {         Security.addProvider(new org.bouncycastle.jce.provider.BouncyCastleProvider());     }     public static Keys generateKeyPair() throws NoSuchAlgorithmException, InvalidAlgorithmParameterException, NoSuchProviderException, InvalidKeySpecException {        Base base = new Base58();         Security.addProvider(new org.bouncycastle.jce.provider.BouncyCastleProvider());         ECGenParameterSpec ecSpec = new ECGenParameterSpec(SPEC);         KeyPairGenerator g = KeyPairGenerator.getInstance(ALGO_ECDSA, PROVIDER);         g.initialize(ecSpec, new SecureRandom());         KeyPair keyPair = g.generateKeyPair();         String pub = base.encode(UtilsSecurity.compressed(keyPair.getPublic().getEncoded()));         String priv = base.encode(keyPair.getPrivate().getEncoded());         Keys keys = new Keys(pub, priv);         return keys;     }      public static PrivateKey privateBytToPrivateKey(byte[] bytes) throws NoSuchAlgorithmException, InvalidKeySpecException, NoSuchProviderException {         EncodedKeySpec privateKeySpec = new PKCS8EncodedKeySpec(bytes);         KeyFactory generator = KeyFactory.getInstance(ALGO_ECDSA, PROVIDER);         return generator.generatePrivate(privateKeySpec);     }      public static PublicKey publicByteToPublicKey(byte[] bytes) throws NoSuchAlgorithmException, InvalidKeySpecException, NoSuchProviderException {         //new X509EncodedKeySpec         EncodedKeySpec publicKeySpec = new X509EncodedKeySpec(bytes);         KeyFactory generator = KeyFactory.getInstance(ALGO_ECDSA, PROVIDER);         return generator.generatePublic(publicKeySpec);     }       public static KeyPair createKeyPairWithPrivkeyPubKey(PrivateKey privateKey, PublicKey publicKey){         return new KeyPair(publicKey, privateKey);     }       public static byte[] sign(PrivateKey privateKey, String hex) throws NoSuchAlgorithmException, NoSuchProviderException, InvalidKeyException, SignatureException, IOException {         Signature signature = Signature.getInstance(ALGO_ECDSA, PROVIDER);         signature.initSign(privateKey);         signature.update(hex.getBytes(StandardCharsets.UTF_8));         byte[] signByte = signature.sign();         return signByte;     }      public static boolean verify(String sha256message, byte[] sign, PublicKey publicKey) throws NoSuchAlgorithmException, NoSuchProviderException, InvalidKeyException, SignatureException {         Signature signature = Signature.getInstance(ALGO_ECDSA, PROVIDER);         signature.initVerify(publicKey);         signature.update(sha256message.getBytes(StandardCharsets.UTF_8));         return signature.verify(sign);     }       public static byte[] compressed(byte[] pub) throws NoSuchAlgorithmException, NoSuchProviderException, InvalidAlgorithmParameterException, InvalidKeySpecException {          // === NOT PART OF THE CODE, JUST GETTING TEST VECTOR ===         PublicKey publicKey = UtilsSecurity.publicByteToPublicKey(pub);          ECPublicKey key = (ECPublicKey) publicKey;         byte[] x = key.getW().getAffineX().toByteArray();         byte[] y = key.getW().getAffineY().toByteArray();          // assumes that x and y are (unsigned) big endian encoded         BigInteger xbi = new BigInteger(1, x);         BigInteger ybi = new BigInteger(1, y);         X9ECParameters x9 = ECNamedCurveTable.getByName(SPEC);         ASN1ObjectIdentifier oid = ECNamedCurveTable.getOID(SPEC);         ECCurve curve = x9.getCurve();         ECPoint point = curve.createPoint(xbi, ybi);         ECNamedDomainParameters dParams = new ECNamedDomainParameters(oid,                 x9.getCurve(), x9.getG(), x9.getN(), x9.getH(), x9.getSeed());         ECPublicKeyParameters pubKey = new ECPublicKeyParameters(point, dParams);         System.out.println(pubKey);          // some additional encoding tricks         byte[] compressed = point.getEncoded(true);         return compressed;     }     public static ECPublicKey decodeKey(byte[] encoded) {          ECNamedCurveParameterSpec params = org.bouncycastle.jce.ECNamedCurveTable.getParameterSpec(SPEC);         org.bouncycastle.jce.spec.ECPublicKeySpec keySpec = new ECPublicKeySpec(params.getCurve().decodePoint(encoded), params);         return new BCECPublicKey(ALGO_ECDSA, keySpec, BouncyCastleProvider.CONFIGURATION);     } }","package International_Trade_Union.utils;  import International_Trade_Union.controllers.BasisController; import International_Trade_Union.entity.DtoTransaction.DtoTransaction; import International_Trade_Union.entity.blockchain.block.Block; import International_Trade_Union.governments.Directors; import International_Trade_Union.governments.UtilsGovernment; import International_Trade_Union.network.AllTransactions; import International_Trade_Union.setings.Seting;  import java.io.File; import java.io.IOException; import java.security.InvalidKeyException; import java.security.NoSuchAlgorithmException; import java.security.NoSuchProviderException; import java.security.SignatureException; import java.security.spec.InvalidKeySpecException; import java.util.ArrayList; import java.util.Comparator; import java.util.List; import java.util.stream.Collectors;  public class UtilsTransaction {     public static void saveAllTransaction(DtoTransaction dtoTransaction, String filename) throws IOException, NoSuchAlgorithmException, SignatureException, InvalidKeySpecException, NoSuchProviderException, InvalidKeyException {         int fileLimit = Seting.SIZE_FILE_LIMIT * 1024 * 1024;          //папка чтобы проверить есть ли         File folder = new File(filename);         List<String> files = new ArrayList<>();         for (File file : folder.listFiles()) {             if(!file.isDirectory()){                 files.add(file.getAbsolutePath());             }         }           int count = 0;         files = files.stream().sorted().collect(Collectors.toList());         String nextFile = \"\";          if (files.size() > 0) {             nextFile = files.get(files.size()-1);              count = Integer.parseInt(nextFile.replaceAll(\"[^\\\\d]\", \"\"));           }          File file = new File(nextFile);          if(file.length() >= fileLimit){             count++;          }          nextFile = filename + count + \".txt\";          String json = UtilsJson.objToStringJson(dtoTransaction);         UtilsFileSaveRead.save(json + \"\\n\", nextFile);      }      public static List<DtoTransaction> readLineObject(String filename ) throws IOException, NoSuchAlgorithmException, InvalidKeySpecException, SignatureException, NoSuchProviderException, InvalidKeyException {         List<DtoTransaction> dtoTransactions = new ArrayList<>();         File folder = new File(filename);         for (final File fileEntry : folder.listFiles()) {             if (fileEntry.isDirectory()) {                 System.out.println(\"is directory \" + fileEntry.getAbsolutePath());             } else {                 List<String> list = UtilsFileSaveRead.reads(fileEntry.getAbsolutePath());                 for (String s : list) {                      DtoTransaction dtoTransaction = UtilsJson.jsonToDtoTransaction(s);                     dtoTransactions.add(dtoTransaction);                 }              }         }         dtoTransactions = dtoTransactions                 .stream()                 .collect(Collectors.toList());          return dtoTransactions;     }       public static void sendTransaction(DtoTransaction dtoTransaction){      } }","package International_Trade_Union.utils;    import International_Trade_Union.setings.Seting;  import java.io.IOException;  import java.math.BigDecimal; import java.nio.charset.Charset; import java.nio.charset.StandardCharsets; import java.security.MessageDigest; import java.security.NoSuchAlgorithmException; import java.util.HashMap; import java.util.List; import java.util.Random; import java.util.Set; import java.util.concurrent.ConcurrentHashMap; import java.util.function.Function; import java.util.function.Predicate; import java.util.regex.Matcher; import java.util.regex.Pattern;  public class UtilsUse {     private static MessageDigest digest;      static {         try {             digest = MessageDigest.getInstance(\"SHA-256\");         } catch (NoSuchAlgorithmException e) {             e.printStackTrace();         }     } //    одно число от другого в процентах     public static Double percentDifferent(Double first, Double second){         return (first / second - 1) * Seting.HUNDRED_PERCENT;     }      //найти моду     public static int mode(List<Integer> array)     {         HashMap<Integer,Integer> hm = new HashMap<Integer,Integer>();         int max  = 1;         int temp = 0;          for(int i = 0; i < array.size(); i++) {              if (hm.get(array.get(i)) != null) {                  int count = hm.get(array.get(i));                 count++;                 hm.put(array.get(i), count);                  if(count > max) {                     max  = count;                     temp = array.get(i);                 }             }              else                 hm.put(array.get(i),1);         }         return temp;     }      public static BigDecimal percentDifferent(BigDecimal first, BigDecimal second){         return first.divide(second).subtract(new BigDecimal(1)).multiply(new BigDecimal(Seting.HUNDRED_PERCENT));     }      public static byte[] sha256(String text){         return digest.digest(text.getBytes(StandardCharsets.UTF_8));     }     public static String sha256hash(String text){         byte[] bytes = sha256(text);         return bytesToHex(bytes);     }      private static String bytesToHex(byte[] hash) {         StringBuilder hexString = new StringBuilder(2 * hash.length);         for (int i = 0; i < hash.length; i++) {             String hex = Integer.toHexString(0xff & hash[i]);             if(hex.length() == 1) {                 hexString.append('0');             }             hexString.append(hex);         }         return hexString.toString();     }      public static String generateRandomStr() {         byte[] array = new byte[7]; // length is bounded by 7         new Random().nextBytes(array);         String generatedString = new String(array, Charset.forName(\"UTF-8\"));          return generatedString;     }      public static double countPercents(double sum, double percent){         return sum * percent / Seting.HUNDRED_PERCENT;     }     public static BigDecimal countPercents(BigDecimal sum, BigDecimal percent){         return sum.multiply(percent).divide(new BigDecimal(Seting.HUNDRED_PERCENT));     }      public  static double countGrowth(long block, double percent, double money){         long year = (long) (block / Seting.COUNT_BLOCK_IN_DAY / (Seting.YEAR / Seting.HALF_YEAR));         double opeartion1 = 1+ (percent / Seting.HALF_YEAR)/Seting.HUNDRED_PERCENT;         double operation2 = Math.pow(opeartion1, year);         double result = money * operation2;         return result;     }      public static boolean hashComplexity(String literral, int hashComplexity){          String regex = \"^[0]{\" + Integer.toString(hashComplexity) + \"}\";         Pattern pattern = Pattern.compile(regex);         Matcher matcher = pattern.matcher(literral);         return matcher.find();     }      public static String hashComplexityStr(String str, int hashComplexity) throws IOException {         int randomNumberProof = 0;         String hash = \"\";         while (true){             randomNumberProof++;             hash = UtilsUse.sha256hash(UtilsJson.objToStringJson(str + randomNumberProof));             if(UtilsUse.hashComplexity(hash.substring(0, hashComplexity), hashComplexity))             {                 break;             }          }         return hash;     }      //для филтрации в стриме, чтобы получить уникальные обекты по полям     public static <T> Predicate<T> distinctByKey(Function<? super T, ?> keyExtractor) {         Set<Object> seen = ConcurrentHashMap.newKeySet();         return t -> seen.add(keyExtractor.apply(t));     }     //подсчитать количество нулей идущих подряд в hash     public static long hashCount(String hash) {         long count = 0;         for (int i = 0; i < hash.length(); i++) {             if(hash.charAt(i) == '0') count++;             else return count;         }         return count;     }      //подсчитывает долю в процентах одного числа от другого     public static double percentageShare(double first, double allNumber){         return (first/allNumber)*Seting.HUNDRED_PERCENT;     }      //опреледеляет ближайщее число к году     public static long nearestDateToYear(long block){         long period = (long) (Seting.COUNT_BLOCK_IN_DAY * Seting.YEAR);         return block / period * period;     }   }","package International_Trade_Union.utils;  import com.fasterxml.jackson.databind.ObjectMapper; import org.apache.http.NameValuePair; import org.apache.http.client.methods.HttpPost; import org.apache.http.message.BasicNameValuePair; import org.json.JSONException;  import javax.net.ssl.HttpsURLConnection; import java.io.*; import java.net.*; import java.nio.charset.Charset; import java.util.ArrayList; import java.util.Base64; import java.util.List;  public class UtilUrl {     public static String readJsonFromUrl(String url) throws IOException, JSONException {         InputStream is = new URL(url).openStream();         try {             BufferedReader rd = new BufferedReader(new InputStreamReader(is, Charset.forName(\"UTF-8\")));             String jsonText = readAll(rd);             ObjectMapper mapper = new ObjectMapper();             return jsonText;         } finally {             System.out.println(\"UtilUrl: readJsonFromUrl: \" + url );             is.close();         }     }      private static String readAll(Reader rd) throws IOException {         StringBuilder sb = new StringBuilder();         int cp;         while ((cp = rd.read()) != -1) {             sb.append((char) cp);         }         return sb.toString();     }      public static String getObject(String jsonObject, String requstStr) throws IOException {         URL url = new URL(requstStr);         HttpURLConnection conn = (HttpURLConnection) url.openConnection(); //        conn.connect();         conn.setReadTimeout(10000);         conn.setConnectTimeout(15000);         conn.setRequestMethod(\"POST\");         conn.setRequestProperty(\"Content-Type\", \"application/json; utf-8\");         conn.setRequestProperty(\"Accept\", \"application/json\");         conn.setDoOutput(true);            try(OutputStream outputStream = conn.getOutputStream()) {             byte[] input = jsonObject.getBytes(\"utf-8\");             outputStream.write(input, 0, input.length);             conn.getResponseCode();         }           conn.connect();         try(BufferedReader br = new BufferedReader(                 new InputStreamReader(conn.getInputStream(), \"utf-8\"))) {             StringBuilder response = new StringBuilder();             String responseLine = null;             while ((responseLine = br.readLine()) != null) {                 response.append(responseLine.trim());             }             return response.toString();          }      }         public static int sendPost(String jsonObject, String requestStr) throws IOException {         int response;         URL url = new URL(requestStr);         HttpURLConnection conn = (HttpURLConnection) url.openConnection(); //        conn.connect();         conn.setReadTimeout(10000);         conn.setConnectTimeout(15000);         conn.setRequestMethod(\"POST\");         conn.setRequestProperty(\"Content-Type\", \"application/json; utf-8\");         conn.setRequestProperty(\"Accept\", \"application/json\");         conn.setDoOutput(true);            try(OutputStream outputStream = conn.getOutputStream()) {             byte[] input = jsonObject.getBytes(\"utf-8\");             outputStream.write(input, 0, input.length);              response = conn.getResponseCode();          }           conn.connect();         return response;     }     }","package International_Trade_Union.vote;  import lombok.Data; import International_Trade_Union.model.Account; import International_Trade_Union.setings.Seting; import org.apache.tomcat.util.net.jsse.JSSEUtil;  import java.util.List; import java.util.Map; import java.util.Objects; import java.util.Set; import java.util.stream.Collectors;  @Data public class CurrentLawVotes {     private String addressLaw;     private Set<String> YES;     private Set<String> NO;       public CurrentLawVotes() {     }      public CurrentLawVotes(String addressLaw, Set<String> YES, Set<String> NO) {         this.addressLaw = addressLaw;         this.YES = YES;         this.NO = NO;     }      //голос фракции     public double voteFractions(Map<String, Double> fractions){         double yes = 0;         double no = 0;         double sum = fractions.entrySet().stream()                 .map(t->t.getValue())                 .collect(Collectors.toList())                 .stream().reduce(0.0, Double::sum);          for (String s : YES) {             if (fractions.containsKey(s)) {                 yes += (fractions.get(s)/sum) * Seting.HUNDRED_PERCENT;             }          }         for (String s : NO) {             if (fractions.containsKey(s)) {                 no += (fractions.get(s)/sum) * Seting.HUNDRED_PERCENT;             }          }         return yes - no;      }      //подсчет голосов для палат     public int voteGovernment(             Map<String, Account> balances,             List<String> governments      ) {         int yes = 0;         int no = 0;          List<String> addressGovernment = governments;         for (String s : YES) {             if (addressGovernment.contains(s)) {                 yes += Seting.VOTE_GOVERNMENT;             }          }         for (String s : NO) {             if (addressGovernment.contains(s)) {                 no += Seting.VOTE_GOVERNMENT;             }          }           return yes - no;      }      //для избрания должностных лиц     public double votesLaw(Map<String, Account> balances,                            Map<String, Integer> yesAverage, Map<String, Integer> noAverage) {         double yes = 0.0;         double no = 0.0;           //         for (String s : YES) {              int count = 1;             count = yesAverage.get(s) > 0 ? yesAverage.get(s) : 1;             yes += balances.get(s).getDigitalStockBalance() / count;          }         //         for (String s : NO) {             int count = 1;             count = noAverage.get(s) > 0 ? noAverage.get(s) : 1;             no += balances.get(s).getDigitalStockBalance() / count;          }           return yes - no;     }      //для избрания должностных лиц     public double votes(Map<String, Account> balances,                         Map<String, Integer> yesAverage, Map<String, Integer> noAverage) {         double yes = 0.0;         double no = 0.0;         for (String s : YES) {             int count = 1;             count = yesAverage.get(s) > 0 ? yesAverage.get(s) : 1;             yes += balances.get(s).getDigitalStockBalance() / count;          }         for (String s : NO) {             int count = 1;             count = noAverage.get(s) > 0 ? noAverage.get(s) : 1;             no += balances.get(s).getDigitalStockBalance() / count;          }           return yes - no;     }      @Override     public boolean equals(Object o) {         if (this == o) return true;         if (!(o instanceof CurrentLawVotes)) return false;         CurrentLawVotes that = (CurrentLawVotes) o;         return getAddressLaw().equals(that.getAddressLaw());     }      @Override     public int hashCode() {         return Objects.hash(getAddressLaw());     } }","package International_Trade_Union.vote;  public class CurrentLawVotesAverage { }","package International_Trade_Union.vote;  import lombok.Data;  import java.util.List; import java.util.Objects;  @Data public class CurrentLawVotesEndBalance {     private String addressLaw;     private double votes;     //CORPORATE_COUNCIL_OF_REFEREES     private int votesCorporateCouncilOfReferees;      //BOARD_OF_DIRECTORS     private int votesBoardOfDirectors;     private int votesBoardOfShareholders;      //GENERAL_EXECUTIVE_DIRECTOR     private int voteGeneralExecutiveDirector;     private int voteHightJudge;      private int founderVote;     private String packageName;     private List<String> laws;     private double fractionVote;      public CurrentLawVotesEndBalance() {     }      public CurrentLawVotesEndBalance             (String addressLaw,              String packageName,              double votes,              int votesCorporateCouncilOfReferees,              int votesBoardOfDirectors,              int votesBoardOfShareholders,              int voteGeneralExecutiveDirector,              int voteHightJudge,                     int founderVote,              double fractionVote,              List<String> laws) {         this.addressLaw = addressLaw;         this.packageName = packageName;         this.votesCorporateCouncilOfReferees = votesCorporateCouncilOfReferees;         this.votesBoardOfShareholders = votesBoardOfShareholders;         this.votesBoardOfDirectors = votesBoardOfDirectors;         this.voteGeneralExecutiveDirector = voteGeneralExecutiveDirector;         this.voteHightJudge = voteHightJudge;         this.founderVote = founderVote;         this.fractionVote = fractionVote;          this.votes = votes;         this.laws = laws;      }      @Override     public boolean equals(Object o) {         if (this == o) return true;         if (!(o instanceof CurrentLawVotesEndBalance)) return false;         CurrentLawVotesEndBalance that = (CurrentLawVotesEndBalance) o;         return getAddressLaw().equals(that.getAddressLaw());     }      @Override     public int hashCode() {         return Objects.hash(getAddressLaw());     } }","package International_Trade_Union.vote;   import lombok.Data; import International_Trade_Union.model.Account;  import java.util.Objects;  @Data public class LawEligibleForParliamentaryApproval {     public LawEligibleForParliamentaryApproval(Account account, Laws laws) {         this.account = account;         this.laws = laws;         this.name = account.getAccount();     }      public LawEligibleForParliamentaryApproval() {     }      private String name;     private Account account;     private Laws laws;      @Override     public boolean equals(Object o) {         if (this == o) return true;         if (!(o instanceof LawEligibleForParliamentaryApproval)) return false;         LawEligibleForParliamentaryApproval that = (LawEligibleForParliamentaryApproval) o;         return Objects.equals(getName(), that.getName()) && Objects.equals(getAccount(), that.getAccount()) && Objects.equals(getLaws(), that.getLaws());     }      @Override     public int hashCode() {         return Objects.hash(getName(), getAccount(), getLaws());     } }","package International_Trade_Union.vote;   import lombok.Data; import International_Trade_Union.setings.Seting; import International_Trade_Union.utils.UtilsJson; import International_Trade_Union.utils.UtilsUse;  import java.io.IOException; import java.util.List; import java.util.Objects;  @Data public class Laws {     //название пакета закона     String packetLawName;     List<String> laws;     String hashLaw;      public Laws() {     }      public Laws(String packetLawName, List<String> laws) throws IOException {         this.packetLawName = packetLawName;         this.laws = laws;         this.hashLaw = Seting.NAME_LAW_ADDRESS_START + UtilsUse.sha256hash(UtilsJson.objToStringJson(this));     }      @Override     public boolean equals(Object o) {         if (this == o) return true;         if (!(o instanceof Laws)) return false;         Laws laws = (Laws) o;         return getHashLaw().equals(laws.getHashLaw());     }      @Override     public int hashCode() {         return Objects.hash(getHashLaw());     } }","package International_Trade_Union.vote;  import International_Trade_Union.entity.DtoTransaction.DtoTransaction; import International_Trade_Union.entity.blockchain.Blockchain; import International_Trade_Union.entity.blockchain.block.Block; import International_Trade_Union.governments.Director; import International_Trade_Union.governments.Directors; import International_Trade_Union.governments.UtilsGovernment; import International_Trade_Union.model.Account; import International_Trade_Union.model.FIndPositonHelperData; import International_Trade_Union.setings.Seting;  import java.io.IOException; import java.security.InvalidKeyException; import java.security.NoSuchAlgorithmException; import java.security.NoSuchProviderException; import java.security.SignatureException; import java.security.spec.InvalidKeySpecException; import java.util.*; import java.util.stream.Collectors;  public class UtilsCurrentLaw {     //подсчет по штучно баланса     public static Map<String, CurrentLawVotes> calculateVote(Map<String, CurrentLawVotes> votes, List<Account> governments, Block block) throws IOException, NoSuchAlgorithmException, SignatureException, InvalidKeySpecException, NoSuchProviderException, InvalidKeyException {          for (int j = 0; j < block.getDtoTransactions().size(); j++) {             DtoTransaction transaction = block.getDtoTransactions().get(j);              if (transaction.getSender().startsWith(Seting.NAME_LAW_ADDRESS_START)) {                 System.out.println(\"law balance cannot be sender\");                 continue;             }             if (transaction.verify() && transaction.getCustomer().startsWith(Seting.NAME_LAW_ADDRESS_START)) {                 for (Account account : governments) {                     //основатель не может участвовать в голосовании                     //!block.getFounderAddress().equals(transaction.getSender())                     if (transaction.getSender().equals(account.getAccount())) {                         CurrentLawVotes currentLawVotes = votes.get(transaction.getCustomer());                          if (currentLawVotes == null) {                             currentLawVotes = new CurrentLawVotes();                             currentLawVotes.setAddressLaw(transaction.getCustomer());                             currentLawVotes.setYES(new HashSet<>());                             currentLawVotes.setNO(new HashSet<>());                              votes.put(transaction.getCustomer(), currentLawVotes);                         }                          if (transaction.getVoteEnum().equals(VoteEnum.YES)) {                              currentLawVotes.getYES().add(transaction.getSender());                             currentLawVotes.getNO().remove(transaction.getSender());                          } else if (transaction.getVoteEnum().equals(VoteEnum.NO)) {                             currentLawVotes.getNO().add(transaction.getSender());                             currentLawVotes.getYES().remove(transaction.getSender());                         }                     }                 }              }          }           return votes;      }      //подсчет целиком баланса     public static Map<String, CurrentLawVotes> calculateVotes(List<Account> governments, List<Block> blocks) throws IOException, NoSuchAlgorithmException, SignatureException, InvalidKeySpecException, NoSuchProviderException, InvalidKeyException {         Map<String, CurrentLawVotes> votes = new HashMap<>();         for (Block block : blocks) {             calculateVote(votes, governments, block);         }          return votes;      }      //возвращаяет усредненное количество голосов,     //суть проста если есть один акаунт и он имеет 100 акций     //и проголосовал за один закон то все сто акций будут для этого закона как сто голосов     //если за два закона то 100/2 то есть если он на протяжении трех лет проголосовал     //за n законов, то его голоса делятся на n.     public static Map<String, Integer> calculateAverageVotesYes(Map<String, CurrentLawVotes> votesMap) {         Map<String, Integer> voteAverage = new HashMap<>();         for (Map.Entry<String, CurrentLawVotes> current : votesMap.entrySet()) {             for (String yesVoteAddress : current.getValue().getYES()) {                 if (voteAverage.containsKey(yesVoteAddress)) {                     int count = voteAverage.get(yesVoteAddress);                     voteAverage.put(yesVoteAddress, count + 1);                 } else {                     int count = 1;                     voteAverage.put(yesVoteAddress, count);                 }             }          }         return voteAverage;     }      //подсчитывает голоса No     public static Map<String, Integer> calculateAverageVotesNo(Map<String, CurrentLawVotes> votesMap) {         Map<String, Integer> voteAverage = new HashMap<>();         for (Map.Entry<String, CurrentLawVotes> current : votesMap.entrySet()) {             for (String yesVoteAddress : current.getValue().getNO()) {                 if (voteAverage.containsKey(yesVoteAddress)) {                     int count = voteAverage.get(yesVoteAddress);                     voteAverage.put(yesVoteAddress, count + 1);                 } else {                     int count = 1;                     voteAverage.put(yesVoteAddress, count);                 }             }          }         return voteAverage;     }        //возвращает списки позиций     public static Map<Director, List<String>> findPositions(              Map<String, Account> balances,             Blockchain blockchain,             List<LawEligibleForParliamentaryApproval> allGovernment,             List<Account> BoardOfShareholders,             Map<Director, FIndPositonHelperData> fIndPositonHelperData      ) throws IOException, NoSuchAlgorithmException, InvalidKeySpecException, SignatureException, NoSuchProviderException, InvalidKeyException {         //список должностей         Directors directors = new Directors();         Map<Director, List<LawEligibleForParliamentaryApproval>> positionsListMap = new HashMap<>();         //добавление всех должностей         for (Director higherSpecialPositions : directors.getDirectors()) {             positionsListMap.put(higherSpecialPositions, UtilsLaws.getPossions(allGovernment, higherSpecialPositions));         }         //список законов с голосами         Map<Director, List<CurrentLawVotesEndBalance>> curentLawVotesEndBalance = new HashMap<>();         for (Map.Entry<Director, List<LawEligibleForParliamentaryApproval>> corp : positionsListMap.entrySet()) {             //убрать повторяющиеся должности из списка.             corp.setValue(corp.getValue().stream() //                    .filter(t-> finalBoardOfShareholders.contains(new Account(t.getLaws().getLaws().get(0), 0, 0)))                     .distinct().collect(Collectors.toList()));              //получить баланс и голоса для действующих законов             curentLawVotesEndBalance.put(corp.getKey(), UtilsGovernment.filters(corp.getValue(), balances, BoardOfShareholders,                     blockchain.getBlockchainList(), Seting.POSITION_YEAR_VOTE));             List<CurrentLawVotesEndBalance> temporary;             if (fIndPositonHelperData.get(corp.getKey()).isElectedWithStock()) {                   //отобрать голоса выше лимита                 curentLawVotesEndBalance.put(corp.getKey(), curentLawVotesEndBalance.get(corp.getKey()));                 List<CurrentLawVotesEndBalance> electedByStock =                         curentLawVotesEndBalance.get(corp.getKey())                                 .stream()                                 .filter(t->directors.isElectedByStocks(t.getPackageName()))                                 .filter(t -> t.getVotes() >= Seting.ORIGINAL_LIMIT_MIN_VOTE)                                 .sorted(Comparator.comparing(CurrentLawVotesEndBalance::getVotes).reversed())                                 .limit(corp.getKey().getCount())                                 .collect(Collectors.toList());                  System.out.println(\"UtilsCurrentLaw: findPostion: \");                 System.out.println(\"*******************************\");                 electedByStock.stream().forEach(System.out::println);                 System.out.println(\"*******************************\");                  //отобрать то количество которое соответсвтвует данной должности                 temporary = electedByStock;              } else {                  curentLawVotesEndBalance.put(corp.getKey(), curentLawVotesEndBalance.get(corp.getKey()));                 //отобрать то количество которое соответсвтвует данной должности                 //избираемые премьер министром                 if(fIndPositonHelperData.get(corp.getKey()).isElectedWithPrimeMinister()){                     //отобрать голоса выше лимита                     curentLawVotesEndBalance.put(corp.getKey(), curentLawVotesEndBalance.get(corp.getKey()));                     List<CurrentLawVotesEndBalance> electedByPrimeMinister =                             curentLawVotesEndBalance.get(corp.getKey())                                     .stream()                                     .filter(t->directors.isElectedCEO(t.getPackageName()))                                     .filter(t -> t.getVoteGeneralExecutiveDirector() >= Seting.ORIGINAL_LIMIT_MIN_VOTE_GENERAL_EXECUTIVE_DIRECTOR)                                     .sorted(Comparator.comparing(CurrentLawVotesEndBalance::getVoteGeneralExecutiveDirector).reversed())                                     .collect(Collectors.toList());                       //отобрать то количество которое соответсвтвует данной должности                     temporary = electedByPrimeMinister;                 }                 //избираемые палатой представителей                 else if(fIndPositonHelperData.get(corp.getKey()).isElectedWithHousOfRepresentativies()){                     //отобрать голоса выше лимита                     curentLawVotesEndBalance.put(corp.getKey(), curentLawVotesEndBalance.get(corp.getKey()));                     List<CurrentLawVotesEndBalance> electedByHouseOfRepresentatives =                             curentLawVotesEndBalance.get(corp.getKey())                                     .stream()                                     .filter(t->directors.isElectedByBoardOfDirectors(t.getPackageName()))                                     .filter(t -> t.getVotesBoardOfDirectors() >= Seting.ORIGINAL_LIMIT_MIN_VOTE_BOARD_OF_DIRECTORS)                                     .sorted(Comparator.comparing(CurrentLawVotesEndBalance::getVotesBoardOfDirectors).reversed())                                     .collect(Collectors.toList());                       //отобрать то количество которое соответсвтвует данной должности                     temporary = electedByHouseOfRepresentatives;                    }                 //избираемые палатаой верховных судей                 else if(fIndPositonHelperData.get(corp.getKey()).isElectedWithChamberOfHightJudjes()){                     //отобрать голоса выше лимита                     curentLawVotesEndBalance.put(corp.getKey(), curentLawVotesEndBalance.get(corp.getKey()));                     List<CurrentLawVotesEndBalance> electedByChamberOfSupremeJudges =                             curentLawVotesEndBalance.get(corp.getKey())                                     .stream()                                     .filter(t->directors.isElectedBYCorporateCouncilOfReferees(t.getPackageName()))                                     .filter(t -> t.getVotesCorporateCouncilOfReferees() >= Seting.ORIGINAL_LIMIT_MIN_VOTE_CORPORATE_COUNCIL_OF_REFEREES)                                     .sorted(Comparator.comparing(CurrentLawVotesEndBalance::getVotesCorporateCouncilOfReferees).reversed())                                     .collect(Collectors.toList());                       //отобрать то количество которое соответсвтвует данной должности                     temporary = electedByChamberOfSupremeJudges;                  }                 else {                     temporary = curentLawVotesEndBalance.get(corp.getKey()).stream()                              .collect(Collectors.toList());                 }              }              temporary = temporary.stream().distinct().collect(Collectors.toList());              curentLawVotesEndBalance.put(corp.getKey(), temporary);         }           List<LawEligibleForParliamentaryApproval> lawEligibleForParliamentaryApprovals =                 UtilsLaws.readLineCurrentLaws(Seting.ORIGINAL_ALL_CORPORATION_LAWS_WITH_BALANCE_FILE);           Map<Director, List<String>> currentPossitions = new HashMap<>();         for (Map.Entry<Director, FIndPositonHelperData> fIndPositonHelperData1 : fIndPositonHelperData.entrySet()) {             List<CurrentLawVotesEndBalance> position = curentLawVotesEndBalance.get(fIndPositonHelperData1.getKey());             //список адресов на данную позицию, пример члена палаты представителей             List<String> currntAddress = new ArrayList<>();             for (CurrentLawVotesEndBalance address : position) {                 for (LawEligibleForParliamentaryApproval lawEligibleForParliamentaryApproval : lawEligibleForParliamentaryApprovals) {                       if (lawEligibleForParliamentaryApproval.getLaws().getHashLaw().equals(address.getAddressLaw())) {                          currntAddress.add(lawEligibleForParliamentaryApproval.getLaws().getLaws().get(0));                      }                 }              }             currentPossitions.put(fIndPositonHelperData1.getKey(), currntAddress);          }           return currentPossitions;     }      //найти членов палаты представителей     //возвращает список позиций     public static List<String> findPosition(             Map<String, Account> balances,             Blockchain blockchain,             List<LawEligibleForParliamentaryApproval> allGovernment,             List<Account> BoardOfShareholders,             Directors positions,             boolean withLimit      ) throws IOException, NoSuchAlgorithmException, InvalidKeySpecException, SignatureException, NoSuchProviderException, InvalidKeyException {         //список должностей          Map<Director, List<LawEligibleForParliamentaryApproval>> positionsListMap = new HashMap<>();         //добавление всех должностей         for (Director higherSpecialPositions : positions.getDirectors()) {             positionsListMap.put(higherSpecialPositions, UtilsLaws.getPossions(allGovernment, higherSpecialPositions));         }         //список законов с голосами         Map<Director, List<CurrentLawVotesEndBalance>> curentLawVotesEndBalance = new HashMap<>();         for (Map.Entry<Director, List<LawEligibleForParliamentaryApproval>> corp : positionsListMap.entrySet()) {             //убрать повторяющиеся должности из списка.             corp.setValue(corp.getValue().stream() //                    .filter(t-> finalBoardOfShareholders.contains(new Account(t.getLaws().getLaws().get(0), 0, 0)))                     .distinct().collect(Collectors.toList()));              //получить баланс и голоса для действующих законов             curentLawVotesEndBalance.put(corp.getKey(), UtilsGovernment.filters(corp.getValue(), balances, BoardOfShareholders,                     blockchain.getBlockchainList(), Seting.POSITION_YEAR_VOTE));             List<CurrentLawVotesEndBalance> temporary;             if (withLimit) {                 //отобрать голоса выше лимита                 curentLawVotesEndBalance.put(corp.getKey(), curentLawVotesEndBalance.get(corp.getKey())                         .stream().filter(t -> t.getVotes() >= Seting.ORIGINAL_LIMIT_MIN_VOTE)                         .collect(Collectors.toList()));                  //отобрать то количество которое соответсвтвует данной должности                 temporary = curentLawVotesEndBalance.get(corp.getKey()).stream()                         .filter(t -> !t.getPackageName().equals(corp.getKey()))                         .sorted(Comparator.comparing(CurrentLawVotesEndBalance::getVotes).reversed())                         .limit(corp.getKey().getCount()).collect(Collectors.toList());             } else {                 //отобрать то количество которое соответсвтвует данной должности                 temporary = curentLawVotesEndBalance.get(corp.getKey()).stream()                         .filter(t -> !t.getPackageName().equals(corp.getKey()))                         .sorted(Comparator.comparing(CurrentLawVotesEndBalance::getVotes).reversed())                         .collect(Collectors.toList());             }               curentLawVotesEndBalance.put(corp.getKey(), temporary);         }           List<LawEligibleForParliamentaryApproval> lawEligibleForParliamentaryApprovals =                 UtilsLaws.readLineCurrentLaws(Seting.ORIGINAL_ALL_CORPORATION_LAWS_WITH_BALANCE_FILE);          //список адресов на данную позицию, пример члена палаты представителей         List<String> currntAddress = new ArrayList<>();          List<CurrentLawVotesEndBalance> position = curentLawVotesEndBalance.get(positions);          for (CurrentLawVotesEndBalance address : position) {             for (LawEligibleForParliamentaryApproval lawEligibleForParliamentaryApproval : lawEligibleForParliamentaryApprovals) {                   if (lawEligibleForParliamentaryApproval.getLaws().getHashLaw().equals(address.getAddressLaw())) {                      currntAddress.add(lawEligibleForParliamentaryApproval.getLaws().getLaws().get(0));                  }             }         }           return currntAddress;     } }","package International_Trade_Union.vote;  import International_Trade_Union.governments.Director; import International_Trade_Union.governments.Directors; import com.fasterxml.jackson.core.JsonProcessingException; import International_Trade_Union.entity.DtoTransaction.DtoTransaction; import International_Trade_Union.entity.blockchain.block.Block; import International_Trade_Union.setings.Seting; import International_Trade_Union.model.Account; import International_Trade_Union.utils.UtilsFileSaveRead; import International_Trade_Union.utils.UtilsJson; import International_Trade_Union.utils.UtilsUse;   import java.io.File; import java.io.IOException; import java.security.InvalidKeyException; import java.security.NoSuchAlgorithmException; import java.security.NoSuchProviderException; import java.security.SignatureException; import java.security.spec.InvalidKeySpecException; import java.util.*; import java.util.stream.Collectors;  public class UtilsLaws {     public static void saveLaws(List<Laws> laws, String filename) throws IOException {         int fileLimit = Seting.SIZE_FILE_LIMIT * 1024 * 1024;          //папка чтобы проверить есть ли         File folder = new File(filename);         List<String> files = new ArrayList<>();         for (File file : folder.listFiles()) {             if(!file.isDirectory()){                 files.add(file.getAbsolutePath());             }         }          int count = 0;         files = files.stream().sorted().collect(Collectors.toList());         String nextFile = \"\";          if (files.size() > 0) {             nextFile = files.get(files.size()-1);              count = Integer.parseInt(nextFile.replaceAll(\"[^\\\\d]\", \"\"));           }          File file = new File(nextFile);          if(file.length() >= fileLimit){             count++;          }          nextFile = filename + count + \".txt\";          List<String> jsons = new ArrayList<>();         for (Laws laws1: laws) {             String json = UtilsJson.objToStringJson(laws1);             jsons.add(json);         }  //        String json = UtilsJson.objToStringJson(minerAccount); //        UtilsFileSaveRead.save(json + \"\\n\", nextFile);         UtilsFileSaveRead.saves(jsons, nextFile, true);     }     public static void saveLaw(Laws laws, String filename) throws IOException, NoSuchAlgorithmException, SignatureException, InvalidKeySpecException, NoSuchProviderException, InvalidKeyException {         int fileLimit = Seting.SIZE_FILE_LIMIT * 1024 * 1024;          //папка чтобы проверить есть ли         File folder = new File(filename);         List<String> files = new ArrayList<>();         for (File file : folder.listFiles()) {             if (!file.isDirectory()) {                 files.add(file.getAbsolutePath());             }         }          int count = 0;         files = files.stream().sorted().collect(Collectors.toList());         String nextFile = \"\";          if (files.size() > 0) {             nextFile = files.get(files.size() - 1);              count = Integer.parseInt(nextFile.replaceAll(\"[^\\\\d]\", \"\"));           }          File file = new File(nextFile);          if (file.length() >= fileLimit) {             count++;          }          nextFile = filename + count + \".txt\";          String json = UtilsJson.objToStringJson(laws);         UtilsFileSaveRead.save(json + \"\\n\", nextFile);      }      public static void saveCurrentsLaws(List<LawEligibleForParliamentaryApproval> lawEligibleForParliamentaryApprovals, String filename) throws IOException {         int fileLimit = Seting.SIZE_FILE_LIMIT * 1024 * 1024;          //папка чтобы проверить есть ли         File folder = new File(filename);         List<String> files = new ArrayList<>();         for (File file : folder.listFiles()) {             if(!file.isDirectory()){                 files.add(file.getAbsolutePath());             }         }          int count = 0;         files = files.stream().sorted().collect(Collectors.toList());         String nextFile = \"\";          if (files.size() > 0) {             nextFile = files.get(files.size()-1);              count = Integer.parseInt(nextFile.replaceAll(\"[^\\\\d]\", \"\"));           }          File file = new File(nextFile);          if(file.length() >= fileLimit){             count++;          }          nextFile = filename + count + \".txt\";          List<String> jsons = new ArrayList<>();         for (LawEligibleForParliamentaryApproval lawEligibleForParliamentaryApproval : lawEligibleForParliamentaryApprovals) {             String json = UtilsJson.objToStringJson(lawEligibleForParliamentaryApproval);             jsons.add(json);         }  //        String json = UtilsJson.objToStringJson(minerAccount); //        UtilsFileSaveRead.save(json + \"\\n\", nextFile);         UtilsFileSaveRead.saves(jsons, nextFile, true);     }     public static void saveCurrentLaw(LawEligibleForParliamentaryApproval lawEligibleForParliamentaryApproval, String filename) throws IOException, NoSuchAlgorithmException, SignatureException, InvalidKeySpecException, NoSuchProviderException, InvalidKeyException {         int fileLimit = Seting.SIZE_FILE_LIMIT * 1024 * 1024;          //папка чтобы проверить есть ли         File folder = new File(filename);         List<String> files = new ArrayList<>();         for (File file : folder.listFiles()) {             if (!file.isDirectory()) {                 files.add(file.getAbsolutePath());             }         }          int count = 0;         files = files.stream().sorted().collect(Collectors.toList());         String nextFile = \"\";          if (files.size() > 0) {             nextFile = files.get(files.size() - 1);              count = Integer.parseInt(nextFile.replaceAll(\"[^\\\\d]\", \"\"));           }          File file = new File(nextFile);          if (file.length() >= fileLimit) {             count++;          }          nextFile = filename + count + \".txt\";          String json = UtilsJson.objToStringJson(lawEligibleForParliamentaryApproval);         UtilsFileSaveRead.save(json + \"\\n\", nextFile);      }      public static List<Laws> readLineLaws(String filename) throws IOException, NoSuchAlgorithmException, InvalidKeySpecException, SignatureException, NoSuchProviderException, InvalidKeyException {         List<Laws> laws = new ArrayList<>();         File folder = new File(filename);         for (final File fileEntry : folder.listFiles()) {             if (fileEntry.isDirectory()) {                 System.out.println(\"is directory \" + fileEntry.getAbsolutePath());             } else {                 List<String> list = UtilsFileSaveRead.reads(fileEntry.getAbsolutePath());                 for (String s : list) {                      Laws laws1 = UtilsJson.jsonToLaw(s);                     laws.add(laws1);                 }              }         }         laws = laws                 .stream()                 .sorted(Comparator.comparing(Laws::getPacketLawName))                 .collect(Collectors.toList());          return laws;     }      public static List<LawEligibleForParliamentaryApproval> readLineCurrentLaws(String filename) throws JsonProcessingException {         List<LawEligibleForParliamentaryApproval> laws = new ArrayList<>();         File folder = new File(filename);         for (final File fileEntry : folder.listFiles()) {             if (fileEntry.isDirectory()) {                 System.out.println(\"is directory \" + fileEntry.getAbsolutePath());             } else {                 List<String> list = UtilsFileSaveRead.reads(fileEntry.getAbsolutePath());                 for (String s : list) {                      LawEligibleForParliamentaryApproval laws1 = UtilsJson.jsonToCurrentLaw(s);                     laws.add(laws1);                 }              }         }          return laws;     }       //возвращает все счета законов     public static List<Account> allPackegeLaws(Map<String, Account> balances) {         List<Account> laws = new ArrayList<>();         laws = balances.entrySet()                 .stream()                 .map(t -> t.getValue())                 .filter(t -> t.getAccount().startsWith(Seting.NAME_LAW_ADDRESS_START))                 .collect(Collectors.toList());         return laws;     }      //возвращает пакет законов и их счета     public static Map<String, Laws> getPackageLaws(List<Block> blocks) throws IOException, NoSuchAlgorithmException, SignatureException, InvalidKeySpecException, NoSuchProviderException, InvalidKeyException {         Map<String, Laws> laws = new HashMap<>();         for (Block block : blocks) {             for (DtoTransaction dtoTransaction : block.getDtoTransactions()) {                 if (dtoTransaction.verify()) {                     if (dtoTransaction.getCustomer().startsWith(Seting.NAME_LAW_ADDRESS_START) && dtoTransaction.getBonusForMiner() >= Seting.COST_LAW) {                         if(dtoTransaction.getLaws() != null && !laws.containsKey(dtoTransaction.getCustomer())){                             laws.put(dtoTransaction.getCustomer(), dtoTransaction.getLaws());                         }                      }                 }             }          }         return laws;     }      //проверяет валидность закона     public static boolean isValidHashLaw(Laws laws) throws IOException {         String hash = laws.getHashLaw();         String hashLaw = Seting.NAME_LAW_ADDRESS_START + UtilsUse.sha256hash(UtilsJson.objToStringJson(laws));         System.out.println(\"UtilsLaw: isValidHashLaw: \" + hash.equals(hashLaw));         System.out.println(\"hash: \" + hash);         System.out.println(\"hashLaw: \" + hashLaw);         return hash.equals(hashLaw);     }        public static List<Account> allPackageLaws(List<Account> accounts){         List<Account> currentLaws = accounts.stream()                 .filter(t -> t.getAccount().startsWith(Seting.NAME_LAW_ADDRESS_START))                 .collect(Collectors.toList());         return currentLaws;     }      //возвращяет список всех законов, как действующих, так и не действующих, если закон новый то автоматически сохраняет его     public static Map<String, Laws> getLaws(List<Block> blocks, String fileLaws) throws IOException, NoSuchAlgorithmException, InvalidKeySpecException, SignatureException, NoSuchProviderException, InvalidKeyException {         List<Laws> lawsForSave = new ArrayList<>();         Map<String, Laws> lawsMap = new HashMap<>();         File file = new File(fileLaws);         List<Laws> lawsList = new ArrayList<>();         if (file.exists()) {             lawsList = readLineLaws(fileLaws);         }         lawsMap = getPackageLaws(blocks);          for (Map.Entry<String, Laws> map : lawsMap.entrySet()) {             if (!lawsList.contains(map.getValue())) {                 if( map.getValue() != null &&                         map.getValue().packetLawName != null&&                         map.getValue().getLaws() != null                         && !map.getValue().getHashLaw().isEmpty()                         && (map.getValue().getLaws().size() > 0)){                          lawsForSave.add(map.getValue());                 }              }          }         saveLaws(lawsForSave, fileLaws);         return lawsMap;     }     public static List<LawEligibleForParliamentaryApproval> getCurrentLaws(Map<String, Laws> lawsMap, Map<String, Account> balances, String fileCurrentLaws) throws IOException, NoSuchAlgorithmException, SignatureException, InvalidKeySpecException, NoSuchProviderException, InvalidKeyException {         List<Account> lawsBalances = allPackegeLaws(balances);           List<LawEligibleForParliamentaryApproval> lawEligibleForParliamentaryApprovals = new ArrayList<>();         LawEligibleForParliamentaryApproval lawEligibleForParliamentaryApproval = null;         File file = new File(fileCurrentLaws);         if (file.exists()) {             lawEligibleForParliamentaryApprovals = readLineCurrentLaws(fileCurrentLaws);         }          for (LawEligibleForParliamentaryApproval eligibleForParliamentaryApproval : lawEligibleForParliamentaryApprovals) {             if(lawsBalances.contains(eligibleForParliamentaryApproval.getAccount())){                 eligibleForParliamentaryApproval.getAccount().                         setDigitalStockBalance(balances.get(eligibleForParliamentaryApproval.getAccount().getAccount()).getDigitalStockBalance());                 eligibleForParliamentaryApproval.getAccount().                         setDigitalDollarBalance(balances.get(eligibleForParliamentaryApproval.getAccount().getAccount()).getDigitalDollarBalance());             }          }           List<LawEligibleForParliamentaryApproval> temporary = new ArrayList<>();         for (Account account : lawsBalances) {             lawEligibleForParliamentaryApproval = new LawEligibleForParliamentaryApproval(account, lawsMap.get(account.getAccount()));             temporary.add(lawEligibleForParliamentaryApproval);         }           lawEligibleForParliamentaryApprovals.addAll(temporary);           lawEligibleForParliamentaryApprovals = lawEligibleForParliamentaryApprovals.stream()                 .filter(t->Objects.nonNull(t.getLaws()))                 .filter(t->Objects.nonNull(t.getAccount()))                 .filter(t->Objects.nonNull(t.getLaws().getHashLaw()))                 .filter(t->Objects.nonNull(t.getLaws().getLaws()))                 .filter(t->Objects.nonNull(t.getName()))                 .filter(t->Objects.nonNull(t.getLaws().getPacketLawName()))                 .filter(t->t != null).                 filter(UtilsUse.distinctByKey(LawEligibleForParliamentaryApproval::getName)).collect(Collectors.toList());          return lawEligibleForParliamentaryApprovals;      }         //отбирает позицию вакансий     public static List<LawEligibleForParliamentaryApproval> getPossions(List<LawEligibleForParliamentaryApproval> lawEligibleForParliamentaryApprovals, Director higherSpecialPositions){          List<LawEligibleForParliamentaryApproval> temporary = new ArrayList<>();         temporary = lawEligibleForParliamentaryApprovals.stream()                 .filter(t->Objects.nonNull(t))                 .filter(t->Objects.nonNull(t.getLaws()))                 .filter(t->Objects.nonNull(t.getLaws().getLaws()))                 .filter(t->Objects.nonNull(t.getLaws().getPacketLawName()))                 .filter(t->Objects.nonNull(t.getName()))                 .filter(t->Objects.nonNull(t.getLaws().getHashLaw()))                 .sorted((f1, f2) -> Double.compare(f2.getAccount().getDigitalStockBalance(), f1.getAccount().getDigitalStockBalance()))                 .filter(t-> t.getLaws().getPacketLawName().equals(higherSpecialPositions.getName()))                 .limit(higherSpecialPositions.getCount())                 .collect(Collectors.toList());         return temporary;      }       //удаляет из списка не лигитимные должности     public static List<LawEligibleForParliamentaryApproval> deletePossions(List<LawEligibleForParliamentaryApproval> lawEligibleForParliamentaryApprovals, List<LawEligibleForParliamentaryApproval> forDeleted, Directors higherSpecialPositions){         List<LawEligibleForParliamentaryApproval> temporary = new ArrayList<>();         for (LawEligibleForParliamentaryApproval lawEligibleForParliamentaryApproval : forDeleted) {             if(lawEligibleForParliamentaryApproval != null &&                     lawEligibleForParliamentaryApproval.getLaws() != null &&                     lawEligibleForParliamentaryApproval.getLaws().getPacketLawName() != null &&                     lawEligibleForParliamentaryApproval.getLaws().getHashLaw() != null &&                     lawEligibleForParliamentaryApproval.getLaws().getHashLaw() != null &&                     lawEligibleForParliamentaryApproval.getLaws().getPacketLawName().equals(higherSpecialPositions.getNames())){                 if(lawEligibleForParliamentaryApprovals.contains(lawEligibleForParliamentaryApproval)){                     temporary.add(lawEligibleForParliamentaryApproval);                 }else {                     continue;                 }             }             temporary.add(lawEligibleForParliamentaryApproval);         }         return temporary;     }   }","package International_Trade_Union.vote;  public enum VoteEnum {     YES,     NO }","package International_Trade_Union;  import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication;   @SpringBootApplication public class UnitedStatesApplication { \tpublic static void main(String[] args) { \t\tSpringApplication.run(UnitedStatesApplication.class, args); \t}  }","","",""],"hashLaw":"LIBERc64d89a86abe0627ed5d0210c417e80a848eee1f1a958299fe8cc4ebf6201030"}}
{"name":"LIBER38072b8b29e391554d90c407f2b7d17dba649c84c37cff46337d5b450b524d8a","account":{"account":"LIBER38072b8b29e391554d90c407f2b7d17dba649c84c37cff46337d5b450b524d8a","digitalDollarBalance":0.0,"digitalStockBalance":0.0},"laws":{"packetLawName":"ORIGINAL_CHARTER_CURRENT_ALL_CODE","laws":["CODE UNITED STATES DUPLICATES ORIGINAL","package International_Trade_Union.config;   import International_Trade_Union.entity.blockchain.Blockchain; import International_Trade_Union.setings.Seting;  import java.io.IOException; import java.security.InvalidKeyException; import java.security.NoSuchAlgorithmException; import java.security.NoSuchProviderException; import java.security.SignatureException; import java.security.spec.InvalidKeySpecException;  public class BLockchainFactory {      public static Blockchain getBlockchain(BlockchainFactoryEnum factoryEnum) throws NoSuchAlgorithmException, InvalidKeySpecException, IOException, SignatureException, NoSuchProviderException, InvalidKeyException {         switch (factoryEnum){             case TEST:                 return new Blockchain(                         Seting.BLOCK_GENERATION_INTERVAL_TEST,                         Seting.DIFFICULTY_ADJUSTMENT_INTERVAL_TEST,                         Seting.INTERVAL_TARGET_TEST,                         Seting.ADDRESS_FOUNDER_TEST);              case ORIGINAL:                 return new Blockchain(                         Seting.BLOCK_GENERATION_INTERVAL,                         Seting.DIFFICULTY_ADJUSTMENT_INTERVAL,                         Seting.INTERVAL_TARGET,                         Seting.ADDRESS_FOUNDER                 );             default: return null;         }     } }","package International_Trade_Union.config;  public enum BlockchainFactoryEnum {     TEST,     ORIGINAL }","package International_Trade_Union.controllers;  import International_Trade_Union.entity.AddressUrl; import International_Trade_Union.entity.SubBlockchainEntity; import org.json.JSONException;  import org.springframework.http.MediaType; import International_Trade_Union.entity.DtoTransaction.DtoTransaction; import International_Trade_Union.entity.blockchain.Blockchain; import International_Trade_Union.entity.blockchain.block.Block; import International_Trade_Union.config.BLockchainFactory; import International_Trade_Union.config.BlockchainFactoryEnum; import International_Trade_Union.entity.EntityChain; import International_Trade_Union.model.Account; import International_Trade_Union.model.Mining; import International_Trade_Union.model.User; import International_Trade_Union.network.AllTransactions; import International_Trade_Union.setings.Seting; import International_Trade_Union.utils.*; import International_Trade_Union.vote.*; import org.springframework.http.HttpStatus; import org.springframework.http.ResponseEntity; import org.springframework.util.Assert; import org.springframework.web.bind.annotation.*; import org.springframework.web.context.request.RequestAttributes; import org.springframework.web.context.request.RequestContextHolder; import org.springframework.web.context.request.ServletRequestAttributes;  import javax.servlet.http.HttpServletRequest; import java.io.IOException;  import java.security.*; import java.security.spec.InvalidKeySpecException;  import java.util.*; import java.util.stream.Collectors;  @RestController public class BasisController {     private static Blockchain blockchain;      private static Set<String> excludedAddresses = new HashSet<>();      public static HttpServletRequest getCurrentRequest() {         RequestAttributes requestAttributes = RequestContextHolder.getRequestAttributes();         if(requestAttributes == null)             return null;         Assert.state(requestAttributes != null, \"Could not find current request via RequestContextHolder\");         Assert.isInstanceOf(ServletRequestAttributes.class, requestAttributes);         HttpServletRequest servletRequest = ((ServletRequestAttributes) requestAttributes).getRequest();         Assert.state(servletRequest != null, \"Could not find current HttpServletRequest\");         return servletRequest;     }       public static Set<String> getExcludedAddresses() {         HttpServletRequest request = getCurrentRequest();         if(request == null)             return excludedAddresses;          String scheme = request.getScheme();         String serverName = request.getServerName();         int serverPort = request.getServerPort();         String contextPath = request.getContextPath();  // includes leading forward slash          String localaddress = scheme + \"://\" + serverName + \":\" + serverPort;          excludedAddresses.add(localaddress);         return excludedAddresses;     }      public static void setExcludedAddresses(Set<String> excludedAddresses) {         BasisController.excludedAddresses = excludedAddresses;     }      private static Set<String> nodes = new HashSet<>(); //    private static Nodes nodes = new Nodes();       public static void setNodes(Set<String> nodes) {         BasisController.nodes = nodes;     }      public static Set<String> getNodes() throws IOException, NoSuchAlgorithmException, InvalidKeySpecException, SignatureException, NoSuchProviderException, InvalidKeyException {          nodes = new HashSet<>();          Set<String> temporary = UtilsAllAddresses.readLineObject(Seting.ORIGINAL_POOL_URL_ADDRESS_FILE);           nodes.addAll(temporary);           nodes = nodes.stream()                 .filter(t -> !t.isBlank())                 .filter(t -> t.startsWith(\"\\\"\"))                 .collect(Collectors.toSet());         nodes = nodes.stream().map(t -> t.replaceAll(\"\\\"\", \"\")).collect(Collectors.toSet());         nodes.addAll(Seting.ORIGINAL_ADDRESSES);         return nodes;     }       public static Blockchain getBlockchain() {         return blockchain;     }      public static synchronized void setBlockchain(Blockchain blockchain) {         BasisController.blockchain = blockchain;     }       static {         try {             blockchain = BLockchainFactory.getBlockchain(BlockchainFactoryEnum.ORIGINAL);         } catch (NoSuchAlgorithmException e) {             throw new RuntimeException(e);         } catch (InvalidKeySpecException e) {             throw new RuntimeException(e);         } catch (IOException e) {             throw new RuntimeException(e);         } catch (SignatureException e) {             throw new RuntimeException(e);         } catch (NoSuchProviderException e) {             throw new RuntimeException(e);         } catch (InvalidKeyException e) {             throw new RuntimeException(e);         }     }       public BasisController() {     }      //TODO если вы прервали mine, то перед следующим вызовом перезапустите сервер и вызовите /addBlock перед mine     //TODO if you interrupted mine, restart the server before next call and call /addBlock before mine     //TODO иначе будет расождение в файле балансов     //TODO otherwise there will be a discrepancy in the balance file     @GetMapping(\"/mine\")     public synchronized ResponseEntity<String> mine() throws NoSuchAlgorithmException, InvalidKeySpecException, IOException, SignatureException, NoSuchProviderException, InvalidKeyException, JSONException, CloneNotSupportedException {          //нахождение адрессов         findAddresses();         sendAddress();          Map<String, Account> balances = SaveBalances.readLineObject(Seting.ORIGINAL_BALANCE_FILE);         blockchain = Mining.getBlockchain(                 Seting.ORIGINAL_BLOCKCHAIN_FILE,                 BlockchainFactoryEnum.ORIGINAL);          if (!blockchain.validatedBlockchain()) {             return new ResponseEntity<>(\"blockchain wrong \", HttpStatus.BAD_GATEWAY);         }          //Прежде чем добыть новый блок сначала в сети ищет самый длинный         resolve_conflicts();            long index = blockchain.sizeBlockhain();         if (blockchain.sizeBlockhain() <= 1) {             //сохранение генезис блока             if (blockchain.sizeBlockhain() == 1) {                 UtilsBlock.saveBLock(blockchain.getBlock(0), Seting.ORIGINAL_BLOCKCHAIN_FILE);             }              balances = Mining.getBalances(Seting.ORIGINAL_BALANCE_FILE, blockchain, balances);             Mining.deleteFiles(Seting.ORIGINAL_BALANCE_FILE);             SaveBalances.saveBalances(balances, Seting.ORIGINAL_BALANCE_FILE);          }         balances = SaveBalances.readLineObject(Seting.ORIGINAL_BALANCE_FILE);          Account miner = balances.get(User.getUserAddress());         if (miner == null) {             miner = new Account(User.getUserAddress(), 0, 0);         }          //транзакции которые мы добавили в блок, и которые стоит удалить из списка когда мы дошли до удаления.         List<DtoTransaction> temporaryDtoList = AllTransactions.getInstance();          //раз в три для очищяет файл sended         AllTransactions.clearAllSendedTransaction(index);         AllTransactions.clearUsedTransaction(AllTransactions.getInsanceSended());         System.out.println(\"BasisController: start mine:\");         Block block = Mining.miningDay(                 miner,                 Seting.ORIGINAL_BLOCKCHAIN_FILE,                 blockchain,                 Seting.BLOCK_GENERATION_INTERVAL,                 Seting.DIFFICULTY_ADJUSTMENT_INTERVAL,                 temporaryDtoList,                 balances,                 index         );         System.out.println(\"BasisController: finish mine:\");         //save sended transaction         AllTransactions.addSendedTransaction(temporaryDtoList);          int diff = Seting.DIFFICULTY_ADJUSTMENT_INTERVAL;         //Тестирование блока         List<Block> testingValidationsBlock = null;          if (blockchain.sizeBlockhain() > diff) { //            testingValidationsBlock = blockchain.getBlockchainList().subList(blockchain.sizeBlockhain() - diff, blockchain.sizeBlockhain());             testingValidationsBlock = blockchain.subBlock(blockchain.sizeBlockhain() - diff, blockchain.sizeBlockhain());         } else { //            testingValidationsBlock = blockchain.getBlockchainList();             testingValidationsBlock = blockchain.clone();         }         if (testingValidationsBlock.size() > 1) {             boolean validationTesting = UtilsBlock.validationOneBlock(                     blockchain.genesisBlock().getFounderAddress(),                     testingValidationsBlock.get(testingValidationsBlock.size() - 1),                     block,                     Seting.BLOCK_GENERATION_INTERVAL,                     diff,                     testingValidationsBlock);              if (validationTesting == false) {                 System.out.println(\"wrong validation block: \" + validationTesting);                 System.out.println(\"index block: \" + block.getIndex());                 return new ResponseEntity<>(\"bad walidation\", HttpStatus.OK);             }             testingValidationsBlock.add(block.clone());         }          //сохранение блока         blockchain.addBlock(block);         UtilsBlock.saveBLock(block, Seting.ORIGINAL_BLOCKCHAIN_FILE);          //перерасчет после добычи         balances = Mining.getBalances(Seting.ORIGINAL_BALANCE_FILE, blockchain, balances);         Mining.deleteFiles(Seting.ORIGINAL_BALANCE_FILE);         SaveBalances.saveBalances(balances, Seting.ORIGINAL_BALANCE_FILE);          //получение и отображение законов, а также сохранение новых законов         //и изменение действующих законов         Map<String, Laws> allLaws = UtilsLaws.getLaws(blockchain.getBlockchainList(), Seting.ORIGINAL_ALL_CORPORATION_LAWS_FILE);          //возвращает все законы с балансом         List<LawEligibleForParliamentaryApproval> allLawsWithBalance = UtilsLaws.getCurrentLaws(allLaws, balances, Seting.ORIGINAL_ALL_CORPORATION_LAWS_WITH_BALANCE_FILE);         //удаление устаревних законов         Mining.deleteFiles(Seting.ORIGINAL_ALL_CORPORATION_LAWS_WITH_BALANCE_FILE);         UtilsLaws.saveCurrentsLaws(allLawsWithBalance, Seting.ORIGINAL_ALL_CORPORATION_LAWS_WITH_BALANCE_FILE);          //отправить актуальный блокчейн         sendAllBlocksToStorage(blockchain.getBlockchainList());          return new ResponseEntity<>(\"add block: \" + block.getIndex(), HttpStatus.CREATED);      }       @GetMapping(\"/chain\")     @ResponseBody     public EntityChain full_chain() throws IOException, NoSuchAlgorithmException, InvalidKeySpecException, SignatureException, NoSuchProviderException, InvalidKeyException {         blockchain = Mining.getBlockchain(                 Seting.ORIGINAL_BLOCKCHAIN_FILE,                 BlockchainFactoryEnum.ORIGINAL);         return new EntityChain(blockchain.sizeBlockhain(), blockchain.getBlockchainList());     }      @GetMapping(\"/size\")     @ResponseBody     public Integer sizeBlockchain() throws IOException, NoSuchAlgorithmException, InvalidKeySpecException, SignatureException, NoSuchProviderException, InvalidKeyException {         blockchain = Mining.getBlockchain(                 Seting.ORIGINAL_BLOCKCHAIN_FILE,                 BlockchainFactoryEnum.ORIGINAL);         return blockchain.sizeBlockhain();     }      @PostMapping(\"/sub-blocks\")     @ResponseBody     public List<Block> subBlocks(@RequestBody SubBlockchainEntity entity) throws IOException, NoSuchAlgorithmException, InvalidKeySpecException, SignatureException, NoSuchProviderException, InvalidKeyException {         blockchain = Mining.getBlockchain(                 Seting.ORIGINAL_BLOCKCHAIN_FILE,                 BlockchainFactoryEnum.ORIGINAL);         return blockchain.getBlockchainList().subList(entity.getStart(), entity.getFinish());     }      @PostMapping(\"/block\")     @ResponseBody     public Block getBlock(@RequestBody Integer index) throws IOException, NoSuchAlgorithmException, InvalidKeySpecException, SignatureException, NoSuchProviderException, InvalidKeyException {         blockchain = Mining.getBlockchain(                 Seting.ORIGINAL_BLOCKCHAIN_FILE,                 BlockchainFactoryEnum.ORIGINAL);         return blockchain.getBlock(index);     }      //TODO нужно чтобы передавался каждый раз не весь блокчейн а часть, как реализованно в биткоин     //TODO is necessary so that not the entire blockchain is transmitted each time, but a part, as implemented in bitcoin     //TODO need to optimization because now not best     @GetMapping(\"/nodes/resolve\")     public synchronized void resolve_conflicts() throws NoSuchAlgorithmException, InvalidKeySpecException, IOException, SignatureException, NoSuchProviderException, InvalidKeyException, JSONException {         Blockchain temporaryBlockchain = BLockchainFactory.getBlockchain(BlockchainFactoryEnum.ORIGINAL);         Blockchain bigBlockchain = BLockchainFactory.getBlockchain(BlockchainFactoryEnum.ORIGINAL);         blockchain = Mining.getBlockchain(                 Seting.ORIGINAL_BLOCKCHAIN_FILE,                 BlockchainFactoryEnum.ORIGINAL);         int blocks_current_size = blockchain.sizeBlockhain();         long hashCountZeroTemporary = 0;         long hashCountZeroBigBlockchain = 0;         EntityChain entityChain = null;          long hashCountZeroAll = 0;         //count hash start with zero all         for (Block block : blockchain.getBlockchainList()) {             hashCountZeroAll += UtilsUse.hashCount(block.getHashBlock());         }          Set<String> nodesAll = getNodes(); //        nodesAll.addAll(Seting.ORIGINAL_ADDRESSES_BLOCKCHAIN_STORAGE);         System.out.println(\"BasisController: resolve: size: \" + getNodes().size());         for (String s : nodesAll) {             System.out.println(\"BasisController: resove: address: \" + s);             String temporaryjson = null;              if (BasisController.getExcludedAddresses().contains(s)) {                 System.out.println(\"its your address or excluded address: \" + s);                 continue;             }             try {                 String address = s + \"/chain\";                 System.out.println(\"BasisController:resolve conflicts: address: \" + s + \"/size\");                 String sizeStr = UtilUrl.readJsonFromUrl(s + \"/size\");                 Integer size = Integer.valueOf(sizeStr);                 if (size > blocks_current_size) {                     System.out.println(\"size from address: \" + s + \" upper than: \" + size + \":blocks_current_size \" + blocks_current_size);                     //Test start algorithm                     SubBlockchainEntity subBlockchainEntity = new SubBlockchainEntity(blocks_current_size, size);                     String subBlockchainJson = UtilsJson.objToStringJson(subBlockchainEntity);                      List<Block> emptyList = new ArrayList<>();                      List<Block> subBlocks = UtilsJson.jsonToListBLock(UtilUrl.getObject(subBlockchainJson, s + \"/sub-blocks\"));                     emptyList.addAll(subBlocks);                     emptyList.addAll(blockchain.getBlockchainList());                      emptyList = emptyList.stream().sorted(Comparator.comparing(Block::getIndex)).collect(Collectors.toList());                     temporaryBlockchain.setBlockchainList(emptyList);                     if (!temporaryBlockchain.validatedBlockchain()) {                         System.out.println(\"first algorithm not worked\");                         emptyList = new ArrayList<>();                         emptyList.addAll(subBlocks);                         for (int i = blockchain.sizeBlockhain() - 1; i > 0; i--) {                             Block block = UtilsJson.jsonToBLock(UtilUrl.getObject(UtilsJson.objToStringJson(i), s + \"/block\"));                             if (!blockchain.getBlock(i).getHashBlock().equals(block.getHashBlock())) {                                 emptyList.add(block);                             } else {                                 emptyList.add(block);                                 emptyList.addAll(blockchain.getBlockchainList().subList(0, i));                                 emptyList = emptyList.stream().sorted(Comparator.comparing(Block::getIndex)).collect(Collectors.toList());                                 temporaryBlockchain.setBlockchainList(emptyList);                                 break;                             }                         }                     }                     if (!temporaryBlockchain.validatedBlockchain()) {                         System.out.println(\"second algorith not worked\");                         temporaryjson = UtilUrl.readJsonFromUrl(address);                         entityChain = UtilsJson.jsonToEntityChain(temporaryjson);                         temporaryBlockchain.setBlockchainList(                                 entityChain.getBlocks().stream().sorted(Comparator.comparing(Block::getIndex)).collect(Collectors.toList()));                     }                 } else {                     System.out.println(\"BasisController: resove: size less: \" + size + \" address: \" + address);                     continue;                 }             } catch (IOException e) {                 System.out.println(\"BasisController: resolve_conflicts: Error: \" + s);                 continue;             }               if (temporaryBlockchain.validatedBlockchain()) {                 for (Block block : temporaryBlockchain.getBlockchainList()) {                     hashCountZeroTemporary += UtilsUse.hashCount(block.getHashBlock());                 }                  if (blocks_current_size < temporaryBlockchain.sizeBlockhain() && hashCountZeroAll < hashCountZeroTemporary) {                     blocks_current_size = temporaryBlockchain.sizeBlockhain();                     bigBlockchain = temporaryBlockchain;                     hashCountZeroBigBlockchain = hashCountZeroTemporary;                 }                 hashCountZeroTemporary = 0;             }          }           if (bigBlockchain.sizeBlockhain() > blockchain.sizeBlockhain() && hashCountZeroBigBlockchain > hashCountZeroAll) {              blockchain = bigBlockchain;             UtilsBlock.deleteFiles();             addBlock(bigBlockchain.getBlockchainList(), BLockchainFactory.getBlockchain(BlockchainFactoryEnum.ORIGINAL));             System.out.println(\"BasisController: resolve: bigblockchain size: \" + bigBlockchain.sizeBlockhain());          }     }       /**      * добавляет блоки в блок чейн пересохраняя файлы, предназначен когда у нас есть готовый      * блокчейн и нужно все файлы(balance, vote, government и т. д.) заного пересохранить.      * adds blocks to the block chain by resaving files, designed when we have it ready      * * Blockchain and you need to save all files (balance, vote, government, etc.) again.      */     public static void addBlock(List<Block> orignalBlocks, Blockchain blockchain) throws IOException, NoSuchAlgorithmException, SignatureException, InvalidKeySpecException, NoSuchProviderException, InvalidKeyException {          Map<String, Account> balances = new HashMap<>();         Blockchain temporaryForValidation = BLockchainFactory.getBlockchain(BlockchainFactoryEnum.ORIGINAL);         temporaryForValidation.setBlockchainList(orignalBlocks);          System.out.println(\"addBlock start\");         for (Block block : orignalBlocks) {             UtilsBlock.saveBLock(block, Seting.ORIGINAL_BLOCKCHAIN_FILE);         }          blockchain = Mining.getBlockchain(                 Seting.ORIGINAL_BLOCKCHAIN_FILE,                 BlockchainFactoryEnum.ORIGINAL);          //перерасчет после добычи         balances = UtilsBalance.calculateBalances(blockchain.getBlockchainList());         Mining.deleteFiles(Seting.ORIGINAL_BALANCE_FILE);         SaveBalances.saveBalances(balances, Seting.ORIGINAL_BALANCE_FILE);           //получение и отображение законов, а также сохранение новых законов         //и изменение действующих законов         Map<String, Laws> allLaws = UtilsLaws.getLaws(blockchain.getBlockchainList(), Seting.ORIGINAL_ALL_CORPORATION_LAWS_FILE);           //возвращает все законы с балансом         List<LawEligibleForParliamentaryApproval> allLawsWithBalance = UtilsLaws.getCurrentLaws(allLaws, balances, Seting.ORIGINAL_ALL_CORPORATION_LAWS_WITH_BALANCE_FILE);         //удаление устаревних законов         Mining.deleteFiles(Seting.ORIGINAL_ALL_CORPORATION_LAWS_WITH_BALANCE_FILE);         UtilsLaws.saveCurrentsLaws(allLawsWithBalance, Seting.ORIGINAL_ALL_CORPORATION_LAWS_WITH_BALANCE_FILE);          System.out.println(\"BasisController: addBlock: finish\");     }      @RequestMapping(method = RequestMethod.POST, value = \"/nodes/register\", consumes = MediaType.APPLICATION_JSON_VALUE)     public synchronized void register_node(@RequestBody AddressUrl urlAddrress) throws IOException, NoSuchAlgorithmException, InvalidKeySpecException, SignatureException, NoSuchProviderException, InvalidKeyException {           for (String s : BasisController.getNodes()) {             String original = s;             String url = s + \"/nodes/register\";              try {                 UtilUrl.sendPost(urlAddrress.getAddress(), url);                 sendAddress();               } catch (Exception e) {                 System.out.println(\"BasisController: register node: wrong node: \" + original);                 BasisController.getNodes().remove(original);                 continue;             }         }          Set<String> nodes = BasisController.getNodes();         nodes = nodes.stream()                 .map(t -> t.replaceAll(\"\\\"\", \"\"))                 .map(t -> t.replaceAll(\"\\\\\\\\\", \"\"))                 .collect(Collectors.toSet());         nodes.add(urlAddrress.getAddress());         BasisController.setNodes(nodes);          Mining.deleteFiles(Seting.ORIGINAL_POOL_URL_ADDRESS_FILE);         nodes.stream().forEach(t -> {             try {                 UtilsAllAddresses.saveAllAddresses(t, Seting.ORIGINAL_POOL_URL_ADDRESS_FILE);             } catch (IOException e) {                 throw new RuntimeException(e);             } catch (NoSuchAlgorithmException e) {                 throw new RuntimeException(e);             } catch (SignatureException e) {                 throw new RuntimeException(e);             } catch (InvalidKeySpecException e) {                 throw new RuntimeException(e);             } catch (NoSuchProviderException e) {                 throw new RuntimeException(e);             } catch (InvalidKeyException e) {                 throw new RuntimeException(e);             }         });      }      //TODO если происходить майнинг, то он возвращает false, пока не прекратиться майнинг.     //TODO if mining occurs, it returns false until mining stops.     /**проверяет целостность цепочки блокчейн true-значит цепочка правильная.      * verifies the integrity of the blockchain chain true-means the chain is correct*/       /**      * Делает перерасчет исходя и текущего блокчейна, заного перезаписывая файлы баланса и другие файлы.      * Makes a recalculation based on the current blockchain, overwriting balance files and other files.      */     @GetMapping(\"/addBlock\")     public boolean getBLock() throws IOException, NoSuchAlgorithmException, InvalidKeySpecException, SignatureException, NoSuchProviderException, InvalidKeyException {         blockchain = Mining.getBlockchain(                 Seting.ORIGINAL_BLOCKCHAIN_FILE,                 BlockchainFactoryEnum.ORIGINAL);         UtilsBlock.deleteFiles();         addBlock(blockchain.getBlockchainList(), BLockchainFactory.getBlockchain(BlockchainFactoryEnum.ORIGINAL));         return true;     }      @GetMapping(\"/getNodes\")     public Set<String> getAllNodes() throws IOException, NoSuchAlgorithmException, InvalidKeySpecException, SignatureException, NoSuchProviderException, InvalidKeyException {         Set<String> temporary = UtilsAllAddresses.readLineObject(Seting.ORIGINAL_POOL_URL_ADDRESS_FILE);         nodes.addAll(temporary);         nodes.addAll(Seting.ORIGINAL_ADDRESSES);         nodes = nodes.stream().filter(t -> t.startsWith(\"\\\"\"))                 .collect(Collectors.toSet());         return nodes;     }      @GetMapping(\"/findAddresses\")     public void findAddresses() throws IOException, NoSuchAlgorithmException, InvalidKeySpecException, SignatureException, NoSuchProviderException, InvalidKeyException {         for (String s : Seting.ORIGINAL_ADDRESSES) {             Set<String> addressesSet = new HashSet<>();             try {                 String addresses = UtilUrl.readJsonFromUrl(s + \"/getDiscoveryAddresses\");                 addressesSet = UtilsJson.jsonToSetAddresses(addresses);             } catch (IOException e) {                 System.out.println(\"BasisController: findAddress: error\");                 continue;             } catch (JSONException e) {                 throw new RuntimeException(e);             }              for (String s1 : addressesSet) {                  register_node(new AddressUrl(s1));             }          }      }      @GetMapping(\"/moreMining\")     public void moreMining() throws JSONException, IOException {         for (int i = 1; i < 2000; i++) {             System.out.println(\"block generate i: \" + i);             UtilUrl.readJsonFromUrl(\"http://localhost:8082/mine\");           }     }       public static void sendAddress() throws IOException, NoSuchAlgorithmException, InvalidKeySpecException, SignatureException, NoSuchProviderException, InvalidKeyException {         //лист временный для отправки аддресов          for (String s : Seting.ORIGINAL_ADDRESSES) {              String original = s;             String url = s + \"/nodes/register\";              if (BasisController.getExcludedAddresses().contains(url)) {                 System.out.println(\"MainController: its your address or excluded address: \" + url);                 continue;             }             try {                 for (String s1 : BasisController.getNodes()) {                       AddressUrl addressUrl = new AddressUrl(s1);                     String json = UtilsJson.objToStringJson(addressUrl);                     UtilUrl.sendPost(json, url);                 }             } catch (Exception e) {                 System.out.println(\"BasisController: sendAddress: wronge node: \" + original);                  continue;             }           }     }      //должен отправлять блокчейн в хранилище блокчейна     public static void sendAllBlocksToStorage(List<Block> blocks) throws IOException, NoSuchAlgorithmException, InvalidKeySpecException, SignatureException, NoSuchProviderException, InvalidKeyException {         String jsonDto;         System.out.println(\"BasisController: sendAllBlocksToStorage: start: \");         try {             jsonDto = UtilsJson.objToStringJson(blocks);         } catch (IOException e) {             throw new RuntimeException(e);         }         int blocks_current_size = blocks.size();         //отправка блокчейна на хранилище блокчейна         System.out.println(\"BasisController: sendAllBlocksToStorage: \");         getNodes().stream().forEach(System.out::println);         for (String s : getNodes()) {               if (BasisController.getExcludedAddresses().contains(s)) {                 System.out.println(\"its your address or excluded address: \" + s);                 continue;             }              try {                 System.out.println(\"BasisController:resolve conflicts: address: \" + s + \"/size\");                 String sizeStr = UtilUrl.readJsonFromUrl(s + \"/size\");                 Integer size =  0;                 if(Integer.valueOf(sizeStr) > 0)                     size = Integer.valueOf(sizeStr);                 System.out.println(\"BasisController: send size: \" + size);                 List<Block> fromToTempBlock = blocks.subList(size, blocks.size());                 String jsonFromTo = UtilsJson.objToStringJson(fromToTempBlock);                 //если блокчейн текущей больше чем в хранилище, то                 //отправить текущий блокчейн отправить в хранилище                 if (size < blocks_current_size) {                     int response = 0;                     //Test start algorithm                     String originalF = s;                     String urlFrom = s + \"/nodes/resolve_from_to_block\";                     try {                         response = UtilUrl.sendPost(jsonFromTo, urlFrom);                      }catch (Exception e){                         System.out.println(\"exception discover: \" + originalF);                         continue;                     }                      System.out.println(\"BasisController: sendAllBlocksStorage: response: \" + response);                      if(response != 0){                         System.out.println(\"BasisController: sendAllBlocks: need change all: \" + response);                         //Test start algorithm                         String original = s;                         String url = s + \"/nodes/resolve_all_blocks\";                         try {                             UtilUrl.sendPost(jsonDto, url);                          }catch (Exception e){                             System.out.println(\"exception discover: \" + original);                             continue;                          }                     }                  }              } catch (JSONException e) {                 e.printStackTrace();                 continue;              } catch (IOException e) {                 e.printStackTrace();                 continue;             }          }      } }","package International_Trade_Union.controllers;  import International_Trade_Union.config.BlockchainFactoryEnum; import International_Trade_Union.entity.blockchain.Blockchain; import International_Trade_Union.model.Mining; import International_Trade_Union.setings.Seting; import org.springframework.web.bind.annotation.GetMapping; import org.springframework.web.bind.annotation.RestController;  import java.io.IOException; import java.security.InvalidKeyException; import java.security.NoSuchAlgorithmException; import java.security.NoSuchProviderException; import java.security.SignatureException; import java.security.spec.InvalidKeySpecException;  @RestController public class BlockchainCheckController {      //TODO во время майнинга, если майнинг не остановлен, он почему то возвращает false, но после остановки true. Нужно исправить.     //TODO during mining, if mining is not stopped, for some reason it returns false, but after stopping it returns true. Need to fix.     //TODO worked after restart server, get true.     //TODO ошибка возникает если прервать mine,     //TODO error occurs if mine is interrupted,     @GetMapping(\"/checkValidation\")     public boolean checkValidation() throws IOException, NoSuchAlgorithmException, SignatureException, InvalidKeySpecException, NoSuchProviderException, InvalidKeyException {         try{             Blockchain blockchain = Mining.getBlockchain(                     Seting.ORIGINAL_BLOCKCHAIN_FILE,                     BlockchainFactoryEnum.ORIGINAL);             System.out.println(\"BlockchainCheckController: checkValidation: size: \" + blockchain.sizeBlockhain());             boolean check = blockchain.validatedBlockchain();             System.out.println(\"check: \" + check);             return check;}         catch (IOException e){             e.printStackTrace();             return false;         }     } }","package International_Trade_Union.controllers;  import International_Trade_Union.config.BlockchainFactoryEnum; import International_Trade_Union.entity.blockchain.Blockchain; import International_Trade_Union.governments.UtilsGovernment; import International_Trade_Union.model.Mining; import International_Trade_Union.utils.SaveBalances; import org.springframework.stereotype.Controller; import org.springframework.ui.Model; import org.springframework.web.bind.annotation.GetMapping; import International_Trade_Union.model.Account; import International_Trade_Union.setings.Seting;  import java.io.IOException; import java.security.InvalidKeyException; import java.security.NoSuchAlgorithmException; import java.security.NoSuchProviderException; import java.security.SignatureException; import java.security.spec.InvalidKeySpecException; import java.util.ArrayList; import java.util.HashMap; import java.util.List; import java.util.Map; import java.util.stream.Collectors;  @Controller public class BoardOfShareholdersController {     @GetMapping(\"board-of-shareholders\")     public String boardOfShareHolders(Model model) throws NoSuchAlgorithmException, InvalidKeySpecException, IOException, SignatureException, NoSuchProviderException, InvalidKeyException {          Blockchain blockchain = Mining.getBlockchain(                 Seting.ORIGINAL_BLOCKCHAIN_FILE,                 BlockchainFactoryEnum.ORIGINAL);          //Получение баланса         Map<String, Account> balances = new HashMap<>();          balances = SaveBalances.readLineObject(Seting.ORIGINAL_BALANCE_FILE);         List<Account> boardOfShareholders = new ArrayList<>();          boardOfShareholders = UtilsGovernment.findBoardOfShareholders(balances, blockchain.getBlockchainList(), Seting.BOARDS_BLOCK);           model.addAttribute(\"title\", \"board of shareholders. total: \" + boardOfShareholders.size());         model.addAttribute(\"boardOfShareholders\", boardOfShareholders);         return \"board-of-shareholders\";     }   }","package International_Trade_Union.controllers;  import International_Trade_Union.CorporateCharterEngDraft.*; import International_Trade_Union.originalCorporateCharter.OriginalCHARTER; import International_Trade_Union.originalCorporateCharter.OriginalCHARTER_ENG; import International_Trade_Union.originalCorporateCharter.OriginalPreamble; import International_Trade_Union.originalCorporateCharter.OriginalPreambleEng; import International_Trade_Union.setings.Seting; import International_Trade_Union.utils.UtilsSecurity; import International_Trade_Union.utils.base.Base; import International_Trade_Union.utils.base.Base58; import org.bouncycastle.jcajce.provider.asymmetric.ec.BCECPublicKey; import org.springframework.stereotype.Controller; import org.springframework.ui.Model; import org.springframework.web.bind.annotation.GetMapping; import International_Trade_Union.CorporateCharterDraft.*;  import java.io.IOException; import java.security.InvalidKeyException; import java.security.NoSuchAlgorithmException; import java.security.NoSuchProviderException; import java.security.SignatureException; import java.security.spec.InvalidKeySpecException; import java.util.ArrayList; import java.util.List;  @Controller public class ConstitutionController {     @GetMapping(\"corporate-charter\")     public String constutionRus(Model model) throws NoSuchAlgorithmException, InvalidKeySpecException, IOException, SignatureException, NoSuchProviderException, InvalidKeyException {          model.addAttribute(\"title\", \"corporate charter-корпоративный устав\");         List<String> rus = charterRusList();         List<String> eng = charterEngList();               model.addAttribute(\"rus\", rus);         model.addAttribute(\"eng\", eng);         return \"corporate-charter\";     }      public static String charterRus (){         String string = \"\";         for (String s : charterRusList()) {             string = s + \"\\n\";         }         return string;     }      public static String charterEng(){         String string = \"\";         for (String s : charterEngList()) {             string = s + \"\\n\";         }         return string;     }       public static List<String> charterRusList(){         List<String> rus = new ArrayList<>();         List<String> eng = new ArrayList<>();          rus.add(\"OriginalPreamble.ARTICLE_0\\n\"+ OriginalPreamble.ARTICLE_0);         rus.add(\"OriginalCHARTER.POWERS_OF_THE_BOARD_OF_DIRECTORS:\\n\"+ OriginalCHARTER.POWERS_OF_THE_BOARD_OF_DIRECTORS);         rus.add(\"OriginalCHARTER.HOW_LAWS_ARE_CHOSEN:\\n\"+ OriginalCHARTER.HOW_LAWS_ARE_CHOSEN);         rus.add(\"OriginalCHARTER.HOW_THE_BOARD_OF_DIRECTORS_IS_ELECTED:\\n\"+ OriginalCHARTER.HOW_THE_BOARD_OF_DIRECTORS_IS_ELECTED);         rus.add(\"OriginalCHARTER.POWERS_OF_THE_BOARD_OF_SHAREHOLDERS:\\n\"+ OriginalCHARTER.POWERS_OF_THE_BOARD_OF_SHAREHOLDERS);         rus.add(\"OriginalCHARTER.HOW_SHAREHOLDERS_BOARD_IS_ELECTED:\\n\"+ OriginalCHARTER.HOW_SHAREHOLDERS_BOARD_IS_ELECTED);         rus.add(\"OriginalCHARTER.VOTE_STOCK:\\n\"+ OriginalCHARTER.VOTE_STOCK);         rus.add(\"OriginalCHARTER.CODE_VOTE_STOCK:\\n\"+ OriginalCHARTER.CODE_VOTE_STOCK);         rus.add(\"OriginalCHARTER.POWERS_OF_DIRECTORS_IN_THE_OFFICE:\\n\"+ OriginalCHARTER.POWERS_OF_DIRECTORS_IN_THE_OFFICE);         rus.add(\"OriginalCHARTER.HOW_OFFICE_DIRECTORS_ARE_CHOSEN:\\n\"+ OriginalCHARTER.HOW_OFFICE_DIRECTORS_ARE_CHOSEN);         rus.add(\"OriginalCHARTER.ONE_VOTE:\\n\"+ OriginalCHARTER.ONE_VOTE);         rus.add(\"OriginalCHARTER.CODE_VOTE_ONE:\\n\"+ OriginalCHARTER.CODE_VOTE_ONE);         rus.add(\"OriginalCHARTER.MECHANISM_FOR_REDUCING_THE_NUMBER_OF_SHARES:\\n\"+ OriginalCHARTER.MECHANISM_FOR_REDUCING_THE_NUMBER_OF_SHARES);         rus.add(\"OriginalCHARTER.WHO_HAS_THE_RIGHT_TO_CREATE_LAWS:\\n\"+ OriginalCHARTER.WHO_HAS_THE_RIGHT_TO_CREATE_LAWS);         rus.add(\"OriginalCHARTER.POWERS_OF_THE_CORPORATE_COUNCIL_OF_JUDGES:\\n\"+ OriginalCHARTER.POWERS_OF_THE_CORPORATE_COUNCIL_OF_JUDGES);         rus.add(\"OriginalCHARTER.HOW_THE_CORPORATE_BOARD_OF_JUDGES_IS_ELECTED:\\n\"+ OriginalCHARTER.HOW_THE_CORPORATE_BOARD_OF_JUDGES_IS_ELECTED);         rus.add(\"OriginalCHARTER.HOW_THE_CHIEF_JUDGE_IS_CHOSEN:\\n\"+ OriginalCHARTER.HOW_THE_CHIEF_JUDGE_IS_CHOSEN);         rus.add(\"OriginalCHARTER.POWERS_OF_THE_CHIEF_JUDGE:\\n\"+ OriginalCHARTER.POWERS_OF_THE_CHIEF_JUDGE);         rus.add(\"OriginalCHARTER.HOW_IS_THE_PROCESS_OF_AMENDING_THE_CHARTER:\\n\"+ OriginalCHARTER.HOW_IS_THE_PROCESS_OF_AMENDING_THE_CHARTER);         rus.add(\"OriginalCHARTER.HOW_THE_BUDGET_IS_APPROVED:\\n\"+ OriginalCHARTER.HOW_THE_BUDGET_IS_APPROVED);         rus.add(\"OriginalCHARTER.HOW_IS_THE_STRATEGIC:\\n\"+ OriginalCHARTER.HOW_IS_THE_STRATEGIC);         rus.add(\"OriginalCHARTER.HOW_NEW_POSITIONS_ARE_ADDED:\\n\"+ OriginalCHARTER.HOW_NEW_POSITIONS_ARE_ADDED);         rus.add(\"OriginalCHARTER.PROPERTY_OF_THE_CORPORATION:\\n\"+ OriginalCHARTER.PROPERTY_OF_THE_CORPORATION);         rus.add(\"OriginalCHARTER.INTERNET_STORE_DIRECTOR:\\n\"+ OriginalCHARTER.INTERNET_STORE_DIRECTOR);         rus.add(\"OriginalCHARTER.GENERAL_EXECUTIVE_DIRECTOR:\\n\"+ OriginalCHARTER.GENERAL_EXECUTIVE_DIRECTOR);         rus.add(\"OriginalCHARTER.DIRECTOR_OF_THE_DIGITAL_EXCHANGE:\\n\"+ OriginalCHARTER.DIRECTOR_OF_THE_DIGITAL_EXCHANGE);         rus.add(\"OriginalCHARTER.DIRECTOR_OF_DIGITAL_BANK:\\n\"+ OriginalCHARTER.DIRECTOR_OF_DIGITAL_BANK);         rus.add(\"OriginalCHARTER.DIRECTOR_OF_THE_COMMERCIAL_COURT:\\n\"+ OriginalCHARTER.DIRECTOR_OF_THE_COMMERCIAL_COURT);         rus.add(\"OriginalCHARTER.MEDIA_DIRECTOR:\\n\"+ OriginalCHARTER.MEDIA_DIRECTOR);         rus.add(\"OriginalCHARTER.DIRECTOR_OF_THE_DEVELOPMENT_OF_THE_IMPLEMENTATION_OF_CRYPTOCURRENCY_TECHNOLOGIES_OF_THE_INTERNATIONAL_TRADE_UNION_CORPORATION:\\n\"+ OriginalCHARTER.DIRECTOR_OF_THE_DEVELOPMENT_OF_THE_IMPLEMENTATION_OF_CRYPTOCURRENCY_TECHNOLOGIES_OF_THE_INTERNATIONAL_TRADE_UNION_CORPORATION);         rus.add(\"OriginalCHARTER.EXPLANATION_WHY_MONEY_DEMURAGE_IS_USED_HERE:\\n\"+ OriginalCHARTER.EXPLANATION_WHY_MONEY_DEMURAGE_IS_USED_HERE);         rus.add(\"OriginalCHARTER.FREEDOM_OF_SPEECH:\\n\"+ OriginalCHARTER.FREEDOM_OF_SPEECH);         rus.add(\"OriginalCHARTER.RIGHTS:\\n\"+ OriginalCHARTER.RIGHTS);         return rus;     }       public static List<String> charterEngList(){         List<String> eng = new ArrayList<>();              //************************************************************************************         eng.add(\"OriginalPreamble.ARTICLE_0\\n\"+ OriginalPreambleEng.ARTICLE_0);         eng.add(\"OriginalCHARTER_ENG.POWERS_OF_THE_BOARD_OF_DIRECTORS:\\n\"+ OriginalCHARTER_ENG.POWERS_OF_THE_BOARD_OF_DIRECTORS);         eng.add(\"OriginalCHARTER_ENG.HOW_LAWS_ARE_CHOSEN:\\n\"+ OriginalCHARTER_ENG.HOW_LAWS_ARE_CHOSEN);         eng.add(\"OriginalCHARTER_ENG.HOW_THE_BOARD_OF_DIRECTORS_IS_ELECTED:\\n\"+ OriginalCHARTER_ENG.HOW_THE_BOARD_OF_DIRECTORS_IS_ELECTED);         eng.add(\"OriginalCHARTER_ENG.POWERS_OF_THE_BOARD_OF_SHAREHOLDERS:\\n\"+ OriginalCHARTER_ENG.POWERS_OF_THE_BOARD_OF_SHAREHOLDERS);         eng.add(\"OriginalCHARTER_ENG.HOW_SHAREHOLDERS_BOARD_IS_ELECTED:\\n\"+ OriginalCHARTER_ENG.HOW_SHAREHOLDERS_BOARD_IS_ELECTED);         eng.add(\"OriginalCHARTER_ENG.VOTE_STOCK:\\n\"+ OriginalCHARTER_ENG.VOTE_STOCK);         eng.add(\"OriginalCHARTER_ENG.CODE_VOTE_STOCK:\\n\"+ OriginalCHARTER_ENG.CODE_VOTE_STOCK);         eng.add(\"OriginalCHARTER_ENG.POWERS_OF_DIRECTORS_IN_THE_OFFICE:\\n\"+ OriginalCHARTER_ENG.POWERS_OF_DIRECTORS_IN_THE_OFFICE);         eng.add(\"OriginalCHARTER_ENG.HOW_OFFICE_DIRECTORS_ARE_CHOSEN:\\n\"+ OriginalCHARTER_ENG.HOW_OFFICE_DIRECTORS_ARE_CHOSEN);         eng.add(\"OriginalCHARTER_ENG.ONE_VOTE:\\n\"+ OriginalCHARTER_ENG.ONE_VOTE);         eng.add(\"OriginalCHARTER_ENG.CODE_VOTE_ONE:\\n\"+ OriginalCHARTER_ENG.CODE_VOTE_ONE);         eng.add(\"OriginalCHARTER_ENG.MECHANISM_FOR_REDUCING_THE_NUMBER_OF_SHARES:\\n\"+ OriginalCHARTER_ENG.MECHANISM_FOR_REDUCING_THE_NUMBER_OF_SHARES);         eng.add(\"OriginalCHARTER_ENG.WHO_HAS_THE_RIGHT_TO_CREATE_LAWS:\\n\"+ OriginalCHARTER_ENG.WHO_HAS_THE_RIGHT_TO_CREATE_LAWS);         eng.add(\"OriginalCHARTER_ENG.POWERS_OF_THE_CORPORATE_COUNCIL_OF_JUDGES:\\n\"+ OriginalCHARTER_ENG.POWERS_OF_THE_CORPORATE_COUNCIL_OF_JUDGES);         eng.add(\"OriginalCHARTER_ENG.HOW_THE_CORPORATE_BOARD_OF_JUDGES_IS_ELECTED:\\n\"+ OriginalCHARTER_ENG.HOW_THE_CORPORATE_BOARD_OF_JUDGES_IS_ELECTED);         eng.add(\"OriginalCHARTER_ENG.HOW_THE_CHIEF_JUDGE_IS_CHOSEN:\\n\"+ OriginalCHARTER_ENG.HOW_THE_CHIEF_JUDGE_IS_CHOSEN);         eng.add(\"OriginalCHARTER_ENG.POWERS_OF_THE_CHIEF_JUDGE:\\n\"+ OriginalCHARTER_ENG.POWERS_OF_THE_CHIEF_JUDGE);         eng.add(\"OriginalCHARTER_ENG.HOW_IS_THE_PROCESS_OF_AMENDING_THE_CHARTER:\\n\"+ OriginalCHARTER_ENG.HOW_IS_THE_PROCESS_OF_AMENDING_THE_CHARTER);         eng.add(\"OriginalCHARTER_ENG.HOW_THE_BUDGET_IS_APPROVED:\\n\"+ OriginalCHARTER_ENG.HOW_THE_BUDGET_IS_APPROVED);         eng.add(\"OriginalCHARTER_ENG.HOW_IS_THE_STRATEGIC:\\n\"+ OriginalCHARTER_ENG.HOW_IS_THE_STRATEGIC);         eng.add(\"OriginalCHARTER_ENG.HOW_NEW_POSITIONS_ARE_ADDED:\\n\"+ OriginalCHARTER_ENG.HOW_NEW_POSITIONS_ARE_ADDED);         eng.add(\"OriginalCHARTER_ENG.PROPERTY_OF_THE_CORPORATION:\\n\"+ OriginalCHARTER_ENG.PROPERTY_OF_THE_CORPORATION);         eng.add(\"OriginalCHARTER_ENG.INTERNET_STORE_DIRECTOR:\\n\"+ OriginalCHARTER_ENG.INTERNET_STORE_DIRECTOR);         eng.add(\"OriginalCHARTER_ENG.GENERAL_EXECUTIVE_DIRECTOR:\\n\"+ OriginalCHARTER_ENG.GENERAL_EXECUTIVE_DIRECTOR);         eng.add(\"OriginalCHARTER_ENG.DIRECTOR_OF_THE_DIGITAL_EXCHANGE:\\n\"+ OriginalCHARTER_ENG.DIRECTOR_OF_THE_DIGITAL_EXCHANGE);         eng.add(\"OriginalCHARTER_ENG.DIRECTOR_OF_DIGITAL_BANK:\\n\"+ OriginalCHARTER_ENG.DIRECTOR_OF_DIGITAL_BANK);         eng.add(\"OriginalCHARTER_ENG.DIRECTOR_OF_THE_COMMERCIAL_COURT:\\n\"+ OriginalCHARTER_ENG.DIRECTOR_OF_THE_COMMERCIAL_COURT);         eng.add(\"OriginalCHARTER_ENG.MEDIA_DIRECTOR:\\n\"+ OriginalCHARTER_ENG.MEDIA_DIRECTOR);         eng.add(\"OriginalCHARTER_ENG.DIRECTOR_OF_THE_DEVELOPMENT_OF_THE_IMPLEMENTATION_OF_CRYPTOCURRENCY_TECHNOLOGIES_OF_THE_INTERNATIONAL_TRADE_UNION_CORPORATION:\\n\"+ OriginalCHARTER_ENG.DIRECTOR_OF_THE_DEVELOPMENT_OF_THE_IMPLEMENTATION_OF_CRYPTOCURRENCY_TECHNOLOGIES_OF_THE_INTERNATIONAL_TRADE_UNION_CORPORATION);         eng.add(\"OriginalCHARTER_ENG.EXPLANATION_WHY_MONEY_DEMURAGE_IS_USED_HERE:\\n\"+ OriginalCHARTER_ENG.EXPLANATION_WHY_MONEY_DEMURAGE_IS_USED_HERE);         eng.add(\"OriginalCHARTER_ENG.FREEDOM_OF_SPEECH:\\n\"+ OriginalCHARTER_ENG.FREEDOM_OF_SPEECH);         eng.add(\"OriginalCHARTER_ENG.RIGHTS:\\n\"+ OriginalCHARTER_ENG.RIGHTS);         return eng;     } }","package International_Trade_Union.controllers;  import org.springframework.stereotype.Controller; import org.springframework.ui.Model; import org.springframework.web.bind.annotation.GetMapping; import org.springframework.web.bind.annotation.PostMapping; import org.springframework.web.servlet.mvc.support.RedirectAttributes; import International_Trade_Union.model.CreateAccount;  import java.security.InvalidAlgorithmParameterException; import java.security.NoSuchAlgorithmException; import java.security.NoSuchProviderException; import java.security.spec.InvalidKeySpecException; import java.util.Map;  @Controller public class CreateAccountController {       @GetMapping(\"create-account\")     public String createAccount(Model model) throws InvalidAlgorithmParameterException, NoSuchAlgorithmException, InvalidKeySpecException, NoSuchProviderException {         model.addAttribute(\"title\", \"create minerAccount\");         Map<String, String> newAccount = CreateAccount.create();          model.addAttribute(\"login\", newAccount.get(\"pubKey\"));         model.addAttribute(\"password\", newAccount.get(\"privKey\"));         return \"create-account\";     }     @PostMapping(\"create-account\")     public String createNewAccount(RedirectAttributes redirectAttrs) throws InvalidAlgorithmParameterException, NoSuchAlgorithmException, InvalidKeySpecException, NoSuchProviderException {         redirectAttrs.addFlashAttribute(\"title\", \"create minerAccount\");         Map<String, String> newAccount = CreateAccount.create();          redirectAttrs.addFlashAttribute(\"login\", newAccount.get(\"pubKey\"));         redirectAttrs.addFlashAttribute(\"password\", newAccount.get(\"privKey\"));          return \"redirect:/create-account\";     }  //    @PostMapping(\"save-creating-minerAccount\") //    public String saveNewAccount(Model model, @RequestParam String changeAddress){ //        User.setUserAddress(changeAddress); //        return \"redirect:/\"; //    }    }","package International_Trade_Union.controllers;  import International_Trade_Union.config.BlockchainFactoryEnum; import International_Trade_Union.entity.DtoTransaction.DtoTransaction; import International_Trade_Union.entity.blockchain.Blockchain; import International_Trade_Union.governments.Director; import International_Trade_Union.governments.Directors; import International_Trade_Union.governments.NamePOSITION; import International_Trade_Union.model.FIndPositonHelperData; import International_Trade_Union.model.Mining; import International_Trade_Union.network.AllTransactions; import International_Trade_Union.utils.base.Base; import International_Trade_Union.utils.base.Base58; import org.springframework.stereotype.Controller; import org.springframework.ui.Model; import org.springframework.web.bind.annotation.GetMapping; import International_Trade_Union.governments.UtilsGovernment; import International_Trade_Union.model.Account; import International_Trade_Union.setings.Seting; import International_Trade_Union.utils.*; import International_Trade_Union.vote.*; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RequestMethod; import org.springframework.web.bind.annotation.RequestParam; import org.springframework.web.servlet.mvc.support.RedirectAttributes;  import java.io.IOException; import java.security.*; import java.security.spec.InvalidKeySpecException; import java.util.*; import java.util.stream.Collectors;  @Controller public class GovernmentController {      //TODO если происходит майнинг почему то происходят ошибки, и если вызвать данный метод, то может     //TODO прерываться сам процесс майнинга     //TODO if mining occurs for some reason, errors are observed, and this method appears, then it can     //TODO interrupt the mining process itself     @GetMapping(\"/governments\")     public String corporateSeniorpositions(Model model) throws NoSuchAlgorithmException, InvalidKeySpecException, IOException, SignatureException, NoSuchProviderException, InvalidKeyException {         Blockchain blockchain = Mining.getBlockchain(                 Seting.ORIGINAL_BLOCKCHAIN_FILE,                 BlockchainFactoryEnum.ORIGINAL);          //за сколько времени занимает подсчет         Date start = new Date();         //Получение баланса         Map<String, Account> balances = new HashMap<>();          balances = SaveBalances.readLineObject(Seting.ORIGINAL_BALANCE_FILE);          //Нахождение должности         List<LawEligibleForParliamentaryApproval> allGovernment =                 UtilsLaws.readLineCurrentLaws(Seting.ORIGINAL_ALL_CORPORATION_LAWS_WITH_BALANCE_FILE);          //список должностей         Map<Director, List<LawEligibleForParliamentaryApproval>> positionsListMap = new HashMap<>();          Directors directors = new Directors();         //добавление всех должностей         for (Director higherSpecialPositions : directors.getDirectors()) {             positionsListMap.put(higherSpecialPositions, UtilsLaws.getPossions(allGovernment, higherSpecialPositions));         }          //список акционеров         List<Account> BoardOfShareholders = UtilsGovernment.findBoardOfShareholders(balances, blockchain.getBlockchainList(), Seting.BOARDS_BLOCK);          //список законов с голосами         Map<String, List<CurrentLawVotesEndBalance>> curentLawVotesEndBalance = new HashMap<>();          //TODO доработать оптимизацию         //TODO избавиться от find position в данном методе         Map<Director, FIndPositonHelperData> fIndPositonHelperDataMap = new HashMap<>();         for (Director higherSpecialPositions : directors.getDirectors()) {             if(higherSpecialPositions.isElectedByCEO()){                 fIndPositonHelperDataMap.put(higherSpecialPositions,                         new FIndPositonHelperData(higherSpecialPositions, false, false, true, false, false));             }             else if(higherSpecialPositions.isElectedByBoardOfDirectors()){                 fIndPositonHelperDataMap.put(higherSpecialPositions,                         new FIndPositonHelperData(higherSpecialPositions, false, false, false, true, false));             }             else if(higherSpecialPositions.isElectedByCorporateCouncilOfReferees()){                 fIndPositonHelperDataMap.put(higherSpecialPositions,                         new FIndPositonHelperData(higherSpecialPositions, false, false, false, false, true));             }             else {                 fIndPositonHelperDataMap.put(higherSpecialPositions,                         new FIndPositonHelperData(higherSpecialPositions, true, true, false ,false, false));              }          }          List<CurrentLawVotesEndBalance> current = UtilsGovernment.filtersVotes(                 allGovernment,                 balances,                 BoardOfShareholders,                 blockchain.getBlockchainList(),                 Seting.LAW_YEAR_VOTE);            //минимальное значение количество положительных голосов для того чтобы закон действовал,         //позиции избираемые акциями в совет директоров         List<CurrentLawVotesEndBalance> electedByStockBoardOfDirectors = current.stream()                 .filter(t -> directors.isElectedByStocks(t.getPackageName()))                 .filter(t -> t.getPackageName().equals(NamePOSITION.BOARD_OF_DIRECTORS.toString()))                 .filter(t -> t.getVotes() >= Seting.ORIGINAL_LIMIT_MIN_VOTE)                 .sorted(Comparator.comparing(CurrentLawVotesEndBalance::getVotes).reversed())                 .limit(directors.getDirector(NamePOSITION.BOARD_OF_DIRECTORS.toString()).getCount())                 .collect(Collectors.toList());           //минимальное значение количество положительных голосов для того чтобы закон действовал,         //позиции избираемые акциями electedByStockCorporateCouncilOfReferees         List<CurrentLawVotesEndBalance> electedByStockCorporateCouncilOfReferees = current.stream()                 .filter(t -> directors.isElectedByStocks(t.getPackageName()))                 .filter(t -> t.getPackageName().equals(NamePOSITION.CORPORATE_COUNCIL_OF_REFEREES.toString()))                 .filter(t -> t.getVotes() >= Seting.ORIGINAL_LIMIT_MIN_VOTE)                 .sorted(Comparator.comparing(CurrentLawVotesEndBalance::getVotes).reversed())                 .limit(directors.getDirector(NamePOSITION.CORPORATE_COUNCIL_OF_REFEREES.toString()).getCount())                 .collect(Collectors.toList());            //позиции созданные советом директоров         List<CurrentLawVotesEndBalance> createdByBoardOfDirectors = current.stream()                 .filter(t->t.getPackageName().startsWith(Seting.ADD_DIRECTOR))                 .filter(t->t.getVotesBoardOfDirectors() >= Seting.ORIGINAL_LIMIT_MIN_VOTE_BOARD_OF_DIRECTORS)                 .collect(Collectors.toList());         //добавление позиций созданных советом директоров         for (CurrentLawVotesEndBalance currentLawVotesEndBalance : createdByBoardOfDirectors) {             directors.addAllByBoardOfDirectors(currentLawVotesEndBalance.getLaws());         }          //позиции избираемые  только советом директоров в кабинет директоров         List<CurrentLawVotesEndBalance> electedByBoardOfDirectors = current.stream()                 .filter(t -> directors.isElectedByBoardOfDirectors(t.getPackageName()))                 .filter(t -> t.getVotesBoardOfDirectors() >= Seting.ORIGINAL_LIMIT_MIN_VOTE_BOARD_OF_DIRECTORS)                 .sorted(Comparator.comparing(CurrentLawVotesEndBalance::getVotesBoardOfDirectors).reversed())                 .collect(Collectors.toList());          List<CurrentLawVotesEndBalance> addDirectors = current.stream()                         .filter(t->directors.isCabinets(t.getPackageName()))                                 .filter(t->t.getVotesBoardOfDirectors() >= Seting.ORIGINAL_LIMIT_MIN_VOTE_BOARD_OF_DIRECTORS)                                         .collect(Collectors.toList());          System.out.println(\"***************************************\");         System.out.println(\"GovernmentController: corporateSeniorpositions: elected by Board of Directors;\");         electedByBoardOfDirectors.stream().forEach(System.out::println);         System.out.println(\"***************************************\");          //групируем по списку         Map<String, List<CurrentLawVotesEndBalance>> group = electedByBoardOfDirectors.stream()                 .collect(Collectors.groupingBy(CurrentLawVotesEndBalance::getPackageName));          Map<Director, List<CurrentLawVotesEndBalance>> original_group = new HashMap<>();          //оставляем то количество которое описано в данной должности         for (Map.Entry<String, List<CurrentLawVotesEndBalance>> stringListEntry : group.entrySet()) {             List<CurrentLawVotesEndBalance> temporary = stringListEntry.getValue();             temporary = temporary.stream()                     .sorted(Comparator.comparing(CurrentLawVotesEndBalance::getVotesBoardOfDirectors))                     .limit(directors.getDirector(stringListEntry.getKey()).getCount())                     .collect(Collectors.toList());             original_group.put(directors.getDirector(stringListEntry.getKey()), temporary);         }          //позиции избираемые палатой верховных судей         List<CurrentLawVotesEndBalance> electedByChamberOfSupremeJudges = current.stream()                 .filter(t -> directors.isElectedBYCorporateCouncilOfReferees(t.getPackageName()))                 .filter(t -> t.getVotesCorporateCouncilOfReferees() >= Seting.ORIGINAL_LIMIT_MIN_VOTE_CORPORATE_COUNCIL_OF_REFEREES)                 .sorted(Comparator.comparing(CurrentLawVotesEndBalance::getVotesCorporateCouncilOfReferees)).collect(Collectors.toList());            //избираемые премьер министром         List<CurrentLawVotesEndBalance> GENERAL_EXECUTIVE_DIRECTOR = electedByBoardOfDirectors.stream()                 .filter(t -> directors.isElectedCEO(t.getPackageName()))                 .filter(t -> NamePOSITION.GENERAL_EXECUTIVE_DIRECTOR.toString().equals(t.getPackageName()))                 .filter(t -> t.getVoteGeneralExecutiveDirector() >= Seting.ORIGINAL_LIMIT_MIN_VOTE_GENERAL_EXECUTIVE_DIRECTOR)                 .sorted(Comparator.comparing(CurrentLawVotesEndBalance::getVoteGeneralExecutiveDirector))                 .collect(Collectors.toList());          //избираемые верховным судьей         List<CurrentLawVotesEndBalance> electedByHightJudge = electedByChamberOfSupremeJudges.stream()                 .filter(t -> directors.isElectedBYCorporateCouncilOfReferees(t.getPackageName()))                 .filter(t -> t.getVoteHightJudge() >= Seting.ORIGINAL_LIMIT_MIN_VOTE_HIGHT_JUDGE)                 .collect(Collectors.toList());          curentLawVotesEndBalance.put(\"elected by GENERAL_EXECUTIVE_DIRECTOR: \", GENERAL_EXECUTIVE_DIRECTOR);         curentLawVotesEndBalance.put(\"elected by hight judge: \", electedByHightJudge);         curentLawVotesEndBalance.put(NamePOSITION.BOARD_OF_DIRECTORS.toString(), electedByStockBoardOfDirectors);         curentLawVotesEndBalance.put(NamePOSITION.CORPORATE_COUNCIL_OF_REFEREES.toString(), electedByStockCorporateCouncilOfReferees);         curentLawVotesEndBalance.put(NamePOSITION.HIGH_JUDGE.toString(), electedByChamberOfSupremeJudges);          for (Map.Entry<Director, List<CurrentLawVotesEndBalance>> higherSpecialPositionsListMap : original_group.entrySet()) {             curentLawVotesEndBalance.put(higherSpecialPositionsListMap.getKey().toString(), higherSpecialPositionsListMap.getValue());         }           Date finish = new Date();         System.out.println(\"given time: \" + new Date(finish.getTime() - start.getTime()));          model.addAttribute(\"show\", curentLawVotesEndBalance);          model.addAttribute(\"title\", \"current guidance\");          return \"/governments\";     }      @GetMapping(\"/create-position\")     public String createPositionShow(Model model) throws IOException, NoSuchAlgorithmException, InvalidKeySpecException, SignatureException, NoSuchProviderException, InvalidKeyException {         Blockchain blockchain = Mining.getBlockchain(                 Seting.ORIGINAL_BLOCKCHAIN_FILE,                 BlockchainFactoryEnum.ORIGINAL);         Map<String, Account> balances = new HashMap<>();         //считывать баланс         balances = SaveBalances.readLineObject(Seting.ORIGINAL_BALANCE_FILE);          Directors directors = new Directors();          List<LawEligibleForParliamentaryApproval> lawEligibleForParliamentaryApprovals =                 UtilsLaws.readLineCurrentLaws(Seting.ORIGINAL_ALL_CORPORATION_LAWS_WITH_BALANCE_FILE);           List<Account> boardOfShareholders = UtilsGovernment.findBoardOfShareholders(balances, blockchain.getBlockchainList(), Seting.BOARDS_BLOCK);          List<CurrentLawVotesEndBalance> current = UtilsGovernment.filtersVotes(                 lawEligibleForParliamentaryApprovals,                 balances,                 boardOfShareholders,                 blockchain.getBlockchainList(),                 Seting.LAW_YEAR_VOTE);           List<String> positions = directors.getDirectors().stream().map(t->t.getName()).collect(Collectors.toList());         //позиции созданные советом директоров          List<CurrentLawVotesEndBalance> createdByBoardOfDirectors = current.stream()                 .filter(t->t.getPackageName().startsWith(Seting.ADD_DIRECTOR))                 .filter(t->t.getVotesBoardOfDirectors() >= Seting.ORIGINAL_LIMIT_MIN_VOTE_BOARD_OF_DIRECTORS)                 .collect(Collectors.toList());         //добавление позиций созданных советом директоров         for (CurrentLawVotesEndBalance currentLawVotesEndBalance : createdByBoardOfDirectors) {             directors.addAllByBoardOfDirectors(currentLawVotesEndBalance.getLaws());         }           positions.addAll(directors.getNames());         positions = positions.stream().distinct().collect(Collectors.toList());         model.addAttribute(\"positions\", positions);         return \"create-position\";     }      @RequestMapping(value = \"/create-position\", method = RequestMethod.POST, params = \"action=/send\")     public String createLaw(Model model,                             @RequestParam String sender,                             @RequestParam String reward,                             @RequestParam String nameLaw,                             @RequestParam String[] laws,                             @RequestParam String password,                             RedirectAttributes redirectAttrs) throws IOException, NoSuchAlgorithmException, SignatureException, NoSuchProviderException, InvalidKeyException, InvalidKeySpecException {           Laws law = new Laws(nameLaw, Arrays.asList(laws));         Base base = new Base58();          Double rewardD = Double.parseDouble(reward);           DtoTransaction dtoTransaction = new DtoTransaction(                 sender,                 law.getHashLaw(),                 0.0,                 0.0,                 law,                 rewardD,                 VoteEnum.valueOf(\"YES\"));         PrivateKey privateKey = UtilsSecurity.privateBytToPrivateKey(base.decode(password));         byte[] sign = UtilsSecurity.sign(privateKey, dtoTransaction.toSign());          redirectAttrs.addFlashAttribute(\"title\", \"sending result!!!\");         redirectAttrs.addFlashAttribute(\"sender\", sender);          redirectAttrs.addFlashAttribute(\"recipient\", law.getHashLaw());         redirectAttrs.addFlashAttribute(\"dollar\", 0.0);         redirectAttrs.addFlashAttribute(\"stock\", 0.0);         redirectAttrs.addFlashAttribute(\"reward\", rewardD);         redirectAttrs.addFlashAttribute(\"vote\", \"YES\");         dtoTransaction.setSign(sign);          if (dtoTransaction.verify() && UtilsGovernment.checkPostionSenderEqualsLaw(sender, law)) {             redirectAttrs.addFlashAttribute(\"sending\", \"success\");             AllTransactions.addTransaction(dtoTransaction);             String jsonDto = UtilsJson.objToStringJson(dtoTransaction);              for (String s : Seting.ORIGINAL_ADDRESSES) {                 String original = s;                 String url = s + \"/addTransaction\";                 if (BasisController.getExcludedAddresses().contains(url)) {                     System.out.println(\"its your address or excluded address: \" + url);                     continue;                 }                 try {                     UtilUrl.sendPost(jsonDto, url);                  } catch (Exception e) {                     System.out.println(\"exception discovery: \" + original);                  }             }         } else             redirectAttrs.addFlashAttribute(\"sending\", \"wrong transaction\");          return \"redirect:/result-sending\";      } }","package International_Trade_Union.controllers;  import International_Trade_Union.config.BLockchainFactory; import International_Trade_Union.config.BlockchainFactoryEnum; import International_Trade_Union.entity.blockchain.Blockchain; import International_Trade_Union.entity.blockchain.block.Block; import International_Trade_Union.governments.Director; import International_Trade_Union.governments.Directors; import International_Trade_Union.governments.NamePOSITION; import International_Trade_Union.model.FIndPositonHelperData; import International_Trade_Union.model.Mining; import org.springframework.stereotype.Controller; import org.springframework.ui.Model; import org.springframework.web.bind.annotation.*; import org.springframework.web.servlet.mvc.support.RedirectAttributes; import International_Trade_Union.entity.DtoTransaction.DtoTransaction; import International_Trade_Union.governments.UtilsGovernment; import International_Trade_Union.model.Account; import International_Trade_Union.network.AllTransactions; import International_Trade_Union.setings.Seting; import International_Trade_Union.utils.*; import International_Trade_Union.utils.base.Base; import International_Trade_Union.utils.base.Base58; import International_Trade_Union.vote.*;  import java.io.IOException; import java.security.*; import java.security.spec.InvalidKeySpecException; import java.util.*; import java.util.stream.Collectors;   @Controller public class LawsController {      @GetMapping(\"detail-laws\")     public String details(Model model) {         return \"detail-laws\";     }       @GetMapping(\"/detail-laws-current/{addressLaw}\")     public String lawsDetail(@PathVariable(value = \"addressLaw\") String addressLaw, RedirectAttributes redirectAttrs) throws NoSuchAlgorithmException, InvalidKeySpecException, IOException, SignatureException, NoSuchProviderException, InvalidKeyException {         System.out.println(\"LawsController detail-laws-current/{addressLaw}: \" + addressLaw);         redirectAttrs.addAttribute(\"title\", \"detail laws\");         //Seting.ORIGINAL_CURRENT_FEDERAL_LAWS_FILE         List<LawEligibleForParliamentaryApproval> lawEligibleForParliamentaryApprovals =                 UtilsLaws.readLineCurrentLaws(Seting.ORIGINAL_ALL_CORPORATION_LAWS_WITH_BALANCE_FILE);          List<String> currntLaws = new ArrayList<>();         for (LawEligibleForParliamentaryApproval lawEligibleForParliamentaryApproval : lawEligibleForParliamentaryApprovals) {             int i = 0;             if (lawEligibleForParliamentaryApproval.getLaws().getHashLaw().equals(addressLaw)) {                  for (String str : lawEligibleForParliamentaryApproval.getLaws().getLaws()) {                      currntLaws.add(\"\" + i + \": \" + str);                     ++i;                 }              }         }          currntLaws.forEach(System.out::println);         redirectAttrs.addFlashAttribute(\"laws\", currntLaws);         return \"redirect:/detail-laws\";     }      @GetMapping(\"/detail-laws-all/{addressLaw}\")     public String lawsDetailAll(@PathVariable(value = \"addressLaw\") String addressLaw, RedirectAttributes redirectAttrs) throws NoSuchAlgorithmException, InvalidKeySpecException, IOException, SignatureException, NoSuchProviderException, InvalidKeyException {         System.out.println(\"LawsController /detail-laws-all/{addressLaw}: \" + addressLaw);         redirectAttrs.addAttribute(\"title\", \"detail laws\");         //ORIGINAL_ALL_CORPORATION_LAWS_FILE         List<Laws> laws = UtilsLaws.readLineLaws(Seting.ORIGINAL_ALL_CORPORATION_LAWS_FILE);         List<String> allLaws = new ArrayList<>();         for (Laws laws1 : laws) {             int i = 0;             if (laws1.getHashLaw().equals(addressLaw)) {                  for (String s : laws1.getLaws()) {                     allLaws.add(\"\" + i + \": \" + s);                     ++i;                 }              }         }          redirectAttrs.addFlashAttribute(\"laws\", allLaws);         return \"redirect:/detail-laws\";     }       @GetMapping(\"/current-laws\")     public String currentLaw(Model model) throws IOException, NoSuchAlgorithmException, InvalidKeySpecException, SignatureException, NoSuchProviderException, InvalidKeyException, CloneNotSupportedException {         Directors directors = new Directors();         Blockchain blockchain = Mining.getBlockchain(                 Seting.ORIGINAL_BLOCKCHAIN_FILE,                 BlockchainFactoryEnum.ORIGINAL);          Map<String, Account> balances = new HashMap<>();         //считывать баланс         balances = SaveBalances.readLineObject(Seting.ORIGINAL_BALANCE_FILE);          List<LawEligibleForParliamentaryApproval> lawEligibleForParliamentaryApprovals =                 UtilsLaws.readLineCurrentLaws(Seting.ORIGINAL_ALL_CORPORATION_LAWS_WITH_BALANCE_FILE);           List<Account> boardOfShareholders = UtilsGovernment.findBoardOfShareholders(balances, blockchain.getBlockchainList(), Seting.BOARDS_BLOCK);           //TODO доработать оптимизацию         //TODO избавиться от find position в данном методе         Map<Director, FIndPositonHelperData> fIndPositonHelperDataMap = new HashMap<>();         for (Director higherSpecialPositions : directors.getDirectors()) {             if (higherSpecialPositions.isElectedByCEO()) {                 fIndPositonHelperDataMap.put(higherSpecialPositions,                         new FIndPositonHelperData(higherSpecialPositions, false, false, true, false, false));             } else if (higherSpecialPositions.isElectedByBoardOfDirectors()) {                 fIndPositonHelperDataMap.put(higherSpecialPositions,                         new FIndPositonHelperData(higherSpecialPositions, false, false, false, true, false));             } else if (higherSpecialPositions.isElectedByCorporateCouncilOfReferees()) {                 fIndPositonHelperDataMap.put(higherSpecialPositions,                         new FIndPositonHelperData(higherSpecialPositions, false, false, false, false, true));             } else {                 fIndPositonHelperDataMap.put(higherSpecialPositions,                         new FIndPositonHelperData(higherSpecialPositions, true, true, false, false, false));              }          }         List<CurrentLawVotesEndBalance> current = UtilsGovernment.filtersVotes(                 lawEligibleForParliamentaryApprovals,                 balances,                 boardOfShareholders,                 blockchain.getBlockchainList(),                 Seting.LAW_YEAR_VOTE);             //минимальное значение количество положительных голосов для того чтобы закон действовал,         //позиции избираемые акциями совета директоров         List<CurrentLawVotesEndBalance> electedByStockBoardOfDirectors = current.stream()                 .filter(t -> directors.isElectedByStocks(t.getPackageName()))                 .filter(t -> t.getPackageName().equals(NamePOSITION.BOARD_OF_DIRECTORS.toString()))                 .filter(t -> t.getVotes() >= Seting.ORIGINAL_LIMIT_MIN_VOTE)                 .sorted(Comparator.comparing(CurrentLawVotesEndBalance::getVotes).reversed())                 .limit(directors.getDirector(NamePOSITION.BOARD_OF_DIRECTORS.toString()).getCount())                 .collect(Collectors.toList());           //минимальное значение количество положительных голосов для того чтобы закон действовал,         //позиции избираемые акциями CORPORATE_COUNCIL_OF_REFEREES         List<CurrentLawVotesEndBalance> electedByStockCorporateCouncilOfReferees = current.stream()                 .filter(t -> directors.isElectedByStocks(t.getPackageName()))                 .filter(t -> t.getPackageName().equals(NamePOSITION.CORPORATE_COUNCIL_OF_REFEREES.toString()))                 .filter(t -> t.getVotes() >= Seting.ORIGINAL_LIMIT_MIN_VOTE)                 .sorted(Comparator.comparing(CurrentLawVotesEndBalance::getVotes).reversed())                 .limit(directors.getDirector(NamePOSITION.CORPORATE_COUNCIL_OF_REFEREES.toString()).getCount())                 .collect(Collectors.toList());            //позиции созданные советом директоров         List<CurrentLawVotesEndBalance> createdByBoardOfDirectors = current.stream()                 .filter(t->t.getPackageName().startsWith(Seting.ADD_DIRECTOR))                 .filter(t->t.getVotesBoardOfDirectors() >= Seting.ORIGINAL_LIMIT_MIN_VOTE_BOARD_OF_DIRECTORS)                 .collect(Collectors.toList());         //добавление позиций созданных советом директоров         for (CurrentLawVotesEndBalance currentLawVotesEndBalance : createdByBoardOfDirectors) {             directors.addAllByBoardOfDirectors(currentLawVotesEndBalance.getLaws());         }          //позиции избираемые только советом директоров         List<CurrentLawVotesEndBalance> electedByBoardOfDirectors = current.stream()                 .filter(t -> directors.isElectedByBoardOfDirectors(t.getPackageName()) || directors.isCabinets(t.getPackageName()))                 .filter(t -> t.getVotesBoardOfDirectors() >= Seting.ORIGINAL_LIMIT_MIN_VOTE_BOARD_OF_DIRECTORS)                 .sorted(Comparator.comparing(CurrentLawVotesEndBalance::getVotesBoardOfDirectors).reversed())                 .collect(Collectors.toList());           //групируем по списку         Map<String, List<CurrentLawVotesEndBalance>> group = electedByBoardOfDirectors.stream()                 .collect(Collectors.groupingBy(CurrentLawVotesEndBalance::getPackageName));          Map<Director, List<CurrentLawVotesEndBalance>> original_group = new HashMap<>();          //оставляем то количество которое описано в данной должности         for (Map.Entry<String, List<CurrentLawVotesEndBalance>> stringListEntry : group.entrySet()) {             List<CurrentLawVotesEndBalance> temporary = stringListEntry.getValue();             temporary = temporary.stream()                     .sorted(Comparator.comparing(CurrentLawVotesEndBalance::getVotesBoardOfDirectors))                     .limit(directors.getDirector(stringListEntry.getKey()).getCount())                     .collect(Collectors.toList());             original_group.put(directors.getDirector(stringListEntry.getKey()), temporary);         }            //позиции избираемые советом корпоративных верховных судей         List<CurrentLawVotesEndBalance> electedByCorporateCouncilOfReferees = current.stream()                 .filter(t -> directors.isElectedBYCorporateCouncilOfReferees(t.getPackageName()))                 .filter(t -> t.getVotesCorporateCouncilOfReferees() >= Seting.ORIGINAL_LIMIT_MIN_VOTE_CORPORATE_COUNCIL_OF_REFEREES)                 .sorted(Comparator.comparing(CurrentLawVotesEndBalance::getVotesCorporateCouncilOfReferees)).collect(Collectors.toList());           //избираемые GENERAL_EXECUTIVE_DIRECTOR         List<CurrentLawVotesEndBalance> electedByGeneralExecutiveDirector = electedByBoardOfDirectors.stream()                 .filter(t -> directors.isElectedCEO(t.getPackageName()))                 .filter(t -> NamePOSITION.GENERAL_EXECUTIVE_DIRECTOR.toString().equals(t.getPackageName()))                 .filter(t -> t.getVoteGeneralExecutiveDirector() >= Seting.ORIGINAL_LIMIT_MIN_VOTE_GENERAL_EXECUTIVE_DIRECTOR)                 .sorted(Comparator.comparing(CurrentLawVotesEndBalance::getVoteGeneralExecutiveDirector))                 .collect(Collectors.toList());          //голос верховного судьи         List<CurrentLawVotesEndBalance> electedByHightJudge = electedByCorporateCouncilOfReferees.stream()                 .filter(t -> directors.isElectedBYCorporateCouncilOfReferees(t.getPackageName()))                 .filter(t -> t.getVoteHightJudge() >= Seting.ORIGINAL_LIMIT_MIN_VOTE_HIGHT_JUDGE)                 .collect(Collectors.toList());           //законы которые получили не достаточно голосов которые могут пройти только если верховный судья одобрет         List<CurrentLawVotesEndBalance> notEnoughVotes = current.stream()                 .filter(t -> !directors.contains(t.getPackageName()))                 .filter(t->!Seting.AMENDMENT_TO_THE_CHARTER.equals(t.getPackageName()))                 .filter(t->!directors.isCabinets(t.getPackageName()))                 .filter(t -> !Seting.ORIGINAL_CHARTER_CURRENT_LAW_PACKAGE_NAME.equals(t.getPackageName()))                 .filter(t->!Seting.ORIGINAL_CHARTER_CURRENT_ALL_CODE.equals(t.getPackageName()))                 .filter(t -> t.getVotesBoardOfShareholders() >= Seting.ORIGINAL_LIMIT_MIN_VOTE_BOARD_OF_SHAREHOLDERS)                 .filter(t -> t.getVotesBoardOfDirectors() >= Seting.ORIGINAL_LIMIT_MIN_VOTE_BOARD_OF_DIRECTORS)                 .filter(t -> t.getVoteHightJudge() >= Seting.ORIGINAL_LIMIT_MIN_VOTE_HIGHT_JUDGE)                 .sorted(Comparator.comparing(CurrentLawVotesEndBalance::getVotes).reversed()).collect(Collectors.toList());           //законы которые получили достаточно голосов и не требуют одобрения верховного судьи         List<CurrentLawVotesEndBalance> powerfulVotes = current.stream()                 .filter(t -> !directors.contains(t.getPackageName()))                 .filter(t-> !Seting.AMENDMENT_TO_THE_CHARTER.equals(t.getPackageName()))                 .filter(t-> !directors.isCabinets(t.getPackageName()))                 .filter(t -> !Seting.ORIGINAL_CHARTER_CURRENT_LAW_PACKAGE_NAME.equals(t.getPackageName()))                 .filter(t->!Seting.ORIGINAL_CHARTER_CURRENT_ALL_CODE.equals(t.getPackageName()))                 .filter(t -> t.getVotesBoardOfShareholders() >= (Seting.ORIGINAL_LIMIT_MIN_VOTE_BOARD_OF_SHAREHOLDERS * Seting.POWERFUL_VOTE))                 .filter(t -> t.getVotesBoardOfDirectors() >= (Seting.ORIGINAL_LIMIT_MIN_VOTE_BOARD_OF_DIRECTORS * Seting.POWERFUL_VOTE))                 .sorted(Comparator.comparing(CurrentLawVotesEndBalance::getVotes).reversed()).collect(Collectors.toList());          //удаление совпадающих голосов         notEnoughVotes.addAll(powerfulVotes);         notEnoughVotes = notEnoughVotes.stream().distinct().collect(Collectors.toList());          //внедрение поправок в устав         List<CurrentLawVotesEndBalance> chapter_amendment = current.stream()                 .filter(t -> !directors.contains(t.getPackageName()))                 .filter(t-> Seting.AMENDMENT_TO_THE_CHARTER.equals(t.getPackageName()))                 .filter(t->!directors.isCabinets(t.getPackageName()))                 .filter(t -> t.getVotesBoardOfShareholders() >= Seting.ORIGINAL_LIMIT_MINT_VOTE_BOARD_OF_SHAREHOLDERS_AMENDMENT)                 .filter(t -> t.getVotesBoardOfDirectors() >= Seting.ORIGINAL_LIMIT_MIN_VOTE_BOARD_OF_DIRECTORS_AMENDMENT)                 .filter(t -> t.getVotesCorporateCouncilOfReferees() >= Seting.ORIGINAL_LIMIT_MIN_VOTE_CORPORATE_COUNCIL_OF_REFEREES_AMENDMENT)                 .sorted(Comparator.comparing(CurrentLawVotesEndBalance::getVotesBoardOfDirectors).reversed()).collect(Collectors.toList());          //бюджет утверждается только советом директоров.         List<CurrentLawVotesEndBalance> budjet = current.stream()                 .filter(t-> !directors.contains(t.getPackageName()))                 .filter(t->Seting.BUDGET.equals(t.getPackageName()))                 .filter(t->!directors.isCabinets(t.getPackageName()))                 .filter(t-> t.getVotesBoardOfDirectors() >= Seting.ORIGINAL_LIMIT_MIN_VOTE_BOARD_OF_DIRECTORS)                 .sorted(Comparator.comparing(CurrentLawVotesEndBalance::getVotesBoardOfDirectors).reversed())                 .limit(1)                 .collect(Collectors.toList());           //добавляет законы, которые создают новые должности директоров         List<CurrentLawVotesEndBalance> addDirectors = current.stream()                 .filter(t->t.getPackageName().startsWith(Seting.ADD_DIRECTOR))                 .filter(t->t.getVotesBoardOfDirectors() >= Seting.ORIGINAL_LIMIT_MIN_VOTE_BOARD_OF_DIRECTORS)                 .collect(Collectors.toList());          //план утверждается только палатой Советом Директоров         List<CurrentLawVotesEndBalance> planFourYears = current.stream()                 .filter(t->!directors.contains(t.getPackageName()))                 .filter(t->Seting.STRATEGIC_PLAN.equals(t.getPackageName()))                 .filter(t->!directors.isCabinets(t.getPackageName()))                 .filter(t->t.getVotesBoardOfDirectors() >= Seting.ORIGINAL_LIMIT_MIN_VOTE_BOARD_OF_DIRECTORS)                 .sorted(Comparator.comparing(CurrentLawVotesEndBalance::getVotesBoardOfDirectors).reversed())                 .limit(1)                 .collect(Collectors.toList());           //устав всегда действующий он подписан основателем         List<CurrentLawVotesEndBalance> CHARTER_ORIGINAL = current.stream()                 .filter(t -> !directors.contains(t.getPackageName()) && Seting.ORIGINAL_CHARTER_CURRENT_LAW_PACKAGE_NAME.equals(t.getPackageName()))                 .filter(t->!directors.isCabinets(t.getPackageName()))                 .filter(t->t.getFounderVote()>=1)                 .sorted(Comparator.comparing(CurrentLawVotesEndBalance::getVotes).reversed())                 .limit(1)                 .collect(Collectors.toList());          //ИСХОДНЫЙ КОД СОЗДАННЫЙ ОСНОВАТЕЛЕМ         List<CurrentLawVotesEndBalance> CHARTER_ORIGINAL_CODE = current.stream()                 .filter(t -> !directors.contains(t.getPackageName()) && Seting.ORIGINAL_CHARTER_CURRENT_ALL_CODE.equals(t.getPackageName()))                 .filter(t->!directors.isCabinets(t.getPackageName()))                 .filter(t->t.getFounderVote()>=1)                 .sorted(Comparator.comparing(CurrentLawVotesEndBalance::getVotes).reversed())                 .limit(1)                 .collect(Collectors.toList());           int startBlock = 22000;         int finishBlock = 22300;         if(blockchain.sizeBlockhain() > finishBlock){             List<Block> blocksCharter = blockchain.subBlock(startBlock, finishBlock);             //учитывает отрезок блоков для выяснения подлиности устава             List<CurrentLawVotesEndBalance> charterBlocks = UtilsGovernment.filtersVotes(                     lawEligibleForParliamentaryApprovals,                     balances,                     boardOfShareholders,                     blocksCharter,                     Seting.LAW_YEAR_VOTE             );             List<CurrentLawVotesEndBalance> charterCheckBlock = charterBlocks.stream()                     .filter(t -> !directors.contains(t.getPackageName()) && Seting.ORIGINAL_CHARTER_CURRENT_LAW_PACKAGE_NAME.equals(t.getPackageName()))                     .filter(t->!directors.isCabinets(t.getPackageName()))                     .filter(t->t.getFounderVote()>=1)                     .sorted(Comparator.comparing(CurrentLawVotesEndBalance::getVotes).reversed())                     .limit(1)                     .collect(Collectors.toList());              CHARTER_ORIGINAL.addAll(charterCheckBlock);               List<CurrentLawVotesEndBalance> charterOriginalCode = charterBlocks.stream()                     .filter(t -> !directors.contains(t.getPackageName()) && Seting.ORIGINAL_CHARTER_CURRENT_ALL_CODE.equals(t.getPackageName()))                     .filter(t->!directors.isCabinets(t.getPackageName()))                     .filter(t->t.getFounderVote()>=1)                     .sorted(Comparator.comparing(CurrentLawVotesEndBalance::getVotes).reversed())                     .limit(1)                     .collect(Collectors.toList());              CHARTER_ORIGINAL_CODE.addAll(charterOriginalCode);         }           for (Map.Entry<Director, List<CurrentLawVotesEndBalance>> higherSpecialPositionsListMap : original_group.entrySet()) {             current.addAll(higherSpecialPositionsListMap.getValue());         }           current = new ArrayList<>();         current.addAll(addDirectors);         current.addAll(budjet);         current.addAll(planFourYears);         current.addAll(electedByStockBoardOfDirectors);         current.addAll(electedByStockCorporateCouncilOfReferees);         current.addAll(electedByBoardOfDirectors);         current.addAll(electedByCorporateCouncilOfReferees);         current.addAll(electedByGeneralExecutiveDirector);         current.addAll(electedByHightJudge);         current.addAll(notEnoughVotes);         current.addAll(CHARTER_ORIGINAL);         current.addAll(CHARTER_ORIGINAL_CODE);         current.addAll(chapter_amendment);         current = current.stream()                 .filter(UtilsUse.distinctByKey(CurrentLawVotesEndBalance::getAddressLaw))                 .collect(Collectors.toList());         System.out.println(\"notEnoughVotes: \" + notEnoughVotes);          model.addAttribute(\"title\", \"How the current laws are approved are described in the statute.\" +                 \" \");         model.addAttribute(\"currentLaw\", current);         return \"current-laws\";     }      @GetMapping(\"/all-laws\")     public String allLaws(Model model) throws IOException, NoSuchAlgorithmException, InvalidKeySpecException, SignatureException, NoSuchProviderException, InvalidKeyException {         Blockchain blockchain = Mining.getBlockchain(                 Seting.ORIGINAL_BLOCKCHAIN_FILE,                 BlockchainFactoryEnum.ORIGINAL);          Map<String, Account> balances = new HashMap<>();         balances = SaveBalances.readLineObject(Seting.ORIGINAL_BALANCE_FILE);           List<Account> boardOfShareholders = UtilsGovernment.findBoardOfShareholders(balances, blockchain.getBlockchainList(), Seting.BOARDS_BLOCK);           List<LawEligibleForParliamentaryApproval> lawEligibleForParliamentaryApprovals =                 UtilsLaws.readLineCurrentLaws(Seting.ORIGINAL_ALL_CORPORATION_LAWS_WITH_BALANCE_FILE);         //данные для отображения           Directors directors = new Directors();         //TODO доработать оптимизацию         //TODO избавиться от find position в данном методе         //TODO доработать оптимизацию         //TODO избавиться от find position в данном методе         Map<Director, FIndPositonHelperData> fIndPositonHelperDataMap = new HashMap<>();         for (Director higherSpecialPositions : directors.getDirectors()) {             if (higherSpecialPositions.isElectedByCEO()) {                 fIndPositonHelperDataMap.put(higherSpecialPositions,                         new FIndPositonHelperData(higherSpecialPositions, false, false, true, false, false));             } else if (higherSpecialPositions.isElectedByBoardOfDirectors()) {                 fIndPositonHelperDataMap.put(higherSpecialPositions,                         new FIndPositonHelperData(higherSpecialPositions, false, false, false, true, false));             } else if (higherSpecialPositions.isElectedByCorporateCouncilOfReferees()) {                 fIndPositonHelperDataMap.put(higherSpecialPositions,                         new FIndPositonHelperData(higherSpecialPositions, false, false, false, false, true));             } else if (higherSpecialPositions.isElectedByStocks()) {                 fIndPositonHelperDataMap.put(higherSpecialPositions,                         new FIndPositonHelperData(higherSpecialPositions, true, true, false, false, false));              }          }           List<CurrentLawVotesEndBalance> current = UtilsGovernment.filtersVotes(                 lawEligibleForParliamentaryApprovals,                 balances,                 boardOfShareholders,                 blockchain.getBlockchainList(),                 Seting.LAW_YEAR_VOTE);           current = current.stream().distinct().collect(Collectors.toList());          current = current.stream().sorted(Comparator.comparing(CurrentLawVotesEndBalance::getVotes).reversed()).collect(Collectors.toList());         model.addAttribute(\"allLaws\", current);         return \"all-laws\";     }       @GetMapping(\"/create-law\")     public String createLawsShow(Model model) {         return \"create-law\";     }       @RequestMapping(value = \"/create-law\", method = RequestMethod.POST, params = \"action=/send\")     public String createLaw(Model model,                             @RequestParam String sender,                             @RequestParam String reward,                             @RequestParam String nameLaw,                             @RequestParam String[] laws,                             @RequestParam String password,                             RedirectAttributes redirectAttrs) throws IOException, NoSuchAlgorithmException, SignatureException, NoSuchProviderException, InvalidKeyException, InvalidKeySpecException {           Laws law = new Laws(nameLaw, Arrays.asList(laws));         Base base = new Base58();          Double rewardD = Double.parseDouble(reward);           DtoTransaction dtoTransaction = new DtoTransaction(                 sender,                 law.getHashLaw(),                 0.0,                 0.0,                 law,                 rewardD,                 VoteEnum.valueOf(\"YES\"));         PrivateKey privateKey = UtilsSecurity.privateBytToPrivateKey(base.decode(password));         byte[] sign = UtilsSecurity.sign(privateKey, dtoTransaction.toSign());          redirectAttrs.addFlashAttribute(\"title\", \"sending result!!!\");         redirectAttrs.addFlashAttribute(\"sender\", sender);          redirectAttrs.addFlashAttribute(\"recipient\", law.getHashLaw());         redirectAttrs.addFlashAttribute(\"dollar\", 0.0);         redirectAttrs.addFlashAttribute(\"stock\", 0.0);         redirectAttrs.addFlashAttribute(\"reward\", rewardD);         redirectAttrs.addFlashAttribute(\"vote\", \"YES\");         dtoTransaction.setSign(sign);          Directors directors = new Directors();         if (dtoTransaction.verify()) {              //если в названия закона совпадает с корпоративными должностями, то закон является действительным только когда             //отправитель совпадает с законом             List<Director> enumPosition = directors.getDirectors();             List<String> corporateSeniorPositions = enumPosition.stream()                     .map(t->t.getName())                     .collect(Collectors.toList());              if (corporateSeniorPositions.contains(law.getPacketLawName()) && !UtilsGovernment.checkPostionSenderEqualsLaw(sender, law)) {                 redirectAttrs.addFlashAttribute(\"sending\", \"wrong transaction: Position to be equals whith send\");                 return \"redirect:/result-sending\";             }              redirectAttrs.addFlashAttribute(\"sending\", \"success\");             AllTransactions.addTransaction(dtoTransaction);             String jsonDto = UtilsJson.objToStringJson(dtoTransaction);              for (String s : Seting.ORIGINAL_ADDRESSES) {                 String original = s;                 String url = s + \"/addTransaction\";                 if (BasisController.getExcludedAddresses().contains(url)) {                     System.out.println(\"its your address or excluded address: \" + url);                     continue;                 }                 try {                     UtilUrl.sendPost(jsonDto, url);                  } catch (Exception e) {                     System.out.println(\"exception discovery: \" + original);                  }             }         } else             redirectAttrs.addFlashAttribute(\"sending\", \"wrong transaction\");          return \"redirect:/result-sending\";      }  }","package International_Trade_Union.controllers;  import International_Trade_Union.about_us_engDraft.AboutUsEngDraft; import International_Trade_Union.governments.Director; import International_Trade_Union.governments.Directors; import International_Trade_Union.governments.UtilsGovernment; import International_Trade_Union.originalCorporateCharter.OriginalPreamble; import International_Trade_Union.originalCorporateCharter.OriginalPreambleEng;  import org.springframework.http.HttpStatus; import org.springframework.http.ResponseEntity; import org.springframework.stereotype.Controller; import org.springframework.ui.Model; import org.springframework.web.bind.annotation.GetMapping; import org.springframework.web.bind.annotation.PostMapping; import org.springframework.web.bind.annotation.RequestParam; import org.springframework.web.servlet.mvc.support.RedirectAttributes; import International_Trade_Union.entity.DtoTransaction.DtoTransaction; import International_Trade_Union.model.Account; import International_Trade_Union.model.User; import International_Trade_Union.network.AllTransactions; import International_Trade_Union.setings.Seting; import International_Trade_Union.utils.*; import International_Trade_Union.utils.base.Base; import International_Trade_Union.utils.base.Base58; import International_Trade_Union.vote.Laws; import International_Trade_Union.vote.VoteEnum;   import java.io.IOException; import java.net.http.WebSocket; import java.security.*; import java.security.spec.InvalidKeySpecException; import java.util.*; import java.util.stream.Collectors;  @Controller public class MainController {      @GetMapping(\"/\")     public String home(Model model) throws IOException, NoSuchAlgorithmException, InvalidKeySpecException, SignatureException, NoSuchProviderException, InvalidKeyException {         model.addAttribute(\"title\", \"Corporation International Trade Union.\");         Map<String, Account> balances = new HashMap<>(); //        Blockchain blockchain = BLockchainFactory.getBlockchain(BlockchainFactoryEnum.ORIGINAL);          //догрузить блокчейн //        List<Block> blocks = UtilsBlock.readLineObject(Seting.ORIGINAL_BLOCKCHAIN_FILE); //        balances = UtilsBalance.calculateBalances(blocks);         balances = SaveBalances.readLineObject(Seting.ORIGINAL_BALANCE_FILE);           Account account = UtilsBalance.getBalance(User.getUserAddress(), balances);         model.addAttribute(\"account\", account);          return \"home\";     }      @PostMapping(\"/setMinner\")     public ResponseEntity<String> setMinnerAddress(@RequestParam(value = \"setMinner\") String setMinner, RedirectAttributes redirectAttrs){         System.out.println(\"MainController:  \" + setMinner);         UtilsFileSaveRead.save(setMinner, Seting.ORIGINAL_ACCOUNT, false);         return new ResponseEntity<>(\"change address: \" + setMinner, HttpStatus.OK);     }        @GetMapping(\"about\")     public String aboutUs(Model model){         model.addAttribute(\"title\", \"ABOUT US\");         model.addAttribute(\"eng\", OriginalPreambleEng.ARTICLE_0);         model.addAttribute(\"rus\", OriginalPreamble.ARTICLE_0);         return \"about\";     }     @GetMapping(\"result-sending\")     public String resultSending(Model model){          return \"result-sending\";     }      @PostMapping(\"/\")     public String new_transaction(             @RequestParam  String sender,             @RequestParam  String recipient,                                    Double dollar,                                    Double stock,                                    Double reward,                                   @RequestParam  String vote,                                   @RequestParam  String password,                                   RedirectAttributes redirectAttrs) throws IOException, NoSuchAlgorithmException, SignatureException, InvalidKeySpecException, NoSuchProviderException, InvalidKeyException {         Base base = new Base58();         vote = vote.toUpperCase(Locale.ROOT);         Laws laws =  new Laws();         laws.setLaws(new ArrayList<>());         laws.setHashLaw(\"\");         laws.setPacketLawName(\"\");         DtoTransaction dtoTransaction = new DtoTransaction(                 sender,                 recipient,                 dollar,                 stock,                 laws,                 reward,                 VoteEnum.valueOf(vote));         PrivateKey privateKey = UtilsSecurity.privateBytToPrivateKey(base.decode(password));         byte[] sign = UtilsSecurity.sign(privateKey, dtoTransaction.toSign());         System.out.println(\"Main Controller: new transaction: vote: \" + vote);         redirectAttrs.addFlashAttribute(\"title\", \"sending result!!!\");         redirectAttrs.addFlashAttribute(\"sender\", sender);         redirectAttrs.addFlashAttribute(\"recipient\", recipient);         redirectAttrs.addFlashAttribute(\"dollar\", dollar);         redirectAttrs.addFlashAttribute(\"stock\", stock);         redirectAttrs.addFlashAttribute(\"reward\", reward);         redirectAttrs.addFlashAttribute(\"vote\", vote);         dtoTransaction.setSign(sign);         Directors directors = new Directors();         if(dtoTransaction.verify()){              //если в названия закона совпадает с корпоративными должностями, то закон является действительным только когда             //отправитель совпадает с законом             List<Director> enumPosition = directors.getDirectors();             List<String> corporateSeniorPositions = directors.getDirectors().stream()                     .map(t->t.getName()).collect(Collectors.toList());             System.out.println(\"LawsController: create_law: \" + laws.getPacketLawName() + \"contains: \" + corporateSeniorPositions.contains(laws.getPacketLawName()));             if(corporateSeniorPositions.contains(laws.getPacketLawName()) && !UtilsGovernment.checkPostionSenderEqualsLaw(sender, laws)){                 redirectAttrs.addFlashAttribute(\"sending\", \"wrong transaction: Position to be equals whith send\");                 return \"redirect:/result-sending\";             }             redirectAttrs.addFlashAttribute(\"sending\", \"success\");             System.out.println(\"dto MainController: \" + dtoTransaction);              AllTransactions.addTransaction(dtoTransaction);             String jsonDto = UtilsJson.objToStringJson(dtoTransaction);             for (String s : Seting.ORIGINAL_ADDRESSES) {                  String original = s;                 String url = s +\"/addTransaction\";                 if(BasisController.getExcludedAddresses().contains(url)){                     System.out.println(\"MainController: its your address or excluded address: \" + url);                     continue;                 }                 try {                     UtilUrl.sendPost(jsonDto, url);                  }catch (Exception e){                     System.out.println(\"exception discover: \" + original);                  }             }            }          else             redirectAttrs.addFlashAttribute(\"sending\", \"wrong transaction\");         return \"redirect:/result-sending\";     }   }","package International_Trade_Union.controllers;  import International_Trade_Union.entity.DtoTransaction.DtoTransaction; import International_Trade_Union.network.AllTransactions; import org.springframework.http.MediaType; import org.springframework.web.bind.annotation.RequestBody; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RequestMethod; import org.springframework.web.bind.annotation.RestController;  import java.io.IOException; import java.security.InvalidKeyException; import java.security.NoSuchAlgorithmException; import java.security.NoSuchProviderException; import java.security.SignatureException; import java.security.spec.InvalidKeySpecException;  @RestController public class TransactionController {     @RequestMapping(method = RequestMethod.POST, value = \"/addTransaction\", consumes = MediaType.APPLICATION_JSON_VALUE)     public  void add(@RequestBody DtoTransaction data) throws IOException, NoSuchAlgorithmException, SignatureException, InvalidKeySpecException, NoSuchProviderException, InvalidKeyException {         System.out.println(\"add transaction: \" + data);         AllTransactions.getInstance();         AllTransactions.addTransaction(data);         System.out.println(\"TransactionController: add: \" + AllTransactions.getInstance().size());     }  }","package International_Trade_Union.entity.blockchain.block;  import International_Trade_Union.entity.DtoTransaction.DtoTransaction; import International_Trade_Union.exception.NotValidTransactionException; import International_Trade_Union.utils.UtilsJson; import International_Trade_Union.utils.UtilsUse; import com.fasterxml.jackson.annotation.JsonAutoDetect;  import lombok.Data;  import java.io.IOException; import java.security.InvalidKeyException; import java.security.NoSuchAlgorithmException; import java.security.NoSuchProviderException; import java.security.SignatureException; import java.security.spec.InvalidKeySpecException; import java.sql.Timestamp; import java.util.List; import java.util.Objects;  @JsonAutoDetect @Data public final class Block implements Cloneable {     private List<DtoTransaction> dtoTransactions;     private String previousHash;     private String minerAddress;     private String founderAddress;     private long randomNumberProof;     private double minerRewards;     private int hashCompexity;     private Timestamp timestamp;     private long index;     private String hashBlock;      public Block(List<DtoTransaction> dtoTransactions,  String previousHex, String minerAddress, String founderAddress, int hashCompexity, long index) throws IOException, NoSuchAlgorithmException, SignatureException, NoSuchProviderException, InvalidKeyException, InvalidKeySpecException {         this.dtoTransactions = dtoTransactions;         this.previousHash = previousHex;         this.minerAddress = minerAddress;         this.minerRewards = miningRewardsCount();         this.hashCompexity = hashCompexity;         this.founderAddress = founderAddress;         this.timestamp = new Timestamp(System.currentTimeMillis());         this.index = index;         this.hashBlock = findHash(hashCompexity);      }      public Block(List<DtoTransaction> dtoTransactions, String previousHash, String minerAddress, String founderAddress, long randomNumberProof, double minerRewards, int hashCompexity, Timestamp timestamp, long index, String hashBlock) {         this.dtoTransactions = dtoTransactions;         this.previousHash = previousHash;         this.minerAddress = minerAddress;         this.founderAddress = founderAddress;         this.randomNumberProof = randomNumberProof;         this.minerRewards = minerRewards;         this.hashCompexity = hashCompexity;         this.timestamp = timestamp;         this.index = index;         this.hashBlock = hashBlock;     }      @JsonAutoDetect     @Data     private class BlockForHash{         private List<DtoTransaction> transactions;         private String previousHash;         private String minerAddress;         private String founderAddress;         private long randomNumberProof;         private double minerRewards;         private int hashCompexity;         private Timestamp timestamp;         private long index;           public BlockForHash() {         }           public BlockForHash(List<DtoTransaction> transactions,                             String previousHash,                             String minerAddress,                             String founderAddress,                             long randomNumberProof,                             double minerRewards,                             int hashCompexity,                             Timestamp timestamp,                             long index) {             this.transactions = transactions;             this.previousHash = previousHash;             this.minerAddress = minerAddress;             this.founderAddress = founderAddress;             this.randomNumberProof = randomNumberProof;             this.minerRewards = minerRewards;             this.hashCompexity = hashCompexity;             this.timestamp = timestamp;             this.index = index;          }         private String hashesAllTrans() throws IOException {             String hash = \"\";             for (DtoTransaction dtoTransaction : dtoTransactions) {                 hash += dtoTransaction.hashForBlock();             }              return hash;          }          public String hashForTransaction() throws IOException {             return UtilsUse.sha256hash(jsonString());         }          public String jsonString() throws IOException {             return UtilsJson.objToStringJson(this);         }     }      public Block() {     }      public String hashForBlockchain()             throws             IOException{         return this.hashBlock;     }       public boolean verifyesTransSign() throws IOException, NoSuchAlgorithmException, SignatureException, NoSuchProviderException, InvalidKeyException, InvalidKeySpecException {         for (DtoTransaction dtoTransaction : dtoTransactions) {             if(!dtoTransaction.verify())                 return false;         }         return true;     }      private double miningRewardsCount(){         double rewards = 0.0;         for (DtoTransaction dtoTransaction : dtoTransactions) {              rewards += dtoTransaction.getBonusForMiner();         }          return rewards;     }      public String jsonString() throws IOException {         return UtilsJson.objToStringJson(this);     }     //TODO     public String findHash(int hashCoplexity) throws IOException, NoSuchAlgorithmException, SignatureException, NoSuchProviderException, InvalidKeyException, InvalidKeySpecException {         if (!verifyesTransSign()){             throw new NotValidTransactionException();         }          this.randomNumberProof = 0;         String hash = \"\";         while (true){             this.randomNumberProof++;             BlockForHash block = new BlockForHash(this.dtoTransactions,                     this.previousHash, this.minerAddress, this.founderAddress,                     this.randomNumberProof, this.minerRewards, this.hashCompexity, this.timestamp, this.index);             hash = block.hashForTransaction();             if(UtilsUse.hashComplexity(hash.substring(0, hashCoplexity), hashCoplexity))             {                 break;             }          }         return hash;     }      @Override     public boolean equals(Object o) {           if (this == o) return true;         if (!(o instanceof Block)) return false;         Block block = (Block) o;         return getRandomNumberProof() == block.getRandomNumberProof() && Double.compare(block.getMinerRewards(), getMinerRewards()) == 0 && getHashCompexity() == block.getHashCompexity() && getIndex() == block.getIndex() && Objects.equals(getDtoTransactions(), block.getDtoTransactions()) && Objects.equals(getPreviousHash(), block.getPreviousHash()) && Objects.equals(getMinerAddress(), block.getMinerAddress()) && Objects.equals(getFounderAddress(), block.getFounderAddress()) && Objects.equals(getTimestamp(), block.getTimestamp()) && Objects.equals(getHashBlock(), block.getHashBlock());     }      @Override     public int hashCode() {         return Objects.hash(getDtoTransactions(), getPreviousHash(), getMinerAddress(), getFounderAddress(), getRandomNumberProof(), getMinerRewards(), getHashCompexity(), getTimestamp(), getIndex(), getHashBlock());     }      @Override     public Block clone() throws CloneNotSupportedException {         return new Block(this.dtoTransactions, this.previousHash, this.minerAddress, this.founderAddress,                 this.randomNumberProof, this.minerRewards, this.hashCompexity, this.timestamp, this.index,                 this.hashBlock);     } }","package International_Trade_Union.entity.blockchain;  import International_Trade_Union.entity.DtoTransaction.DtoTransaction; import International_Trade_Union.entity.blockchain.block.Block; import International_Trade_Union.setings.Seting; import International_Trade_Union.utils.UtilsBlock; import International_Trade_Union.utils.UtilsJson; import International_Trade_Union.utils.UtilsSecurity; import International_Trade_Union.utils.UtilsUse; import International_Trade_Union.utils.base.Base; import International_Trade_Union.utils.base.Base58; import International_Trade_Union.vote.Laws; import International_Trade_Union.vote.VoteEnum; import com.fasterxml.jackson.annotation.JsonAutoDetect;  import lombok.Data;  import java.io.IOException; import java.security.*; import java.security.spec.InvalidKeySpecException; import java.util.ArrayList; import java.util.List; import java.util.Objects;   @JsonAutoDetect @Data public class Blockchain implements Cloneable{     private List<Block> blockchainList;     //как часто должно создаваться блок в миллисекундах 1000 миллисекунд = 1 секунд     private long BLOCK_GENERATION_INTERVAL;     //каждые сколько блоков должен происходить перерасчет сложности     private int DIFFICULTY_ADJUSTMENT_INTERVAL;     //блок действителен, если значение блока меньше данного занчения в миллисекунда     private long INTERVAL_TARGET;     private String ADDRESS_FOUNDER;     public int sizeBlockhain(){          return blockchainList.size();     }      public void setBlockchainList(List<Block> blockchainList) throws IOException, NoSuchAlgorithmException, InvalidKeySpecException, SignatureException, NoSuchProviderException, InvalidKeyException {         this.blockchainList = blockchainList;      }      public Blockchain(long BLOCK_GENERATION_INTERVAL, int DIFFICULTY_ADJUSTMENT_INTERVAL, long INTERVAL_TARGET, String ADDRESS_FOUNDER) throws NoSuchAlgorithmException, InvalidKeySpecException, NoSuchProviderException, IOException, SignatureException, InvalidKeyException {         this(new ArrayList<>(), BLOCK_GENERATION_INTERVAL, DIFFICULTY_ADJUSTMENT_INTERVAL, INTERVAL_TARGET, ADDRESS_FOUNDER);      }     public Blockchain(List<Block> blockchainList, long BLOCK_GENERATION_INTERVAL, int DIFFICULTY_ADJUSTMENT_INTERVAL, long INTERVAL_TARGET,String ADDRESS_FOUNDER) throws IOException, NoSuchAlgorithmException, InvalidKeySpecException, SignatureException, NoSuchProviderException, InvalidKeyException {         this.blockchainList = blockchainList;         this.BLOCK_GENERATION_INTERVAL = BLOCK_GENERATION_INTERVAL;         this.DIFFICULTY_ADJUSTMENT_INTERVAL = DIFFICULTY_ADJUSTMENT_INTERVAL;         this.INTERVAL_TARGET = INTERVAL_TARGET;         this.ADDRESS_FOUNDER = ADDRESS_FOUNDER;         Block block = genesisBlock();         addBlock(block);     }      public void addBlock(Block newBlock) throws IOException, NoSuchAlgorithmException, SignatureException, InvalidKeySpecException, NoSuchProviderException, InvalidKeyException { //        if(blockchainList.size() > 2){ //            boolean time = UtilsBlock.isValidTimestamp(blockchainList.get(blockchainList.size()-1), newBlock, INTERVAL_TARGET); //            if(!time){ //                System.out.println(\"time out block add \" + time); //               return; //            } //        }         blockchainList.add(newBlock);       }      public Block genesisBlock() throws IOException, NoSuchAlgorithmException, InvalidKeySpecException, NoSuchProviderException, SignatureException, InvalidKeyException {         Base base = new Base58();         //dto sign         //pub byte keys         //transactions         List<DtoTransaction> transactions = new ArrayList<>();          DtoTransaction gold = new DtoTransaction(Seting.BASIS_ADDRESS, ADDRESS_FOUNDER,                 Seting.FOUNDERS_REMUNERATION_DIGITAL_DOLLAR, Seting.FOUNDERS_REMNUNERATION_DIGITAL_STOCK, new Laws(), 0.0, VoteEnum.YES);         PrivateKey privateKey = UtilsSecurity.privateBytToPrivateKey(base.decode(Seting.BASIS_PASSWORD));         byte[] signGold = UtilsSecurity.sign(privateKey, gold.toSign());         gold.setSign(signGold);         transactions.add(gold);          String genesisHash = genesisPrevHash();         Block block = new Block(transactions,  genesisHash, ADDRESS_FOUNDER, ADDRESS_FOUNDER,  Seting.HASH_COMPLEXITY_GENESIS, blockchainList.size());         return block;     }        public String genesisPrevHash() throws IOException {         return UtilsUse.hashComplexityStr(Seting.CORPORATE_CHARTER_DRAFT, Seting.HASH_COMPLEXITY_GENESIS);     }      public String getHashBlock(int index) throws IOException {         return blockchainList.get(index).hashForBlockchain();     }     public Block getBlock(int index){         return blockchainList.get(index);     }        public boolean validatedBlockchain() throws IOException, NoSuchAlgorithmException, SignatureException, InvalidKeySpecException, NoSuchProviderException, InvalidKeyException {        return UtilsBlock.validation(blockchainList, BLOCK_GENERATION_INTERVAL, DIFFICULTY_ADJUSTMENT_INTERVAL);     }      public String jsonString() throws IOException {         return UtilsJson.objToStringJson(blockchainList);     }     @Override     public boolean equals(Object o) {         if (this == o) return true;         if (!(o instanceof Blockchain)) return false;         Blockchain that = (Blockchain) o;         return getBlockchainList().equals(that.getBlockchainList());     }      @Override     public int hashCode() {         return Objects.hash(getBlockchainList());     }      public  List<Block> subBlock(int startIndex, int finishIndex) throws CloneNotSupportedException {         List<Block> temporary = this.getBlockchainList().subList(startIndex, finishIndex);         List<Block> result = new ArrayList<>();         for (Block block : temporary) {             result.add(block.clone());         }         return result;     }       @Override     public List<Block> clone() throws CloneNotSupportedException {         List<Block> result = new ArrayList<>();         for (Block block : blockchainList) {             result.add(block.clone());         }         return result;      } }","package International_Trade_Union.entity.DtoTransaction;  import org.bouncycastle.jcajce.provider.asymmetric.ec.BCECPublicKey; import International_Trade_Union.setings.Seting; import International_Trade_Union.utils.UtilsJson; import International_Trade_Union.utils.UtilsSecurity; import International_Trade_Union.utils.UtilsUse; import International_Trade_Union.utils.base.Base; import International_Trade_Union.utils.base.Base58; import International_Trade_Union.vote.Laws; import International_Trade_Union.vote.VoteEnum; import com.fasterxml.jackson.annotation.JsonAutoDetect;  import lombok.Data;   import java.io.IOException; import java.security.*; import java.security.spec.InvalidKeySpecException; import java.util.Arrays; import java.util.Objects;   @JsonAutoDetect @Data public class DtoTransaction {     private String sender;     private String customer;     private double digitalDollar;     private double digitalStockBalance;     private Laws laws;     private double bonusForMiner;     private VoteEnum voteEnum;     private byte[] sign;        public DtoTransaction(String sender, String customer, double digitalDollar, double digitalStockBalance, Laws laws, double bonusForMiner, VoteEnum voteEnum) {         this.sender = sender;         this.customer = customer;         this.digitalDollar = digitalDollar;         this.digitalStockBalance = digitalStockBalance;         this.laws = laws;         this.bonusForMiner = bonusForMiner;         this.voteEnum = voteEnum;     }      public DtoTransaction() {     }      //TODO возможно стоит перевести проверку подписи в отдельный utils, под вопросом!!     public boolean verify() throws IOException, NoSuchAlgorithmException, SignatureException, NoSuchProviderException, InvalidKeyException, InvalidKeySpecException {         Base base = new Base58();         byte[] pub = base.decode(sender);         BCECPublicKey publicKey = (BCECPublicKey) UtilsSecurity.decodeKey(pub); //        PublicKey publicKey = UtilsSecurity.publicByteToPublicKey(pub);         String sha = sender + customer + digitalDollar + digitalStockBalance + laws + bonusForMiner;         sha = UtilsUse.sha256hash(sha);         if(sender.isBlank() || customer.isBlank() || digitalDollar < 0 || digitalStockBalance < 0 || bonusForMiner < 0 || laws == null){             System.out.println(\"wrong dto transaction sender or customer blank? or dollar, reputation or reward less then 0\");             return false;         }         if(Seting.BASIS_ADDRESS.equals(publicKey))             return true;         return UtilsSecurity.verify(sha, sign, publicKey);     }      public String toSign(){         String sha = sender + customer + digitalDollar + digitalStockBalance + laws + bonusForMiner;         return UtilsUse.sha256hash(sha);     }      public String hashForBlock() throws IOException {         return UtilsUse.sha256hash(jsonString());     }      public String jsonString() throws IOException {         return UtilsJson.objToStringJson(this);     }      @Override     public boolean equals(Object o) {         if (this == o) return true;         if (!(o instanceof DtoTransaction)) return false;         DtoTransaction that = (DtoTransaction) o;         return Double.compare(that.getDigitalDollar(), getDigitalDollar()) == 0 && Double.compare(that.getDigitalStockBalance(), getDigitalStockBalance()) == 0 && Double.compare(that.getBonusForMiner(), getBonusForMiner()) == 0 && getSender().equals(that.getSender()) && getCustomer().equals(that.getCustomer()) && getLaws().equals(that.getLaws()) && getVoteEnum() == that.getVoteEnum() && Arrays.equals(getSign(), that.getSign());     }      @Override     public int hashCode() {         int result = Objects.hash(getSender(), getCustomer(), getDigitalDollar(), getDigitalStockBalance(), getLaws(), getBonusForMiner(), getVoteEnum());         result = 31 * result + Arrays.hashCode(getSign());         return result;     } }","package International_Trade_Union.entity;  import lombok.Data;  @Data public class AddressUrl {     private String address;      public AddressUrl() {     }      public AddressUrl(String address) {         this.address = address;     } }","package International_Trade_Union.entity;   import lombok.Data; import International_Trade_Union.entity.blockchain.block.Block;  import java.util.List;  @Data public class EntityChain {      private int size;     private List<Block> blocks;      public EntityChain() {     }      public EntityChain(int sizeBlockhain, List<Block> blockchainList) {         this.size = sizeBlockhain;         this.blocks = blockchainList;     } }","package International_Trade_Union.entity;   import lombok.Data; import International_Trade_Union.entity.blockchain.Blockchain; import International_Trade_Union.entity.blockchain.block.Block; import International_Trade_Union.model.Account;  import java.util.List; import java.util.Map;  @Data public class ResultMiningData {     private Map<String, Account> balance;     private Blockchain blockchain;     private Block miningBlock;     private List<Block> lastBlock;     private Account governments;  }","package International_Trade_Union.entity;  import lombok.Data;  @Data public class SubBlockchainEntity {     private int start;     private int finish;      public SubBlockchainEntity(int start, int finish) {         this.start = start;         this.finish = finish;     }      public SubBlockchainEntity() {     } }","package International_Trade_Union.exception;  import java.io.IOException;  public class NotValidTransactionException extends IOException { }","package International_Trade_Union.governments;   import International_Trade_Union.model.Account;  public class CompareObject {      public int compare(Account o1, Account o2) {         double x1 = o1.getDigitalStockBalance();         double x2 = o2.getDigitalStockBalance();         int power = Double.compare(x1, x2);         if (power != 0)             return power;         double gold1 = o1.getDigitalDollarBalance();         double gold2 = o2.getDigitalDollarBalance();         int gold = Double.compare(gold1, gold2);         if(gold != 0)             return gold;         double first = x1 + gold1;         double second = x2 + gold2;         return Double.compare(first, second);     }      @Override     public boolean equals(Object obj) {         return false;     } }","package International_Trade_Union.governments;  import lombok.AllArgsConstructor; import lombok.Data; import lombok.NoArgsConstructor;  import java.util.Arrays; import java.util.List; import java.util.Locale; import java.util.Objects; import java.util.stream.Collectors;  @Data @NoArgsConstructor @AllArgsConstructor public class Director {     //количество юридических или физических лиц в данной должности     //количество юридических или физических лиц в данной должности     private String name;     private  int count;      private boolean electedByCEO;     private boolean electedByBoardOfDirectors;       private boolean electedByCorporateCouncilOfReferees;     private boolean electedByStocks;     private boolean officeOfDirectors;       @Override     public boolean equals(Object o) {         if (this == o) return true;         if (!(o instanceof Director)) return false;         Director director = (Director) o;         return getName().equals(director.getName());     }      @Override     public int hashCode() {         return Objects.hash(getName());     }      public boolean isAppointedByTheGovernment(){         if(electedByCEO || electedByBoardOfDirectors || electedByCorporateCouncilOfReferees)             return true;         else return false;     }     public int getCount() {         return count;     }     }","package International_Trade_Union.governments;  import International_Trade_Union.setings.Seting; import International_Trade_Union.utils.UtilsUse; import lombok.Data;  import java.util.ArrayList; import java.util.List; import java.util.Locale; import java.util.stream.Collectors;  @Data  public class Directors {     public Directors() {          directors = new ArrayList<>();         Director CORPORATE_COUNCIL_OF_REFEREES = new Director(\"CORPORATE_COUNCIL_OF_REFEREES\", 55, false, false, false, true, false);         Director BOARD_OF_DIRECTORS = new Director(\"BOARD_OF_DIRECTORS\", 301, false, false, false, true, false);          Director GENERAL_EXECUTIVE_DIRECTOR = new Director(\"GENERAL_EXECUTIVE_DIRECTOR\", 1, false, true, false, false, true);         Director HIGH_JUDGE = new Director(\"HIGH_JUDGE\",1, false, false, true, false, false);          Director INTERNET_STORE_DIRECTOR = new Director(\"INTERNET_STORE_DIRECTOR\",1, false, true, false, false, true);         Director DIRECTOR_OF_THE_DIGITAL_EXCHANGE = new Director(\"DIRECTOR_OF_THE_DIGITAL_EXCHANGE\",1, false, true, false, false, true);         Director DIRECTOR_OF_DIGITAL_BANK = new Director(\"DIRECTOR_OF_DIGITAL_BANK\",1, false, true, false, false, true);         Director DIRECTOR_OF_THE_COMMERCIAL_COURT = new Director(\"DIRECTOR_OF_THE_COMMERCIAL_COURT\",1, false, true, false, false, true);         Director MEDIA_DIRECTOR = new Director(\"MEDIA_DIRECTOR\",1, false, true, false, false, true);         Director DIRECTOR_OF_THE_DEVELOPMENT_OF_THE_IMPLEMENTATION_OF_CRYPTOCURRENCY_TECHNOLOGIES_OF_THE_INTERNATIONAL_TRADE_UNION_CORPORATION = new Director(\"DIRECTOR_OF_THE_DEVELOPMENT_OF_THE_IMPLEMENTATION_OF_CRYPTOCURRENCY_TECHNOLOGIES_OF_THE_INTERNATIONAL_TRADE_UNION_CORPORATION\",1, false, true, false, false, true);          directors.add(CORPORATE_COUNCIL_OF_REFEREES);         directors.add(BOARD_OF_DIRECTORS);          directors.add(GENERAL_EXECUTIVE_DIRECTOR);         directors.add(HIGH_JUDGE);          directors.add(INTERNET_STORE_DIRECTOR);         directors.add(DIRECTOR_OF_THE_DIGITAL_EXCHANGE);         directors.add(DIRECTOR_OF_DIGITAL_BANK);         directors.add(DIRECTOR_OF_THE_COMMERCIAL_COURT);         directors.add(MEDIA_DIRECTOR);         directors.add(DIRECTOR_OF_THE_DEVELOPMENT_OF_THE_IMPLEMENTATION_OF_CRYPTOCURRENCY_TECHNOLOGIES_OF_THE_INTERNATIONAL_TRADE_UNION_CORPORATION);     }       public Director getDirector(String str){        List<Director> director = directors                .stream()                .filter(t->t.getName().equals(str))                .collect(Collectors.toList());        return director.get(0);      }     private List<Director> directors;      public boolean contains(String str) {         str = str.toUpperCase();         directors = directors.stream().filter(UtilsUse.distinctByKey(Director::getName)).collect(Collectors.toList());         List<String> strings = directors.stream().map(t->t.getName()).collect(Collectors.toList());        return strings.contains(str);     }      public boolean isCabinets(String str) {         List<String> list = directors.stream()                 .filter(t->t.isOfficeOfDirectors())                 .filter(UtilsUse.distinctByKey(Director::getName))                 .map(t->t.getName())                 .collect(Collectors.toList());         return list.contains(str.toUpperCase(Locale.ROOT));     }       //должности которые добавляются только советом директоров     public void addByBoardOfDirectors(String str) {         if (str.startsWith(Seting.ADD_DIRECTOR)) {             Director director = new Director(str, 1, false, true, false, false, true);             directors.add(director);             directors = directors.stream().filter(UtilsUse.distinctByKey(Director::getName)).collect(Collectors.toList());         }      }      public void addAllByBoardOfDirectors(List<String> strings) {         strings = strings.stream()                 .filter(t -> t.startsWith(Seting.ADD_DIRECTOR))                 .distinct()                 .collect(Collectors.toList());         for (String s : strings) {             Director director = new Director(s, 1, false, true, false, false, true);             directors.add(director);         }         directors = directors.stream().filter(UtilsUse.distinctByKey(Director::getName)).collect(Collectors.toList());      }       public List<String> getNames() {         return directors.stream().map(t -> t.getName()).collect(Collectors.toList());     }       public  boolean isElectedByStocks(String str){         List<String> list = directors.stream()                 .filter(t->t.isElectedByStocks())                 .map(t->t.getName())                 .collect(Collectors.toList());          return list.contains(str.toUpperCase(Locale.ROOT));     }     public boolean isElectedCEO(String str){         List<String> list = directors.stream()                 .filter(t->t.isElectedByCEO())                 .map(t->t.getName())                 .collect(Collectors.toList());          return list.contains(str.toUpperCase(Locale.ROOT));     }      public  boolean isElectedByBoardOfDirectors(String  str){         List<String> list = directors.stream()                 .filter(t->t.isElectedByBoardOfDirectors())                 .map(t->t.getName())                 .collect(Collectors.toList());          return list.contains(str.toUpperCase(Locale.ROOT));     }      public boolean isElectedBYCorporateCouncilOfReferees(String  str){         List<String> list = directors.stream()                 .filter(t->t.isElectedByCorporateCouncilOfReferees())                 .map(t->t.getName())                 .collect(Collectors.toList());          return list.contains(str.toUpperCase(Locale.ROOT));     }      public boolean isofficeOfDirectors(String str){         List<String> list = directors.stream()                 .filter(t->t.isOfficeOfDirectors())                 .map(t->t.getName())                 .collect(Collectors.toList());          return list.contains(str.toUpperCase(Locale.ROOT));     } }","package International_Trade_Union.governments;  public enum NamePOSITION {     BOARD_OF_DIRECTORS,     CORPORATE_COUNCIL_OF_REFEREES,     GENERAL_EXECUTIVE_DIRECTOR,     HIGH_JUDGE }","package International_Trade_Union.governments;   import International_Trade_Union.entity.DtoTransaction.DtoTransaction; import International_Trade_Union.entity.blockchain.block.Block; import International_Trade_Union.model.Account; import International_Trade_Union.setings.Seting; import International_Trade_Union.vote.*;  import java.io.IOException; import java.security.InvalidKeyException; import java.security.NoSuchAlgorithmException; import java.security.NoSuchProviderException; import java.security.SignatureException; import java.security.spec.InvalidKeySpecException; import java.util.*; import java.util.stream.Collectors;  public class UtilsGovernment {      //для корпоративных позиций, адресс отправителя должен совпадать с первой строкой закона     public static boolean checkPostionSenderEqualsLaw(String addressSender, Laws laws) {         Directors directors = new Directors();         List<Director> enumPosition = directors.getDirectors();         List<String> corporateSeniorPositions = enumPosition.stream().map(t->t.getName()).collect(Collectors.toList());         if (corporateSeniorPositions.contains(laws.getPacketLawName())) {             if (laws.getLaws().get(0) != null && addressSender.equals(laws.getLaws().get(0))) {                 System.out.println(\"UtilsBogernment: checkPostionSenderEqualsLaw: \" + laws.getLaws().get(0) + \" true:\");                 return true;             } else {                 System.out.println(\"UtilsBogernment: checkPostionSenderEqualsLaw: \" + laws.getLaws().get(0) + \" false:\");                 return false;             }         }         System.out.println(\"UtilsBogernment: checkPostionSenderEqualsLaw: \" + laws.getLaws().get(0) + \" not position:\");         return true;     }       //определение совета акционеров     public static List<Account> findBoardOfShareholders(Map<String, Account> balances, List<Block> blocks, int limit) {         List<Block> minersHaveMoreStock = null;         if (blocks.size() > limit) {             minersHaveMoreStock = blocks.subList(blocks.size() - limit, blocks.size());         } else {             minersHaveMoreStock = blocks;         }         List<Account> boardAccounts = minersHaveMoreStock.stream().map(                         t -> new Account(t.getMinerAddress(), 0, 0))                 .collect(Collectors.toList());          for (Block block : minersHaveMoreStock) {             for (DtoTransaction dtoTransaction : block.getDtoTransactions()) {                 boardAccounts.add(new Account(dtoTransaction.getSender(), 0, 0));             }          }           CompareObject compareObject = new CompareObject();          List<Account> boardOfShareholders = balances.entrySet().stream()                 .filter(t -> boardAccounts.contains(t.getValue()))                 .map(t -> t.getValue()).collect(Collectors.toList());           boardOfShareholders = boardOfShareholders                 .stream()                 .filter(t -> !t.getAccount().startsWith(Seting.NAME_LAW_ADDRESS_START))                 .filter(t -> t.getDigitalStockBalance() > 0)                 .sorted(Comparator.comparing(Account::getDigitalStockBalance).reversed())                 .collect(Collectors.toList());          boardOfShareholders = boardOfShareholders                 .stream()                 .limit(Seting.BOARD_OF_SHAREHOLDERS)                 .collect(Collectors.toList());          return boardOfShareholders;     }       public static List<CurrentLawVotesEndBalance> filtersVotes(             List<LawEligibleForParliamentaryApproval> approvalList,             Map<String, Account> balances,             List<Account> BoardOfShareholders,             List<Block> blocks,             int limitBlocks     ) throws IOException, NoSuchAlgorithmException, SignatureException, InvalidKeySpecException, NoSuchProviderException, InvalidKeyException {         //действующие законы чьи голоса больше ORIGINAL_LIMIT_MIN_VOTE         List<CurrentLawVotesEndBalance> current = new ArrayList<>();         Map<String, CurrentLawVotes> votesMap = null;         List<Account> accounts = balances.entrySet().stream().map(t -> t.getValue()).collect(Collectors.toList());         if (blocks.size() > limitBlocks) {             votesMap = UtilsCurrentLaw.calculateVotes(accounts, blocks.subList(blocks.size() - limitBlocks, blocks.size()));         } else {             votesMap = UtilsCurrentLaw.calculateVotes(accounts, blocks);         }          //подсчитать средннее количество раз сколько он проголосовал за         Map<String, Integer> yesAverage = UtilsCurrentLaw.calculateAverageVotesYes(votesMap);         //подсчитать среднее количество раз сколько он проголосовал против         Map<String, Integer> noAverage = UtilsCurrentLaw.calculateAverageVotesNo(votesMap);           //подсчитываем голоса для для обычных законов и законов позиций         for (LawEligibleForParliamentaryApproval lawEligibleForParliamentaryApproval : approvalList) {             if (votesMap.containsKey(lawEligibleForParliamentaryApproval.getLaws().getHashLaw())) {                 String address = lawEligibleForParliamentaryApproval.getLaws().getHashLaw();                 String packageName = lawEligibleForParliamentaryApproval.getLaws().getPacketLawName();                 List<String> laws = lawEligibleForParliamentaryApproval.getLaws().getLaws();                 double vote = 0;                 int supremeVotes = 0;                 int boafdOfShareholderVotes = 0;                 int houseOfRepresentativiesVotes = 0;                 int primeMinisterVotes = 0;                 int hightJudgesVotes = 0;                 int founderVote = 0;                  //для законов подсчитываем специальные голоса                 vote = votesMap.get(lawEligibleForParliamentaryApproval.getLaws().getHashLaw()).votesLaw(balances, yesAverage, noAverage);                 List<String> boardOfShareholdersAddress = BoardOfShareholders.stream().map(t -> t.getAccount()).collect(Collectors.toList());                 boafdOfShareholderVotes = votesMap.get(lawEligibleForParliamentaryApproval.getLaws().getHashLaw()).voteGovernment(balances, boardOfShareholdersAddress);                  List<String> founder = List.of(Seting.ADDRESS_FOUNDER);                 founderVote = votesMap.get(lawEligibleForParliamentaryApproval.getLaws().getHashLaw()).voteGovernment(balances, founder);                 CurrentLawVotesEndBalance currentLawVotesEndBalance = new CurrentLawVotesEndBalance(                         address,                         packageName,                         vote,                         supremeVotes,                         houseOfRepresentativiesVotes,                         boafdOfShareholderVotes,                         primeMinisterVotes,                         hightJudgesVotes,                         founderVote,                         laws);                 current.add(currentLawVotesEndBalance);              }         }          List<String> houseOfRepresentativies = new ArrayList<>();         List<String> chamberOfSumpremeJudges = new ArrayList<>();          for (CurrentLawVotesEndBalance currentLawVotesEndBalance: current) {             if(currentLawVotesEndBalance.getPackageName().equals(NamePOSITION.BOARD_OF_DIRECTORS.toString())){                 if(currentLawVotesEndBalance.getVotes() >= Seting.ORIGINAL_LIMIT_MIN_VOTE){                      houseOfRepresentativies.add(currentLawVotesEndBalance.getLaws().get(0));                 }              }             if(currentLawVotesEndBalance.getPackageName().equals(NamePOSITION.CORPORATE_COUNCIL_OF_REFEREES.toString())){                 if(currentLawVotesEndBalance.getVotes() >= Seting.ORIGINAL_LIMIT_MIN_VOTE){                     chamberOfSumpremeJudges.add(currentLawVotesEndBalance.getLaws().get(0));                 }              }         }            for (CurrentLawVotesEndBalance currentLawVotesEndBalance : current) {             if(votesMap.containsKey(currentLawVotesEndBalance.getAddressLaw())){                   double vote = votesMap.get(currentLawVotesEndBalance.getAddressLaw()).votesLaw(balances, yesAverage, noAverage);                 int supremeVotes  = votesMap.get(currentLawVotesEndBalance.getAddressLaw()).voteGovernment(balances, chamberOfSumpremeJudges);                 int houseOfRepresentativiesVotes = votesMap.get(currentLawVotesEndBalance.getAddressLaw()).voteGovernment(balances, houseOfRepresentativies);                  currentLawVotesEndBalance.setVotes(vote);                 currentLawVotesEndBalance.setVotesBoardOfDirectors(houseOfRepresentativiesVotes);                 currentLawVotesEndBalance.setVotesCorporateCouncilOfReferees(supremeVotes);             }          }          List<String> primeMinister = new ArrayList<>();         List<String> hightJudge = new ArrayList<>();         for (CurrentLawVotesEndBalance currentLawVotesEndBalance : current) {             if(currentLawVotesEndBalance.getPackageName().equals(NamePOSITION.GENERAL_EXECUTIVE_DIRECTOR.toString())){                 if(currentLawVotesEndBalance.getVotesBoardOfDirectors() >= Seting.ORIGINAL_LIMIT_MIN_VOTE_BOARD_OF_DIRECTORS){                     primeMinister.add(currentLawVotesEndBalance.getLaws().get(0));                 }             }              if(currentLawVotesEndBalance.getPackageName().equals(NamePOSITION.HIGH_JUDGE.toString())){                 if(currentLawVotesEndBalance.getVotesCorporateCouncilOfReferees() >= Seting.ORIGINAL_LIMIT_MIN_VOTE_CORPORATE_COUNCIL_OF_REFEREES){                     hightJudge.add(currentLawVotesEndBalance.getLaws().get(0));                 }             }         }         for (CurrentLawVotesEndBalance currentLawVotesEndBalance : current) {             if(votesMap.containsKey(currentLawVotesEndBalance.getAddressLaw())){                 int primeMinisterVotes = votesMap.get(currentLawVotesEndBalance.getAddressLaw()).voteGovernment(balances, primeMinister);                 int hightJudgeVotes = votesMap.get(currentLawVotesEndBalance.getAddressLaw()).voteGovernment(balances, hightJudge);                  currentLawVotesEndBalance.setVoteGeneralExecutiveDirector(primeMinisterVotes);                 currentLawVotesEndBalance.setVoteHightJudge(hightJudgeVotes);             }          }           return current;      }          //без учета палаты представителей     public static List<CurrentLawVotesEndBalance> filters(List<LawEligibleForParliamentaryApproval> approvalList, Map<String, Account> balances,                                                           List<Account> BoardOfShareholders, List<Block> blocks, int limitBlocks) throws IOException, NoSuchAlgorithmException, InvalidKeySpecException, SignatureException, NoSuchProviderException, InvalidKeyException {         //действующие законы чьи голоса больше ORIGINAL_LIMIT_MIN_VOTE         List<CurrentLawVotesEndBalance> current = new ArrayList<>();         Map<String, CurrentLawVotes> votesMap = null;         List<Account> accounts = balances.entrySet().stream().map(t -> t.getValue()).collect(Collectors.toList());         if (blocks.size() > limitBlocks) {             votesMap = UtilsCurrentLaw.calculateVotes(accounts, blocks.subList(blocks.size() - limitBlocks, blocks.size()));         } else {             votesMap = UtilsCurrentLaw.calculateVotes(accounts, blocks);         }          //подсчитать средннее количество раз сколько он проголосовал за         Map<String, Integer> yesAverage = UtilsCurrentLaw.calculateAverageVotesYes(votesMap);         //подсчитать среднее количество раз сколько он проголосовал против         Map<String, Integer> noAverage = UtilsCurrentLaw.calculateAverageVotesNo(votesMap);          for (LawEligibleForParliamentaryApproval lawEligibleForParliamentaryApproval : approvalList) {             if (votesMap.containsKey(lawEligibleForParliamentaryApproval.getLaws().getHashLaw())) {                 String address = lawEligibleForParliamentaryApproval.getLaws().getHashLaw();                 String packageName = lawEligibleForParliamentaryApproval.getLaws().getPacketLawName();                 List<String> laws = lawEligibleForParliamentaryApproval.getLaws().getLaws();                 double vote = votesMap.get(lawEligibleForParliamentaryApproval.getLaws().getHashLaw()).votes(balances, yesAverage, noAverage);                  CurrentLawVotesEndBalance currentLawVotesEndBalance = new CurrentLawVotesEndBalance(address, packageName, vote, 0, 0, 0, 0, 0, 0,  laws);                 current.add(currentLawVotesEndBalance);              }         }         return current;     }   }","package International_Trade_Union.model;   import lombok.Data; import International_Trade_Union.entity.DtoTransaction.DtoTransaction; import International_Trade_Union.utils.UtilsSecurity; import International_Trade_Union.utils.base.Base; import International_Trade_Union.utils.base.Base58; import International_Trade_Union.vote.Laws; import International_Trade_Union.vote.VoteEnum;  import java.io.IOException; import java.security.*; import java.security.spec.InvalidKeySpecException; import java.util.Objects;   @Data public class Account {     private String account;     private double digitalDollarBalance;     private double digitalStockBalance;       public Account(String account, double digitalDollarBalance) {         this(account, digitalDollarBalance, 0.0);      }      public Account(String account, double digitalDollarBalance, double digitalStockBalance) {         this.account = account;         this.digitalDollarBalance = digitalDollarBalance;         this.digitalStockBalance = digitalStockBalance;     }      public Account() {     }      @Override     public boolean equals(Object o) {         if (this == o) return true;         if (!(o instanceof Account)) return false;         Account account1 = (Account) o;         return getAccount().equals(account1.getAccount());     }      @Override     public int hashCode() {         return Objects.hash(getAccount());     }      private DtoTransaction sendMoney(String recipient, String privatekey, double digitalDollar, double digitalStock, Laws laws, double minerRewards, VoteEnum voteEnum) throws NoSuchAlgorithmException, InvalidKeySpecException, NoSuchProviderException, SignatureException, IOException, InvalidKeyException {          DtoTransaction transaction = null;         if (account.equals(recipient)){             System.out.println(\"sender %s, recipient %s cannot be equals! Error!\".format(account,recipient));             return transaction;         }              if(digitalDollarBalance < digitalDollar + minerRewards  ){                 System.out.println(\"sender don't have digitalDollar\");                 return transaction;             }             if(digitalStockBalance < digitalStock){                 System.out.println(\"sender don't have digitalReputation\");                 return transaction;             }             else{                 Base base = new Base58();                 PrivateKey privateKey = UtilsSecurity.privateBytToPrivateKey(base.decode(privatekey));                  transaction = new DtoTransaction(this.getAccount(), recipient, digitalDollar, digitalStock, laws, minerRewards, voteEnum);                 byte[] signGold = UtilsSecurity.sign(privateKey, transaction.toSign());                 transaction.setSign(signGold);             }         return transaction;     }  //      recipient - получатель //      gold сумма отправки, last Block - это послдний блок.     public DtoTransaction send(String recipient, String privateKey, double digitalDollar, double digitalReputation, Laws laws,  double minerRewards, VoteEnum voteEnum) throws NoSuchAlgorithmException, InvalidKeySpecException, SignatureException, IOException, NoSuchProviderException, InvalidKeyException {          return sendMoney(recipient,privateKey, digitalDollar, digitalReputation, laws, minerRewards, voteEnum);     }      }","package International_Trade_Union.model;  import International_Trade_Union.utils.UtilsSecurity; import International_Trade_Union.utils.base.Base; import International_Trade_Union.utils.base.Base58;  import java.security.InvalidAlgorithmParameterException; import java.security.NoSuchAlgorithmException; import java.security.NoSuchProviderException; import java.security.spec.InvalidKeySpecException; import java.util.HashMap; import java.util.Map;  public class CreateAccount {     public static Map<String, String> create() throws InvalidAlgorithmParameterException, NoSuchAlgorithmException, InvalidKeySpecException, NoSuchProviderException {         Map<String, String> create = new HashMap<>();         Base base = new Base58();         Keys keyPair = UtilsSecurity.generateKeyPair();         String pubkey = keyPair.getPubkey();         String privKey = keyPair.getPrivkey();         System.out.println(\"pubkey: \" + pubkey);         System.out.println(\"privKey: \" + privKey);         create.put(\"pubKey\", pubkey);         create.put(\"privKey\", privKey);         return create;     } }","package International_Trade_Union.model;  import International_Trade_Union.governments.Director; import lombok.AllArgsConstructor; import lombok.Data; import lombok.NoArgsConstructor;  @Data @AllArgsConstructor @NoArgsConstructor public class FIndPositonHelperData {     Director addressPosition;     boolean withLimited;     boolean electedWithStock;     boolean electedWithPrimeMinister;     boolean electedWithHousOfRepresentativies;     boolean electedWithChamberOfHightJudjes;  }","package International_Trade_Union.model;  import lombok.Data;  @Data public class Keys {     private String pubkey;     private String privkey;      public Keys(String pubkey, String privkey) {         this.pubkey = pubkey;         this.privkey = privkey;     } }","package International_Trade_Union.model;    import International_Trade_Union.config.BLockchainFactory; import International_Trade_Union.config.BlockchainFactoryEnum; import International_Trade_Union.entity.DtoTransaction.DtoTransaction; import International_Trade_Union.entity.blockchain.Blockchain; import International_Trade_Union.entity.blockchain.block.Block; import International_Trade_Union.governments.Director; import International_Trade_Union.governments.Directors; import International_Trade_Union.governments.UtilsGovernment; import International_Trade_Union.setings.Seting; import International_Trade_Union.utils.base.Base; import International_Trade_Union.utils.base.Base58; import International_Trade_Union.vote.Laws; import International_Trade_Union.vote.VoteEnum; import International_Trade_Union.utils.*;  import java.io.File; import java.io.IOException; import java.security.*; import java.security.spec.InvalidKeySpecException; import java.util.*; import java.util.stream.Collectors;  public class Mining {      public static Blockchain getBlockchain(String filename, BlockchainFactoryEnum factoryEnum) throws IOException, NoSuchAlgorithmException, InvalidKeySpecException, SignatureException, NoSuchProviderException, InvalidKeyException {          List<Block> blocks = UtilsBlock.readLineObject(filename);         Blockchain blockchain = null;         blockchain = BLockchainFactory.getBlockchain(factoryEnum);          if (blocks.size() != 0) {            blockchain.setBlockchainList(blocks);         }         return blockchain;     }      public static Map<String, Account> getBalances(String filename, Blockchain blockchain, Map<String, Account> balances) throws IOException, NoSuchAlgorithmException, SignatureException, InvalidKeySpecException, NoSuchProviderException, InvalidKeyException {         //start test           //папка чтобы проверить есть ли         File folder = new File(filename);         List<String> files = new ArrayList<>();         for (File file : folder.listFiles()) {             if(!file.isDirectory()){                 files.add(file.getAbsolutePath());             }         }          if (files.size() > 0 ){             File file = new File(files.get(files.size()-1));             if(file.exists() && file.length() > 0){                 balances = SaveBalances.readLineObject(filename);             }          }          if (balances == null) {             balances = new HashMap<>();         }          Block block;         if(blockchain != null && blockchain.sizeBlockhain() > 0){             block = blockchain.getBlock(blockchain.sizeBlockhain() - 1);             balances = UtilsBalance.calculateBalance(balances, block);           }           return balances;     }      public static void deleteFiles(String fileDelit) {         UtilsFileSaveRead.deleteAllFiles(fileDelit);     }       public static Block miningDay(             Account minner,             String filename,             Blockchain blockchain,             long blockGenerationInterval,             int DIFFICULTY_ADJUSTMENT_INTERVAL,             List<DtoTransaction> transactionList,             Map<String, Account> balances,             long index     ) throws IOException, NoSuchAlgorithmException, SignatureException, InvalidKeySpecException, NoSuchProviderException, InvalidKeyException {         Directors directors = new Directors();         //получение транзакций с сети         List<DtoTransaction> listTransactions = transactionList;          //определение валидных транзакций         List<DtoTransaction> forAdd = new ArrayList<>();          cicle:         for (DtoTransaction transaction : listTransactions) {             if (transaction.verify()) {                  Account account = balances.get(transaction.getSender());                 if (account == null) {                     System.out.println(\"minerAccount null\");                     continue cicle;                 }                 if(transaction.getCustomer().startsWith(Seting.NAME_LAW_ADDRESS_START) && !balances.containsKey(transaction.getCustomer())){                     //если в названия закона совпадает с корпоративными должностями, то закон является действительным только когда                     //отправитель совпадает с законом                     List<Director> enumPosition = directors.getDirectors();                     List<String> corporateSeniorPositions = directors.getDirectors().stream()                             .map(t->t.getName()).collect(Collectors.toList());                     System.out.println(\"LawsController: create_law: \" + transaction.getLaws().getPacketLawName()                             + \"contains: \" + corporateSeniorPositions.contains(transaction.getLaws().getPacketLawName()));                     if(corporateSeniorPositions.contains(transaction.getLaws().getPacketLawName())                             && !UtilsGovernment.checkPostionSenderEqualsLaw(transaction.getSender(), transaction.getLaws())){                         System.out.println(\"if your create special corporate position, you need \" +                                 \"sender to be equals with first law: now its wrong\");                         continue cicle;                     }                 }                 if(transaction.getLaws() == null){                     System.out.println(\"law cannot to be null: \");                     continue cicle;                 }                  if (account != null) {                     if(transaction.getSender().equals(Seting.BASIS_ADDRESS)){                         System.out.println(\"only this miner can input basis adress in this block\");                         continue cicle;                     }                     if(transaction.getCustomer().equals(Seting.BASIS_ADDRESS)){                         System.out.println(\"basis address canot to be customer(recipient)\");                         continue cicle;                     }                      if( account.getDigitalDollarBalance() < transaction.getDigitalDollar() + transaction.getBonusForMiner()){                         System.out.println(\"sender don't have digital dollar: \" + account.getAccount() + \" balance: \" + account.getDigitalDollarBalance() );                         System.out.println(\"digital dollar for send: \" + (transaction.getDigitalDollar() + transaction.getBonusForMiner()));                         continue cicle;                     }                     if (account.getDigitalStockBalance() < transaction.getDigitalStockBalance()){                         System.out.println(\"sender don't have digital reputation: \" + account.getAccount() + \" balance: \" + account.getDigitalStockBalance());                         System.out.println(\"digital reputation for send: \" + (transaction.getDigitalDollar() + transaction.getBonusForMiner()));                         continue cicle;                     }                     if(transaction.getSender().equals(transaction.getCustomer()) ){                         System.out.println(\"sender end recipient equals \" + transaction.getSender() + \" : recipient: \" + transaction.getCustomer());                         continue cicle;                     }                     forAdd.add(transaction);                 }              }         }           //доход майнера         double minerRewards = Seting.DIGITAL_DOLLAR_REWARDS_BEFORE;         double digitalReputationForMiner = Seting.DIGITAL_STOCK_REWARDS_BEFORE;          //доход основателя         double founderReward = Seting.DIGITAL_DOLLAR_FOUNDER_REWARDS_BEFORE;         double founderDigigtalReputationReward = Seting.DIGITAL_REPUTATION_FOUNDER_REWARDS_BEFORE;          Base base = new Base58();          //суммирует все вознаграждения майнеров         PrivateKey privateKey = UtilsSecurity.privateBytToPrivateKey(base.decode(Seting.BASIS_PASSWORD));         double sumRewards = forAdd.stream().collect(Collectors.summingDouble(DtoTransaction::getBonusForMiner));          //вознаграждения майнера         DtoTransaction minerRew = new DtoTransaction(Seting.BASIS_ADDRESS, minner.getAccount(),                 minerRewards, digitalReputationForMiner, new Laws(), sumRewards, VoteEnum.YES );          byte[] signGold = UtilsSecurity.sign(privateKey, minerRew.toSign());         minerRew.setSign(signGold);          //вознаграждение основателя         DtoTransaction founderRew = new DtoTransaction(Seting.BASIS_ADDRESS, blockchain.getADDRESS_FOUNDER(),                 founderReward, founderDigigtalReputationReward, new Laws(), 0.0, VoteEnum.YES);         byte[] signFounder = UtilsSecurity.sign(privateKey, founderRew.toSign());          founderRew.setSign(signFounder);           forAdd.add(minerRew);         forAdd.add(founderRew);           //определение сложности и создание блока          int difficulty = UtilsBlock.difficulty(blockchain.getBlockchainList(), blockGenerationInterval, DIFFICULTY_ADJUSTMENT_INTERVAL);          System.out.println(\"Mining: miningBlock: difficulty: \" + difficulty + \" index: \" + index);           //blockchain.getHashBlock(blockchain.sizeBlockhain() - 1)         Block block = new Block(                 forAdd,                 blockchain.getHashBlock(blockchain.sizeBlockhain() - 1),                 minner.getAccount(),                 blockchain.getADDRESS_FOUNDER(),                 difficulty,                 index);          return block;     } }","package International_Trade_Union.model;  import International_Trade_Union.setings.Seting; import International_Trade_Union.utils.UtilsFileSaveRead;  import java.io.FileNotFoundException;   public class User {     private static String addressMiner=\"\";      public static void setUserAddress(String addressMiner) { //        System.out.println(\"change minerAccount: \" + addressMiner); //        UtilsFileSaveRead.save(addressMiner, Seting.ORIGINAL_ACCOUNT, false);         User.addressMiner = addressMiner;     }      public static String getUserAddress() throws FileNotFoundException {         addressMiner = UtilsFileSaveRead.read(Seting.ORIGINAL_ACCOUNT);         System.out.println(\"user: \" + addressMiner);         if(addressMiner.isEmpty() || addressMiner == null)             addressMiner = \"empty \";         return addressMiner;     } }","package International_Trade_Union.network;  import International_Trade_Union.entity.DtoTransaction.DtoTransaction; import International_Trade_Union.model.Mining; import International_Trade_Union.setings.Seting; import International_Trade_Union.utils.*; import org.json.JSONException;  import java.io.File; import java.io.IOException; import java.security.InvalidKeyException; import java.security.NoSuchAlgorithmException; import java.security.NoSuchProviderException; import java.security.SignatureException; import java.security.spec.InvalidKeySpecException; import java.util.ArrayList; import java.util.List; import java.util.stream.Collectors;  public class AllTransactions {     private static List<DtoTransaction> instance = new ArrayList<>();     //все транзакции которые уже добавлены в блок, нужно чтобы повторно     //не добавлялись в блок если они скачены с дисковери.     private static List<DtoTransaction> sendedTransaction = new ArrayList<>();      public static List<DtoTransaction> readFrom() throws IOException, NoSuchAlgorithmException, InvalidKeySpecException, SignatureException, NoSuchProviderException, InvalidKeyException {         return UtilsTransaction.readLineObject(Seting.ORGINAL_ALL_TRANSACTION_FILE);     }      public static synchronized List<DtoTransaction> getInstance() throws IOException, NoSuchAlgorithmException, InvalidKeySpecException, SignatureException, NoSuchProviderException, InvalidKeyException {         if (instance == null) {             instance = new ArrayList<>();         }         instance = new ArrayList<>();          //считываем с пула транзакции из дисковери.         for (String s : Seting.ORIGINAL_ADDRESSES) {             try {                 String json = UtilUrl.readJsonFromUrl(s + \"/getTransactions\");                 List<DtoTransaction> list = UtilsJson.jsonToDtoTransactionList(json);                  instance.addAll(list);               } catch (IOException | JSONException e) {                  System.out.println(\"AllTransaction: getInstance: Error\");                 continue;             }           }          instance.addAll(UtilsTransaction.readLineObject(Seting.ORGINAL_ALL_TRANSACTION_FILE));         instance = instance.stream().distinct().collect(Collectors.toList());          sendedTransaction = getInsanceSended();          instance.removeAll(sendedTransaction);         return instance;     }      public static synchronized void clearAllTransaction() {         instance = new ArrayList<>();         Mining.deleteFiles(Seting.ORGINAL_ALL_TRANSACTION_FILE);     }      public static synchronized void clearAllSendedTransaction(long index) {         if(index % (Seting.COUNT_BLOCK_IN_DAY * Seting.DAY_DELETED_SENDED_FILE) == 0){             sendedTransaction = new ArrayList<>();             Mining.deleteFiles(Seting.ORIGINAL_ALL_SENDED_TRANSACTION_FILE);             System.out.println(\"clear delete sended transaction\");         }      }      public static synchronized void clearUsedTransaction(List<DtoTransaction> transactions) throws IOException, NoSuchAlgorithmException, SignatureException, InvalidKeySpecException, NoSuchProviderException, InvalidKeyException {         instance = getInstance();         List<DtoTransaction> temporaryDto = new ArrayList<>();          instance = temporaryDto;         instance.removeAll(transactions);         Mining.deleteFiles(Seting.ORGINAL_ALL_TRANSACTION_FILE);         for (DtoTransaction dtoTransaction : instance) {              UtilsTransaction.saveAllTransaction(dtoTransaction, Seting.ORGINAL_ALL_TRANSACTION_FILE);         }       }      public static synchronized void addTransaction(DtoTransaction transaction) throws IOException, NoSuchAlgorithmException, SignatureException, InvalidKeySpecException, NoSuchProviderException, InvalidKeyException {          instance = getInstance();         instance.add(transaction);         Mining.deleteFiles(Seting.ORGINAL_ALL_TRANSACTION_FILE);         instance = instance.stream().filter(UtilsUse.distinctByKey(DtoTransaction::toSign)).collect(Collectors.toList());         for (DtoTransaction dtoTransaction : instance) {             UtilsTransaction.saveAllTransaction(dtoTransaction, Seting.ORGINAL_ALL_TRANSACTION_FILE);         }       }      public static synchronized void addSendedTransaction(List<DtoTransaction> transactions) throws IOException, NoSuchAlgorithmException, InvalidKeySpecException, SignatureException, NoSuchProviderException, InvalidKeyException {         sendedTransaction = getInsanceSended();         sendedTransaction.addAll(transactions);          Mining.deleteFiles(Seting.ORIGINAL_ALL_SENDED_TRANSACTION_FILE);         for (DtoTransaction dtoTransaction : sendedTransaction) {             UtilsTransaction.saveAllTransaction(dtoTransaction, Seting.ORIGINAL_ALL_SENDED_TRANSACTION_FILE);         }          System.out.println(\"AllTransaction: addSendedTransaction: \" + sendedTransaction.size());      }      public static List<DtoTransaction> getInsanceSended() throws IOException, NoSuchAlgorithmException, InvalidKeySpecException, SignatureException, NoSuchProviderException, InvalidKeyException {         if (sendedTransaction == null) {             sendedTransaction = new ArrayList<>();         }         sendedTransaction = UtilsTransaction.readLineObject(Seting.ORIGINAL_ALL_SENDED_TRANSACTION_FILE);         sendedTransaction = sendedTransaction.stream().distinct().collect(Collectors.toList());         return sendedTransaction;     }  }","package International_Trade_Union.network;    import International_Trade_Union.entity.DtoTransaction.DtoTransaction;  import java.util.ArrayList; import java.util.List;  public class Transactions {     public  List<DtoTransaction> getTransactions() {         List<DtoTransaction> transactions = new ArrayList<>();         return transactions;     } }","package International_Trade_Union.node;  import java.util.HashSet; import java.util.Set;  public class Nodes {      public int size(){         return urlAddress.size();     }      public Nodes() {         this.urlAddress = new HashSet<>();     }      public Nodes(Set<String> urlAddress) {         this.urlAddress = urlAddress;     }      private  Set<String> urlAddress = new HashSet<>();      public  void setUrlAddress(Set<String> urlAddress) {         this.urlAddress = urlAddress;     }     public void addAddress(String addressUrl){         urlAddress.add(addressUrl);     }      public  Set<String> getUrlAddresses() {         return urlAddress;     }      public void clear(){         urlAddress = new HashSet<>();     } }","package International_Trade_Union.setings;  import International_Trade_Union.about_usDraft.AboutUsDraft; import International_Trade_Union.about_us_engDraft.AboutUsEngDraft; import International_Trade_Union.CorporateCharterEngDraft.CorporateCharter; import International_Trade_Union.governments.Directors; import International_Trade_Union.governments.NamePOSITION; import International_Trade_Union.utils.UtilsUse;  import java.util.Set;  public interface Seting {     // значение используется для вычисления процентов     int HUNDRED_PERCENT = 100;     // значение используется как константа года,     // в данной системе отсутствует високосный год     int YEAR = 360;      Directors directors = new Directors();       //используется для очистки из файла, где хранятся отправленные транзакции,     //чтобы предотвратить добавление повторно уже отправленных транзакций     int DAY_DELETED_SENDED_FILE = 3;        //За какой период последних блоков учитывать для отбора акционеров.     //Акционерами могут быть только с наибольшим количеством баланса     //отправители и майнеры.     int BOARDS_BLOCK = (int) (Seting.COUNT_BLOCK_IN_DAY * YEAR);       //минимальное значение количество положительных голосов, для того чтобы избрать     // Совет Директоров и Совет Корпоративных Верховных Судей,     int ORIGINAL_LIMIT_MIN_VOTE = (int) (200 * Seting.COUNT_BLOCK_IN_DAY * 1 / 8);        //Минимальное значение чтобы Совет Корпоративных Верховных Судей могла избрать Верховного Судью     int ORIGINAL_LIMIT_MIN_VOTE_CORPORATE_COUNCIL_OF_REFEREES = 3;      //Минимальное значение остатка голосов чтобы Совет директоров утверждал бюджет,     //стратегический план, в создании новых должностей и назначении новых должностей,     //и т.д. Также участвовал в утверждении законов, вместе с другими участниками.     int ORIGINAL_LIMIT_MIN_VOTE_BOARD_OF_DIRECTORS = 15;//15;      //Минимальное количество остатка голосов чтобы Совет Акционеров     //утверждал вместе с остальными участниками в утверждении законов.     int ORIGINAL_LIMIT_MIN_VOTE_BOARD_OF_SHAREHOLDERS = 100; //100;      //голос Генерального Исполнительного Директора     int ORIGINAL_LIMIT_MIN_VOTE_GENERAL_EXECUTIVE_DIRECTOR = 1;      //голос Верховного Судьи     int ORIGINAL_LIMIT_MIN_VOTE_HIGHT_JUDGE = 1;      //для преодоления верховного судьи, если Верховный Судья не одобрил закон     //то нужно получить в два раза больше голосов, чтобы преодолеть вето Верховного Судьи     int POWERFUL_VOTE = 2;      //данная мера нужна чтобы если один счет голосует за несколько кандидатов,     //его голос не делился равномерно, а становился значительно сильнее,     //чтобы не допустить монополии, если очень богатый человек захочет должностные лица поставить к власти     //то он не сможет пример: счет X проголосовал ЗА = 2 закона и ПРОТИВ = 3 закона     //100 = voteYES, 100 = voteNO, voteYES / (2^3) = 12.5 , voteNO / (3^3) = 3.7     //таким образом чем больше голосует, тем меньше голосов остается для избрания     //должностных лиц, это защита от сверхбогатых участников Совета Акционеров     int POWERING_FOR_VOTING = 3;       //голос должностных лиц,     int VOTE_GOVERNMENT = 1;     //голос должностных лиц вместо акций учитывается только один     //голос, как будто у них одна акция     double STOCK_VOTE_GOVERNMENT = 1;      //    процент который получает основатель от добычи     Double FOUNDERS_REWARD = 2.0;      //address for send rewards     String BASIS_ADDRESS = \"faErFrDnBhfSfNnj1hYjxydKNH28cRw1PBwDQEXH3QsJ\";     String BASIS_PASSWORD = \"3hupFSQNWwiJuQNc68HiWzPgyNpQA2yy9iiwhytMS7rZyfPddNRwtvExeevhayzN6xL2YmTXN6NCA8jBhV9ge1w8KciHedGUMgZyq2T7rDdvekVNwEgf5pQrELv8VAEvQ4Kb5uviXJFuMyuD1kRAGExrZym5nppyibEVnTC9Uiw8YzUh2JmVT9iUajnVV3wJ5foMs\";      //сложность коррекция каждые n блоков     int DIFFICULTY_ADJUSTMENT_INTERVAL = (int) (Seting.COUNT_BLOCK_IN_DAY / 2);     int DIFFICULTY_ADJUSTMENT_INTERVAL_TEST = 10;      long BLOCK_GENERATION_INTERVAL = Seting.BLOCK_TIME * 1000;// after Seting.BLOCK_TIME     long BLOCK_GENERATION_INTERVAL_TEST = 0 * 1000;       long INTERVAL_TARGET = 600000;     long INTERVAL_TARGET_TEST = 25000;      // плата за обслуживание каждые 6 месяцев.     Double ANNUAL_MAINTENANCE_FREE_DIGITAL_DOLLAR_YEAR = 0.2;     //отрицательная ставка для цифровой акции     double ANNUAL_MAINTENANCE_FREE_DIGITAL_STOCK_YEAR = 0.4;     //каждые сколько месяцев снимать     int HALF_YEAR = 2;      //стоимость создания закона 5     double COST_LAW = 5;     //с чего начинается адрес пакета закона     //сокращенно корпорация     String NAME_LAW_ADDRESS_START = \"LIBER\";      int HASH_COMPLEXITY_GENESIS = 1;      //совет акционеров    int BOARD_OF_SHAREHOLDERS = 1500;      //ПОПРАВКА В УСТАВЕ    //требования к поправкам     String AMENDMENT_TO_THE_CHARTER = \"AMENDMENT_TO_THE_CHARTER\";      //директора созданные Советом директоров     String ADD_DIRECTOR = \"ADD_DIRECTOR\";      //бюджет должен формировать только палата представителей     String BUDGET = \"BUDGET\";      //план также утверждается на четыре года и утверждается только палатой представителей     //каждый план обязан содержать дату начала планирования с какого числа вступает в силу.     //FOUR-YEAR PLAN     String STRATEGIC_PLAN = \"STRATEGIC_PLAN\";       //лимиты для ведения поправок     //палата судей минимум 5 голосов     int ORIGINAL_LIMIT_MIN_VOTE_CORPORATE_COUNCIL_OF_REFEREES_AMENDMENT = 5;// 5;     //палата представителей 20% голосов     int ORIGINAL_LIMIT_MIN_VOTE_BOARD_OF_DIRECTORS_AMENDMENT =            directors.getDirector(NamePOSITION.BOARD_OF_DIRECTORS.toString()).getCount() * 20 / 100;      //Совет акционеров минимум 20% голосов     int ORIGINAL_LIMIT_MINT_VOTE_BOARD_OF_SHAREHOLDERS_AMENDMENT = BOARD_OF_SHAREHOLDERS * 20 / 100;       //    адресс основателя: здесь будет мой адрес. Сейчас заглушка     String ADDRESS_FOUNDER_TEST = \"stExZb8ifLfnFoq4JJuTifpAcscegATH8znhwW26zyTa\";     String ADDRESS_FOUNDER = \"stExZb8ifLfnFoq4JJuTifpAcscegATH8znhwW26zyTa\";      String CORPORATE_CHARTER_DRAFT = International_Trade_Union.CorporateCharterDraft.CorporateCharter.getAllConstitution() + \"\\n\" + CorporateCharter.getAllConstitution() + AboutUsDraft.getAboutUs()             + AboutUsEngDraft.getAboutUs();      //КЛЮЧЕВОЕ НАЗВАНИЕ ПАКЕТА ЧТО ЭТО УСТАВ, ДЕЙСТВУЮЩИЙ УСТАВ ПОДПИСАН ОСНОВАТЕЛЕМ.     String ORIGINAL_CHARTER_CURRENT_LAW_PACKAGE_NAME = \"ORIGINAL_CHARTER_CURRENT_LAW_PACKAGE_NAME\";      //КЛЮЧЕВОЕ НАЗВАНИЕ ДЛЯ КОДА КОТОРЫЙ СОПРОВОЖДАЕТСЯ С УСТАВОМ     String ORIGINAL_CHARTER_CURRENT_ALL_CODE = \"ORIGINAL_CHARTER_CURRENT_ALL_CODE\";      //начальная сумма основателя     Double FOUNDERS_REMUNERATION_DIGITAL_DOLLAR = 30000000.0;     double FOUNDERS_REMNUNERATION_DIGITAL_STOCK = 30000000.0;       // сколько секунд в сутках     int DAY_SECOND = 86400;      //    за сколько секунд добывается каждый блок     int BLOCK_TIME = 150;       //сколько блоков добывается в сутки     double COUNT_BLOCK_IN_DAY = (DAY_SECOND / BLOCK_TIME);      //подсчет голосов для должности в годах, учитываются только те голоса     //которые не позже четырех лет для законов и должностей,     //голоса отданные за законы должны обновляться каждые четыре года     //как и за должности     int POSITION_YEAR_VOTE = (int) Seting.COUNT_BLOCK_IN_DAY * YEAR * 4;     //подсчет голосов для законов в годах     int LAW_YEAR_VOTE = (int) Seting.COUNT_BLOCK_IN_DAY * YEAR * 4;         String ORIGINAL_INDEX_FILE = \"C:\\\\resources\\\\index\\\\index.txt\";     String ORIGINAL_BLOCKCHAIN_FILE = \"C:\\\\resources\\\\blockchain\\\\\";     String ORIGINAL_BALANCE_FILE = \"C:\\\\resources\\\\balance\\\\\";     String ORIGINAL_BOARD_0F_SHAREHOLDERS_FILE = \"C:\\\\resources\\\\federalGovernment\\\\federalGovernment.txt\";     String ORIGINAL_ALL_CORPORATION_LAWS_FILE = \"C:\\\\resources\\\\federalLaws\\\\\";     String ORIGINAL_ACCOUNT = \"C:\\\\resources\\\\minerAccount\\\\minerAccount.txt\";     String ORIGINAL_CORPORATE_VOTE_FILE = \"C:\\\\resources\\\\vote\\\\\";      String ORIGINAL_ALL_CORPORATION_LAWS_WITH_BALANCE_FILE = \"C:\\\\resources\\\\allLawsWithBalance\\\\\";     String ORGINAL_ALL_TRANSACTION_FILE = \"C:\\\\resources\\\\transactions\\\\\";     String ORIGINAL_ALL_SENDED_TRANSACTION_FILE = \"C:\\\\resources\\\\sendedTransaction\\\\\";     String ORIGINAL_POOL_URL_ADDRESS_FILE = \"C:\\\\resources\\\\poolAddress\\\\\";      //адресса discovery     Set<String> ORIGINAL_ADDRESSES = Set.of(\"http://194.87.236.238:80\");       //адреса хранилищ блокчейнов //    Set<String> ORIGINAL_ADDRESSES_BLOCKCHAIN_STORAGE = Set.of(\"http://localhost:8084\");      int SIZE_FILE_LIMIT = 100;      //папки файла для тестирования с сохранениям файла     String TEST_LAST_BLOCK = \".\\\\src\\\\test\\\\java\\\\unitted_states_of_mankind\\\\resourceTestingFileSaved\\\\lastBlock\\\\\";     String INDEX_TEST = \".\\\\src\\\\test\\\\java\\\\unitted_states_of_mankind\\\\resourceTestingFileSaved\\\\index\\\\index.txt\";     String TEST_BLOCKCHAIN_SAVED = \".\\\\src\\\\test\\\\java\\\\unitted_states_of_mankind\\\\resourceTestingFileSaved\\\\network\\\\\";     String TEST_BLOCKCHAIN_BALANCES = \".\\\\src\\\\test\\\\java\\\\unitted_states_of_mankind\\\\resourceTestingFileSaved\\\\balances\\\\\";     String TEST_FEDERAL_GOVERNMENT = \".\\\\src\\\\test\\\\java\\\\unitted_states_of_mankind\\\\resourceTestingFileSaved\\\\federal government\\\\federalGovernment.txt\";     String TEST_FEDERAL_LAWS = \".\\\\src\\\\test\\\\java\\\\unitted_states_of_mankind\\\\resourceTestingFileSaved\\\\laws\\\\\";     String TEST_CURRENT_LAWS = \".\\\\src\\\\test\\\\java\\\\unitted_states_of_mankind\\\\resourceTestingFileSaved\\\\current laws\\\\\";     String TEST_FEDERAL_VOTE = \".\\\\src\\\\test\\\\java\\\\unitted_states_of_mankind\\\\resourceTestingFileSaved\\\\vote\\\\\";     String TEST_ALL_FEDERAL_LAWS_WITH_BALANCE_FILE = \".\\\\src\\\\test\\\\java\\\\unitted_states_of_mankind\\\\resourceTestingFileSaved\\\\allLawsWithBalance\\\\\";      //Временный блокчейн для тестирования     String TEST_LAST_BLOCK_TEMPORARY = \".\\\\src\\\\test\\\\java\\\\unitted_states_of_mankind\\\\resourceTestingFileWithoutSave\\\\lastBlock\\\\\";     String TEST_INDEX_TEMPORARY = \".\\\\src\\\\test\\\\java\\\\unitted_states_of_mankind\\\\resourceTestingFileWithoutSave\\\\index\\\\index.txt\";     String TEST_TEMPORARY_BLOCKCHAIN = \".\\\\src\\\\test\\\\java\\\\unitted_states_of_mankind\\\\resourceTestingFileWithoutSave\\\\temporary blockchain\\\\\";     String TEST_BLOCKCHAIN_BALANCES_TEMPORARY = \".\\\\src\\\\test\\\\java\\\\unitted_states_of_mankind\\\\resourceTestingFileWithoutSave\\\\balances\\\\\";     String TEST_FEDERAL_GOVERNMENT_TEMPORARY = \".\\\\src\\\\test\\\\java\\\\unitted_states_of_mankind\\\\resourceTestingFileWithoutSave\\\\federal government\\\\federalGovernment.txt\";     String TEST_FEDERAL_LAWS_TEMPORARY = \".\\\\src\\\\test\\\\java\\\\unitted_states_of_mankind\\\\resourceTestingFileWithoutSave\\\\laws\\\\\";     String TEST_CURRENT_LAWS_TEMPORARY = \".\\\\src\\\\test\\\\java\\\\unitted_states_of_mankind\\\\resourceTestingFileWithoutSave\\\\current laws\\\\\";     String TEST_FEDERAL_VOTE_TEMPORARY = \".\\\\src\\\\test\\\\java\\\\unitted_states_of_mankind\\\\resourceTestingFileSaved\\\\vote\\\\\";     String TEST_ALL_FEDERAL_LAWS_WITH_BALANCE_TEMPORARY = \".\\\\unitedStates\\\\src\\\\test\\\\java\\\\unitted_states_of_mankind\\\\resourceTestingFileWithoutSave\\\\allLawsWithBalance\\\\\";      String TEST_FILE_WRITE_INFO = \".\\\\src\\\\test\\\\java\\\\unitted_states_of_mankind\\\\blockchainTwentyYearTest\\\\\";     double DIGITAL_DOLLAR_REWARDS_BEFORE = 200.0;     double DIGITAL_STOCK_REWARDS_BEFORE = 200.0;     double DIGITAL_DOLLAR_FOUNDER_REWARDS_BEFORE = Math.round(UtilsUse.countPercents(Seting.DIGITAL_DOLLAR_REWARDS_BEFORE, Seting.FOUNDERS_REWARD));     double DIGITAL_REPUTATION_FOUNDER_REWARDS_BEFORE = Math.round(UtilsUse.countPercents(Seting.DIGITAL_STOCK_REWARDS_BEFORE, Seting.FOUNDERS_REWARD));    }","package International_Trade_Union.sheduled;  import org.springframework.context.annotation.Configuration; import org.springframework.scheduling.annotation.EnableScheduling;  @EnableScheduling @Configuration public class SchedulerConfig { }","package International_Trade_Union.simulation;  import lombok.Data;  @Data public class AccountSimulation {     private String publicKey;     private String privateKey;     private double digitalDollarBalance;     private double digitalReputationBalance;       public AccountSimulation(String publicKey, String privateKey, double digitalDollarBalance, double digitalReputationBalance) {         this.publicKey = publicKey;         this.privateKey = privateKey;         this.digitalDollarBalance = digitalDollarBalance;         this.digitalReputationBalance = digitalReputationBalance;     }      public AccountSimulation(String publicKey, double digitalDollarBalance, double digitalReputationBalance) {         this.publicKey = publicKey;         this.digitalDollarBalance = digitalDollarBalance;         this.digitalReputationBalance = digitalReputationBalance;     }      public AccountSimulation() {     }   }","package International_Trade_Union.simulation;    import International_Trade_Union.model.Account;  import java.util.ArrayList; import java.util.List;  public class AddapterAccountSimulationToAccount {     public static List<Account> getAccounts(List<AccountSimulation> accountSimulations){         List<Account> accounts = new ArrayList<>();          for (AccountSimulation accountSimulation :accountSimulations) {              Account account = new Account(accountSimulation.getPublicKey(), accountSimulation.getDigitalDollarBalance());             accounts.add(account);         }         return accounts;     } }","package International_Trade_Union.simulation;    import International_Trade_Union.model.Keys; import International_Trade_Union.utils.UtilsSecurity; import International_Trade_Union.utils.base.Base; import International_Trade_Union.utils.base.Base58;  import java.security.InvalidAlgorithmParameterException; import java.security.NoSuchAlgorithmException; import java.security.NoSuchProviderException; import java.security.spec.InvalidKeySpecException; import java.util.ArrayList; import java.util.List;  public class GenerateAccountsSimulation {     public static List<AccountSimulation> accountSimulations(int count) throws InvalidAlgorithmParameterException, NoSuchAlgorithmException, NoSuchProviderException, InvalidKeySpecException {         Keys keyPair = null;         List<AccountSimulation> list = new ArrayList<>();         Base base = new Base58();         for (int i = 0; i < count; i++) {             keyPair = UtilsSecurity.generateKeyPair();             String pub =keyPair.getPubkey();             String priv = keyPair.getPrivkey();             AccountSimulation accountSimulation = new AccountSimulation(pub, priv, 0.0, 0.0);             list.add(accountSimulation);         }         return list;      } }","package International_Trade_Union.utils.base;  public interface Base {     String encode(byte[] input);     byte[] decode(String input); }","package International_Trade_Union.utils.base;    /*  * Copyright 2011 Google Inc.  * Copyright 2018 Andreas Schildbach  *  * From https://github.com/bitcoinj/bitcoinj/blob/master/core/src/main/java/org/bitcoinj/core/Base58.java  *  * Licensed under the Apache License, Version 2.0 (the \"License\");  * you may not use this file except in compliance with the License.  * You may obtain a copy of the License at  *  *    http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an \"AS IS\" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */  import java.math.BigInteger; import java.util.Arrays;  /**  * Base58 is a way to encode Bitcoin addresses (or arbitrary data) as alphanumeric strings.  * <p>  * Note that this is not the same base58 as used by Flickr, which you may find referenced around the Internet.  * <p>  * Satoshi explains: why base-58 instead of standard base-64 encoding?  * <ul>  * <li>Don't want 0OIl characters that look the same in some fonts and  *     could be used to create visually identical looking minerAccount numbers.</li>  * <li>A string with non-alphanumeric characters is not as easily accepted as an minerAccount number.</li>  * <li>E-mail usually won't line-break if there's no punctuation to break at.</li>  * <li>Doubleclicking selects the whole number as one word if it's all alphanumeric.</li>  * </ul>  * <p>  * However, note that the encoding/decoding runs in O(n&sup2;) time, so it is not useful for large data.  * <p>  * The basic idea of the encoding is to treat the data bytes as a large number represented using  * base-256 digits, convert the number to be represented using base-58 digits, preserve the exact  * number of leading zeros (which are otherwise lost during the mathematical operations on the  * numbers), and finally represent the resulting base-58 digits as alphanumeric ASCII characters.  */ public class Base58 implements Base {     public static final char[] ALPHABET = \"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz\".toCharArray();     private static final char ENCODED_ZERO = ALPHABET[0];     private static final int[] INDEXES = new int[128];     static {         Arrays.fill(INDEXES, -1);         for (int i = 0; i < ALPHABET.length; i++) {             INDEXES[ALPHABET[i]] = i;         }     }      /**      * Encodes the given bytes as a base58 string (no checksum is appended).      *      * @param input the bytes to encode      * @return the base58-encoded string      */     public String encode(byte[] input) {         if (input.length == 0) {             return \"\";         }         // Count leading zeros.         int zeros = 0;         while (zeros < input.length && input[zeros] == 0) {             ++zeros;         }         // Convert base-256 digits to base-58 digits (plus conversion to ASCII characters)         input = Arrays.copyOf(input, input.length); // since we modify it in-place         char[] encoded = new char[input.length * 2]; // upper bound         int outputStart = encoded.length;         for (int inputStart = zeros; inputStart < input.length; ) {             encoded[--outputStart] = ALPHABET[divmod(input, inputStart, 256, 58)];             if (input[inputStart] == 0) {                 ++inputStart; // optimization - skip leading zeros             }         }         // Preserve exactly as many leading encoded zeros in output as there were leading zeros in input.         while (outputStart < encoded.length && encoded[outputStart] == ENCODED_ZERO) {             ++outputStart;         }         while (--zeros >= 0) {             encoded[--outputStart] = ENCODED_ZERO;         }         // Return encoded string (including encoded leading zeros).         return new String(encoded, outputStart, encoded.length - outputStart);     }      /**      * Decodes the given base58 string into the original data bytes.      *      * @param input the base58-encoded string to decode      * @return the decoded data bytes      */     public byte[] decode(String input) {         if (input.length() == 0) {             return new byte[0];         }         // Convert the base58-encoded ASCII chars to a base58 byte sequence (base58 digits).         byte[] input58 = new byte[input.length()];         for (int i = 0; i < input.length(); ++i) {             char c = input.charAt(i);             int digit = c < 128 ? INDEXES[c] : -1;             if (digit < 0) {                 throw new IllegalStateException(\"InvalidCharacter in base 58\");             }             input58[i] = (byte) digit;         }         // Count leading zeros.         int zeros = 0;         while (zeros < input58.length && input58[zeros] == 0) {             ++zeros;         }         // Convert base-58 digits to base-256 digits.         byte[] decoded = new byte[input.length()];         int outputStart = decoded.length;         for (int inputStart = zeros; inputStart < input58.length; ) {             decoded[--outputStart] = divmod(input58, inputStart, 58, 256);             if (input58[inputStart] == 0) {                 ++inputStart; // optimization - skip leading zeros             }         }         // Ignore extra leading zeroes that were added during the calculation.         while (outputStart < decoded.length && decoded[outputStart] == 0) {             ++outputStart;         }         // Return decoded data (including original number of leading zeros).         return Arrays.copyOfRange(decoded, outputStart - zeros, decoded.length);     }      public  BigInteger decodeToBigInteger(String input) {         return new BigInteger(1, decode(input));     }      /**      * Divides a number, represented as an array of bytes each containing a single digit      * in the specified base, by the given divisor. The given number is modified in-place      * to contain the quotient, and the return value is the remainder.      *      * @param number the number to divide      * @param firstDigit the index within the array of the first non-zero digit      *        (this is used for optimization by skipping the leading zeros)      * @param base the base in which the number's digits are represented (up to 256)      * @param divisor the number to divide by (up to 256)      * @return the remainder of the division operation      */     private byte divmod(byte[] number, int firstDigit, int base, int divisor) {         // this is just long division which accounts for the base of the input digits         int remainder = 0;         for (int i = firstDigit; i < number.length; i++) {             int digit = (int) number[i] & 0xFF;             int temp = remainder * base + digit;             number[i] = (byte) (temp / divisor);             remainder = temp % divisor;         }         return (byte) remainder;     } }","package International_Trade_Union.utils;    import International_Trade_Union.setings.Seting; import International_Trade_Union.model.Account;  import java.io.File; import java.io.IOException; import java.security.InvalidKeyException; import java.security.NoSuchAlgorithmException; import java.security.NoSuchProviderException; import java.security.SignatureException; import java.security.spec.InvalidKeySpecException; import java.util.ArrayList; import java.util.List; import java.util.Map; import java.util.stream.Collectors;  public class SaveBalances {      public static void saveBalances(Map<String, Account> balances, String filename) throws IOException, NoSuchAlgorithmException, SignatureException, InvalidKeySpecException, NoSuchProviderException, InvalidKeyException {         int fileLimit = Seting.SIZE_FILE_LIMIT * 1024 * 1024;          //папка чтобы проверить есть ли         File folder = new File(filename);         List<String> files = new ArrayList<>();         for (File file : folder.listFiles()) {             if(!file.isDirectory()){                 files.add(file.getAbsolutePath());             }         }          int count = 0;         files = files.stream().sorted().collect(Collectors.toList());         String nextFile = \"\";          if (files.size() > 0) {             nextFile = files.get(files.size()-1);              count = Integer.parseInt(nextFile.replaceAll(\"[^\\\\d]\", \"\"));           }          File file = new File(nextFile);          if(file.length() >= fileLimit){             count++;          }          nextFile = filename + count + \".txt\";          List<String> jsons = new ArrayList<>();         for (Map.Entry<String, Account> stringAccountEntry : balances.entrySet()) {             String json = UtilsJson.objToStringJson(stringAccountEntry.getValue());             jsons.add(json);         }  //        String json = UtilsJson.objToStringJson(minerAccount); //        UtilsFileSaveRead.save(json + \"\\n\", nextFile);         UtilsFileSaveRead.saves(jsons, nextFile, true);      }      public static Map<String, Account> readLineObject(String filename ) throws IOException, NoSuchAlgorithmException, InvalidKeySpecException, SignatureException, NoSuchProviderException, InvalidKeyException {         List<Account> accounts = new ArrayList<>();         File folder = new File(filename);         for (final File fileEntry : folder.listFiles()) {             if (fileEntry.isDirectory()) {                 System.out.println(\"is directory \" + fileEntry.getAbsolutePath());             } else {                 List<String> list = UtilsFileSaveRead.reads(fileEntry.getAbsolutePath());                 for (String s : list) {                    Account account = UtilsJson.jsonToAccount(s);                     accounts.add(account);                 }              }         }         Map<String, Account> balances = accounts                 .stream()                 .collect(Collectors.toMap(Account::getAccount, t->t, (v1, v2) -> v1));         return balances;     } }","package International_Trade_Union.utils;    import International_Trade_Union.model.Account; import International_Trade_Union.setings.Seting;  import java.util.ArrayList; import java.util.List;  public class UtilAccounts {  //    поиск аккаунта по адрессу     public static Account serchAccountByAddress(List<Account> accountList, String address){         Account result = null;         for (Account account : accountList) {             if(account.getAccount().equals(address)){                 result = account; //                System.out.println(String.format(\"find minerAccount: %s, address %s\", minerAccount.getAccount(), address));                 return result;             }         }         return result;     } //    возвращает список счетов чья наличность больше n     public static List<Account> allAccountsRemnantUpperLimit(              List<Account> accountList, double bottomLineMoney){         List<Account> accounts = new ArrayList<>();                  for (Account account : accountList) {                      if(account.getDigitalDollarBalance()>bottomLineMoney)                         accounts.add(account);                 }               return accounts;     }  //    подсчитывает общий баланс всех участников     public static double getAllBalance( List<Account> accountList){         double allBalance = 0.0;              for (Account account : accountList) {                 if(!account.getAccount().equals(Seting.BASIS_ADDRESS))                     allBalance+=account.getDigitalDollarBalance();             }           return allBalance;     }     }","package International_Trade_Union.utils;  import International_Trade_Union.entity.DtoTransaction.DtoTransaction; import International_Trade_Union.setings.Seting;  import java.io.File; import java.io.IOException; import java.security.InvalidKeyException; import java.security.NoSuchAlgorithmException; import java.security.NoSuchProviderException; import java.security.SignatureException; import java.security.spec.InvalidKeySpecException; import java.util.ArrayList; import java.util.HashSet; import java.util.List; import java.util.Set; import java.util.stream.Collectors;  public class UtilsAllAddresses {     public static void saveAllAddresses(String adress, String filename) throws IOException, NoSuchAlgorithmException, SignatureException, InvalidKeySpecException, NoSuchProviderException, InvalidKeyException {         int fileLimit = Seting.SIZE_FILE_LIMIT * 1024 * 1024;          //папка чтобы проверить есть ли         File folder = new File(filename);         List<String> files = new ArrayList<>();         for (File file : folder.listFiles()) {             if(!file.isDirectory()){                 files.add(file.getAbsolutePath());             }         }           int count = 0;         files = files.stream().sorted().collect(Collectors.toList());         String nextFile = \"\";          if (files.size() > 0) {             nextFile = files.get(files.size()-1);              count = Integer.parseInt(nextFile.replaceAll(\"[^\\\\d]\", \"\"));           }          File file = new File(nextFile);          if(file.length() >= fileLimit){             count++;          }          nextFile = filename + count + \".txt\";          String json = UtilsJson.objToStringJson(adress);         UtilsFileSaveRead.save(json + \"\\n\", nextFile);      }      public static Set<String> readLineObject(String filename ) throws IOException, NoSuchAlgorithmException, InvalidKeySpecException, SignatureException, NoSuchProviderException, InvalidKeyException {         Set<String> allAddresses = new HashSet<>();         File folder = new File(filename);         for (final File fileEntry : folder.listFiles()) {             if (fileEntry.isDirectory()) {                 System.out.println(\"is directory \" + fileEntry.getAbsolutePath());             } else {                 Set<String> list = UtilsFileSaveRead.readSet(fileEntry.getAbsolutePath())                         .stream().collect(Collectors.toSet());                 for (String s : list) {                     allAddresses.add(s);                 }              }         }          allAddresses = allAddresses                 .stream()                 .collect(Collectors.toSet());           return allAddresses;     }  }","package International_Trade_Union.utils;    import International_Trade_Union.entity.DtoTransaction.DtoTransaction; import International_Trade_Union.entity.blockchain.Blockchain; import International_Trade_Union.entity.blockchain.block.Block; import International_Trade_Union.setings.Seting; import International_Trade_Union.model.Account; import International_Trade_Union.vote.VoteEnum;  import java.io.IOException; import java.security.*; import java.security.spec.InvalidKeySpecException; import java.util.*;   public class UtilsBalance {      //подсчет по штучно баланса     public  static Map<String, Account> calculateBalance(Map<String, Account> balances, Block block) throws IOException, NoSuchAlgorithmException, SignatureException, InvalidKeySpecException, NoSuchProviderException, InvalidKeyException {           double percent = Seting.ANNUAL_MAINTENANCE_FREE_DIGITAL_DOLLAR_YEAR / Seting.HALF_YEAR;         double digitalReputationPercent = Seting.ANNUAL_MAINTENANCE_FREE_DIGITAL_STOCK_YEAR / Seting.HALF_YEAR;             int i = (int) block.getIndex();               for (int j = 0; j < block.getDtoTransactions().size(); j++) {                 int BasisSendCount = 0;                   DtoTransaction transaction = block.getDtoTransactions().get(j);                  if(transaction.getSender().startsWith(Seting.NAME_LAW_ADDRESS_START)){                     System.out.println(\"law balance cannot be sender\");                     continue;                 }                 if (transaction.verify()) {                     if(transaction.getSender().equals(Seting.BASIS_ADDRESS))                         BasisSendCount++;                       Account sender = getBalance(transaction.getSender(), balances);                     Account customer = getBalance(transaction.getCustomer(), balances);                      boolean sendTrue = true;                     if(sender.getAccount().equals(Seting.BASIS_ADDRESS) && BasisSendCount > 2){                         System.out.println(\"Basis address can send only two the base address can send no more than two times per block:\" + Seting.BASIS_ADDRESS);                         continue;                     }                      double minerRewards = Seting.DIGITAL_DOLLAR_REWARDS_BEFORE;                     double digitalReputationForMiner = Seting.DIGITAL_STOCK_REWARDS_BEFORE;                        if(sender.getAccount().equals(Seting.BASIS_ADDRESS) ){                        if(i > 1 && (transaction.getDigitalDollar() > minerRewards || transaction.getDigitalStockBalance() > digitalReputationForMiner )){                            System.out.println(\"rewards cannot be upper than \" + minerRewards);                            continue;                        }                         if(!customer.getAccount().equals(block.getFounderAddress()) && !customer.getAccount().equals(block.getMinerAddress())){                             System.out.println(\"Basis address can send only to founder or miner\");                             continue;                         }                     }                     sendTrue = UtilsBalance.sendMoney(sender, customer, transaction.getDigitalDollar(), transaction.getDigitalStockBalance(), transaction.getBonusForMiner(), transaction.getVoteEnum());                      //если транзация валидная то записать данн иыезменения в баланс                     if(sendTrue){                         balances.put(sender.getAccount(), sender);                         balances.put(customer.getAccount(), customer);                     }                  }              }           if (i != 0 && i / Seting.COUNT_BLOCK_IN_DAY % (Seting.YEAR / Seting.HALF_YEAR) == 0.0) {              for (Map.Entry<String, Account> changeBalance : balances.entrySet()) {                 Account change = changeBalance.getValue();                 change.setDigitalStockBalance(change.getDigitalStockBalance() - UtilsUse.countPercents(change.getDigitalStockBalance(), digitalReputationPercent));                 change.setDigitalDollarBalance(change.getDigitalDollarBalance() - UtilsUse.countPercents(change.getDigitalDollarBalance(), percent));             }         }           return balances;      }     //подсчет целиком баланса     public static Map<String, Account> calculateBalances(List<Block> blocks) throws IOException, NoSuchAlgorithmException, SignatureException, InvalidKeySpecException, NoSuchProviderException, InvalidKeyException {         Map<String, Account> balances = new HashMap<>();         for (Block block :  blocks) {             calculateBalance(balances, block);         }          return balances;      }        public static Account getBalance(String address, Map<String, Account> balances) {         if (balances.containsKey(address)) {             return balances.get(address);         } else {             Account account = new Account(address, 0.0, 0.0);             return account;         }     }       public static Account findAccount(Blockchain blockList, String address) throws IOException, NoSuchAlgorithmException, SignatureException, InvalidKeySpecException, NoSuchProviderException, InvalidKeyException {         Map<String, Account> accountMap = calculateBalances(blockList.getBlockchainList());         Account account = accountMap.get(address);         return account != null? account: new Account(address, 0.0, 0.0);     }      public static boolean sendMoney(Account senderAddress, Account recipientAddress, double digitalDollar, double digitalReputation, double minerRewards) throws NoSuchAlgorithmException, InvalidKeySpecException, IOException, SignatureException, NoSuchProviderException, InvalidKeyException {         return sendMoney(senderAddress, recipientAddress, digitalDollar, digitalReputation, minerRewards, VoteEnum.YES);     }      public static boolean sendMoney(Account senderAddress, Account recipientAddress, double digitalDollar, double digitalReputation, double minerRewards, VoteEnum voteEnum) throws NoSuchAlgorithmException, InvalidKeySpecException, NoSuchProviderException, IOException, SignatureException, InvalidKeyException {         double remnantDigitalDollar = 0.0;         double remnantDigitalReputation = 0.0;         boolean sendTrue = true;         if (senderAddress.getAccount().equals(recipientAddress.getAccount())) {             System.out.println(\"sender %s, recipient %s cannot be equals! Error!\".format(senderAddress.getAccount(), recipientAddress.getAccount()));             sendTrue = false;         }          remnantDigitalDollar = senderAddress.getDigitalDollarBalance();         remnantDigitalReputation = senderAddress.getDigitalStockBalance();          if (!senderAddress.getAccount().equals(Seting.BASIS_ADDRESS)) {             if(remnantDigitalDollar < digitalDollar + minerRewards){                 sendTrue = false;             }             else if(remnantDigitalReputation < digitalReputation){                     System.out.printf(\"sender power %f, les than powerSend:  %f\\n\",                             senderAddress.getDigitalStockBalance(), digitalReputation);                     sendTrue = false;              } else if (recipientAddress.getAccount().equals(Seting.BASIS_ADDRESS)) {                 System.out.println(\"Basis canot to be recipient;\");                 sendTrue = false;             } else {                  senderAddress.setDigitalDollarBalance(senderAddress.getDigitalDollarBalance() - digitalDollar);                 senderAddress.setDigitalStockBalance(senderAddress.getDigitalStockBalance() - digitalReputation);                 recipientAddress.setDigitalDollarBalance(recipientAddress.getDigitalDollarBalance() + digitalDollar);                 //сделано чтобы можно было увеличить или отнять власть                 if (voteEnum.equals(VoteEnum.YES)) {                     recipientAddress.setDigitalStockBalance(recipientAddress.getDigitalStockBalance() + digitalReputation);                 } else if (voteEnum.equals(VoteEnum.NO)) {                     //политика сдерживания.                     recipientAddress.setDigitalStockBalance(recipientAddress.getDigitalStockBalance() - digitalReputation);                 }              }           }  else if (senderAddress.getAccount().equals(Seting.BASIS_ADDRESS)) {              recipientAddress.setDigitalDollarBalance(recipientAddress.getDigitalDollarBalance() + digitalDollar);             recipientAddress.setDigitalStockBalance(recipientAddress.getDigitalStockBalance() + digitalReputation);          }         return sendTrue;     } }","package International_Trade_Union.utils;   import com.fasterxml.jackson.core.JsonProcessingException; import International_Trade_Union.config.BLockchainFactory; import International_Trade_Union.config.BlockchainFactoryEnum; import International_Trade_Union.entity.DtoTransaction.DtoTransaction; import International_Trade_Union.entity.blockchain.Blockchain; import International_Trade_Union.entity.blockchain.block.Block; import International_Trade_Union.setings.Seting;   import java.io.*; import java.security.*; import java.security.spec.InvalidKeySpecException; import java.util.*; import java.util.stream.Collectors;  public class UtilsBlock {      public static void saveBlocks(List<Block> blocks, String filename) throws IOException {         int fileLimit = Seting.SIZE_FILE_LIMIT * 1024 * 1024;          //папка чтобы проверить есть ли         File folder = new File(filename);         List<String> files = new ArrayList<>();         for (File file : folder.listFiles()) {             if(!file.isDirectory()){                 files.add(file.getAbsolutePath());             }         }          int count = 0;         files = files.stream().sorted().collect(Collectors.toList());         String nextFile = \"\";          if (files.size() > 0) {             nextFile = files.get(files.size()-1);              count = Integer.parseInt(nextFile.replaceAll(\"[^\\\\d]\", \"\"));           }          File file = new File(nextFile);          if(file.length() >= fileLimit){             count++;          }          nextFile = filename + count + \".txt\";          List<String> jsons = new ArrayList<>();         for (Block block: blocks) {             String json = UtilsJson.objToStringJson(block);             jsons.add(json);         }  //        String json = UtilsJson.objToStringJson(minerAccount); //        UtilsFileSaveRead.save(json + \"\\n\", nextFile);         UtilsFileSaveRead.saves(jsons, nextFile, true);     }     public static void saveBLock(Block block, String filename) throws IOException, NoSuchAlgorithmException, SignatureException, InvalidKeySpecException, NoSuchProviderException, InvalidKeyException {         int fileLimit = Seting.SIZE_FILE_LIMIT * 1024 * 1024;          //папка чтобы проверить есть ли         File folder = new File(filename);         List<String> files = new ArrayList<>();         for (File file : folder.listFiles()) {             if(!file.isDirectory()){                 files.add(file.getAbsolutePath());             }         }           int count = 0;         files = files.stream().sorted().collect(Collectors.toList());         String nextFile = \"\";          if (files.size() > 0) {             nextFile = files.get(files.size()-1);              count = Integer.parseInt(nextFile.replaceAll(\"[^\\\\d]\", \"\"));           }          File file = new File(nextFile);          if(file.length() >= fileLimit){             count++;          }           nextFile = filename + count + \".txt\";          String json = UtilsJson.objToStringJson(block);         UtilsFileSaveRead.save(json + \"\\n\", nextFile);      }        public static List<Block> read(String nameFile) throws FileNotFoundException, JsonProcessingException {         return  UtilsJson.jsonToListBLock(UtilsFileSaveRead.read(nameFile));     }      public static List<Block> readLineObject(String filename ) throws IOException, NoSuchAlgorithmException, InvalidKeySpecException, SignatureException, NoSuchProviderException, InvalidKeyException {         List<Block> blocks = new ArrayList<>();         File folder = new File(filename);          for (final File fileEntry : folder.listFiles()) {             if (fileEntry.isDirectory()) {                 System.out.println(\"is directory \" + fileEntry.getAbsolutePath());             } else {                List<String> list = UtilsFileSaveRead.reads(fileEntry.getAbsolutePath());                 for (String s : list) {                      Block block = UtilsJson.jsonToBLock(s);                     blocks.add(block);                 }              }         }         blocks = blocks                 .stream()                 .sorted(Comparator.comparing(Block::getIndex))                 .collect(Collectors.toList());          return blocks;     }     public static Blockchain readBLock(String nameFile, long BLOCK_GENERATION_INTERVAL, int DIFFICULTY_ADJUSTMENT_INTERVAL, long INTERVAL_TARGET , String ADDRESS_FOUNDER) throws NoSuchAlgorithmException, InvalidKeySpecException, IOException, SignatureException, NoSuchProviderException, InvalidKeyException {         List<Block> blocks = null;         List<List<Block>> list = new ArrayList<>();          File folder = new File(nameFile);          for (final File fileEntry : folder.listFiles()) {             if (fileEntry.isDirectory()) {                 System.out.println(\"is directory \" + fileEntry.getAbsolutePath());             } else {                 blocks = UtilsJson.jsonToListBLock(UtilsFileSaveRead.read(fileEntry.getAbsolutePath()));                 list.add(blocks);             }         }          // new Blockchain(BLOCK_GENERATION_INTERVAL, DIFFICULTY_ADJUSTMENT_INTERVAL, INTERVAL_TARGET, ADDRESS_FOUNDER);         Blockchain blockchain = BLockchainFactory.getBlockchain(BlockchainFactoryEnum.ORIGINAL);         blockchain.setBlockchainList(new ArrayList<>());          for (List<Block> lists : list) {             for (int i = 0; i < lists.size(); i++) {                 blockchain.addBlock(lists.get(i));             }          }          List<Block> blockList = blockchain.getBlockchainList()                 .stream()                 .sorted(Comparator.comparing(Block::getIndex))                 .collect(Collectors.toList());         blockchain.setBlockchainList(blockList);          return blockchain;     }      public static Blockchain readBLock() throws IOException, NoSuchAlgorithmException, InvalidKeySpecException, SignatureException, NoSuchProviderException, InvalidKeyException {        return readBLock(Seting.TEST_FILE_WRITE_INFO, Seting.BLOCK_GENERATION_INTERVAL,  Seting.DIFFICULTY_ADJUSTMENT_INTERVAL, Seting.INTERVAL_TARGET, Seting.ADDRESS_FOUNDER );     }      public static boolean isValidTimestamp(Block newBlock, Block prevBLock, long timestamp){         return (prevBLock.getTimestamp().getTime() - timestamp <newBlock.getTimestamp().getTime())                 && newBlock.getTimestamp().getTime() < System.currentTimeMillis();     }      //https://lhartikk.github.io/jekyll/update/2017/07/13/chapter2.html     //сайт сложности     //https://lhartikk.github.io/jekyll/update/2017/07/13/chapter2.html     //https://tproger.ru/translations/blockchain-explained/      //new https://guicommits.com/building-blockchain-with-python/     public static int difficulty(List<Block> blocks, long BLOCK_GENERATION_INTERVAL, int  DIFFICULTY_ADJUSTMENT_INTERVAL ){          //секунды как часто создается блоки         int difficulty = 1;         Block latestBlock = blocks.get(blocks.size() -1);         if(latestBlock.getIndex() != 0 && latestBlock.getIndex() % DIFFICULTY_ADJUSTMENT_INTERVAL == 0){             difficulty = getAdjustedDifficulty(latestBlock, blocks, BLOCK_GENERATION_INTERVAL, DIFFICULTY_ADJUSTMENT_INTERVAL);             System.out.println(\"difficulty: change dificulty: \" + difficulty);         }         else {             difficulty =  latestBlock.getHashCompexity();         }         return difficulty == 0? 1: difficulty;     }       private static int getAdjustedDifficulty(Block latestBlock, List<Block> blocks, long BLOCK_GENERATION_INTERVAL, int DIFFICULTY_ADJUSTMENT_INTERVAL){         Block prevAdjustmentBlock = blocks.get(blocks.size() - DIFFICULTY_ADJUSTMENT_INTERVAL);          long timeExpected = BLOCK_GENERATION_INTERVAL * DIFFICULTY_ADJUSTMENT_INTERVAL;         long timeTaken = latestBlock.getTimestamp().getTime() - prevAdjustmentBlock.getTimestamp().getTime();          if(timeTaken < timeExpected / 2){              return prevAdjustmentBlock.getHashCompexity() + 1;         }else if(timeTaken > timeExpected * 2){              return prevAdjustmentBlock.getHashCompexity() - 1;         }else {             return prevAdjustmentBlock.getHashCompexity();         }     }      public static boolean validationOneBlock(             String addressFounder,             Block previusblock,             Block thisBlock,             long blockGenerationInterval,             int difficultyAdjustmentInterval,             List<Block> lastBlock) throws IOException, NoSuchAlgorithmException, SignatureException, InvalidKeySpecException, NoSuchProviderException, InvalidKeyException {          boolean addressFounderReward = false;         boolean addressMinerReward = false;         if(!addressFounder.equals(thisBlock.getFounderAddress())){             System.out.println(\"genesis address not equals block founder: \");             System.out.println(\"genesis address: \" + addressFounder);             System.out.println(\"block address: \" + thisBlock.getFounderAddress());             return false;          }               String actualPrevHash = previusblock.hashForBlockchain();             String recordedPrevHash = thisBlock.getPreviousHash();            boolean validated = true;         int countBasisSendFounder = 0;         int countBasisSendAll = 0;         finished:         for (DtoTransaction transaction : thisBlock.getDtoTransactions()) {             if(transaction.verify() && transaction.getSender().equals(Seting.BASIS_ADDRESS)){                 double minerReward = Seting.DIGITAL_DOLLAR_REWARDS_BEFORE;                 double minerPowerReward = Seting.DIGITAL_STOCK_REWARDS_BEFORE;                    if(transaction.getSender().equals(Seting.BASIS_ADDRESS)&&                         transaction.getCustomer().equals(thisBlock.getMinerAddress()) && transaction.getDigitalDollar() > minerReward                         && thisBlock.getIndex() > 1){                     System.out.println(\"wrong transaction: reward miner wrong digital dollar: \" + minerReward + \" index: \" + thisBlock.getIndex());                     System.out.println(\"sendmoney \" + transaction.getDigitalDollar());                     validated = false;                     break;                 }                 if(transaction.getSender().equals(Seting.BASIS_ADDRESS) &&                         transaction.getCustomer().equals(thisBlock.getMinerAddress()) && transaction.getDigitalStockBalance()                         > minerPowerReward                         && thisBlock.getIndex() > 1){                     System.out.println(\"wrong transaction: reward miner wrong digital stock: \" + minerPowerReward + \" need: \" + transaction.getDigitalStockBalance());                     System.out.println(transaction);                     validated = false;                     break;                 }                   if(transaction.getSender().equals(Seting.BASIS_ADDRESS)                         &&transaction.getCustomer().equals(addressFounder)){                     countBasisSendFounder += 1;                 }                  if(transaction.getSender().equals(Seting.BASIS_ADDRESS)&&!transaction.getCustomer().equals(addressFounder))                 {                     countBasisSendAll +=1;                 }                  if(countBasisSendFounder > 2 && thisBlock.getIndex() > 1){                     System.out.println(\"basis sender send for founder uper one: \" + countBasisSendFounder);                     validated = false;                     break;                 }                  if(countBasisSendAll > 1 && thisBlock.getIndex() > 1){                     System.out.println(\"basis sender send uper two: \" + countBasisSendAll + \" block index: \" + thisBlock.getIndex());                     validated = false;                     break;                 }             }             else if(!transaction.verify()){                 System.out.println(\"wrong transaction: \" + transaction + \" verify: \" + transaction.verify());                 validated = false;                 break finished;             }          }             if(!UtilsUse.hashComplexity(thisBlock.getHashBlock(), thisBlock.getHashCompexity())){                 System.out.println(\"does't start hash with 0\");                 System.out.println(\"this block hash: \" + thisBlock.getHashBlock());                 return false;             }              if(!actualPrevHash.equals(recordedPrevHash)){                 System.out.println(\"Blockchain is invalid, expected: \" + recordedPrevHash + \" actual: \" + actualPrevHash );                 System.out.println(\"index block: \" + thisBlock.getIndex());                 System.out.println(\"wrong chain hash\");                 return false;             }          return validated;     }      public static void deleteFiles(){         UtilsFileSaveRead.deleteAllFiles(Seting.ORIGINAL_BLOCKCHAIN_FILE);          UtilsFileSaveRead.deleteAllFiles(Seting.ORIGINAL_BALANCE_FILE);         UtilsFileSaveRead.deleteAllFiles(Seting.ORIGINAL_ALL_CORPORATION_LAWS_FILE);         UtilsFileSaveRead.deleteAllFiles(Seting.ORIGINAL_ALL_CORPORATION_LAWS_WITH_BALANCE_FILE);     }      public static boolean validation(List<Block> blocks, long BLOCK_GENERATION_INTERVAL, int DIFFICULTY_ADJUSTMENT_INTERVAL ) throws IOException, NoSuchAlgorithmException, SignatureException, InvalidKeySpecException, NoSuchProviderException, InvalidKeyException {         boolean validated = true;         List<Block> temporary = new ArrayList<>();         Block prevBlock  = null;         for (Block block : blocks) {             if(prevBlock == null){                 prevBlock = block;                 temporary.add(block);                 continue;             }              temporary.add(block);              validated = validationOneBlock(block.getFounderAddress(),                     prevBlock,                     block,                     BLOCK_GENERATION_INTERVAL,                     DIFFICULTY_ADJUSTMENT_INTERVAL,                     temporary );             if(validated == false){                  System.out.println(\"ERROR: UtilsBlock: validation: prevBLock.Hash():\" + prevBlock.getHashBlock());                 System.out.println(\"ERROR: UtilsBlock: validation: index:\" + block.getIndex());                 System.out.println(\"ERROR: UtilsBlock: validation: block.Hash():\" + block.getHashBlock());                 System.out.println(\"ERROR: UtilsBlock: validation: BLOCK_GENERATION_INTERVAL:\" + BLOCK_GENERATION_INTERVAL);                 System.out.println(\"ERROR: UtilsBlock: validation: DIFFICULTY_ADJUSTMENT_INTERVAL:\" + DIFFICULTY_ADJUSTMENT_INTERVAL);                 System.out.println(\"ERROR: UtilsBlock: validation: temporary:\" + temporary.size());                 return false;             }             prevBlock = block;         }         return validated;     } }","package International_Trade_Union.utils;  public class UtilsCheckDtoTransaction {  }","package International_Trade_Union.utils;  import java.io.*; import java.util.ArrayList; import java.util.HashSet; import java.util.List; import java.util.Set;  public class UtilsFileSaveRead {      public static void save(String object, String fileName) throws IOException {        save(object, fileName, true);     }     public static void save(String object, String fileName, boolean save){         try(BufferedWriter writer = new BufferedWriter(new FileWriter(fileName, save))) {             writer.write(object);             writer.flush();          }catch (IOException e){             e.printStackTrace();         }       }      public static void saves(List<String> objects, String fileName, boolean save){          try(BufferedWriter writer = new BufferedWriter(new FileWriter(fileName, save))) {              for (String s : objects) {                 writer.write(s + \"\\n\");             }             writer.flush();          }catch (IOException e){             e.printStackTrace();         }     }      public static String read(String file) throws FileNotFoundException {         String text = \"\";         File file1 = new File(file);         if(!file1.exists()){             System.out.println(\"file dosn't have\");             return text;         }         try( BufferedReader reader = new BufferedReader(new FileReader(file))){             while (reader.ready()){                 text += reader.readLine();             }         }catch (IOException e){             e.printStackTrace();         }         return text;     }     public static Set<String> readSet(String file){         Set<String> list = new HashSet<>();          try( BufferedReader reader = new BufferedReader(new FileReader(file))){             while (reader.ready()){                 list.add(reader.readLine());             }         }catch (IOException e){             e.printStackTrace();         }         return list;     }     public static List<String> reads(String file){         List<String> list = new ArrayList<>();          try( BufferedReader reader = new BufferedReader(new FileReader(file))){             while (reader.ready()){                 list.add(reader.readLine());             }         }catch (IOException e){             e.printStackTrace();         }         return list;     }         public static void deleteAllFiles(String path){         File folder = new File(path);         for (File file : folder.listFiles()) {             if(!file.isDirectory()){                 file.delete();             }         }     }      public static void deleteFile(String path){         File file = new File(path);         file.delete();     }  }","package International_Trade_Union.utils;  import com.fasterxml.jackson.core.JsonProcessingException; import com.fasterxml.jackson.core.type.TypeReference; import com.fasterxml.jackson.databind.ObjectMapper; import International_Trade_Union.entity.DtoTransaction.DtoTransaction; import International_Trade_Union.entity.EntityChain; import International_Trade_Union.entity.blockchain.block.Block; import International_Trade_Union.model.Account; import International_Trade_Union.vote.CurrentLawVotes; import International_Trade_Union.vote.LawEligibleForParliamentaryApproval; import International_Trade_Union.vote.Laws;   import java.io.IOException; import java.io.StringWriter; import java.util.List; import java.util.Set;  public class UtilsJson {     public static String objToStringJson(Object object) throws IOException {         ObjectMapper mapper = new ObjectMapper();         StringWriter writer = new StringWriter();         mapper.writeValue(writer, object);         return writer.toString();     }      public static Object jsonToListBLock(String json, Class cls) throws JsonProcessingException {         ObjectMapper mapper = new ObjectMapper();         return mapper.readValue(json, cls);     }      public static List<Block> jsonToListBLock(String json) throws JsonProcessingException {         ObjectMapper mapper = new ObjectMapper();         return mapper.readValue(json, new TypeReference<List<Block>>(){});     }     public static List<Account> jsonToListAccounts(String json) throws JsonProcessingException {         ObjectMapper mapper = new ObjectMapper();         return mapper.readValue(json, new TypeReference<List<Account>>(){});     }      public static Set<String> jsonToSetAddresses(String json) throws  JsonProcessingException{         ObjectMapper mapper = new ObjectMapper();         return mapper.readValue(json, new TypeReference<Set<String>>(){});     }     public static Block jsonToBLock(String json) throws JsonProcessingException {         ObjectMapper mapper = new ObjectMapper();         return mapper.readValue(json, Block.class);     }      public static Laws jsonToLaw(String json) throws JsonProcessingException {         ObjectMapper mapper = new ObjectMapper();         return mapper.readValue(json, Laws.class);     }      public static CurrentLawVotes jsonToVote(String json) throws  JsonProcessingException{         ObjectMapper mapper = new ObjectMapper();         return mapper.readValue(json, CurrentLawVotes.class);     }      public static LawEligibleForParliamentaryApproval jsonToCurrentLaw(String json) throws JsonProcessingException {         ObjectMapper mapper = new ObjectMapper();         return mapper.readValue(json, LawEligibleForParliamentaryApproval.class);     }     public static Account jsonToAccount(String json) throws JsonProcessingException {         ObjectMapper mapper = new ObjectMapper();         return mapper.readValue(json, Account.class);     }     public static EntityChain jsonToEntityChain(String json) throws  JsonProcessingException{         ObjectMapper mapper = new ObjectMapper();         return mapper.readValue(json, EntityChain.class);     }      public static DtoTransaction jsonToDtoTransaction(String json) throws  JsonProcessingException{         ObjectMapper mapper = new ObjectMapper();         return mapper.readValue(json, DtoTransaction.class);      }      public static List<DtoTransaction> jsonToDtoTransactionList(String json) throws  JsonProcessingException{         ObjectMapper mapper = new ObjectMapper();         return mapper.readValue(json, new TypeReference<List<DtoTransaction>>(){});     } }","package International_Trade_Union.utils;    import International_Trade_Union.model.Keys; import International_Trade_Union.utils.base.Base; import International_Trade_Union.utils.base.Base58;  import org.bouncycastle.asn1.ASN1ObjectIdentifier; import org.bouncycastle.asn1.x9.ECNamedCurveTable; import org.bouncycastle.asn1.x9.X9ECParameters; import org.bouncycastle.crypto.params.ECNamedDomainParameters; import org.bouncycastle.crypto.params.ECPublicKeyParameters; import org.bouncycastle.jcajce.provider.asymmetric.ec.BCECPublicKey; import org.bouncycastle.jce.provider.BouncyCastleProvider; import org.bouncycastle.jce.spec.ECNamedCurveParameterSpec; import org.bouncycastle.jce.spec.ECPublicKeySpec; import org.bouncycastle.math.ec.ECCurve; import org.bouncycastle.math.ec.ECPoint;  import java.io.IOException; import java.math.BigInteger; import java.nio.charset.StandardCharsets; import java.security.*; import java.security.interfaces.ECPublicKey; import java.security.spec.*;  //https://metamug.com/article/security/sign-verify-digital-signature-ecdsa-java.html //https://stackoverflow.com/questions/8451205/create-privatekey-and-publickey-having-a-byte-array-encoded-in-base-64 public class UtilsSecurity {     private static final String SPEC = \"secp256k1\";     private static final String ALGO_ECDSA = \"ECDSA\";     private static final String PROVIDER = \"BC\";      static {         Security.addProvider(new org.bouncycastle.jce.provider.BouncyCastleProvider());     }     public static Keys generateKeyPair() throws NoSuchAlgorithmException, InvalidAlgorithmParameterException, NoSuchProviderException, InvalidKeySpecException {        Base base = new Base58();         Security.addProvider(new org.bouncycastle.jce.provider.BouncyCastleProvider());         ECGenParameterSpec ecSpec = new ECGenParameterSpec(SPEC);         KeyPairGenerator g = KeyPairGenerator.getInstance(ALGO_ECDSA, PROVIDER);         g.initialize(ecSpec, new SecureRandom());         KeyPair keyPair = g.generateKeyPair();         String pub = base.encode(UtilsSecurity.compressed(keyPair.getPublic().getEncoded()));         String priv = base.encode(keyPair.getPrivate().getEncoded());         Keys keys = new Keys(pub, priv);         return keys;     }      public static PrivateKey privateBytToPrivateKey(byte[] bytes) throws NoSuchAlgorithmException, InvalidKeySpecException, NoSuchProviderException {         EncodedKeySpec privateKeySpec = new PKCS8EncodedKeySpec(bytes);         KeyFactory generator = KeyFactory.getInstance(ALGO_ECDSA, PROVIDER);         return generator.generatePrivate(privateKeySpec);     }      public static PublicKey publicByteToPublicKey(byte[] bytes) throws NoSuchAlgorithmException, InvalidKeySpecException, NoSuchProviderException {         //new X509EncodedKeySpec         EncodedKeySpec publicKeySpec = new X509EncodedKeySpec(bytes);         KeyFactory generator = KeyFactory.getInstance(ALGO_ECDSA, PROVIDER);         return generator.generatePublic(publicKeySpec);     }       public static KeyPair createKeyPairWithPrivkeyPubKey(PrivateKey privateKey, PublicKey publicKey){         return new KeyPair(publicKey, privateKey);     }       public static byte[] sign(PrivateKey privateKey, String hex) throws NoSuchAlgorithmException, NoSuchProviderException, InvalidKeyException, SignatureException, IOException {         Signature signature = Signature.getInstance(ALGO_ECDSA, PROVIDER);         signature.initSign(privateKey);         signature.update(hex.getBytes(StandardCharsets.UTF_8));         byte[] signByte = signature.sign();         return signByte;     }      public static boolean verify(String sha256message, byte[] sign, PublicKey publicKey) throws NoSuchAlgorithmException, NoSuchProviderException, InvalidKeyException, SignatureException {         Signature signature = Signature.getInstance(ALGO_ECDSA, PROVIDER);         signature.initVerify(publicKey);         signature.update(sha256message.getBytes(StandardCharsets.UTF_8));         return signature.verify(sign);     }       public static byte[] compressed(byte[] pub) throws NoSuchAlgorithmException, NoSuchProviderException, InvalidAlgorithmParameterException, InvalidKeySpecException {          // === NOT PART OF THE CODE, JUST GETTING TEST VECTOR ===         PublicKey publicKey = UtilsSecurity.publicByteToPublicKey(pub);          ECPublicKey key = (ECPublicKey) publicKey;         byte[] x = key.getW().getAffineX().toByteArray();         byte[] y = key.getW().getAffineY().toByteArray();          // assumes that x and y are (unsigned) big endian encoded         BigInteger xbi = new BigInteger(1, x);         BigInteger ybi = new BigInteger(1, y);         X9ECParameters x9 = ECNamedCurveTable.getByName(SPEC);         ASN1ObjectIdentifier oid = ECNamedCurveTable.getOID(SPEC);         ECCurve curve = x9.getCurve();         ECPoint point = curve.createPoint(xbi, ybi);         ECNamedDomainParameters dParams = new ECNamedDomainParameters(oid,                 x9.getCurve(), x9.getG(), x9.getN(), x9.getH(), x9.getSeed());         ECPublicKeyParameters pubKey = new ECPublicKeyParameters(point, dParams);         System.out.println(pubKey);          // some additional encoding tricks         byte[] compressed = point.getEncoded(true);         return compressed;     }     public static ECPublicKey decodeKey(byte[] encoded) {          ECNamedCurveParameterSpec params = org.bouncycastle.jce.ECNamedCurveTable.getParameterSpec(SPEC);         org.bouncycastle.jce.spec.ECPublicKeySpec keySpec = new ECPublicKeySpec(params.getCurve().decodePoint(encoded), params);         return new BCECPublicKey(ALGO_ECDSA, keySpec, BouncyCastleProvider.CONFIGURATION);     } }","package International_Trade_Union.utils;  import International_Trade_Union.entity.DtoTransaction.DtoTransaction; import International_Trade_Union.entity.blockchain.block.Block; import International_Trade_Union.setings.Seting;  import java.io.File; import java.io.IOException; import java.security.InvalidKeyException; import java.security.NoSuchAlgorithmException; import java.security.NoSuchProviderException; import java.security.SignatureException; import java.security.spec.InvalidKeySpecException; import java.util.ArrayList; import java.util.Comparator; import java.util.List; import java.util.stream.Collectors;  public class UtilsTransaction {     public static void saveAllTransaction(DtoTransaction dtoTransaction, String filename) throws IOException, NoSuchAlgorithmException, SignatureException, InvalidKeySpecException, NoSuchProviderException, InvalidKeyException {         int fileLimit = Seting.SIZE_FILE_LIMIT * 1024 * 1024;          //папка чтобы проверить есть ли         File folder = new File(filename);         List<String> files = new ArrayList<>();         for (File file : folder.listFiles()) {             if(!file.isDirectory()){                 files.add(file.getAbsolutePath());             }         }           int count = 0;         files = files.stream().sorted().collect(Collectors.toList());         String nextFile = \"\";          if (files.size() > 0) {             nextFile = files.get(files.size()-1);              count = Integer.parseInt(nextFile.replaceAll(\"[^\\\\d]\", \"\"));           }          File file = new File(nextFile);          if(file.length() >= fileLimit){             count++;          }          nextFile = filename + count + \".txt\";          String json = UtilsJson.objToStringJson(dtoTransaction);         UtilsFileSaveRead.save(json + \"\\n\", nextFile);      }      public static List<DtoTransaction> readLineObject(String filename ) throws IOException, NoSuchAlgorithmException, InvalidKeySpecException, SignatureException, NoSuchProviderException, InvalidKeyException {         List<DtoTransaction> dtoTransactions = new ArrayList<>();         File folder = new File(filename);         for (final File fileEntry : folder.listFiles()) {             if (fileEntry.isDirectory()) {                 System.out.println(\"is directory \" + fileEntry.getAbsolutePath());             } else {                 List<String> list = UtilsFileSaveRead.reads(fileEntry.getAbsolutePath());                 for (String s : list) {                      DtoTransaction dtoTransaction = UtilsJson.jsonToDtoTransaction(s);                     dtoTransactions.add(dtoTransaction);                 }              }         }         dtoTransactions = dtoTransactions                 .stream()                 .collect(Collectors.toList());          return dtoTransactions;     }  }","package International_Trade_Union.utils;    import International_Trade_Union.setings.Seting;  import java.io.IOException;  import java.math.BigDecimal; import java.nio.charset.Charset; import java.nio.charset.StandardCharsets; import java.security.MessageDigest; import java.security.NoSuchAlgorithmException; import java.util.HashMap; import java.util.List; import java.util.Random; import java.util.Set; import java.util.concurrent.ConcurrentHashMap; import java.util.function.Function; import java.util.function.Predicate; import java.util.regex.Matcher; import java.util.regex.Pattern;  public class UtilsUse {     private static MessageDigest digest;      static {         try {             digest = MessageDigest.getInstance(\"SHA-256\");         } catch (NoSuchAlgorithmException e) {             e.printStackTrace();         }     } //    одно число от другого в процентах     public static Double percentDifferent(Double first, Double second){         return (first / second - 1) * Seting.HUNDRED_PERCENT;     }      //найти моду     public static int mode(List<Integer> array)     {         HashMap<Integer,Integer> hm = new HashMap<Integer,Integer>();         int max  = 1;         int temp = 0;          for(int i = 0; i < array.size(); i++) {              if (hm.get(array.get(i)) != null) {                  int count = hm.get(array.get(i));                 count++;                 hm.put(array.get(i), count);                  if(count > max) {                     max  = count;                     temp = array.get(i);                 }             }              else                 hm.put(array.get(i),1);         }         return temp;     }      public static BigDecimal percentDifferent(BigDecimal first, BigDecimal second){         return first.divide(second).subtract(new BigDecimal(1)).multiply(new BigDecimal(Seting.HUNDRED_PERCENT));     }      public static byte[] sha256(String text){         return digest.digest(text.getBytes(StandardCharsets.UTF_8));     }     public static String sha256hash(String text){         byte[] bytes = sha256(text);         return bytesToHex(bytes);     }      private static String bytesToHex(byte[] hash) {         StringBuilder hexString = new StringBuilder(2 * hash.length);         for (int i = 0; i < hash.length; i++) {             String hex = Integer.toHexString(0xff & hash[i]);             if(hex.length() == 1) {                 hexString.append('0');             }             hexString.append(hex);         }         return hexString.toString();     }      public static String generateRandomStr() {         byte[] array = new byte[7]; // length is bounded by 7         new Random().nextBytes(array);         String generatedString = new String(array, Charset.forName(\"UTF-8\"));          return generatedString;     }      public static double countPercents(double sum, double percent){         return sum * percent / Seting.HUNDRED_PERCENT;     }     public static BigDecimal countPercents(BigDecimal sum, BigDecimal percent){         return sum.multiply(percent).divide(new BigDecimal(Seting.HUNDRED_PERCENT));     }      public  static double countGrowth(long block, double percent, double money){         long year = (long) (block / Seting.COUNT_BLOCK_IN_DAY / (Seting.YEAR / Seting.HALF_YEAR));         double opeartion1 = 1+ (percent / Seting.HALF_YEAR)/Seting.HUNDRED_PERCENT;         double operation2 = Math.pow(opeartion1, year);         double result = money * operation2;         return result;     }      public static boolean hashComplexity(String literral, int hashComplexity){          String regex = \"^[0]{\" + Integer.toString(hashComplexity) + \"}\";         Pattern pattern = Pattern.compile(regex);         Matcher matcher = pattern.matcher(literral);         return matcher.find();     }      public static String hashComplexityStr(String str, int hashComplexity) throws IOException {         int randomNumberProof = 0;         String hash = \"\";         while (true){             randomNumberProof++;             hash = UtilsUse.sha256hash(UtilsJson.objToStringJson(str + randomNumberProof));             if(UtilsUse.hashComplexity(hash.substring(0, hashComplexity), hashComplexity))             {                 break;             }          }         return hash;     }      //для филтрации в стриме, чтобы получить уникальные обекты по полям     public static <T> Predicate<T> distinctByKey(Function<? super T, ?> keyExtractor) {         Set<Object> seen = ConcurrentHashMap.newKeySet();         return t -> seen.add(keyExtractor.apply(t));     }     //подсчитать количество нулей идущих подряд в hash     public static long hashCount(String hash) {         long count = 0;         for (int i = 0; i < hash.length(); i++) {             if(hash.charAt(i) == '0') count++;             else return count;         }         return count;     }      //подсчитывает долю в процентах одного числа от другого     public static double percentageShare(double first, double allNumber){         return (first/allNumber)*Seting.HUNDRED_PERCENT;     }      //опреледеляет ближайщее число к году     public static long nearestDateToYear(long block){         long period = (long) (Seting.COUNT_BLOCK_IN_DAY * Seting.YEAR);         return block / period * period;     }   }","package International_Trade_Union.utils;  import com.fasterxml.jackson.databind.ObjectMapper; import org.apache.http.NameValuePair; import org.apache.http.client.methods.HttpPost; import org.apache.http.message.BasicNameValuePair; import org.json.JSONException;  import javax.net.ssl.HttpsURLConnection; import java.io.*; import java.net.*; import java.nio.charset.Charset; import java.util.ArrayList; import java.util.Base64; import java.util.List;  public class UtilUrl {     public static String readJsonFromUrl(String url) throws IOException, JSONException {         InputStream is = new URL(url).openStream();         try {             BufferedReader rd = new BufferedReader(new InputStreamReader(is, Charset.forName(\"UTF-8\")));             String jsonText = readAll(rd);             ObjectMapper mapper = new ObjectMapper();             return jsonText;         } finally {             System.out.println(\"UtilUrl: readJsonFromUrl: \" + url );             is.close();         }     }      private static String readAll(Reader rd) throws IOException {         StringBuilder sb = new StringBuilder();         int cp;         while ((cp = rd.read()) != -1) {             sb.append((char) cp);         }         return sb.toString();     }      public static String getObject(String jsonObject, String requstStr) throws IOException {         URL url = new URL(requstStr);         HttpURLConnection conn = (HttpURLConnection) url.openConnection(); //        conn.connect();         conn.setReadTimeout(10000);         conn.setConnectTimeout(15000);         conn.setRequestMethod(\"POST\");         conn.setRequestProperty(\"Content-Type\", \"application/json; utf-8\");         conn.setRequestProperty(\"Accept\", \"application/json\");         conn.setDoOutput(true);            try(OutputStream outputStream = conn.getOutputStream()) {             byte[] input = jsonObject.getBytes(\"utf-8\");             outputStream.write(input, 0, input.length);             conn.getResponseCode();         }           conn.connect();         try(BufferedReader br = new BufferedReader(                 new InputStreamReader(conn.getInputStream(), \"utf-8\"))) {             StringBuilder response = new StringBuilder();             String responseLine = null;             while ((responseLine = br.readLine()) != null) {                 response.append(responseLine.trim());             }             return response.toString();          }      }         public static int sendPost(String jsonObject, String requestStr) throws IOException {         int response;         URL url = new URL(requestStr);         HttpURLConnection conn = (HttpURLConnection) url.openConnection(); //        conn.connect();         conn.setReadTimeout(10000);         conn.setConnectTimeout(15000);         conn.setRequestMethod(\"POST\");         conn.setRequestProperty(\"Content-Type\", \"application/json; utf-8\");         conn.setRequestProperty(\"Accept\", \"application/json\");         conn.setDoOutput(true);            try(OutputStream outputStream = conn.getOutputStream()) {             byte[] input = jsonObject.getBytes(\"utf-8\");             outputStream.write(input, 0, input.length);              response = conn.getResponseCode();          }           conn.connect();         return response;     }     }","package International_Trade_Union.vote;  import lombok.Data; import International_Trade_Union.model.Account; import International_Trade_Union.setings.Seting; import org.apache.tomcat.util.net.jsse.JSSEUtil;  import java.util.List; import java.util.Map; import java.util.Objects; import java.util.Set; import java.util.stream.Collectors;  @Data public class CurrentLawVotes {     private String addressLaw;     private Set<String> YES;     private Set<String> NO;       public CurrentLawVotes() {     }      public CurrentLawVotes(String addressLaw, Set<String> YES, Set<String> NO) {         this.addressLaw = addressLaw;         this.YES = YES;         this.NO = NO;     }      //подсчет голосов для палат     public int voteGovernment(             Map<String, Account> balances,             List<String> governments      ) {         int yes = 0;         int no = 0;          List<String> addressGovernment = governments;         for (String s : YES) {             if (addressGovernment.contains(s)) {                 yes += Seting.VOTE_GOVERNMENT;             }          }         for (String s : NO) {             if (addressGovernment.contains(s)) {                 no += Seting.VOTE_GOVERNMENT;             }          }           return yes - no;      }      //для избрания должностных лиц     public double votesLaw(Map<String, Account> balances,                            Map<String, Integer> yesAverage, Map<String, Integer> noAverage) {         double yes = 0.0;         double no = 0.0;           //         for (String s : YES) {              int count = 1;             count = yesAverage.get(s) > 0 ? yesAverage.get(s) : 1;             yes += balances.get(s).getDigitalStockBalance() / Math.pow(count, Seting.POWERING_FOR_VOTING);          }         //         for (String s : NO) {             int count = 1;             count = noAverage.get(s) > 0 ? noAverage.get(s) : 1;             no += balances.get(s).getDigitalStockBalance() / Math.pow(count, Seting.POWERING_FOR_VOTING);          }           return yes - no;     }      //для избрания должностных лиц     public double votes(Map<String, Account> balances,                         Map<String, Integer> yesAverage, Map<String, Integer> noAverage) {         double yes = 0.0;         double no = 0.0;         for (String s : YES) {             int count = 1;             count = yesAverage.get(s) > 0 ? yesAverage.get(s) : 1;             yes += balances.get(s).getDigitalStockBalance() / count;          }         for (String s : NO) {             int count = 1;             count = noAverage.get(s) > 0 ? noAverage.get(s) : 1;             no += balances.get(s).getDigitalStockBalance() / count;          }           return yes - no;     }      @Override     public boolean equals(Object o) {         if (this == o) return true;         if (!(o instanceof CurrentLawVotes)) return false;         CurrentLawVotes that = (CurrentLawVotes) o;         return getAddressLaw().equals(that.getAddressLaw());     }      @Override     public int hashCode() {         return Objects.hash(getAddressLaw());     } }","package International_Trade_Union.vote;  public class CurrentLawVotesAverage { }","package International_Trade_Union.vote;  import lombok.Data;  import java.util.List; import java.util.Objects;  @Data public class CurrentLawVotesEndBalance {     private String addressLaw;     private double votes;     //CORPORATE_COUNCIL_OF_REFEREES     private int votesCorporateCouncilOfReferees;      //BOARD_OF_DIRECTORS     private int votesBoardOfDirectors;     private int votesBoardOfShareholders;      //GENERAL_EXECUTIVE_DIRECTOR     private int voteGeneralExecutiveDirector;     private int voteHightJudge;      private int founderVote;     private String packageName;     private List<String> laws;      public CurrentLawVotesEndBalance() {     }      public CurrentLawVotesEndBalance             (String addressLaw,              String packageName,              double votes,              int votesCorporateCouncilOfReferees,              int votesBoardOfDirectors,              int votesBoardOfShareholders,              int voteGeneralExecutiveDirector,              int voteHightJudge,                     int founderVote,              List<String> laws) {         this.addressLaw = addressLaw;         this.packageName = packageName;         this.votesCorporateCouncilOfReferees = votesCorporateCouncilOfReferees;         this.votesBoardOfShareholders = votesBoardOfShareholders;         this.votesBoardOfDirectors = votesBoardOfDirectors;         this.voteGeneralExecutiveDirector = voteGeneralExecutiveDirector;         this.voteHightJudge = voteHightJudge;         this.founderVote = founderVote;          this.votes = votes;         this.laws = laws;      }      @Override     public boolean equals(Object o) {         if (this == o) return true;         if (!(o instanceof CurrentLawVotesEndBalance)) return false;         CurrentLawVotesEndBalance that = (CurrentLawVotesEndBalance) o;         return getAddressLaw().equals(that.getAddressLaw());     }      @Override     public int hashCode() {         return Objects.hash(getAddressLaw());     } }","package International_Trade_Union.vote;   import lombok.Data; import International_Trade_Union.model.Account;  import java.util.Objects;  @Data public class LawEligibleForParliamentaryApproval {     public LawEligibleForParliamentaryApproval(Account account, Laws laws) {         this.account = account;         this.laws = laws;         this.name = account.getAccount();     }      public LawEligibleForParliamentaryApproval() {     }      private String name;     private Account account;     private Laws laws;      @Override     public boolean equals(Object o) {         if (this == o) return true;         if (!(o instanceof LawEligibleForParliamentaryApproval)) return false;         LawEligibleForParliamentaryApproval that = (LawEligibleForParliamentaryApproval) o;         return Objects.equals(getName(), that.getName()) && Objects.equals(getAccount(), that.getAccount()) && Objects.equals(getLaws(), that.getLaws());     }      @Override     public int hashCode() {         return Objects.hash(getName(), getAccount(), getLaws());     } }","package International_Trade_Union.vote;   import lombok.Data; import International_Trade_Union.setings.Seting; import International_Trade_Union.utils.UtilsJson; import International_Trade_Union.utils.UtilsUse;  import java.io.IOException; import java.util.List; import java.util.Objects;  @Data public class Laws {     //название пакета закона     String packetLawName;     List<String> laws;     String hashLaw;      public Laws() {     }      public Laws(String packetLawName, List<String> laws) throws IOException {         this.packetLawName = packetLawName;         this.laws = laws;         this.hashLaw = Seting.NAME_LAW_ADDRESS_START + UtilsUse.sha256hash(UtilsJson.objToStringJson(this));     }      @Override     public boolean equals(Object o) {         if (this == o) return true;         if (!(o instanceof Laws)) return false;         Laws laws = (Laws) o;         return getHashLaw().equals(laws.getHashLaw());     }      @Override     public int hashCode() {         return Objects.hash(getHashLaw());     } }","package International_Trade_Union.vote;  import International_Trade_Union.entity.DtoTransaction.DtoTransaction; import International_Trade_Union.entity.blockchain.Blockchain; import International_Trade_Union.entity.blockchain.block.Block; import International_Trade_Union.governments.Director; import International_Trade_Union.governments.Directors; import International_Trade_Union.governments.UtilsGovernment; import International_Trade_Union.model.Account; import International_Trade_Union.model.FIndPositonHelperData; import International_Trade_Union.setings.Seting;  import java.io.IOException; import java.security.InvalidKeyException; import java.security.NoSuchAlgorithmException; import java.security.NoSuchProviderException; import java.security.SignatureException; import java.security.spec.InvalidKeySpecException; import java.util.*; import java.util.stream.Collectors;  public class UtilsCurrentLaw {     //подсчет по штучно баланса     public static Map<String, CurrentLawVotes> calculateVote(Map<String, CurrentLawVotes> votes, List<Account> governments, Block block) throws IOException, NoSuchAlgorithmException, SignatureException, InvalidKeySpecException, NoSuchProviderException, InvalidKeyException {          for (int j = 0; j < block.getDtoTransactions().size(); j++) {             DtoTransaction transaction = block.getDtoTransactions().get(j);              if (transaction.getSender().startsWith(Seting.NAME_LAW_ADDRESS_START)) {                 System.out.println(\"law balance cannot be sender\");                 continue;             }             if (transaction.verify() && transaction.getCustomer().startsWith(Seting.NAME_LAW_ADDRESS_START)) {                 for (Account account : governments) {                     //основатель не может участвовать в голосовании                     //!block.getFounderAddress().equals(transaction.getSender())                     if (transaction.getSender().equals(account.getAccount())) {                         CurrentLawVotes currentLawVotes = votes.get(transaction.getCustomer());                          if (currentLawVotes == null) {                             currentLawVotes = new CurrentLawVotes();                             currentLawVotes.setAddressLaw(transaction.getCustomer());                             currentLawVotes.setYES(new HashSet<>());                             currentLawVotes.setNO(new HashSet<>());                              votes.put(transaction.getCustomer(), currentLawVotes);                         }                          if (transaction.getVoteEnum().equals(VoteEnum.YES)) {                              currentLawVotes.getYES().add(transaction.getSender());                             currentLawVotes.getNO().remove(transaction.getSender());                          } else if (transaction.getVoteEnum().equals(VoteEnum.NO)) {                             currentLawVotes.getNO().add(transaction.getSender());                             currentLawVotes.getYES().remove(transaction.getSender());                         }                     }                 }              }          }           return votes;      }      //подсчет целиком баланса     public static Map<String, CurrentLawVotes> calculateVotes(List<Account> governments, List<Block> blocks) throws IOException, NoSuchAlgorithmException, SignatureException, InvalidKeySpecException, NoSuchProviderException, InvalidKeyException {         Map<String, CurrentLawVotes> votes = new HashMap<>();         for (Block block : blocks) {             calculateVote(votes, governments, block);         }          return votes;      }      //возвращаяет усредненное количество голосов,     //суть проста если есть один акаунт и он имеет 100 акций     //и проголосовал за один закон то все сто акций будут для этого закона как сто голосов     //если за два закона то 100/2 то есть если он на протяжении трех лет проголосовал     //за n законов, то его голоса делятся на n.     public static Map<String, Integer> calculateAverageVotesYes(Map<String, CurrentLawVotes> votesMap) {         Map<String, Integer> voteAverage = new HashMap<>();         for (Map.Entry<String, CurrentLawVotes> current : votesMap.entrySet()) {             for (String yesVoteAddress : current.getValue().getYES()) {                 if (voteAverage.containsKey(yesVoteAddress)) {                     int count = voteAverage.get(yesVoteAddress);                     voteAverage.put(yesVoteAddress, count + 1);                 } else {                     int count = 1;                     voteAverage.put(yesVoteAddress, count);                 }             }          }         return voteAverage;     }      //подсчитывает голоса No     public static Map<String, Integer> calculateAverageVotesNo(Map<String, CurrentLawVotes> votesMap) {         Map<String, Integer> voteAverage = new HashMap<>();         for (Map.Entry<String, CurrentLawVotes> current : votesMap.entrySet()) {             for (String yesVoteAddress : current.getValue().getNO()) {                 if (voteAverage.containsKey(yesVoteAddress)) {                     int count = voteAverage.get(yesVoteAddress);                     voteAverage.put(yesVoteAddress, count + 1);                 } else {                     int count = 1;                     voteAverage.put(yesVoteAddress, count);                 }             }          }         return voteAverage;     }        //возвращает списки позиций     public static Map<Director, List<String>> findPositions(              Map<String, Account> balances,             Blockchain blockchain,             List<LawEligibleForParliamentaryApproval> allGovernment,             List<Account> BoardOfShareholders,             Map<Director, FIndPositonHelperData> fIndPositonHelperData      ) throws IOException, NoSuchAlgorithmException, InvalidKeySpecException, SignatureException, NoSuchProviderException, InvalidKeyException {         //список должностей         Directors directors = new Directors();         Map<Director, List<LawEligibleForParliamentaryApproval>> positionsListMap = new HashMap<>();         //добавление всех должностей         for (Director higherSpecialPositions : directors.getDirectors()) {             positionsListMap.put(higherSpecialPositions, UtilsLaws.getPossions(allGovernment, higherSpecialPositions));         }         //список законов с голосами         Map<Director, List<CurrentLawVotesEndBalance>> curentLawVotesEndBalance = new HashMap<>();         for (Map.Entry<Director, List<LawEligibleForParliamentaryApproval>> corp : positionsListMap.entrySet()) {             //убрать повторяющиеся должности из списка.             corp.setValue(corp.getValue().stream() //                    .filter(t-> finalBoardOfShareholders.contains(new Account(t.getLaws().getLaws().get(0), 0, 0)))                     .distinct().collect(Collectors.toList()));              //получить баланс и голоса для действующих законов             curentLawVotesEndBalance.put(corp.getKey(), UtilsGovernment.filters(corp.getValue(), balances, BoardOfShareholders,                     blockchain.getBlockchainList(), Seting.POSITION_YEAR_VOTE));             List<CurrentLawVotesEndBalance> temporary;             if (fIndPositonHelperData.get(corp.getKey()).isElectedWithStock()) {                   //отобрать голоса выше лимита                 curentLawVotesEndBalance.put(corp.getKey(), curentLawVotesEndBalance.get(corp.getKey()));                 List<CurrentLawVotesEndBalance> electedByStock =                         curentLawVotesEndBalance.get(corp.getKey())                                 .stream()                                 .filter(t->directors.isElectedByStocks(t.getPackageName()))                                 .filter(t -> t.getVotes() >= Seting.ORIGINAL_LIMIT_MIN_VOTE)                                 .sorted(Comparator.comparing(CurrentLawVotesEndBalance::getVotes).reversed())                                 .limit(corp.getKey().getCount())                                 .collect(Collectors.toList());                  System.out.println(\"UtilsCurrentLaw: findPostion: \");                 System.out.println(\"*******************************\");                 electedByStock.stream().forEach(System.out::println);                 System.out.println(\"*******************************\");                  //отобрать то количество которое соответсвтвует данной должности                 temporary = electedByStock;              } else {                  curentLawVotesEndBalance.put(corp.getKey(), curentLawVotesEndBalance.get(corp.getKey()));                 //отобрать то количество которое соответсвтвует данной должности                 //избираемые премьер министром                 if(fIndPositonHelperData.get(corp.getKey()).isElectedWithPrimeMinister()){                     //отобрать голоса выше лимита                     curentLawVotesEndBalance.put(corp.getKey(), curentLawVotesEndBalance.get(corp.getKey()));                     List<CurrentLawVotesEndBalance> electedByPrimeMinister =                             curentLawVotesEndBalance.get(corp.getKey())                                     .stream()                                     .filter(t->directors.isElectedCEO(t.getPackageName()))                                     .filter(t -> t.getVoteGeneralExecutiveDirector() >= Seting.ORIGINAL_LIMIT_MIN_VOTE_GENERAL_EXECUTIVE_DIRECTOR)                                     .sorted(Comparator.comparing(CurrentLawVotesEndBalance::getVoteGeneralExecutiveDirector).reversed())                                     .collect(Collectors.toList());                       //отобрать то количество которое соответсвтвует данной должности                     temporary = electedByPrimeMinister;                 }                 //избираемые палатой представителей                 else if(fIndPositonHelperData.get(corp.getKey()).isElectedWithHousOfRepresentativies()){                     //отобрать голоса выше лимита                     curentLawVotesEndBalance.put(corp.getKey(), curentLawVotesEndBalance.get(corp.getKey()));                     List<CurrentLawVotesEndBalance> electedByHouseOfRepresentatives =                             curentLawVotesEndBalance.get(corp.getKey())                                     .stream()                                     .filter(t->directors.isElectedByBoardOfDirectors(t.getPackageName()))                                     .filter(t -> t.getVotesBoardOfDirectors() >= Seting.ORIGINAL_LIMIT_MIN_VOTE_BOARD_OF_DIRECTORS)                                     .sorted(Comparator.comparing(CurrentLawVotesEndBalance::getVotesBoardOfDirectors).reversed())                                     .collect(Collectors.toList());                       //отобрать то количество которое соответсвтвует данной должности                     temporary = electedByHouseOfRepresentatives;                    }                 //избираемые палатаой верховных судей                 else if(fIndPositonHelperData.get(corp.getKey()).isElectedWithChamberOfHightJudjes()){                     //отобрать голоса выше лимита                     curentLawVotesEndBalance.put(corp.getKey(), curentLawVotesEndBalance.get(corp.getKey()));                     List<CurrentLawVotesEndBalance> electedByChamberOfSupremeJudges =                             curentLawVotesEndBalance.get(corp.getKey())                                     .stream()                                     .filter(t->directors.isElectedBYCorporateCouncilOfReferees(t.getPackageName()))                                     .filter(t -> t.getVotesCorporateCouncilOfReferees() >= Seting.ORIGINAL_LIMIT_MIN_VOTE_CORPORATE_COUNCIL_OF_REFEREES)                                     .sorted(Comparator.comparing(CurrentLawVotesEndBalance::getVotesCorporateCouncilOfReferees).reversed())                                     .collect(Collectors.toList());                       //отобрать то количество которое соответсвтвует данной должности                     temporary = electedByChamberOfSupremeJudges;                  }                 else {                     temporary = curentLawVotesEndBalance.get(corp.getKey()).stream()                              .collect(Collectors.toList());                 }              }              temporary = temporary.stream().distinct().collect(Collectors.toList());              curentLawVotesEndBalance.put(corp.getKey(), temporary);         }           List<LawEligibleForParliamentaryApproval> lawEligibleForParliamentaryApprovals =                 UtilsLaws.readLineCurrentLaws(Seting.ORIGINAL_ALL_CORPORATION_LAWS_WITH_BALANCE_FILE);           Map<Director, List<String>> currentPossitions = new HashMap<>();         for (Map.Entry<Director, FIndPositonHelperData> fIndPositonHelperData1 : fIndPositonHelperData.entrySet()) {             List<CurrentLawVotesEndBalance> position = curentLawVotesEndBalance.get(fIndPositonHelperData1.getKey());             //список адресов на данную позицию, пример члена палаты представителей             List<String> currntAddress = new ArrayList<>();             for (CurrentLawVotesEndBalance address : position) {                 for (LawEligibleForParliamentaryApproval lawEligibleForParliamentaryApproval : lawEligibleForParliamentaryApprovals) {                       if (lawEligibleForParliamentaryApproval.getLaws().getHashLaw().equals(address.getAddressLaw())) {                          currntAddress.add(lawEligibleForParliamentaryApproval.getLaws().getLaws().get(0));                      }                 }              }             currentPossitions.put(fIndPositonHelperData1.getKey(), currntAddress);          }           return currentPossitions;     }      //найти членов палаты представителей     //возвращает список позиций     public static List<String> findPosition(             Map<String, Account> balances,             Blockchain blockchain,             List<LawEligibleForParliamentaryApproval> allGovernment,             List<Account> BoardOfShareholders,             Directors positions,             boolean withLimit      ) throws IOException, NoSuchAlgorithmException, InvalidKeySpecException, SignatureException, NoSuchProviderException, InvalidKeyException {         //список должностей          Map<Director, List<LawEligibleForParliamentaryApproval>> positionsListMap = new HashMap<>();         //добавление всех должностей         for (Director higherSpecialPositions : positions.getDirectors()) {             positionsListMap.put(higherSpecialPositions, UtilsLaws.getPossions(allGovernment, higherSpecialPositions));         }         //список законов с голосами         Map<Director, List<CurrentLawVotesEndBalance>> curentLawVotesEndBalance = new HashMap<>();         for (Map.Entry<Director, List<LawEligibleForParliamentaryApproval>> corp : positionsListMap.entrySet()) {             //убрать повторяющиеся должности из списка.             corp.setValue(corp.getValue().stream() //                    .filter(t-> finalBoardOfShareholders.contains(new Account(t.getLaws().getLaws().get(0), 0, 0)))                     .distinct().collect(Collectors.toList()));              //получить баланс и голоса для действующих законов             curentLawVotesEndBalance.put(corp.getKey(), UtilsGovernment.filters(corp.getValue(), balances, BoardOfShareholders,                     blockchain.getBlockchainList(), Seting.POSITION_YEAR_VOTE));             List<CurrentLawVotesEndBalance> temporary;             if (withLimit) {                 //отобрать голоса выше лимита                 curentLawVotesEndBalance.put(corp.getKey(), curentLawVotesEndBalance.get(corp.getKey())                         .stream().filter(t -> t.getVotes() >= Seting.ORIGINAL_LIMIT_MIN_VOTE)                         .collect(Collectors.toList()));                  //отобрать то количество которое соответсвтвует данной должности                 temporary = curentLawVotesEndBalance.get(corp.getKey()).stream()                         .filter(t -> !t.getPackageName().equals(corp.getKey()))                         .sorted(Comparator.comparing(CurrentLawVotesEndBalance::getVotes).reversed())                         .limit(corp.getKey().getCount()).collect(Collectors.toList());             } else {                 //отобрать то количество которое соответсвтвует данной должности                 temporary = curentLawVotesEndBalance.get(corp.getKey()).stream()                         .filter(t -> !t.getPackageName().equals(corp.getKey()))                         .sorted(Comparator.comparing(CurrentLawVotesEndBalance::getVotes).reversed())                         .collect(Collectors.toList());             }               curentLawVotesEndBalance.put(corp.getKey(), temporary);         }           List<LawEligibleForParliamentaryApproval> lawEligibleForParliamentaryApprovals =                 UtilsLaws.readLineCurrentLaws(Seting.ORIGINAL_ALL_CORPORATION_LAWS_WITH_BALANCE_FILE);          //список адресов на данную позицию, пример члена палаты представителей         List<String> currntAddress = new ArrayList<>();          List<CurrentLawVotesEndBalance> position = curentLawVotesEndBalance.get(positions);          for (CurrentLawVotesEndBalance address : position) {             for (LawEligibleForParliamentaryApproval lawEligibleForParliamentaryApproval : lawEligibleForParliamentaryApprovals) {                   if (lawEligibleForParliamentaryApproval.getLaws().getHashLaw().equals(address.getAddressLaw())) {                      currntAddress.add(lawEligibleForParliamentaryApproval.getLaws().getLaws().get(0));                  }             }         }           return currntAddress;     } }","package International_Trade_Union.vote;  import International_Trade_Union.governments.Director; import International_Trade_Union.governments.Directors; import com.fasterxml.jackson.core.JsonProcessingException; import International_Trade_Union.entity.DtoTransaction.DtoTransaction; import International_Trade_Union.entity.blockchain.block.Block; import International_Trade_Union.setings.Seting; import International_Trade_Union.model.Account; import International_Trade_Union.utils.UtilsFileSaveRead; import International_Trade_Union.utils.UtilsJson; import International_Trade_Union.utils.UtilsUse;   import java.io.File; import java.io.IOException; import java.security.InvalidKeyException; import java.security.NoSuchAlgorithmException; import java.security.NoSuchProviderException; import java.security.SignatureException; import java.security.spec.InvalidKeySpecException; import java.util.*; import java.util.stream.Collectors;  public class UtilsLaws {     public static void saveLaws(List<Laws> laws, String filename) throws IOException {         int fileLimit = Seting.SIZE_FILE_LIMIT * 1024 * 1024;          //папка чтобы проверить есть ли         File folder = new File(filename);         List<String> files = new ArrayList<>();         for (File file : folder.listFiles()) {             if(!file.isDirectory()){                 files.add(file.getAbsolutePath());             }         }          int count = 0;         files = files.stream().sorted().collect(Collectors.toList());         String nextFile = \"\";          if (files.size() > 0) {             nextFile = files.get(files.size()-1);              count = Integer.parseInt(nextFile.replaceAll(\"[^\\\\d]\", \"\"));           }          File file = new File(nextFile);          if(file.length() >= fileLimit){             count++;          }          nextFile = filename + count + \".txt\";          List<String> jsons = new ArrayList<>();         for (Laws laws1: laws) {             String json = UtilsJson.objToStringJson(laws1);             jsons.add(json);         }  //        String json = UtilsJson.objToStringJson(minerAccount); //        UtilsFileSaveRead.save(json + \"\\n\", nextFile);         UtilsFileSaveRead.saves(jsons, nextFile, true);     }     public static void saveLaw(Laws laws, String filename) throws IOException, NoSuchAlgorithmException, SignatureException, InvalidKeySpecException, NoSuchProviderException, InvalidKeyException {         int fileLimit = Seting.SIZE_FILE_LIMIT * 1024 * 1024;          //папка чтобы проверить есть ли         File folder = new File(filename);         List<String> files = new ArrayList<>();         for (File file : folder.listFiles()) {             if (!file.isDirectory()) {                 files.add(file.getAbsolutePath());             }         }          int count = 0;         files = files.stream().sorted().collect(Collectors.toList());         String nextFile = \"\";          if (files.size() > 0) {             nextFile = files.get(files.size() - 1);              count = Integer.parseInt(nextFile.replaceAll(\"[^\\\\d]\", \"\"));           }          File file = new File(nextFile);          if (file.length() >= fileLimit) {             count++;          }          nextFile = filename + count + \".txt\";          String json = UtilsJson.objToStringJson(laws);         UtilsFileSaveRead.save(json + \"\\n\", nextFile);      }      public static void saveCurrentsLaws(List<LawEligibleForParliamentaryApproval> lawEligibleForParliamentaryApprovals, String filename) throws IOException {         int fileLimit = Seting.SIZE_FILE_LIMIT * 1024 * 1024;          //папка чтобы проверить есть ли         File folder = new File(filename);         List<String> files = new ArrayList<>();         for (File file : folder.listFiles()) {             if(!file.isDirectory()){                 files.add(file.getAbsolutePath());             }         }          int count = 0;         files = files.stream().sorted().collect(Collectors.toList());         String nextFile = \"\";          if (files.size() > 0) {             nextFile = files.get(files.size()-1);              count = Integer.parseInt(nextFile.replaceAll(\"[^\\\\d]\", \"\"));           }          File file = new File(nextFile);          if(file.length() >= fileLimit){             count++;          }          nextFile = filename + count + \".txt\";          List<String> jsons = new ArrayList<>();         for (LawEligibleForParliamentaryApproval lawEligibleForParliamentaryApproval : lawEligibleForParliamentaryApprovals) {             String json = UtilsJson.objToStringJson(lawEligibleForParliamentaryApproval);             jsons.add(json);         }  //        String json = UtilsJson.objToStringJson(minerAccount); //        UtilsFileSaveRead.save(json + \"\\n\", nextFile);         UtilsFileSaveRead.saves(jsons, nextFile, true);     }     public static void saveCurrentLaw(LawEligibleForParliamentaryApproval lawEligibleForParliamentaryApproval, String filename) throws IOException, NoSuchAlgorithmException, SignatureException, InvalidKeySpecException, NoSuchProviderException, InvalidKeyException {         int fileLimit = Seting.SIZE_FILE_LIMIT * 1024 * 1024;          //папка чтобы проверить есть ли         File folder = new File(filename);         List<String> files = new ArrayList<>();         for (File file : folder.listFiles()) {             if (!file.isDirectory()) {                 files.add(file.getAbsolutePath());             }         }          int count = 0;         files = files.stream().sorted().collect(Collectors.toList());         String nextFile = \"\";          if (files.size() > 0) {             nextFile = files.get(files.size() - 1);              count = Integer.parseInt(nextFile.replaceAll(\"[^\\\\d]\", \"\"));           }          File file = new File(nextFile);          if (file.length() >= fileLimit) {             count++;          }          nextFile = filename + count + \".txt\";          String json = UtilsJson.objToStringJson(lawEligibleForParliamentaryApproval);         UtilsFileSaveRead.save(json + \"\\n\", nextFile);      }      public static List<Laws> readLineLaws(String filename) throws IOException, NoSuchAlgorithmException, InvalidKeySpecException, SignatureException, NoSuchProviderException, InvalidKeyException {         List<Laws> laws = new ArrayList<>();         File folder = new File(filename);         for (final File fileEntry : folder.listFiles()) {             if (fileEntry.isDirectory()) {                 System.out.println(\"is directory \" + fileEntry.getAbsolutePath());             } else {                 List<String> list = UtilsFileSaveRead.reads(fileEntry.getAbsolutePath());                 for (String s : list) {                      Laws laws1 = UtilsJson.jsonToLaw(s);                     laws.add(laws1);                 }              }         }         laws = laws                 .stream()                 .sorted(Comparator.comparing(Laws::getPacketLawName))                 .collect(Collectors.toList());          return laws;     }      public static List<LawEligibleForParliamentaryApproval> readLineCurrentLaws(String filename) throws JsonProcessingException {         List<LawEligibleForParliamentaryApproval> laws = new ArrayList<>();         File folder = new File(filename);         for (final File fileEntry : folder.listFiles()) {             if (fileEntry.isDirectory()) {                 System.out.println(\"is directory \" + fileEntry.getAbsolutePath());             } else {                 List<String> list = UtilsFileSaveRead.reads(fileEntry.getAbsolutePath());                 for (String s : list) {                      LawEligibleForParliamentaryApproval laws1 = UtilsJson.jsonToCurrentLaw(s);                     laws.add(laws1);                 }              }         }          return laws;     }       //возвращает все счета законов     public static List<Account> allPackegeLaws(Map<String, Account> balances) {         List<Account> laws = new ArrayList<>();         laws = balances.entrySet()                 .stream()                 .map(t -> t.getValue())                 .filter(t -> t.getAccount().startsWith(Seting.NAME_LAW_ADDRESS_START))                 .collect(Collectors.toList());         return laws;     }      //возвращает пакет законов и их счета     public static Map<String, Laws> getPackageLaws(List<Block> blocks) throws IOException, NoSuchAlgorithmException, SignatureException, InvalidKeySpecException, NoSuchProviderException, InvalidKeyException {         Map<String, Laws> laws = new HashMap<>();         for (Block block : blocks) {             for (DtoTransaction dtoTransaction : block.getDtoTransactions()) {                 if (dtoTransaction.verify()) {                     if (dtoTransaction.getCustomer().startsWith(Seting.NAME_LAW_ADDRESS_START) && dtoTransaction.getBonusForMiner() >= Seting.COST_LAW) {                         if(dtoTransaction.getLaws() != null && !laws.containsKey(dtoTransaction.getCustomer())){                             laws.put(dtoTransaction.getCustomer(), dtoTransaction.getLaws());                         }                      }                 }             }          }         return laws;     }      //проверяет валидность закона     public static boolean isValidHashLaw(Laws laws) throws IOException {         String hash = laws.getHashLaw();         String hashLaw = Seting.NAME_LAW_ADDRESS_START + UtilsUse.sha256hash(UtilsJson.objToStringJson(laws));         System.out.println(\"UtilsLaw: isValidHashLaw: \" + hash.equals(hashLaw));         System.out.println(\"hash: \" + hash);         System.out.println(\"hashLaw: \" + hashLaw);         return hash.equals(hashLaw);     }        public static List<Account> allPackageLaws(List<Account> accounts){         List<Account> currentLaws = accounts.stream()                 .filter(t -> t.getAccount().startsWith(Seting.NAME_LAW_ADDRESS_START))                 .collect(Collectors.toList());         return currentLaws;     }      //возвращяет список всех законов, как действующих, так и не действующих, если закон новый то автоматически сохраняет его     public static Map<String, Laws> getLaws(List<Block> blocks, String fileLaws) throws IOException, NoSuchAlgorithmException, InvalidKeySpecException, SignatureException, NoSuchProviderException, InvalidKeyException {         List<Laws> lawsForSave = new ArrayList<>();         Map<String, Laws> lawsMap = new HashMap<>();         File file = new File(fileLaws);         List<Laws> lawsList = new ArrayList<>();         if (file.exists()) {             lawsList = readLineLaws(fileLaws);         }         lawsMap = getPackageLaws(blocks);          for (Map.Entry<String, Laws> map : lawsMap.entrySet()) {             if (!lawsList.contains(map.getValue())) {                 if( map.getValue() != null &&                         map.getValue().packetLawName != null&&                         map.getValue().getLaws() != null                         && !map.getValue().getHashLaw().isEmpty()                         && (map.getValue().getLaws().size() > 0)){                          lawsForSave.add(map.getValue());                 }              }          }         saveLaws(lawsForSave, fileLaws);         return lawsMap;     }     public static List<LawEligibleForParliamentaryApproval> getCurrentLaws(Map<String, Laws> lawsMap, Map<String, Account> balances, String fileCurrentLaws) throws IOException, NoSuchAlgorithmException, SignatureException, InvalidKeySpecException, NoSuchProviderException, InvalidKeyException {         List<Account> lawsBalances = allPackegeLaws(balances);           List<LawEligibleForParliamentaryApproval> lawEligibleForParliamentaryApprovals = new ArrayList<>();         LawEligibleForParliamentaryApproval lawEligibleForParliamentaryApproval = null;         File file = new File(fileCurrentLaws);         if (file.exists()) {             lawEligibleForParliamentaryApprovals = readLineCurrentLaws(fileCurrentLaws);         }          for (LawEligibleForParliamentaryApproval eligibleForParliamentaryApproval : lawEligibleForParliamentaryApprovals) {             if(lawsBalances.contains(eligibleForParliamentaryApproval.getAccount())){                 eligibleForParliamentaryApproval.getAccount().                         setDigitalStockBalance(balances.get(eligibleForParliamentaryApproval.getAccount().getAccount()).getDigitalStockBalance());                 eligibleForParliamentaryApproval.getAccount().                         setDigitalDollarBalance(balances.get(eligibleForParliamentaryApproval.getAccount().getAccount()).getDigitalDollarBalance());             }          }           List<LawEligibleForParliamentaryApproval> temporary = new ArrayList<>();         for (Account account : lawsBalances) {             lawEligibleForParliamentaryApproval = new LawEligibleForParliamentaryApproval(account, lawsMap.get(account.getAccount()));             temporary.add(lawEligibleForParliamentaryApproval);         }           lawEligibleForParliamentaryApprovals.addAll(temporary);           lawEligibleForParliamentaryApprovals = lawEligibleForParliamentaryApprovals.stream()                 .filter(t->Objects.nonNull(t.getLaws()))                 .filter(t->Objects.nonNull(t.getAccount()))                 .filter(t->Objects.nonNull(t.getLaws().getHashLaw()))                 .filter(t->Objects.nonNull(t.getLaws().getLaws()))                 .filter(t->Objects.nonNull(t.getName()))                 .filter(t->Objects.nonNull(t.getLaws().getPacketLawName()))                 .filter(t->t != null).                 filter(UtilsUse.distinctByKey(LawEligibleForParliamentaryApproval::getName)).collect(Collectors.toList());          return lawEligibleForParliamentaryApprovals;      }         //отбирает позицию вакансий     public static List<LawEligibleForParliamentaryApproval> getPossions(List<LawEligibleForParliamentaryApproval> lawEligibleForParliamentaryApprovals, Director higherSpecialPositions){          List<LawEligibleForParliamentaryApproval> temporary = new ArrayList<>();         temporary = lawEligibleForParliamentaryApprovals.stream()                 .filter(t->Objects.nonNull(t))                 .filter(t->Objects.nonNull(t.getLaws()))                 .filter(t->Objects.nonNull(t.getLaws().getLaws()))                 .filter(t->Objects.nonNull(t.getLaws().getPacketLawName()))                 .filter(t->Objects.nonNull(t.getName()))                 .filter(t->Objects.nonNull(t.getLaws().getHashLaw()))                 .sorted((f1, f2) -> Double.compare(f2.getAccount().getDigitalStockBalance(), f1.getAccount().getDigitalStockBalance()))                 .filter(t-> t.getLaws().getPacketLawName().equals(higherSpecialPositions.getName()))                 .limit(higherSpecialPositions.getCount())                 .collect(Collectors.toList());         return temporary;      }       //удаляет из списка не лигитимные должности     public static List<LawEligibleForParliamentaryApproval> deletePossions(List<LawEligibleForParliamentaryApproval> lawEligibleForParliamentaryApprovals, List<LawEligibleForParliamentaryApproval> forDeleted, Directors higherSpecialPositions){         List<LawEligibleForParliamentaryApproval> temporary = new ArrayList<>();         for (LawEligibleForParliamentaryApproval lawEligibleForParliamentaryApproval : forDeleted) {             if(lawEligibleForParliamentaryApproval != null &&                     lawEligibleForParliamentaryApproval.getLaws() != null &&                     lawEligibleForParliamentaryApproval.getLaws().getPacketLawName() != null &&                     lawEligibleForParliamentaryApproval.getLaws().getHashLaw() != null &&                     lawEligibleForParliamentaryApproval.getLaws().getHashLaw() != null &&                     lawEligibleForParliamentaryApproval.getLaws().getPacketLawName().equals(higherSpecialPositions.getNames())){                 if(lawEligibleForParliamentaryApprovals.contains(lawEligibleForParliamentaryApproval)){                     temporary.add(lawEligibleForParliamentaryApproval);                 }else {                     continue;                 }             }             temporary.add(lawEligibleForParliamentaryApproval);         }         return temporary;     }   }","package International_Trade_Union.vote;  public enum VoteEnum {     YES,     NO }","package International_Trade_Union;  import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; import org.springframework.scheduling.annotation.EnableScheduling;  @SpringBootApplication public class UnitedStatesApplication { \tpublic static void main(String[] args) { \t\tSpringApplication.run(UnitedStatesApplication.class, args); \t}  }","CODE UNITED STATES DUPLICATES ORIGINAL STORAGE","package International_Trade_Union.config;   import International_Trade_Union.entity.blockchain.Blockchain; import International_Trade_Union.setings.Seting;  import java.io.IOException; import java.security.InvalidKeyException; import java.security.NoSuchAlgorithmException; import java.security.NoSuchProviderException; import java.security.SignatureException; import java.security.spec.InvalidKeySpecException;  public class BLockchainFactory {      public static Blockchain getBlockchain(BlockchainFactoryEnum factoryEnum) throws NoSuchAlgorithmException, InvalidKeySpecException, IOException, SignatureException, NoSuchProviderException, InvalidKeyException {         switch (factoryEnum){             case TEST:                 return new Blockchain(                         Seting.BLOCK_GENERATION_INTERVAL_TEST,                         Seting.DIFFICULTY_ADJUSTMENT_INTERVAL_TEST,                         Seting.INTERVAL_TARGET_TEST,                         Seting.ADDRESS_FOUNDER_TEST);              case ORIGINAL:                 return new Blockchain(                         Seting.BLOCK_GENERATION_INTERVAL,                         Seting.DIFFICULTY_ADJUSTMENT_INTERVAL,                         Seting.INTERVAL_TARGET,                         Seting.ADDRESS_FOUNDER                 );             default: return null;         }     } }","package International_Trade_Union.config;  public enum BlockchainFactoryEnum {     TEST,     ORIGINAL }","package International_Trade_Union.controllers;  import International_Trade_Union.entity.AddressUrl; import International_Trade_Union.entity.SubBlockchainEntity; import International_Trade_Union.network.AllTransactions; import org.json.JSONException;  import org.springframework.http.HttpStatus; import org.springframework.http.MediaType; import International_Trade_Union.entity.blockchain.Blockchain; import International_Trade_Union.entity.blockchain.block.Block; import International_Trade_Union.config.BLockchainFactory; import International_Trade_Union.config.BlockchainFactoryEnum; import International_Trade_Union.entity.EntityChain; import International_Trade_Union.model.Account; import International_Trade_Union.model.Mining; import International_Trade_Union.setings.Seting; import International_Trade_Union.utils.*; import International_Trade_Union.vote.*; import org.springframework.http.ResponseEntity; import org.springframework.util.Assert; import org.springframework.web.bind.annotation.*; import org.springframework.web.context.request.RequestAttributes; import org.springframework.web.context.request.RequestContextHolder; import org.springframework.web.context.request.ServletRequestAttributes;  import javax.servlet.http.HttpServletRequest; import java.io.IOException;  import java.security.*; import java.security.spec.InvalidKeySpecException;  import java.util.*; import java.util.stream.Collectors;  @RestController public class BasisController {     private static Blockchain blockchain;      private static Set<String> excludedAddresses = new HashSet<>();      public static HttpServletRequest getCurrentRequest() {         RequestAttributes requestAttributes = RequestContextHolder.getRequestAttributes();         Assert.state(requestAttributes != null, \"Could not find current request via RequestContextHolder\");         Assert.isInstanceOf(ServletRequestAttributes.class, requestAttributes);         HttpServletRequest servletRequest = ((ServletRequestAttributes) requestAttributes).getRequest();         Assert.state(servletRequest != null, \"Could not find current HttpServletRequest\");         return servletRequest;     }       public static Set<String> getExcludedAddresses() {         HttpServletRequest request = getCurrentRequest();          String scheme = request.getScheme();         String serverName = request.getServerName();         int serverPort = request.getServerPort();         String contextPath = request.getContextPath();  // includes leading forward slash          String localaddress = scheme + \"://\" + serverName + \":\" + serverPort;          excludedAddresses.add(localaddress);         return excludedAddresses;     }      public static void setExcludedAddresses(Set<String> excludedAddresses) {         BasisController.excludedAddresses = excludedAddresses;     }      private static Set<String> nodes = new HashSet<>(); //    private static Nodes nodes = new Nodes();       public static void setNodes(Set<String> nodes) {         BasisController.nodes = nodes;     }      public static Set<String> getNodes() throws IOException, NoSuchAlgorithmException, InvalidKeySpecException, SignatureException, NoSuchProviderException, InvalidKeyException {          nodes = new HashSet<>();          Set<String> temporary = UtilsAllAddresses.readLineObject(Seting.ORIGINAL_POOL_URL_ADDRESS_FILE);          nodes.addAll(Seting.ORIGINAL_ADDRESSES);         nodes.addAll(temporary);           nodes = nodes.stream()                 .filter(t -> !t.isBlank())                 .filter(t -> t.startsWith(\"\\\"\"))                 .collect(Collectors.toSet());         nodes = nodes.stream().map(t -> t.replaceAll(\"\\\"\", \"\")).collect(Collectors.toSet());          return nodes;     }      public static Blockchain getBlockchain() {         return blockchain;     }      public static synchronized void setBlockchain(Blockchain blockchain) {         BasisController.blockchain = blockchain;     }      static {         try {             blockchain = BLockchainFactory.getBlockchain(BlockchainFactoryEnum.ORIGINAL);         } catch (NoSuchAlgorithmException e) {             throw new RuntimeException(e);         } catch (InvalidKeySpecException e) {             throw new RuntimeException(e);         } catch (IOException e) {             throw new RuntimeException(e);         } catch (SignatureException e) {             throw new RuntimeException(e);         } catch (NoSuchProviderException e) {             throw new RuntimeException(e);         } catch (InvalidKeyException e) {             throw new RuntimeException(e);         }     }      public BasisController() {     }     //TODO если вы прервали mine, то перед следующим вызовом перезапустите сервер и вызовите /addBlock перед mine     //TODO if you interrupted mine, restart the server before next call and call /addBlock before mine     //TODO иначе будет расождение в файле балансов     //TODO otherwise there will be a discrepancy in the balance file       @GetMapping(\"/chain\")     @ResponseBody     public synchronized EntityChain full_chain() throws IOException, NoSuchAlgorithmException, InvalidKeySpecException, SignatureException, NoSuchProviderException, InvalidKeyException {         blockchain = Mining.getBlockchain(                 Seting.ORIGINAL_BLOCKCHAIN_FILE,                 BlockchainFactoryEnum.ORIGINAL);          if(!blockchain.validatedBlockchain()){             System.out.println(\"wrong block chain, delete blocks\");             UtilsBlock.deleteFiles();             blockchain.setBlockchainList(new ArrayList<>());             return new EntityChain();         }         return new EntityChain(blockchain.sizeBlockhain(), blockchain.getBlockchainList());     }      @GetMapping(\"/size\")     @ResponseBody     public synchronized   Integer sizeBlockchain() throws IOException, NoSuchAlgorithmException, InvalidKeySpecException, SignatureException, NoSuchProviderException, InvalidKeyException {           blockchain = Mining.getBlockchain(                 Seting.ORIGINAL_BLOCKCHAIN_FILE,                 BlockchainFactoryEnum.ORIGINAL);         if(!blockchain.validatedBlockchain()){             System.out.println(\"wrong block chain, delete blocks: sizeBlockchain: size\");             UtilsBlock.deleteFiles();             blockchain.setBlockchainList(new ArrayList<>());             blockchain = Mining.getBlockchain(Seting.ORIGINAL_BLOCKCHAIN_FILE, BlockchainFactoryEnum.ORIGINAL);             return blockchain.sizeBlockhain();         }          return blockchain.sizeBlockhain();     }      @PostMapping(\"/sub-blocks\")     @ResponseBody     public  List<Block> subBlocks(@RequestBody SubBlockchainEntity entity) throws IOException, NoSuchAlgorithmException, InvalidKeySpecException, SignatureException, NoSuchProviderException, InvalidKeyException {         blockchain = Mining.getBlockchain(                 Seting.ORIGINAL_BLOCKCHAIN_FILE,                 BlockchainFactoryEnum.ORIGINAL);         return blockchain.getBlockchainList().subList(entity.getStart(), entity.getFinish());     }      @PostMapping(\"/block\")     @ResponseBody     public Block getBlock(@RequestBody Integer index) throws IOException, NoSuchAlgorithmException, InvalidKeySpecException, SignatureException, NoSuchProviderException, InvalidKeyException {         blockchain = Mining.getBlockchain(                 Seting.ORIGINAL_BLOCKCHAIN_FILE,                 BlockchainFactoryEnum.ORIGINAL);         return blockchain.getBlock(index);     }      //TODO нужно чтобы передавался каждый раз не весь блокчейн а часть, как реализованно в биткоин     //TODO is necessary so that not the entire blockchain is transmitted each time, but a part, as implemented in bitcoin     //TODO need to optimization because now not best     @GetMapping(\"/nodes/resolve\")     public synchronized void resolve_conflicts() throws NoSuchAlgorithmException, InvalidKeySpecException, IOException, SignatureException, NoSuchProviderException, InvalidKeyException, JSONException {         Blockchain temporaryBlockchain = BLockchainFactory.getBlockchain(BlockchainFactoryEnum.ORIGINAL);         Blockchain bigBlockchain = BLockchainFactory.getBlockchain(BlockchainFactoryEnum.ORIGINAL);         blockchain = Mining.getBlockchain(                 Seting.ORIGINAL_BLOCKCHAIN_FILE,                 BlockchainFactoryEnum.ORIGINAL);          if(!blockchain.validatedBlockchain()){             System.out.println(\"wrong block chain, delete blocks\");             UtilsBlock.deleteFiles();             blockchain.setBlockchainList(new ArrayList<>());             return;         }         int blocks_current_size = blockchain.sizeBlockhain();         long hashCountZeroTemporary = 0;         long hashCountZeroBigBlockchain = 0;         EntityChain entityChain = null;          long hashCountZeroAll = 0;         //count hash sztart with zero all         for (Block block : blockchain.getBlockchainList()) {             hashCountZeroAll += UtilsUse.hashCount(block.getHashBlock());         }         System.out.println(\"BasisController: resolve: size: \" + getNodes().size());         Set<String> nodesAll = getNodes(); //        nodesAll.addAll(Seting.ORIGINAL_ADDRESSES_BLOCKCHAIN_STORAGE);          for (String s : nodesAll) {             System.out.println(\"BasisController: resove: address: \" + s);             String temporaryjson = null;              if (BasisController.getExcludedAddresses().contains(s)) {                 System.out.println(\"its your address or excluded address: \" + s);                 continue;             }             try {                 String address = s + \"/chain\";                 System.out.println(\"BasisController:resolve conflicts: address: \" + s +\"/size\");                 String sizeStr = UtilUrl.readJsonFromUrl(s + \"/size\");                 Integer size = Integer.valueOf(sizeStr);                 if(size > blocks_current_size){                     System.out.println(\"size from address: \" + s + \" upper than: \" + size +\":blocks_current_size \" + blocks_current_size );                     //Test start algorithm                     SubBlockchainEntity subBlockchainEntity = new SubBlockchainEntity(blocks_current_size, size);                     String subBlockchainJson = UtilsJson.objToStringJson(subBlockchainEntity);                      List<Block> emptyList = new ArrayList<>();                      List<Block> subBlocks = UtilsJson.jsonToListBLock(UtilUrl.getObject(subBlockchainJson, s + \"/sub-blocks\"));                     emptyList.addAll(subBlocks);                     emptyList.addAll(blockchain.getBlockchainList());                      emptyList = emptyList.stream().sorted(Comparator.comparing(Block::getIndex)).collect(Collectors.toList());                     temporaryBlockchain.setBlockchainList(emptyList);                     if(!temporaryBlockchain.validatedBlockchain()){                         System.out.println(\"first algorithm not worked\");                         emptyList = new ArrayList<>();                         emptyList.addAll(subBlocks);                         for (int i = blockchain.sizeBlockhain()-1; i > 0 ; i--) {                             Block block = UtilsJson.jsonToBLock(UtilUrl.getObject(UtilsJson.objToStringJson(i), s+\"/block\"));                             if(!blockchain.getBlock(i).getHashBlock().equals(block.getHashBlock())){                                 emptyList.add(block);                             }                             else {                                 emptyList.add(block);                                 emptyList.addAll(blockchain.getBlockchainList().subList(0, i));                                 emptyList = emptyList.stream().sorted(Comparator.comparing(Block::getIndex)).collect(Collectors.toList());                                 temporaryBlockchain.setBlockchainList(emptyList);                                 break;                             }                         }                     }                     if (!temporaryBlockchain.validatedBlockchain()){                         System.out.println(\"second algorith not worked\");                         temporaryjson = UtilUrl.readJsonFromUrl(address);                         entityChain = UtilsJson.jsonToEntityChain(temporaryjson);                         temporaryBlockchain.setBlockchainList(                                 entityChain.getBlocks().stream().sorted(Comparator.comparing(Block::getIndex)).collect(Collectors.toList()));                     }                 }                  else {                     System.out.println(\"BasisController: resove: size less: \" + size + \" address: \" + address);                     continue;                 }             } catch (IOException e) {                 System.out.println(\"BasisController: resolve_conflicts: Error: \" + s);                 continue;             }               if (temporaryBlockchain.validatedBlockchain()) {                 for (Block block : temporaryBlockchain.getBlockchainList()) {                     hashCountZeroTemporary += UtilsUse.hashCount(block.getHashBlock());                 }                  if (blocks_current_size < temporaryBlockchain.sizeBlockhain() && hashCountZeroAll < hashCountZeroTemporary) {                     blocks_current_size = temporaryBlockchain.sizeBlockhain();                     bigBlockchain = temporaryBlockchain;                     hashCountZeroBigBlockchain = hashCountZeroTemporary;                 }                 hashCountZeroTemporary = 0;             }          }           if (bigBlockchain.sizeBlockhain() > blockchain.sizeBlockhain() && hashCountZeroBigBlockchain > hashCountZeroAll) {                  blockchain = bigBlockchain;                 System.out.println(\"Basis Controller: delete resolve conflicts\");                 UtilsBlock.deleteFiles();                 addBlock(bigBlockchain.getBlockchainList(), BLockchainFactory.getBlockchain(BlockchainFactoryEnum.ORIGINAL));                 System.out.println(\"BasisController: resolve: bigblockchain size: \" + bigBlockchain.sizeBlockhain());           }     }      @PostMapping(\"/nodes/resolve_all_blocks\")     public synchronized ResponseEntity<String>resolve_blocks_conflict(@RequestBody List<Block> blocks) throws IOException, NoSuchAlgorithmException, InvalidKeySpecException, SignatureException, NoSuchProviderException, InvalidKeyException, JSONException, CloneNotSupportedException { //         Blockchain temporaryBlockchain = BLockchainFactory.getBlockchain(BlockchainFactoryEnum.ORIGINAL);         blocks = blocks.stream().sorted(Comparator.comparing(Block::getIndex)).collect(Collectors.toList());         temporaryBlockchain.setBlockchainList(blocks);         System.out.println(\"size temporary blocks: \" + blocks.size());          blockchain = Mining.getBlockchain(                 Seting.ORIGINAL_BLOCKCHAIN_FILE,                 BlockchainFactoryEnum.ORIGINAL);          if(!blockchain.validatedBlockchain()){             System.out.println(\"wrong block chain, delete blocks: resolve all blocks\");             UtilsBlock.deleteFiles();             blockchain.setBlockchainList(new ArrayList<>());             return new ResponseEntity<>(\"please retry  wrong blockchain in storage\", HttpStatus.CONFLICT);         }          long hashCountZeroTemporary = 0;          long hashCountZeroAll = 0;           //count hash start with zero all         for (Block block : blockchain.getBlockchainList()) {             hashCountZeroAll += UtilsUse.hashCount(block.getHashBlock());         }          if (temporaryBlockchain.validatedBlockchain()) {             for (Block block : temporaryBlockchain.getBlockchainList()) {                 hashCountZeroTemporary += UtilsUse.hashCount(block.getHashBlock());             }          }else {             return new ResponseEntity<>(\"FALSE\", HttpStatus.EXPECTATION_FAILED);         }          if (temporaryBlockchain.sizeBlockhain() > blockchain.sizeBlockhain() && hashCountZeroTemporary > hashCountZeroAll) {              blockchain = temporaryBlockchain;             UtilsBlock.deleteFiles();             if(temporaryBlockchain.validatedBlockchain()){                 System.out.println(\"delete resolve all blocks\");                 UtilsBlock.deleteFiles();                 addBlock(temporaryBlockchain.getBlockchainList(), BLockchainFactory.getBlockchain(BlockchainFactoryEnum.ORIGINAL));             }              System.out.println(\"BasisController: resolve: bigblockchain size: \" + temporaryBlockchain.sizeBlockhain());           }         resolve_conflicts();         return  new ResponseEntity<>(\"OK\", HttpStatus.OK);      }      @PostMapping(\"/nodes/resolve_from_to_block\")     public synchronized ResponseEntity<String> resolve_conflict(@RequestBody List<Block> blocks) throws JSONException, NoSuchAlgorithmException, InvalidKeySpecException, IOException, SignatureException, NoSuchProviderException, InvalidKeyException, CloneNotSupportedException { //         Blockchain temporaryBlockchain = BLockchainFactory.getBlockchain(BlockchainFactoryEnum.ORIGINAL);          blockchain = Mining.getBlockchain(                 Seting.ORIGINAL_BLOCKCHAIN_FILE,                 BlockchainFactoryEnum.ORIGINAL);          if(!blockchain.validatedBlockchain()){             System.out.println(\"wrong block chain, delete blocks: from to block:\");             UtilsBlock.deleteFiles();             blockchain.setBlockchainList(new ArrayList<>());             return new ResponseEntity<>(\"please retry  wrong blockchain in storage\", HttpStatus.CONFLICT);         }         List<Block> tempBlocks = blockchain.getBlockchainList();         blocks.addAll(tempBlocks);         blocks = blocks.stream().sorted(Comparator.comparing(Block::getIndex)).collect(Collectors.toList());         temporaryBlockchain.setBlockchainList(blocks);          long hashCountZeroTemporary = 0;          long hashCountZeroAll = 0;           //count hash start with zero all         for (Block block : blockchain.getBlockchainList()) {             hashCountZeroAll += UtilsUse.hashCount(block.getHashBlock());         }          if (temporaryBlockchain.validatedBlockchain()) {             for (Block block : temporaryBlockchain.getBlockchainList()) {                 hashCountZeroTemporary += UtilsUse.hashCount(block.getHashBlock());             }          }else {             return new ResponseEntity<>(\"FALSE\", HttpStatus.EXPECTATION_FAILED);         }          if (temporaryBlockchain.sizeBlockhain() > blockchain.sizeBlockhain() && hashCountZeroTemporary > hashCountZeroAll) {              blockchain = temporaryBlockchain;             UtilsBlock.deleteFiles();             if(temporaryBlockchain.validatedBlockchain()){                 System.out.println(\"reslove from to block: \");                 UtilsBlock.deleteFiles();                 addBlock(temporaryBlockchain.getBlockchainList(), BLockchainFactory.getBlockchain(BlockchainFactoryEnum.ORIGINAL));             }             System.out.println(\"BasisController: resolve: bigblockchain size: \" + temporaryBlockchain.sizeBlockhain());           }         resolve_conflicts();         return  new ResponseEntity<>(\"OK\", HttpStatus.OK);     }     /**добавляет блоки в блок чейн пересохраняя файлы, предназначен когда у нас есть готовый      * блокчейн и нужно все файлы(balance, vote, government и т. д.) заного пересохранить.      * adds blocks to the block chain by resaving files, designed when we have it ready      *      * Blockchain and you need to save all files (balance, vote, government, etc.) again.*/     public static void addBlock(List<Block> orignalBlocks, Blockchain blockchain) throws IOException, NoSuchAlgorithmException, SignatureException, InvalidKeySpecException, NoSuchProviderException, InvalidKeyException {         //раз в три для очищяет файл sended         AllTransactions.clearAllSendedTransaction(blockchain.sizeBlockhain());         Map<String, Account> balances = new HashMap<>();         Blockchain temporaryForValidation =  BLockchainFactory.getBlockchain(BlockchainFactoryEnum.ORIGINAL);         temporaryForValidation.setBlockchainList(orignalBlocks);          blockchain = Mining.getBlockchain(                 Seting.ORIGINAL_BLOCKCHAIN_FILE,                 BlockchainFactoryEnum.ORIGINAL);          if(!blockchain.validatedBlockchain()){             UtilsBlock.deleteFiles();         }             System.out.println(\"addBlock start\");             for (Block block : orignalBlocks) {                 UtilsBlock.saveBLock(block, Seting.ORIGINAL_BLOCKCHAIN_FILE);             }            //перерасчет после добычи //        balances = UtilsBalance.calculateBalances(blockchain.getBlockchainList()); //        Mining.deleteFiles(Seting.ORIGINAL_BALANCE_FILE); //        SaveBalances.saveBalances(balances, Seting.ORIGINAL_BALANCE_FILE);           //получение и отображение законов, а также сохранение новых законов         //и изменение действующих законов //        Map<String, Laws> allLaws = UtilsLaws.getLaws(blockchain.getBlockchainList(), Seting.ORIGINAL_ALL_CORPORATION_LAWS_FILE);           //возвращает все законы с балансом //        List<LawEligibleForParliamentaryApproval> allLawsWithBalance = UtilsLaws.getCurrentLaws(allLaws, balances, Seting.ORIGINAL_ALL_CORPORATION_LAWS_WITH_BALANCE_FILE); //        удаление устаревних законов //        Mining.deleteFiles(Seting.ORIGINAL_ALL_CORPORATION_LAWS_WITH_BALANCE_FILE); //        UtilsLaws.saveCurrentsLaws(allLawsWithBalance, Seting.ORIGINAL_ALL_CORPORATION_LAWS_WITH_BALANCE_FILE);          System.out.println(\"BasisController: addBlock: finish\");     }      @RequestMapping(method = RequestMethod.POST, value = \"/nodes/register\", consumes = MediaType.APPLICATION_JSON_VALUE)     public synchronized void register_node(@RequestBody AddressUrl urlAddrress) throws IOException, NoSuchAlgorithmException, InvalidKeySpecException, SignatureException, NoSuchProviderException, InvalidKeyException {           for (String s : BasisController.getNodes()) {             String original = s;             String url = s + \"/nodes/register\";              try {                 UtilUrl.sendPost(urlAddrress.getAddress(), url);                 sendAddress();               } catch (Exception e) {                 System.out.println(\"BasisController: register node: wrong node: \" + original);                 BasisController.getNodes().remove(original);                 continue;             }         }          Set<String> nodes = BasisController.getNodes();         nodes = nodes.stream()                 .map(t -> t.replaceAll(\"\\\"\", \"\"))                 .map(t -> t.replaceAll(\"\\\\\\\\\", \"\"))                 .collect(Collectors.toSet());         nodes.add(urlAddrress.getAddress());         BasisController.setNodes(nodes);          Mining.deleteFiles(Seting.ORIGINAL_POOL_URL_ADDRESS_FILE);         nodes.stream().forEach(t -> {             try {                 UtilsAllAddresses.saveAllAddresses(t, Seting.ORIGINAL_POOL_URL_ADDRESS_FILE);             } catch (IOException e) {                 throw new RuntimeException(e);             } catch (NoSuchAlgorithmException e) {                 throw new RuntimeException(e);             } catch (SignatureException e) {                 throw new RuntimeException(e);             } catch (InvalidKeySpecException e) {                 throw new RuntimeException(e);             } catch (NoSuchProviderException e) {                 throw new RuntimeException(e);             } catch (InvalidKeyException e) {                 throw new RuntimeException(e);             }         });      }      /**Делает перерасчет исходя и текущего блокчейна, заного перезаписывая файлы баланса и другие файлы.      * Makes a recalculation based on the current blockchain, overwriting balance files and other files.*/     @GetMapping(\"/addBlock\")     public boolean getBLock() throws IOException, NoSuchAlgorithmException, InvalidKeySpecException, SignatureException, NoSuchProviderException, InvalidKeyException {         blockchain = Mining.getBlockchain(                 Seting.ORIGINAL_BLOCKCHAIN_FILE,                 BlockchainFactoryEnum.ORIGINAL);         UtilsBlock.deleteFiles();         addBlock(blockchain.getBlockchainList(), BLockchainFactory.getBlockchain(BlockchainFactoryEnum.ORIGINAL));         return true;     }      @GetMapping(\"/getNodes\")     public Set<String> getAllNodes() throws IOException, NoSuchAlgorithmException, InvalidKeySpecException, SignatureException, NoSuchProviderException, InvalidKeyException {         Set<String> temporary = UtilsAllAddresses.readLineObject(Seting.ORIGINAL_POOL_URL_ADDRESS_FILE);         nodes.addAll(temporary);         nodes.addAll(Seting.ORIGINAL_ADDRESSES);         nodes = nodes.stream().filter(t -> t.startsWith(\"\\\"\"))                 .collect(Collectors.toSet());         return nodes;     }      @GetMapping(\"/findAddresses\")     public void findAddresses() throws IOException, NoSuchAlgorithmException, InvalidKeySpecException, SignatureException, NoSuchProviderException, InvalidKeyException {         for (String s : Seting.ORIGINAL_ADDRESSES) {             Set<String> addressesSet = new HashSet<>();             try {                 String addresses = UtilUrl.readJsonFromUrl(s + \"/getDiscoveryAddresses\");                 addressesSet = UtilsJson.jsonToSetAddresses(addresses);             } catch (IOException e) {                 System.out.println(\"BasisController: findAddress: error\");                 continue;             } catch (JSONException e) {                 throw new RuntimeException(e);             }              for (String s1 : addressesSet) {                  register_node(new AddressUrl(s1));             }          }      }       public static void sendAddress() throws IOException, NoSuchAlgorithmException, InvalidKeySpecException, SignatureException, NoSuchProviderException, InvalidKeyException {         //лист временный для отправки аддресов          for (String s : Seting.ORIGINAL_ADDRESSES) {              String original = s;             String url = s + \"/nodes/register\";              if(BasisController.getExcludedAddresses().contains(url)){                 System.out.println(\"MainController: its your address or excluded address: \" + url);                 continue;             }             try {                 for (String s1 : BasisController.getNodes()) {                       AddressUrl addressUrl = new AddressUrl(s1);                     String json = UtilsJson.objToStringJson(addressUrl);                     UtilUrl.sendPost(json, url);                 }             } catch (Exception e) {                 System.out.println(\"BasisController: sendAddress: wronge node: \" + original);                  continue;             }           }     } }","package International_Trade_Union.controllers;  import International_Trade_Union.config.BlockchainFactoryEnum; import International_Trade_Union.entity.blockchain.Blockchain; import International_Trade_Union.model.Mining; import International_Trade_Union.setings.Seting; import org.springframework.web.bind.annotation.GetMapping; import org.springframework.web.bind.annotation.RestController;  import java.io.IOException; import java.security.InvalidKeyException; import java.security.NoSuchAlgorithmException; import java.security.NoSuchProviderException; import java.security.SignatureException; import java.security.spec.InvalidKeySpecException;  @RestController public class BlockchainCheckController {      //TODO во время майнинга, если майнинг не остановлен, он почему то возвращает false, но после остановки true. Нужно исправить.     //TODO during mining, if mining is not stopped, for some reason it returns false, but after stopping it returns true. Need to fix.     //TODO worked after restart server, get true.     //TODO ошибка возникает если прервать mine,     //TODO error occurs if mine is interrupted,     @GetMapping(\"/checkValidation\")     public synchronized boolean checkValidation() throws IOException, NoSuchAlgorithmException, SignatureException, InvalidKeySpecException, NoSuchProviderException, InvalidKeyException {         try{             Blockchain blockchain = Mining.getBlockchain(                     Seting.ORIGINAL_BLOCKCHAIN_FILE,                     BlockchainFactoryEnum.ORIGINAL);             System.out.println(\"BlockchainCheckController: checkValidation: size: \" + blockchain.sizeBlockhain());             return blockchain.validatedBlockchain();}         catch (IOException e){             e.printStackTrace();             return false;         }     } }","package International_Trade_Union.controllers;   import International_Trade_Union.entity.DtoTransaction.DtoTransaction; import International_Trade_Union.network.AllTransactions; import org.springframework.http.MediaType; import org.springframework.web.bind.annotation.*;  import java.io.IOException; import java.security.InvalidKeyException; import java.security.NoSuchAlgorithmException; import java.security.NoSuchProviderException; import java.security.SignatureException; import java.security.spec.InvalidKeySpecException; import java.util.List; import java.util.stream.Collectors;  @RestController public class TransactionController {     @RequestMapping(method = RequestMethod.POST, value = \"/addTransaction\", consumes = MediaType.APPLICATION_JSON_VALUE)     public  void add(@RequestBody DtoTransaction data) throws IOException, NoSuchAlgorithmException, SignatureException, InvalidKeySpecException, NoSuchProviderException, InvalidKeyException {         System.out.println(\"add transaction: \" + data);         AllTransactions.getInstance();         if(!AllTransactions.getInstance().contains(data))             AllTransactions.addTransaction(data);         System.out.println(\"TransactionController: add: \" + AllTransactions.getInstance().size());     }      @GetMapping(\"/getTransactions\")     public List<DtoTransaction> getTransaction() throws IOException, NoSuchAlgorithmException, InvalidKeySpecException, SignatureException, NoSuchProviderException, InvalidKeyException {         return AllTransactions.getInstance().stream().distinct().collect(Collectors.toList());     }  }","package International_Trade_Union.entity.blockchain.block;  import International_Trade_Union.entity.DtoTransaction.DtoTransaction; import International_Trade_Union.exception.NotValidTransactionException; import International_Trade_Union.utils.UtilsJson; import International_Trade_Union.utils.UtilsUse; import com.fasterxml.jackson.annotation.JsonAutoDetect;  import lombok.Data;  import java.io.IOException; import java.security.InvalidKeyException; import java.security.NoSuchAlgorithmException; import java.security.NoSuchProviderException; import java.security.SignatureException; import java.security.spec.InvalidKeySpecException; import java.sql.Timestamp; import java.util.List; import java.util.Objects;  @JsonAutoDetect @Data public final class Block implements Cloneable {     private List<DtoTransaction> dtoTransactions;     private String previousHash;     private String minerAddress;     private String founderAddress;     private long randomNumberProof;     private double minerRewards;     private int hashCompexity;     private Timestamp timestamp;     private long index;     private String hashBlock;      public Block(List<DtoTransaction> dtoTransactions,  String previousHex, String minerAddress, String founderAddress, int hashCompexity, long index) throws IOException, NoSuchAlgorithmException, SignatureException, NoSuchProviderException, InvalidKeyException, InvalidKeySpecException {         this.dtoTransactions = dtoTransactions;         this.previousHash = previousHex;         this.minerAddress = minerAddress;         this.minerRewards = miningRewardsCount();         this.hashCompexity = hashCompexity;         this.founderAddress = founderAddress;         this.timestamp = new Timestamp(System.currentTimeMillis());         this.index = index;         this.hashBlock = findHash(hashCompexity);      }      public Block(List<DtoTransaction> dtoTransactions, String previousHash, String minerAddress, String founderAddress, long randomNumberProof, double minerRewards, int hashCompexity, Timestamp timestamp, long index, String hashBlock) {         this.dtoTransactions = dtoTransactions;         this.previousHash = previousHash;         this.minerAddress = minerAddress;         this.founderAddress = founderAddress;         this.randomNumberProof = randomNumberProof;         this.minerRewards = minerRewards;         this.hashCompexity = hashCompexity;         this.timestamp = timestamp;         this.index = index;         this.hashBlock = hashBlock;     }      @JsonAutoDetect     @Data     private class BlockForHash{         private List<DtoTransaction> transactions;         private String previousHash;         private String minerAddress;         private String founderAddress;         private long randomNumberProof;         private double minerRewards;         private int hashCompexity;         private Timestamp timestamp;         private long index;           public BlockForHash() {         }           public BlockForHash(List<DtoTransaction> transactions,                             String previousHash,                             String minerAddress,                             String founderAddress,                             long randomNumberProof,                             double minerRewards,                             int hashCompexity,                             Timestamp timestamp,                             long index) {             this.transactions = transactions;             this.previousHash = previousHash;             this.minerAddress = minerAddress;             this.founderAddress = founderAddress;             this.randomNumberProof = randomNumberProof;             this.minerRewards = minerRewards;             this.hashCompexity = hashCompexity;             this.timestamp = timestamp;             this.index = index;          }         private String hashesAllTrans() throws IOException {             String hash = \"\";             for (DtoTransaction dtoTransaction : dtoTransactions) {                 hash += dtoTransaction.hashForBlock();             }              return hash;          }          public String hashForTransaction() throws IOException {             return UtilsUse.sha256hash(jsonString());         }          public String jsonString() throws IOException {             return UtilsJson.objToStringJson(this);         }     }      public Block() {     }      public String hashForBlockchain()             throws             IOException{         return this.hashBlock;     }       public boolean verifyesTransSign() throws IOException, NoSuchAlgorithmException, SignatureException, NoSuchProviderException, InvalidKeyException, InvalidKeySpecException {         for (DtoTransaction dtoTransaction : dtoTransactions) {             if(!dtoTransaction.verify())                 return false;         }         return true;     }      private double miningRewardsCount(){         double rewards = 0.0;         for (DtoTransaction dtoTransaction : dtoTransactions) {              rewards += dtoTransaction.getBonusForMiner();         }          return rewards;     }      public String jsonString() throws IOException {         return UtilsJson.objToStringJson(this);     }     //TODO     public String findHash(int hashCoplexity) throws IOException, NoSuchAlgorithmException, SignatureException, NoSuchProviderException, InvalidKeyException, InvalidKeySpecException {         if (!verifyesTransSign()){             throw new NotValidTransactionException();         }          this.randomNumberProof = 0;         String hash = \"\";         while (true){             this.randomNumberProof++;             BlockForHash block = new BlockForHash(this.dtoTransactions,                     this.previousHash, this.minerAddress, this.founderAddress,                     this.randomNumberProof, this.minerRewards, this.hashCompexity, this.timestamp, this.index);             hash = block.hashForTransaction();             if(UtilsUse.hashComplexity(hash.substring(0, hashCoplexity), hashCoplexity))             {                 break;             }          }         return hash;     }      @Override     public boolean equals(Object o) {           if (this == o) return true;         if (!(o instanceof Block)) return false;         Block block = (Block) o;         return getRandomNumberProof() == block.getRandomNumberProof() && Double.compare(block.getMinerRewards(), getMinerRewards()) == 0 && getHashCompexity() == block.getHashCompexity() && getIndex() == block.getIndex() && Objects.equals(getDtoTransactions(), block.getDtoTransactions()) && Objects.equals(getPreviousHash(), block.getPreviousHash()) && Objects.equals(getMinerAddress(), block.getMinerAddress()) && Objects.equals(getFounderAddress(), block.getFounderAddress()) && Objects.equals(getTimestamp(), block.getTimestamp()) && Objects.equals(getHashBlock(), block.getHashBlock());     }      @Override     public int hashCode() {         return Objects.hash(getDtoTransactions(), getPreviousHash(), getMinerAddress(), getFounderAddress(), getRandomNumberProof(), getMinerRewards(), getHashCompexity(), getTimestamp(), getIndex(), getHashBlock());     }      @Override     public Block clone() throws CloneNotSupportedException {         return new Block(this.dtoTransactions, this.previousHash, this.minerAddress, this.founderAddress,                 this.randomNumberProof, this.minerRewards, this.hashCompexity, this.timestamp, this.index,                 this.hashBlock);     } }","package International_Trade_Union.entity.blockchain;  import International_Trade_Union.entity.DtoTransaction.DtoTransaction; import International_Trade_Union.entity.blockchain.block.Block; import International_Trade_Union.setings.Seting; import International_Trade_Union.utils.UtilsBlock; import International_Trade_Union.utils.UtilsJson; import International_Trade_Union.utils.UtilsSecurity; import International_Trade_Union.utils.UtilsUse; import International_Trade_Union.utils.base.Base; import International_Trade_Union.utils.base.Base58; import International_Trade_Union.vote.Laws; import International_Trade_Union.vote.VoteEnum; import com.fasterxml.jackson.annotation.JsonAutoDetect;  import lombok.Data;  import java.io.IOException; import java.security.*; import java.security.spec.InvalidKeySpecException; import java.util.ArrayList; import java.util.List; import java.util.Objects;   @JsonAutoDetect @Data public class Blockchain implements Cloneable{     private List<Block> blockchainList;     //как часто должно создаваться блок в миллисекундах 1000 миллисекунд = 1 секунд     private long BLOCK_GENERATION_INTERVAL;     //каждые сколько блоков должен происходить перерасчет сложности     private int DIFFICULTY_ADJUSTMENT_INTERVAL;     //блок действителен, если значение блока меньше данного занчения в миллисекунда     private long INTERVAL_TARGET;     private String ADDRESS_FOUNDER;     public int sizeBlockhain(){          return blockchainList.size();     }      public void setBlockchainList(List<Block> blockchainList) throws IOException, NoSuchAlgorithmException, InvalidKeySpecException, SignatureException, NoSuchProviderException, InvalidKeyException {         this.blockchainList = blockchainList;      }      public Blockchain(long BLOCK_GENERATION_INTERVAL, int DIFFICULTY_ADJUSTMENT_INTERVAL, long INTERVAL_TARGET, String ADDRESS_FOUNDER) throws NoSuchAlgorithmException, InvalidKeySpecException, NoSuchProviderException, IOException, SignatureException, InvalidKeyException {         this(new ArrayList<>(), BLOCK_GENERATION_INTERVAL, DIFFICULTY_ADJUSTMENT_INTERVAL, INTERVAL_TARGET, ADDRESS_FOUNDER);      }     public Blockchain(List<Block> blockchainList, long BLOCK_GENERATION_INTERVAL, int DIFFICULTY_ADJUSTMENT_INTERVAL, long INTERVAL_TARGET,String ADDRESS_FOUNDER) throws IOException, NoSuchAlgorithmException, InvalidKeySpecException, SignatureException, NoSuchProviderException, InvalidKeyException {         this.blockchainList = blockchainList;         this.BLOCK_GENERATION_INTERVAL = BLOCK_GENERATION_INTERVAL;         this.DIFFICULTY_ADJUSTMENT_INTERVAL = DIFFICULTY_ADJUSTMENT_INTERVAL;         this.INTERVAL_TARGET = INTERVAL_TARGET;         this.ADDRESS_FOUNDER = ADDRESS_FOUNDER;         Block block = genesisBlock();         addBlock(block);     }      public void addBlock(Block newBlock) throws IOException, NoSuchAlgorithmException, SignatureException, InvalidKeySpecException, NoSuchProviderException, InvalidKeyException { //        if(blockchainList.size() > 2){ //            boolean time = UtilsBlock.isValidTimestamp(blockchainList.get(blockchainList.size()-1), newBlock, INTERVAL_TARGET); //            if(!time){ //                System.out.println(\"time out block add \" + time); //               return; //            } //        }         blockchainList.add(newBlock);       }      public Block genesisBlock() throws IOException, NoSuchAlgorithmException, InvalidKeySpecException, NoSuchProviderException, SignatureException, InvalidKeyException {         Base base = new Base58();         //dto sign         //pub byte keys         //transactions         List<DtoTransaction> transactions = new ArrayList<>();          DtoTransaction gold = new DtoTransaction(Seting.BASIS_ADDRESS, ADDRESS_FOUNDER,                 Seting.FOUNDERS_REMUNERATION_DIGITAL_DOLLAR, Seting.FOUNDERS_REMNUNERATION_DIGITAL_STOCK, new Laws(), 0.0, VoteEnum.YES);         PrivateKey privateKey = UtilsSecurity.privateBytToPrivateKey(base.decode(Seting.BASIS_PASSWORD));         byte[] signGold = UtilsSecurity.sign(privateKey, gold.toSign());         gold.setSign(signGold);         transactions.add(gold);          String genesisHash = genesisPrevHash();         Block block = new Block(transactions,  genesisHash, ADDRESS_FOUNDER, ADDRESS_FOUNDER,  Seting.HASH_COMPLEXITY_GENESIS, blockchainList.size());         return block;     }        public String genesisPrevHash() throws IOException {         return UtilsUse.hashComplexityStr(Seting.CORPORATE_CHARTER_DRAFT, Seting.HASH_COMPLEXITY_GENESIS);     }      public String getHashBlock(int index) throws IOException {         return blockchainList.get(index).hashForBlockchain();     }     public Block getBlock(int index){         return blockchainList.get(index);     }        public boolean validatedBlockchain() throws IOException, NoSuchAlgorithmException, SignatureException, InvalidKeySpecException, NoSuchProviderException, InvalidKeyException {        return UtilsBlock.validation(blockchainList, BLOCK_GENERATION_INTERVAL, DIFFICULTY_ADJUSTMENT_INTERVAL);     }      public String jsonString() throws IOException {         return UtilsJson.objToStringJson(blockchainList);     }     @Override     public boolean equals(Object o) {         if (this == o) return true;         if (!(o instanceof Blockchain)) return false;         Blockchain that = (Blockchain) o;         return getBlockchainList().equals(that.getBlockchainList());     }      @Override     public int hashCode() {         return Objects.hash(getBlockchainList());     }      public  List<Block> subBlock(int startIndex, int finishIndex) throws CloneNotSupportedException {         List<Block> temporary = this.getBlockchainList().subList(startIndex, finishIndex);         List<Block> result = new ArrayList<>();         for (Block block : temporary) {             result.add(block.clone());         }         return result;     }       @Override     public List<Block> clone() throws CloneNotSupportedException {         List<Block> result = new ArrayList<>();         for (Block block : blockchainList) {             result.add(block.clone());         }         return result;      } }","package International_Trade_Union.entity.DtoTransaction;  import org.bouncycastle.jcajce.provider.asymmetric.ec.BCECPublicKey; import International_Trade_Union.setings.Seting; import International_Trade_Union.utils.UtilsJson; import International_Trade_Union.utils.UtilsSecurity; import International_Trade_Union.utils.UtilsUse; import International_Trade_Union.utils.base.Base; import International_Trade_Union.utils.base.Base58; import International_Trade_Union.vote.Laws; import International_Trade_Union.vote.VoteEnum; import com.fasterxml.jackson.annotation.JsonAutoDetect;  import lombok.Data;   import java.io.IOException; import java.security.*; import java.security.spec.InvalidKeySpecException; import java.util.Arrays; import java.util.Objects;   @JsonAutoDetect @Data public class DtoTransaction {     private String sender;     private String customer;     private double digitalDollar;     private double digitalStockBalance;     private Laws laws;     private double bonusForMiner;     private VoteEnum voteEnum;     private byte[] sign;        public DtoTransaction(String sender, String customer, double digitalDollar, double digitalStockBalance, Laws laws, double bonusForMiner, VoteEnum voteEnum) {         this.sender = sender;         this.customer = customer;         this.digitalDollar = digitalDollar;         this.digitalStockBalance = digitalStockBalance;         this.laws = laws;         this.bonusForMiner = bonusForMiner;         this.voteEnum = voteEnum;     }      public DtoTransaction() {     }      //TODO возможно стоит перевести проверку подписи в отдельный utils, под вопросом!!     public boolean verify() throws IOException, NoSuchAlgorithmException, SignatureException, NoSuchProviderException, InvalidKeyException, InvalidKeySpecException {         Base base = new Base58();         byte[] pub = base.decode(sender);         BCECPublicKey publicKey = (BCECPublicKey) UtilsSecurity.decodeKey(pub); //        PublicKey publicKey = UtilsSecurity.publicByteToPublicKey(pub);         String sha = sender + customer + digitalDollar + digitalStockBalance + laws + bonusForMiner;         sha = UtilsUse.sha256hash(sha);         if(sender.isBlank() || customer.isBlank() || digitalDollar < 0 || digitalStockBalance < 0 || bonusForMiner < 0 || laws == null){             System.out.println(\"wrong dto transaction sender or customer blank? or dollar, reputation or reward less then 0\");             return false;         }         if(Seting.BASIS_ADDRESS.equals(publicKey))             return true;         return UtilsSecurity.verify(sha, sign, publicKey);     }      public String toSign(){         String sha = sender + customer + digitalDollar + digitalStockBalance + laws + bonusForMiner;         return UtilsUse.sha256hash(sha);     }      public String hashForBlock() throws IOException {         return UtilsUse.sha256hash(jsonString());     }      public String jsonString() throws IOException {         return UtilsJson.objToStringJson(this);     }      @Override     public boolean equals(Object o) {         if (this == o) return true;         if (!(o instanceof DtoTransaction)) return false;         DtoTransaction that = (DtoTransaction) o;         return Double.compare(that.getDigitalDollar(), getDigitalDollar()) == 0 && Double.compare(that.getDigitalStockBalance(), getDigitalStockBalance()) == 0 && Double.compare(that.getBonusForMiner(), getBonusForMiner()) == 0 && getSender().equals(that.getSender()) && getCustomer().equals(that.getCustomer()) && getLaws().equals(that.getLaws()) && getVoteEnum() == that.getVoteEnum() && Arrays.equals(getSign(), that.getSign());     }      @Override     public int hashCode() {         int result = Objects.hash(getSender(), getCustomer(), getDigitalDollar(), getDigitalStockBalance(), getLaws(), getBonusForMiner(), getVoteEnum());         result = 31 * result + Arrays.hashCode(getSign());         return result;     } }","package International_Trade_Union.entity;  import lombok.Data;  @Data public class AddressUrl {     private String address;      public AddressUrl() {     }      public AddressUrl(String address) {         this.address = address;     } }","package International_Trade_Union.entity;   import lombok.Data; import International_Trade_Union.entity.blockchain.block.Block;  import java.util.List;  @Data public class EntityChain {      private int size;     private List<Block> blocks;      public EntityChain() {     }      public EntityChain(int sizeBlockhain, List<Block> blockchainList) {         this.size = sizeBlockhain;         this.blocks = blockchainList;     } }","package International_Trade_Union.entity;   import lombok.Data; import International_Trade_Union.entity.blockchain.Blockchain; import International_Trade_Union.entity.blockchain.block.Block; import International_Trade_Union.model.Account;  import java.util.List; import java.util.Map;  @Data public class ResultMiningData {     private Map<String, Account> balance;     private Blockchain blockchain;     private Block miningBlock;     private List<Block> lastBlock;     private Account governments;  }","package International_Trade_Union.entity;  import lombok.Data;  @Data public class SubBlockchainEntity {     private int start;     private int finish;      public SubBlockchainEntity(int start, int finish) {         this.start = start;         this.finish = finish;     }      public SubBlockchainEntity() {     } }","package International_Trade_Union.exception;  import java.io.IOException;  public class NotValidTransactionException extends IOException { }","package International_Trade_Union.governments;   import International_Trade_Union.model.Account;  public class CompareObject {      public int compare(Account o1, Account o2) {         double x1 = o1.getDigitalStockBalance();         double x2 = o2.getDigitalStockBalance();         int power = Double.compare(x1, x2);         if (power != 0)             return power;         double gold1 = o1.getDigitalDollarBalance();         double gold2 = o2.getDigitalDollarBalance();         int gold = Double.compare(gold1, gold2);         if(gold != 0)             return gold;         double first = x1 + gold1;         double second = x2 + gold2;         return Double.compare(first, second);     }      @Override     public boolean equals(Object obj) {         return false;     } }","package International_Trade_Union.governments;  import lombok.AllArgsConstructor; import lombok.Data; import lombok.NoArgsConstructor;  import java.util.Arrays; import java.util.List; import java.util.Locale; import java.util.Objects; import java.util.stream.Collectors;  @Data @NoArgsConstructor @AllArgsConstructor public class Director {     //количество юридических или физических лиц в данной должности     //количество юридических или физических лиц в данной должности     private String name;     private  int count;      private boolean electedByCEO;     private boolean electedByBoardOfDirectors;       private boolean electedByCorporateCouncilOfReferees;     private boolean electedByStocks;     private boolean officeOfDirectors;       @Override     public boolean equals(Object o) {         if (this == o) return true;         if (!(o instanceof Director)) return false;         Director director = (Director) o;         return getName().equals(director.getName());     }      @Override     public int hashCode() {         return Objects.hash(getName());     }      public boolean isAppointedByTheGovernment(){         if(electedByCEO || electedByBoardOfDirectors || electedByCorporateCouncilOfReferees)             return true;         else return false;     }     public int getCount() {         return count;     }     }","package International_Trade_Union.governments;  import International_Trade_Union.setings.Seting; import International_Trade_Union.utils.UtilsUse; import lombok.Data;  import java.util.ArrayList; import java.util.List; import java.util.Locale; import java.util.stream.Collectors;  @Data  public class Directors {     public Directors() {          directors = new ArrayList<>();         Director CORPORATE_COUNCIL_OF_REFEREES = new Director(\"CORPORATE_COUNCIL_OF_REFEREES\", 55, false, false, false, true, false);         Director BOARD_OF_DIRECTORS = new Director(\"BOARD_OF_DIRECTORS\", 301, false, false, false, true, false);          Director GENERAL_EXECUTIVE_DIRECTOR = new Director(\"GENERAL_EXECUTIVE_DIRECTOR\", 1, false, true, false, false, true);         Director HIGH_JUDGE = new Director(\"HIGH_JUDGE\",1, false, false, true, false, false);          Director INTERNET_STORE_DIRECTOR = new Director(\"INTERNET_STORE_DIRECTOR\",1, false, true, false, false, true);         Director DIRECTOR_OF_THE_DIGITAL_EXCHANGE = new Director(\"DIRECTOR_OF_THE_DIGITAL_EXCHANGE\",1, false, true, false, false, true);         Director DIRECTOR_OF_DIGITAL_BANK = new Director(\"DIRECTOR_OF_DIGITAL_BANK\",1, false, true, false, false, true);         Director DIRECTOR_OF_THE_COMMERCIAL_COURT = new Director(\"DIRECTOR_OF_THE_COMMERCIAL_COURT\",1, false, true, false, false, true);         Director MEDIA_DIRECTOR = new Director(\"MEDIA_DIRECTOR\",1, false, true, false, false, true);         Director DIRECTOR_OF_THE_DEVELOPMENT_OF_THE_IMPLEMENTATION_OF_CRYPTOCURRENCY_TECHNOLOGIES_OF_THE_INTERNATIONAL_TRADE_UNION_CORPORATION = new Director(\"DIRECTOR_OF_THE_DEVELOPMENT_OF_THE_IMPLEMENTATION_OF_CRYPTOCURRENCY_TECHNOLOGIES_OF_THE_INTERNATIONAL_TRADE_UNION_CORPORATION\",1, false, true, false, false, true);          directors.add(CORPORATE_COUNCIL_OF_REFEREES);         directors.add(BOARD_OF_DIRECTORS);          directors.add(GENERAL_EXECUTIVE_DIRECTOR);         directors.add(HIGH_JUDGE);          directors.add(INTERNET_STORE_DIRECTOR);         directors.add(DIRECTOR_OF_THE_DIGITAL_EXCHANGE);         directors.add(DIRECTOR_OF_DIGITAL_BANK);         directors.add(DIRECTOR_OF_THE_COMMERCIAL_COURT);         directors.add(MEDIA_DIRECTOR);         directors.add(DIRECTOR_OF_THE_DEVELOPMENT_OF_THE_IMPLEMENTATION_OF_CRYPTOCURRENCY_TECHNOLOGIES_OF_THE_INTERNATIONAL_TRADE_UNION_CORPORATION);     }       public Director getDirector(String str){        List<Director> director = directors                .stream()                .filter(t->t.getName().equals(str))                .collect(Collectors.toList());        return director.get(0);      }     private List<Director> directors;      public boolean contains(String str) {         str = str.toUpperCase();         directors = directors.stream().filter(UtilsUse.distinctByKey(Director::getName)).collect(Collectors.toList());         List<String> strings = directors.stream().map(t->t.getName()).collect(Collectors.toList());        return strings.contains(str);     }      public boolean isCabinets(String str) {         List<String> list = directors.stream()                 .filter(t->t.isOfficeOfDirectors())                 .filter(UtilsUse.distinctByKey(Director::getName))                 .map(t->t.getName())                 .collect(Collectors.toList());         return list.contains(str.toUpperCase(Locale.ROOT));     }       //должности которые добавляются только советом директоров     public void addByBoardOfDirectors(String str) {         if (str.startsWith(Seting.ADD_DIRECTOR)) {             Director director = new Director(str, 1, false, true, false, false, true);             directors.add(director);             directors = directors.stream().filter(UtilsUse.distinctByKey(Director::getName)).collect(Collectors.toList());         }      }      public void addAllByBoardOfDirectors(List<String> strings) {         strings = strings.stream()                 .filter(t -> t.startsWith(Seting.ADD_DIRECTOR))                 .distinct()                 .collect(Collectors.toList());         for (String s : strings) {             Director director = new Director(s, 1, false, true, false, false, true);             directors.add(director);         }         directors = directors.stream().filter(UtilsUse.distinctByKey(Director::getName)).collect(Collectors.toList());      }       public List<String> getNames() {         return directors.stream().map(t -> t.getName()).collect(Collectors.toList());     }       public  boolean isElectedByStocks(String str){         List<String> list = directors.stream()                 .filter(t->t.isElectedByStocks())                 .map(t->t.getName())                 .collect(Collectors.toList());          return list.contains(str.toUpperCase(Locale.ROOT));     }     public boolean isElectedCEO(String str){         List<String> list = directors.stream()                 .filter(t->t.isElectedByCEO())                 .map(t->t.getName())                 .collect(Collectors.toList());          return list.contains(str.toUpperCase(Locale.ROOT));     }      public  boolean isElectedByBoardOfDirectors(String  str){         List<String> list = directors.stream()                 .filter(t->t.isElectedByBoardOfDirectors())                 .map(t->t.getName())                 .collect(Collectors.toList());          return list.contains(str.toUpperCase(Locale.ROOT));     }      public boolean isElectedBYCorporateCouncilOfReferees(String  str){         List<String> list = directors.stream()                 .filter(t->t.isElectedByCorporateCouncilOfReferees())                 .map(t->t.getName())                 .collect(Collectors.toList());          return list.contains(str.toUpperCase(Locale.ROOT));     }      public boolean isofficeOfDirectors(String str){         List<String> list = directors.stream()                 .filter(t->t.isOfficeOfDirectors())                 .map(t->t.getName())                 .collect(Collectors.toList());          return list.contains(str.toUpperCase(Locale.ROOT));     } }","package International_Trade_Union.governments;  public enum NamePOSITION {     BOARD_OF_DIRECTORS,     CORPORATE_COUNCIL_OF_REFEREES,     GENERAL_EXECUTIVE_DIRECTOR,     HIGH_JUDGE }","package International_Trade_Union.governments;   import International_Trade_Union.entity.DtoTransaction.DtoTransaction; import International_Trade_Union.entity.blockchain.block.Block; import International_Trade_Union.model.Account; import International_Trade_Union.setings.Seting; import International_Trade_Union.vote.*;  import java.io.IOException; import java.security.InvalidKeyException; import java.security.NoSuchAlgorithmException; import java.security.NoSuchProviderException; import java.security.SignatureException; import java.security.spec.InvalidKeySpecException; import java.util.*; import java.util.stream.Collectors;  public class UtilsGovernment {      //для корпоративных позиций, адресс отправителя должен совпадать с первой строкой закона     public static boolean checkPostionSenderEqualsLaw(String addressSender, Laws laws) {         Directors directors = new Directors();         List<Director> enumPosition = directors.getDirectors();         List<String> corporateSeniorPositions = enumPosition.stream().map(t->t.getName()).collect(Collectors.toList());         if (corporateSeniorPositions.contains(laws.getPacketLawName())) {             if (laws.getLaws().get(0) != null && addressSender.equals(laws.getLaws().get(0))) {                 System.out.println(\"UtilsBogernment: checkPostionSenderEqualsLaw: \" + laws.getLaws().get(0) + \" true:\");                 return true;             } else {                 System.out.println(\"UtilsBogernment: checkPostionSenderEqualsLaw: \" + laws.getLaws().get(0) + \" false:\");                 return false;             }         }         System.out.println(\"UtilsBogernment: checkPostionSenderEqualsLaw: \" + laws.getLaws().get(0) + \" not position:\");         return true;     }       //определение совета акционеров     public static List<Account> findBoardOfShareholders(Map<String, Account> balances, List<Block> blocks, int limit) {         List<Block> minersHaveMoreStock = null;         if (blocks.size() > limit) {             minersHaveMoreStock = blocks.subList(blocks.size() - limit, blocks.size());         } else {             minersHaveMoreStock = blocks;         }         List<Account> boardAccounts = minersHaveMoreStock.stream().map(                         t -> new Account(t.getMinerAddress(), 0, 0))                 .collect(Collectors.toList());          for (Block block : minersHaveMoreStock) {             for (DtoTransaction dtoTransaction : block.getDtoTransactions()) {                 boardAccounts.add(new Account(dtoTransaction.getSender(), 0, 0));             }          }           CompareObject compareObject = new CompareObject();          List<Account> boardOfShareholders = balances.entrySet().stream()                 .filter(t -> boardAccounts.contains(t.getValue()))                 .map(t -> t.getValue()).collect(Collectors.toList());           boardOfShareholders = boardOfShareholders                 .stream()                 .filter(t -> !t.getAccount().startsWith(Seting.NAME_LAW_ADDRESS_START))                 .filter(t -> t.getDigitalStockBalance() > 0)                 .sorted(Comparator.comparing(Account::getDigitalStockBalance).reversed())                 .collect(Collectors.toList());          boardOfShareholders = boardOfShareholders                 .stream()                 .limit(Seting.BOARD_OF_SHAREHOLDERS)                 .collect(Collectors.toList());          return boardOfShareholders;     }       public static List<CurrentLawVotesEndBalance> filtersVotes(             List<LawEligibleForParliamentaryApproval> approvalList,             Map<String, Account> balances,             List<Account> BoardOfShareholders,             List<Block> blocks,             int limitBlocks     ) throws IOException, NoSuchAlgorithmException, SignatureException, InvalidKeySpecException, NoSuchProviderException, InvalidKeyException {         //действующие законы чьи голоса больше ORIGINAL_LIMIT_MIN_VOTE         List<CurrentLawVotesEndBalance> current = new ArrayList<>();         Map<String, CurrentLawVotes> votesMap = null;         List<Account> accounts = balances.entrySet().stream().map(t -> t.getValue()).collect(Collectors.toList());         if (blocks.size() > limitBlocks) {             votesMap = UtilsCurrentLaw.calculateVotes(accounts, blocks.subList(blocks.size() - limitBlocks, blocks.size()));         } else {             votesMap = UtilsCurrentLaw.calculateVotes(accounts, blocks);         }          //подсчитать средннее количество раз сколько он проголосовал за         Map<String, Integer> yesAverage = UtilsCurrentLaw.calculateAverageVotesYes(votesMap);         //подсчитать среднее количество раз сколько он проголосовал против         Map<String, Integer> noAverage = UtilsCurrentLaw.calculateAverageVotesNo(votesMap);           //подсчитываем голоса для для обычных законов и законов позиций         for (LawEligibleForParliamentaryApproval lawEligibleForParliamentaryApproval : approvalList) {             if (votesMap.containsKey(lawEligibleForParliamentaryApproval.getLaws().getHashLaw())) {                 String address = lawEligibleForParliamentaryApproval.getLaws().getHashLaw();                 String packageName = lawEligibleForParliamentaryApproval.getLaws().getPacketLawName();                 List<String> laws = lawEligibleForParliamentaryApproval.getLaws().getLaws();                 double vote = 0;                 int supremeVotes = 0;                 int boafdOfShareholderVotes = 0;                 int houseOfRepresentativiesVotes = 0;                 int primeMinisterVotes = 0;                 int hightJudgesVotes = 0;                 int founderVote = 0;                  //для законов подсчитываем специальные голоса                 vote = votesMap.get(lawEligibleForParliamentaryApproval.getLaws().getHashLaw()).votesLaw(balances, yesAverage, noAverage);                 List<String> boardOfShareholdersAddress = BoardOfShareholders.stream().map(t -> t.getAccount()).collect(Collectors.toList());                 boafdOfShareholderVotes = votesMap.get(lawEligibleForParliamentaryApproval.getLaws().getHashLaw()).voteGovernment(balances, boardOfShareholdersAddress);                  List<String> founder = List.of(Seting.ADDRESS_FOUNDER);                 founderVote = votesMap.get(lawEligibleForParliamentaryApproval.getLaws().getHashLaw()).voteGovernment(balances, founder);                 CurrentLawVotesEndBalance currentLawVotesEndBalance = new CurrentLawVotesEndBalance(                         address,                         packageName,                         vote,                         supremeVotes,                         houseOfRepresentativiesVotes,                         boafdOfShareholderVotes,                         primeMinisterVotes,                         hightJudgesVotes,                         founderVote,                         laws);                 current.add(currentLawVotesEndBalance);              }         }          List<String> houseOfRepresentativies = new ArrayList<>();         List<String> chamberOfSumpremeJudges = new ArrayList<>();          for (CurrentLawVotesEndBalance currentLawVotesEndBalance: current) {             if(currentLawVotesEndBalance.getPackageName().equals(NamePOSITION.BOARD_OF_DIRECTORS.toString())){                 if(currentLawVotesEndBalance.getVotes() >= Seting.ORIGINAL_LIMIT_MIN_VOTE){                      houseOfRepresentativies.add(currentLawVotesEndBalance.getLaws().get(0));                 }              }             if(currentLawVotesEndBalance.getPackageName().equals(NamePOSITION.CORPORATE_COUNCIL_OF_REFEREES.toString())){                 if(currentLawVotesEndBalance.getVotes() >= Seting.ORIGINAL_LIMIT_MIN_VOTE){                     chamberOfSumpremeJudges.add(currentLawVotesEndBalance.getLaws().get(0));                 }              }         }            for (CurrentLawVotesEndBalance currentLawVotesEndBalance : current) {             if(votesMap.containsKey(currentLawVotesEndBalance.getAddressLaw())){                   double vote = votesMap.get(currentLawVotesEndBalance.getAddressLaw()).votesLaw(balances, yesAverage, noAverage);                 int supremeVotes  = votesMap.get(currentLawVotesEndBalance.getAddressLaw()).voteGovernment(balances, chamberOfSumpremeJudges);                 int houseOfRepresentativiesVotes = votesMap.get(currentLawVotesEndBalance.getAddressLaw()).voteGovernment(balances, houseOfRepresentativies);                  currentLawVotesEndBalance.setVotes(vote);                 currentLawVotesEndBalance.setVotesBoardOfDirectors(houseOfRepresentativiesVotes);                 currentLawVotesEndBalance.setVotesCorporateCouncilOfReferees(supremeVotes);             }          }          List<String> primeMinister = new ArrayList<>();         List<String> hightJudge = new ArrayList<>();         for (CurrentLawVotesEndBalance currentLawVotesEndBalance : current) {             if(currentLawVotesEndBalance.getPackageName().equals(NamePOSITION.GENERAL_EXECUTIVE_DIRECTOR.toString())){                 if(currentLawVotesEndBalance.getVotesBoardOfDirectors() >= Seting.ORIGINAL_LIMIT_MIN_VOTE_BOARD_OF_DIRECTORS){                     primeMinister.add(currentLawVotesEndBalance.getLaws().get(0));                 }             }              if(currentLawVotesEndBalance.getPackageName().equals(NamePOSITION.HIGH_JUDGE.toString())){                 if(currentLawVotesEndBalance.getVotesCorporateCouncilOfReferees() >= Seting.ORIGINAL_LIMIT_MIN_VOTE_CORPORATE_COUNCIL_OF_REFEREES){                     hightJudge.add(currentLawVotesEndBalance.getLaws().get(0));                 }             }         }         for (CurrentLawVotesEndBalance currentLawVotesEndBalance : current) {             if(votesMap.containsKey(currentLawVotesEndBalance.getAddressLaw())){                 int primeMinisterVotes = votesMap.get(currentLawVotesEndBalance.getAddressLaw()).voteGovernment(balances, primeMinister);                 int hightJudgeVotes = votesMap.get(currentLawVotesEndBalance.getAddressLaw()).voteGovernment(balances, hightJudge);                  currentLawVotesEndBalance.setVoteGeneralExecutiveDirector(primeMinisterVotes);                 currentLawVotesEndBalance.setVoteHightJudge(hightJudgeVotes);             }          }           return current;      }          //без учета палаты представителей     public static List<CurrentLawVotesEndBalance> filters(List<LawEligibleForParliamentaryApproval> approvalList, Map<String, Account> balances,                                                           List<Account> BoardOfShareholders, List<Block> blocks, int limitBlocks) throws IOException, NoSuchAlgorithmException, InvalidKeySpecException, SignatureException, NoSuchProviderException, InvalidKeyException {         //действующие законы чьи голоса больше ORIGINAL_LIMIT_MIN_VOTE         List<CurrentLawVotesEndBalance> current = new ArrayList<>();         Map<String, CurrentLawVotes> votesMap = null;         List<Account> accounts = balances.entrySet().stream().map(t -> t.getValue()).collect(Collectors.toList());         if (blocks.size() > limitBlocks) {             votesMap = UtilsCurrentLaw.calculateVotes(accounts, blocks.subList(blocks.size() - limitBlocks, blocks.size()));         } else {             votesMap = UtilsCurrentLaw.calculateVotes(accounts, blocks);         }          //подсчитать средннее количество раз сколько он проголосовал за         Map<String, Integer> yesAverage = UtilsCurrentLaw.calculateAverageVotesYes(votesMap);         //подсчитать среднее количество раз сколько он проголосовал против         Map<String, Integer> noAverage = UtilsCurrentLaw.calculateAverageVotesNo(votesMap);          for (LawEligibleForParliamentaryApproval lawEligibleForParliamentaryApproval : approvalList) {             if (votesMap.containsKey(lawEligibleForParliamentaryApproval.getLaws().getHashLaw())) {                 String address = lawEligibleForParliamentaryApproval.getLaws().getHashLaw();                 String packageName = lawEligibleForParliamentaryApproval.getLaws().getPacketLawName();                 List<String> laws = lawEligibleForParliamentaryApproval.getLaws().getLaws();                 double vote = votesMap.get(lawEligibleForParliamentaryApproval.getLaws().getHashLaw()).votes(balances, yesAverage, noAverage);                  CurrentLawVotesEndBalance currentLawVotesEndBalance = new CurrentLawVotesEndBalance(address, packageName, vote, 0, 0, 0, 0, 0, 0,  laws);                 current.add(currentLawVotesEndBalance);              }         }         return current;     }   }","package International_Trade_Union.model;   import lombok.Data; import International_Trade_Union.entity.DtoTransaction.DtoTransaction; import International_Trade_Union.utils.UtilsSecurity; import International_Trade_Union.utils.base.Base; import International_Trade_Union.utils.base.Base58; import International_Trade_Union.vote.Laws; import International_Trade_Union.vote.VoteEnum;  import java.io.IOException; import java.security.*; import java.security.spec.InvalidKeySpecException; import java.util.Objects;   @Data public class Account {     private String account;     private double digitalDollarBalance;     private double digitalStockBalance;       public Account(String account, double digitalDollarBalance) {         this(account, digitalDollarBalance, 0.0);      }      public Account(String account, double digitalDollarBalance, double digitalStockBalance) {         this.account = account;         this.digitalDollarBalance = digitalDollarBalance;         this.digitalStockBalance = digitalStockBalance;     }      public Account() {     }      @Override     public boolean equals(Object o) {         if (this == o) return true;         if (!(o instanceof Account)) return false;         Account account1 = (Account) o;         return getAccount().equals(account1.getAccount());     }      @Override     public int hashCode() {         return Objects.hash(getAccount());     }      private DtoTransaction sendMoney(String recipient, String privatekey, double digitalDollar, double digitalStock, Laws laws, double minerRewards, VoteEnum voteEnum) throws NoSuchAlgorithmException, InvalidKeySpecException, NoSuchProviderException, SignatureException, IOException, InvalidKeyException {          DtoTransaction transaction = null;         if (account.equals(recipient)){             System.out.println(\"sender %s, recipient %s cannot be equals! Error!\".format(account,recipient));             return transaction;         }              if(digitalDollarBalance < digitalDollar + minerRewards  ){                 System.out.println(\"sender don't have digitalDollar\");                 return transaction;             }             if(digitalStockBalance < digitalStock){                 System.out.println(\"sender don't have digitalReputation\");                 return transaction;             }             else{                 Base base = new Base58();                 PrivateKey privateKey = UtilsSecurity.privateBytToPrivateKey(base.decode(privatekey));                  transaction = new DtoTransaction(this.getAccount(), recipient, digitalDollar, digitalStock, laws, minerRewards, voteEnum);                 byte[] signGold = UtilsSecurity.sign(privateKey, transaction.toSign());                 transaction.setSign(signGold);             }         return transaction;     }  //      recipient - получатель //      gold сумма отправки, last Block - это послдний блок.     public DtoTransaction send(String recipient, String privateKey, double digitalDollar, double digitalReputation, Laws laws,  double minerRewards, VoteEnum voteEnum) throws NoSuchAlgorithmException, InvalidKeySpecException, SignatureException, IOException, NoSuchProviderException, InvalidKeyException {          return sendMoney(recipient,privateKey, digitalDollar, digitalReputation, laws, minerRewards, voteEnum);     }      }","package International_Trade_Union.model;  import International_Trade_Union.utils.UtilsSecurity; import International_Trade_Union.utils.base.Base; import International_Trade_Union.utils.base.Base58;  import java.security.InvalidAlgorithmParameterException; import java.security.NoSuchAlgorithmException; import java.security.NoSuchProviderException; import java.security.spec.InvalidKeySpecException; import java.util.HashMap; import java.util.Map;  public class CreateAccount {     public static Map<String, String> create() throws InvalidAlgorithmParameterException, NoSuchAlgorithmException, InvalidKeySpecException, NoSuchProviderException {         Map<String, String> create = new HashMap<>();         Base base = new Base58();         Keys keyPair = UtilsSecurity.generateKeyPair();         String pubkey = keyPair.getPubkey();         String privKey = keyPair.getPrivkey();         System.out.println(\"pubkey: \" + pubkey);         System.out.println(\"privKey: \" + privKey);         create.put(\"pubKey\", pubkey);         create.put(\"privKey\", privKey);         return create;     } }","package International_Trade_Union.model;  import International_Trade_Union.governments.Director; import lombok.AllArgsConstructor; import lombok.Data; import lombok.NoArgsConstructor;  @Data @AllArgsConstructor @NoArgsConstructor public class FIndPositonHelperData {     Director addressPosition;     boolean withLimited;     boolean electedWithStock;     boolean electedWithPrimeMinister;     boolean electedWithHousOfRepresentativies;     boolean electedWithChamberOfHightJudjes;  }","package International_Trade_Union.model;  import lombok.Data;  @Data public class Keys {     private String pubkey;     private String privkey;      public Keys(String pubkey, String privkey) {         this.pubkey = pubkey;         this.privkey = privkey;     } }","package International_Trade_Union.model;    import International_Trade_Union.config.BLockchainFactory; import International_Trade_Union.config.BlockchainFactoryEnum; import International_Trade_Union.entity.blockchain.Blockchain; import International_Trade_Union.entity.blockchain.block.Block; import International_Trade_Union.utils.*; import java.io.File; import java.io.IOException; import java.security.*; import java.security.spec.InvalidKeySpecException; import java.util.*;   public class Mining {      public static Blockchain getBlockchain(String filename, BlockchainFactoryEnum factoryEnum) throws IOException, NoSuchAlgorithmException, InvalidKeySpecException, SignatureException, NoSuchProviderException, InvalidKeyException {          List<Block> blocks = UtilsBlock.readLineObject(filename);         Blockchain blockchain = null;         blockchain = BLockchainFactory.getBlockchain(factoryEnum);          if (blocks.size() != 0) {            blockchain.setBlockchainList(blocks);         }         return blockchain;     }      public static Map<String, Account> getBalances(String filename, Blockchain blockchain, Map<String, Account> balances) throws IOException, NoSuchAlgorithmException, SignatureException, InvalidKeySpecException, NoSuchProviderException, InvalidKeyException {         //start test           //папка чтобы проверить есть ли         File folder = new File(filename);         List<String> files = new ArrayList<>();         for (File file : folder.listFiles()) {             if(!file.isDirectory()){                 files.add(file.getAbsolutePath());             }         }          if (files.size() > 0 ){             File file = new File(files.get(files.size()-1));             if(file.exists() && file.length() > 0){                 balances = SaveBalances.readLineObject(filename);             }          }          if (balances == null) {             balances = new HashMap<>();         }          Block block;         if(blockchain != null && blockchain.sizeBlockhain() > 0){             block = blockchain.getBlock(blockchain.sizeBlockhain() - 1);             balances = UtilsBalance.calculateBalance(balances, block);           }           return balances;     }      public static void deleteFiles(String fileDelit) {         UtilsFileSaveRead.deleteAllFiles(fileDelit);     }   }","package International_Trade_Union.model;  import International_Trade_Union.setings.Seting; import International_Trade_Union.utils.UtilsFileSaveRead;  import java.io.FileNotFoundException;   public class User {     private static String addressMiner=\"\";      public static void setUserAddress(String addressMiner) { //        System.out.println(\"change minerAccount: \" + addressMiner); //        UtilsFileSaveRead.save(addressMiner, Seting.ORIGINAL_ACCOUNT, false);         User.addressMiner = addressMiner;     }      public static String getUserAddress() throws FileNotFoundException {         addressMiner = UtilsFileSaveRead.read(Seting.ORIGINAL_ACCOUNT);         System.out.println(\"user: \" + addressMiner);         if(addressMiner.isEmpty() || addressMiner == null)             addressMiner = \"empty \";         return addressMiner;     } }","package International_Trade_Union.network;  import International_Trade_Union.entity.DtoTransaction.DtoTransaction; import International_Trade_Union.model.Mining; import International_Trade_Union.setings.Seting; import International_Trade_Union.utils.UtilUrl; import International_Trade_Union.utils.UtilsJson; import International_Trade_Union.utils.UtilsTransaction; import International_Trade_Union.utils.UtilsUse; import org.json.JSONException;  import java.io.IOException; import java.security.InvalidKeyException; import java.security.NoSuchAlgorithmException; import java.security.NoSuchProviderException; import java.security.SignatureException; import java.security.spec.InvalidKeySpecException; import java.util.ArrayList; import java.util.List; import java.util.stream.Collectors;  public class AllTransactions {     private static List<DtoTransaction> instance = new ArrayList<>();     //все транзакции которые уже добавлены в блок, нужно чтобы повторно     //не добавлялись в блок если они скачены с дисковери.     private static List<DtoTransaction> sendedTransaction = new ArrayList<>();      public static List<DtoTransaction> readFrom() throws IOException, NoSuchAlgorithmException, InvalidKeySpecException, SignatureException, NoSuchProviderException, InvalidKeyException {         return UtilsTransaction.readLineObject(Seting.ORGINAL_ALL_TRANSACTION_FILE);     }      public static synchronized List<DtoTransaction> getInstance() throws IOException, NoSuchAlgorithmException, InvalidKeySpecException, SignatureException, NoSuchProviderException, InvalidKeyException {         if (instance == null) {             instance = new ArrayList<>();         }         instance = new ArrayList<>();          //считываем с пула транзакции из дисковери.         for (String s : Seting.ORIGINAL_ADDRESSES) {             try {                 String json = UtilUrl.readJsonFromUrl(s + \"/getTransactions\");                 List<DtoTransaction> list = UtilsJson.jsonToDtoTransactionList(json);                  instance.addAll(list);               } catch (IOException | JSONException e) {                  System.out.println(\"AllTransaction: getInstance: Error\");                 continue;             }           }          instance.addAll(UtilsTransaction.readLineObject(Seting.ORGINAL_ALL_TRANSACTION_FILE));         instance = instance.stream().distinct().collect(Collectors.toList());          sendedTransaction = getInsanceSended();          instance.removeAll(sendedTransaction);         return instance;     }      public static synchronized void clearAllTransaction() {         instance = new ArrayList<>();         Mining.deleteFiles(Seting.ORGINAL_ALL_TRANSACTION_FILE);     }      public static synchronized void clearAllSendedTransaction(long index) {         if(index % (Seting.COUNT_BLOCK_IN_DAY * Seting.DAY_DELETED_SENDED_FILE) == 0){             sendedTransaction = new ArrayList<>();             Mining.deleteFiles(Seting.ORIGINAL_ALL_SENDED_TRANSACTION_FILE);             System.out.println(\"clear delete sended transaction\");             AllTransactions.clearAllTransaction();         }      }      public static synchronized void clearUsedTransaction(List<DtoTransaction> transactions) throws IOException, NoSuchAlgorithmException, SignatureException, InvalidKeySpecException, NoSuchProviderException, InvalidKeyException {         instance = getInstance();         List<DtoTransaction> temporaryDto = new ArrayList<>();          instance = temporaryDto;         instance.removeAll(transactions);         Mining.deleteFiles(Seting.ORGINAL_ALL_TRANSACTION_FILE);         for (DtoTransaction dtoTransaction : instance) {              UtilsTransaction.saveAllTransaction(dtoTransaction, Seting.ORGINAL_ALL_TRANSACTION_FILE);         }       }      public static synchronized void addTransaction(DtoTransaction transaction) throws IOException, NoSuchAlgorithmException, SignatureException, InvalidKeySpecException, NoSuchProviderException, InvalidKeyException {          instance = getInstance();         instance.add(transaction);         Mining.deleteFiles(Seting.ORGINAL_ALL_TRANSACTION_FILE);         instance = instance.stream().filter(UtilsUse.distinctByKey(DtoTransaction::toSign)).collect(Collectors.toList());         for (DtoTransaction dtoTransaction : instance) {             UtilsTransaction.saveAllTransaction(dtoTransaction, Seting.ORGINAL_ALL_TRANSACTION_FILE);         }       }      public static synchronized void addSendedTransaction(List<DtoTransaction> transactions) throws IOException, NoSuchAlgorithmException, InvalidKeySpecException, SignatureException, NoSuchProviderException, InvalidKeyException {         sendedTransaction = getInsanceSended();         sendedTransaction.addAll(transactions);          Mining.deleteFiles(Seting.ORIGINAL_ALL_SENDED_TRANSACTION_FILE);         for (DtoTransaction dtoTransaction : sendedTransaction) {             UtilsTransaction.saveAllTransaction(dtoTransaction, Seting.ORIGINAL_ALL_SENDED_TRANSACTION_FILE);         }          System.out.println(\"AllTransaction: addSendedTransaction: \" + sendedTransaction.size());      }      public static List<DtoTransaction> getInsanceSended() throws IOException, NoSuchAlgorithmException, InvalidKeySpecException, SignatureException, NoSuchProviderException, InvalidKeyException {         if (sendedTransaction == null) {             sendedTransaction = new ArrayList<>();         }         sendedTransaction = UtilsTransaction.readLineObject(Seting.ORIGINAL_ALL_SENDED_TRANSACTION_FILE);         sendedTransaction = sendedTransaction.stream().distinct().collect(Collectors.toList());         return sendedTransaction;     }  }","package International_Trade_Union.network;    import International_Trade_Union.entity.DtoTransaction.DtoTransaction;  import java.util.ArrayList; import java.util.List;  public class Transactions {     public  List<DtoTransaction> getTransactions() {         List<DtoTransaction> transactions = new ArrayList<>();         return transactions;     } }","package International_Trade_Union.node;  import java.util.HashSet; import java.util.Set;  public class Nodes {      public int size(){         return urlAddress.size();     }      public Nodes() {         this.urlAddress = new HashSet<>();     }      public Nodes(Set<String> urlAddress) {         this.urlAddress = urlAddress;     }      private  Set<String> urlAddress = new HashSet<>();      public  void setUrlAddress(Set<String> urlAddress) {         this.urlAddress = urlAddress;     }     public void addAddress(String addressUrl){         urlAddress.add(addressUrl);     }      public  Set<String> getUrlAddresses() {         return urlAddress;     }      public void clear(){         urlAddress = new HashSet<>();     } }","package International_Trade_Union.setings;  import International_Trade_Union.about_usDraft.AboutUsDraft; import International_Trade_Union.about_us_engDraft.AboutUsEngDraft; import International_Trade_Union.CorporateCharterEngDraft.CorporateCharter; import International_Trade_Union.governments.Directors; import International_Trade_Union.governments.NamePOSITION; import International_Trade_Union.utils.UtilsUse;  import java.util.HashSet; import java.util.Set;  public interface Seting {     // значение используется для вычисления процентов     int HUNDRED_PERCENT = 100;     // значение используется как константа года,     // в данной системе отсутствует високосный год     int YEAR = 360;      Directors directors = new Directors();       //используется для очистки из файла, где хранятся отправленные транзакции,     //чтобы предотвратить добавление повторно уже отправленных транзакций     int DAY_DELETED_SENDED_FILE = 3;        //За какой период последних блоков учитывать для отбора акционеров.     //Акционерами могут быть только с наибольшим количеством баланса     //отправители и майнеры.     int BOARDS_BLOCK = (int) (Seting.COUNT_BLOCK_IN_DAY * YEAR);        //минимальное значение количество положительных голосов, для того чтобы избрать     // Совет Директоров и Совет Корпоративных Верховных Судей,     int ORIGINAL_LIMIT_MIN_VOTE = (int) (200 * Seting.COUNT_BLOCK_IN_DAY * 1 / 8);        //Минимальное значение чтобы Совет Корпоративных Верховных Судей могла избрать Верховного Судью     int ORIGINAL_LIMIT_MIN_VOTE_CORPORATE_COUNCIL_OF_REFEREES = 3;      //Минимальное значение остатка голосов чтобы Совет директоров утверждал бюджет,     //стратегический план, в создании новых должностей и назначении новых должностей,     //и т.д. Также участвовал в утверждении законов, вместе с другими участниками.     int ORIGINAL_LIMIT_MIN_VOTE_BOARD_OF_DIRECTORS = 15;//15;      //Минимальное количество остатка голосов чтобы Совет Акционеров     //утверждал вместе с остальными участниками в утверждении законов.     int ORIGINAL_LIMIT_MIN_VOTE_BOARD_OF_SHAREHOLDERS = 100; //100;      //голос Генерального Исполнительного Директора     int ORIGINAL_LIMIT_MIN_VOTE_GENERAL_EXECUTIVE_DIRECTOR = 1;      //голос Верховного Судьи     int ORIGINAL_LIMIT_MIN_VOTE_HIGHT_JUDGE = 1;      //для преодоления верховного судьи, если Верховный Судья не одобрил закон     //то нужно получить в два раза больше голосов, чтобы преодолеть вето Верховного Судьи     int POWERFUL_VOTE = 2;      //данная мера нужна чтобы если один счет голосует за несколько кандидатов,     //его голос не делился равномерно, а становился значительно сильнее,     //чтобы не допустить монополии, если очень богатый человек захочет должностные лица поставить к власти     //то он не сможет пример: счет X проголосовал ЗА = 2 закона и ПРОТИВ = 3 закона     //100 = voteYES, 100 = voteNO, voteYES / (2^3) = 12.5 , voteNO / (3^3) = 3.7     //таким образом чем больше голосует, тем меньше голосов остается для избрания     //должностных лиц, это защита от сверхбогатых участников Совета Акционеров     int POWERING_FOR_VOTING = 3;       //голос должностных лиц,     int VOTE_GOVERNMENT = 1;     //голос должностных лиц вместо акций учитывается только один     //голос, как будто у них одна акция     double STOCK_VOTE_GOVERNMENT = 1;      //    процент который получает основатель от добычи     Double FOUNDERS_REWARD = 2.0;      //address for send rewards     String BASIS_ADDRESS = \"faErFrDnBhfSfNnj1hYjxydKNH28cRw1PBwDQEXH3QsJ\";     String BASIS_PASSWORD = \"3hupFSQNWwiJuQNc68HiWzPgyNpQA2yy9iiwhytMS7rZyfPddNRwtvExeevhayzN6xL2YmTXN6NCA8jBhV9ge1w8KciHedGUMgZyq2T7rDdvekVNwEgf5pQrELv8VAEvQ4Kb5uviXJFuMyuD1kRAGExrZym5nppyibEVnTC9Uiw8YzUh2JmVT9iUajnVV3wJ5foMs\";      //сложность коррекция каждые n блоков     int DIFFICULTY_ADJUSTMENT_INTERVAL = (int) (Seting.COUNT_BLOCK_IN_DAY / 2);     int DIFFICULTY_ADJUSTMENT_INTERVAL_TEST = 10;      long BLOCK_GENERATION_INTERVAL = Seting.BLOCK_TIME * 1000;// after Seting.BLOCK_TIME     long BLOCK_GENERATION_INTERVAL_TEST = 0 * 1000;       long INTERVAL_TARGET = 600000;     long INTERVAL_TARGET_TEST = 25000;      // плата за обслуживание каждые 6 месяцев.     Double ANNUAL_MAINTENANCE_FREE_DIGITAL_DOLLAR_YEAR = 0.2;     //отрицательная ставка для цифровой акции     double ANNUAL_MAINTENANCE_FREE_DIGITAL_STOCK_YEAR = 0.4;     //каждые сколько месяцев снимать     int HALF_YEAR = 2;      //стоимость создания закона 5     double COST_LAW = 5;     //с чего начинается адрес пакета закона     //сокращенно корпорация     String NAME_LAW_ADDRESS_START = \"LIBER\";      int HASH_COMPLEXITY_GENESIS = 1;      //совет акционеров    int BOARD_OF_SHAREHOLDERS = 1500;      //ПОПРАВКА В УСТАВЕ    //требования к поправкам     String AMENDMENT_TO_THE_CHARTER = \"AMENDMENT_TO_THE_CHARTER\";      //директора созданные Советом директоров     String ADD_DIRECTOR = \"ADD_DIRECTOR\";      //бюджет должен формировать только палата представителей     String BUDGET = \"BUDGET\";      //план также утверждается на четыре года и утверждается только палатой представителей     //каждый план обязан содержать дату начала планирования с какого числа вступает в силу.     //FOUR-YEAR PLAN     String STRATEGIC_PLAN = \"STRATEGIC_PLAN\";       //лимиты для ведения поправок     //палата судей минимум 5 голосов     int ORIGINAL_LIMIT_MIN_VOTE_CORPORATE_COUNCIL_OF_REFEREES_AMENDMENT = 5;// 5;     //палата представителей 20% голосов     int ORIGINAL_LIMIT_MIN_VOTE_BOARD_OF_DIRECTORS_AMENDMENT =            directors.getDirector(NamePOSITION.BOARD_OF_DIRECTORS.toString()).getCount() * 20 / 100;      //Совет акционеров минимум 20% голосов     int ORIGINAL_LIMIT_MINT_VOTE_BOARD_OF_SHAREHOLDERS_AMENDMENT = BOARD_OF_SHAREHOLDERS * 20 / 100;       //    адресс основателя: здесь будет мой адрес. Сейчас заглушка     String ADDRESS_FOUNDER_TEST = \"stExZb8ifLfnFoq4JJuTifpAcscegATH8znhwW26zyTa\";     String ADDRESS_FOUNDER = \"stExZb8ifLfnFoq4JJuTifpAcscegATH8znhwW26zyTa\";      String CORPORATE_CHARTER_DRAFT = International_Trade_Union.CorporateCharterDraft.CorporateCharter.getAllConstitution() + \"\\n\" + CorporateCharter.getAllConstitution() + AboutUsDraft.getAboutUs()             + AboutUsEngDraft.getAboutUs();      //КЛЮЧЕВОЕ НАЗВАНИЕ ПАКЕТА ЧТО ЭТО УСТАВ, ДЕЙСТВУЮЩИЙ УСТАВ ПОДПИСАН ОСНОВАТЕЛЕМ.     String ORIGINAL_CHARTER_CURRENT_LAW_PACKAGE_NAME = \"ORIGINAL_CHARTER_CURRENT_LAW_PACKAGE_NAME\";      //КЛЮЧЕВОЕ НАЗВАНИЕ ДЛЯ КОДА КОТОРЫЙ СОПРОВОЖДАЕТСЯ С УСТАВОМ     String ORIGINAL_CHARTER_CURRENT_ALL_CODE = \"ORIGINAL_CHARTER_CURRENT_ALL_CODE\";      //начальная сумма основателя     Double FOUNDERS_REMUNERATION_DIGITAL_DOLLAR = 30000000.0;     double FOUNDERS_REMNUNERATION_DIGITAL_STOCK = 30000000.0;       // сколько секунд в сутках     int DAY_SECOND = 86400;      //    за сколько секунд добывается каждый блок     int BLOCK_TIME = 150;       //сколько блоков добывается в сутки     double COUNT_BLOCK_IN_DAY = (DAY_SECOND / BLOCK_TIME);      //подсчет голосов для должности в годах, учитываются только те голоса     //которые не позже четырех лет для законов и должностей,     //голоса отданные за законы должны обновляться каждые четыре года     //как и за должности     int POSITION_YEAR_VOTE = (int) Seting.COUNT_BLOCK_IN_DAY * YEAR * 4;     //подсчет голосов для законов в годах     int LAW_YEAR_VOTE = (int) Seting.COUNT_BLOCK_IN_DAY * YEAR * 4;         String ORIGINAL_INDEX_FILE = \".\\\\src\\\\main\\\\resources\\\\index\\\\index.txt\"; //    String ORIGINAL_BLOCKCHAIN_FILE = \".\\\\src\\\\main\\\\resources\\\\blockchain\\\\\";     String ORIGINAL_BLOCKCHAIN_FILE = \"C:\\\\resources\\\\blockchain\\\\\"; //    String ORIGINAL_BALANCE_FILE = \".\\\\src\\\\main\\\\resources\\\\balance\\\\\";     String ORIGINAL_BALANCE_FILE = \"C:\\\\resources\\\\balance\\\\\";     String ORIGINAL_BOARD_0F_SHAREHOLDERS_FILE = \".\\\\src\\\\main\\\\resources\\\\federalGovernment\\\\federalGovernment.txt\"; //    String ORIGINAL_ALL_CORPORATION_LAWS_FILE = \".\\\\src\\\\main\\\\resources\\\\federalLaws\\\\\";     String ORIGINAL_ALL_CORPORATION_LAWS_FILE = \"C:\\\\resources\\\\federalLaws\\\\\"; //    String ORIGINAL_ACCOUNT = \".\\\\src\\\\main\\\\resources\\\\minerAccount\\\\minerAccount.txt\";     String ORIGINAL_ACCOUNT = \"C:\\\\resources\\\\minerAccount\\\\minerAccount.txt\";     String ORIGINAL_CORPORATE_VOTE_FILE = \".\\\\src\\\\main\\\\resources\\\\vote\\\\\";  //    String ORIGINAL_ALL_CORPORATION_LAWS_WITH_BALANCE_FILE = \".\\\\src\\\\main\\\\resources\\\\allLawsWithBalance\\\\\";     String ORIGINAL_ALL_CORPORATION_LAWS_WITH_BALANCE_FILE = \"C:\\\\resources\\\\allLawsWithBalance\\\\\"; //    String ORGINAL_ALL_TRANSACTION_FILE = \".\\\\src\\\\main\\\\resources\\\\transactions\\\\\";     String ORGINAL_ALL_TRANSACTION_FILE = \"C:\\\\resources\\\\transactions\\\\\"; //    String ORIGINAL_ALL_SENDED_TRANSACTION_FILE = \".\\\\src\\\\main\\\\resources\\\\sendedTransaction\\\\\";     String ORIGINAL_ALL_SENDED_TRANSACTION_FILE = \"C:\\\\resources\\\\sendedTransaction\\\\\"; //    String ORIGINAL_POOL_URL_ADDRESS_FILE = \".\\\\src\\\\main\\\\resources\\\\poolAddress\\\\\";     String ORIGINAL_POOL_URL_ADDRESS_FILE = \"C:\\\\resources\\\\poolAddress\\\\\";      //адреса discovery     Set<String> ORIGINAL_ADDRESSES = Set.of(\"http://localhost:8083\");      //адреса хранилищ блокчейнов //    Set<String> ORIGINAL_ADDRESSES_BLOCKCHAIN_STORAGE = Set.of(\"http://localhost:8084\");      int SIZE_FILE_LIMIT = 100;       String TEST_FILE_WRITE_INFO = \".\\\\src\\\\test\\\\java\\\\unitted_states_of_mankind\\\\blockchainTwentyYearTest\\\\\";     double DIGITAL_DOLLAR_REWARDS_BEFORE = 200.0;     double DIGITAL_STOCK_REWARDS_BEFORE = 200.0;     double DIGITAL_DOLLAR_FOUNDER_REWARDS_BEFORE = Math.round(UtilsUse.countPercents(Seting.DIGITAL_DOLLAR_REWARDS_BEFORE, Seting.FOUNDERS_REWARD));     double DIGITAL_REPUTATION_FOUNDER_REWARDS_BEFORE = Math.round(UtilsUse.countPercents(Seting.DIGITAL_STOCK_REWARDS_BEFORE, Seting.FOUNDERS_REWARD));  //    String DELETED_POOL_TRANSACTION_TIME = \"PT48H\";  }","package International_Trade_Union.sheduled;   import International_Trade_Union.network.AllTransactions; import International_Trade_Union.setings.Seting; import org.springframework.scheduling.annotation.Scheduled; import org.springframework.stereotype.Service;  @Service public class DeletedSendedTransaction { // //    @Scheduled(fixedDelayString = Seting.DELETED_POOL_TRANSACTION_TIME) //    public void computePrice() throws InterruptedException { //        AllTransactions.clearAllTransaction(); //    }  }","package International_Trade_Union.sheduled;  import org.springframework.context.annotation.Configuration; import org.springframework.scheduling.annotation.EnableScheduling;  @EnableScheduling @Configuration public class SchedulerConfig { }","package International_Trade_Union.utils.base;  public interface Base {     String encode(byte[] input);     byte[] decode(String input); }","package International_Trade_Union.utils.base;    /*  * Copyright 2011 Google Inc.  * Copyright 2018 Andreas Schildbach  *  * From https://github.com/bitcoinj/bitcoinj/blob/master/core/src/main/java/org/bitcoinj/core/Base58.java  *  * Licensed under the Apache License, Version 2.0 (the \"License\");  * you may not use this file except in compliance with the License.  * You may obtain a copy of the License at  *  *    http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an \"AS IS\" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */  import java.math.BigInteger; import java.util.Arrays;  /**  * Base58 is a way to encode Bitcoin addresses (or arbitrary data) as alphanumeric strings.  * <p>  * Note that this is not the same base58 as used by Flickr, which you may find referenced around the Internet.  * <p>  * Satoshi explains: why base-58 instead of standard base-64 encoding?  * <ul>  * <li>Don't want 0OIl characters that look the same in some fonts and  *     could be used to create visually identical looking minerAccount numbers.</li>  * <li>A string with non-alphanumeric characters is not as easily accepted as an minerAccount number.</li>  * <li>E-mail usually won't line-break if there's no punctuation to break at.</li>  * <li>Doubleclicking selects the whole number as one word if it's all alphanumeric.</li>  * </ul>  * <p>  * However, note that the encoding/decoding runs in O(n&sup2;) time, so it is not useful for large data.  * <p>  * The basic idea of the encoding is to treat the data bytes as a large number represented using  * base-256 digits, convert the number to be represented using base-58 digits, preserve the exact  * number of leading zeros (which are otherwise lost during the mathematical operations on the  * numbers), and finally represent the resulting base-58 digits as alphanumeric ASCII characters.  */ public class Base58 implements Base {     public static final char[] ALPHABET = \"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz\".toCharArray();     private static final char ENCODED_ZERO = ALPHABET[0];     private static final int[] INDEXES = new int[128];     static {         Arrays.fill(INDEXES, -1);         for (int i = 0; i < ALPHABET.length; i++) {             INDEXES[ALPHABET[i]] = i;         }     }      /**      * Encodes the given bytes as a base58 string (no checksum is appended).      *      * @param input the bytes to encode      * @return the base58-encoded string      */     public String encode(byte[] input) {         if (input.length == 0) {             return \"\";         }         // Count leading zeros.         int zeros = 0;         while (zeros < input.length && input[zeros] == 0) {             ++zeros;         }         // Convert base-256 digits to base-58 digits (plus conversion to ASCII characters)         input = Arrays.copyOf(input, input.length); // since we modify it in-place         char[] encoded = new char[input.length * 2]; // upper bound         int outputStart = encoded.length;         for (int inputStart = zeros; inputStart < input.length; ) {             encoded[--outputStart] = ALPHABET[divmod(input, inputStart, 256, 58)];             if (input[inputStart] == 0) {                 ++inputStart; // optimization - skip leading zeros             }         }         // Preserve exactly as many leading encoded zeros in output as there were leading zeros in input.         while (outputStart < encoded.length && encoded[outputStart] == ENCODED_ZERO) {             ++outputStart;         }         while (--zeros >= 0) {             encoded[--outputStart] = ENCODED_ZERO;         }         // Return encoded string (including encoded leading zeros).         return new String(encoded, outputStart, encoded.length - outputStart);     }      /**      * Decodes the given base58 string into the original data bytes.      *      * @param input the base58-encoded string to decode      * @return the decoded data bytes      */     public byte[] decode(String input) {         if (input.length() == 0) {             return new byte[0];         }         // Convert the base58-encoded ASCII chars to a base58 byte sequence (base58 digits).         byte[] input58 = new byte[input.length()];         for (int i = 0; i < input.length(); ++i) {             char c = input.charAt(i);             int digit = c < 128 ? INDEXES[c] : -1;             if (digit < 0) {                 throw new IllegalStateException(\"InvalidCharacter in base 58\");             }             input58[i] = (byte) digit;         }         // Count leading zeros.         int zeros = 0;         while (zeros < input58.length && input58[zeros] == 0) {             ++zeros;         }         // Convert base-58 digits to base-256 digits.         byte[] decoded = new byte[input.length()];         int outputStart = decoded.length;         for (int inputStart = zeros; inputStart < input58.length; ) {             decoded[--outputStart] = divmod(input58, inputStart, 58, 256);             if (input58[inputStart] == 0) {                 ++inputStart; // optimization - skip leading zeros             }         }         // Ignore extra leading zeroes that were added during the calculation.         while (outputStart < decoded.length && decoded[outputStart] == 0) {             ++outputStart;         }         // Return decoded data (including original number of leading zeros).         return Arrays.copyOfRange(decoded, outputStart - zeros, decoded.length);     }      public  BigInteger decodeToBigInteger(String input) {         return new BigInteger(1, decode(input));     }      /**      * Divides a number, represented as an array of bytes each containing a single digit      * in the specified base, by the given divisor. The given number is modified in-place      * to contain the quotient, and the return value is the remainder.      *      * @param number the number to divide      * @param firstDigit the index within the array of the first non-zero digit      *        (this is used for optimization by skipping the leading zeros)      * @param base the base in which the number's digits are represented (up to 256)      * @param divisor the number to divide by (up to 256)      * @return the remainder of the division operation      */     private byte divmod(byte[] number, int firstDigit, int base, int divisor) {         // this is just long division which accounts for the base of the input digits         int remainder = 0;         for (int i = firstDigit; i < number.length; i++) {             int digit = (int) number[i] & 0xFF;             int temp = remainder * base + digit;             number[i] = (byte) (temp / divisor);             remainder = temp % divisor;         }         return (byte) remainder;     } }","package International_Trade_Union.utils;    import International_Trade_Union.setings.Seting; import International_Trade_Union.model.Account;  import java.io.File; import java.io.IOException; import java.security.InvalidKeyException; import java.security.NoSuchAlgorithmException; import java.security.NoSuchProviderException; import java.security.SignatureException; import java.security.spec.InvalidKeySpecException; import java.util.ArrayList; import java.util.List; import java.util.Map; import java.util.stream.Collectors;  public class SaveBalances {      public static void saveBalances(Map<String, Account> balances, String filename) throws IOException, NoSuchAlgorithmException, SignatureException, InvalidKeySpecException, NoSuchProviderException, InvalidKeyException {         int fileLimit = Seting.SIZE_FILE_LIMIT * 1024 * 1024;          //папка чтобы проверить есть ли         File folder = new File(filename);         List<String> files = new ArrayList<>();         for (File file : folder.listFiles()) {             if(!file.isDirectory()){                 files.add(file.getAbsolutePath());             }         }          int count = 0;         files = files.stream().sorted().collect(Collectors.toList());         String nextFile = \"\";          if (files.size() > 0) {             nextFile = files.get(files.size()-1);              count = Integer.parseInt(nextFile.replaceAll(\"[^\\\\d]\", \"\"));           }          File file = new File(nextFile);          if(file.length() >= fileLimit){             count++;          }          nextFile = filename + count + \".txt\";          List<String> jsons = new ArrayList<>();         for (Map.Entry<String, Account> stringAccountEntry : balances.entrySet()) {             String json = UtilsJson.objToStringJson(stringAccountEntry.getValue());             jsons.add(json);         }  //        String json = UtilsJson.objToStringJson(minerAccount); //        UtilsFileSaveRead.save(json + \"\\n\", nextFile);         UtilsFileSaveRead.saves(jsons, nextFile, true);      }      public static Map<String, Account> readLineObject(String filename ) throws IOException, NoSuchAlgorithmException, InvalidKeySpecException, SignatureException, NoSuchProviderException, InvalidKeyException {         List<Account> accounts = new ArrayList<>();         File folder = new File(filename);         for (final File fileEntry : folder.listFiles()) {             if (fileEntry.isDirectory()) {                 System.out.println(\"is directory \" + fileEntry.getAbsolutePath());             } else {                 List<String> list = UtilsFileSaveRead.reads(fileEntry.getAbsolutePath());                 for (String s : list) {                    Account account = UtilsJson.jsonToAccount(s);                     accounts.add(account);                 }              }         }         Map<String, Account> balances = accounts                 .stream()                 .collect(Collectors.toMap(Account::getAccount, t->t, (v1, v2) -> v1));         return balances;     } }","package International_Trade_Union.utils;    import International_Trade_Union.model.Account; import International_Trade_Union.setings.Seting;  import java.util.ArrayList; import java.util.List;  public class UtilAccounts {  //    поиск аккаунта по адрессу     public static Account serchAccountByAddress(List<Account> accountList, String address){         Account result = null;         for (Account account : accountList) {             if(account.getAccount().equals(address)){                 result = account; //                System.out.println(String.format(\"find minerAccount: %s, address %s\", minerAccount.getAccount(), address));                 return result;             }         }         return result;     } //    возвращает список счетов чья наличность больше n     public static List<Account> allAccountsRemnantUpperLimit(              List<Account> accountList, double bottomLineMoney){         List<Account> accounts = new ArrayList<>();                  for (Account account : accountList) {                      if(account.getDigitalDollarBalance()>bottomLineMoney)                         accounts.add(account);                 }               return accounts;     }  //    подсчитывает общий баланс всех участников     public static double getAllBalance( List<Account> accountList){         double allBalance = 0.0;              for (Account account : accountList) {                 if(!account.getAccount().equals(Seting.BASIS_ADDRESS))                     allBalance+=account.getDigitalDollarBalance();             }           return allBalance;     }     }","package International_Trade_Union.utils;  import International_Trade_Union.entity.DtoTransaction.DtoTransaction; import International_Trade_Union.setings.Seting;  import java.io.File; import java.io.IOException; import java.security.InvalidKeyException; import java.security.NoSuchAlgorithmException; import java.security.NoSuchProviderException; import java.security.SignatureException; import java.security.spec.InvalidKeySpecException; import java.util.ArrayList; import java.util.HashSet; import java.util.List; import java.util.Set; import java.util.stream.Collectors;  public class UtilsAllAddresses {     public static void saveAllAddresses(String adress, String filename) throws IOException, NoSuchAlgorithmException, SignatureException, InvalidKeySpecException, NoSuchProviderException, InvalidKeyException {         int fileLimit = Seting.SIZE_FILE_LIMIT * 1024 * 1024;          //папка чтобы проверить есть ли         File folder = new File(filename);         List<String> files = new ArrayList<>();         for (File file : folder.listFiles()) {             if(!file.isDirectory()){                 files.add(file.getAbsolutePath());             }         }           int count = 0;         files = files.stream().sorted().collect(Collectors.toList());         String nextFile = \"\";          if (files.size() > 0) {             nextFile = files.get(files.size()-1);              count = Integer.parseInt(nextFile.replaceAll(\"[^\\\\d]\", \"\"));           }          File file = new File(nextFile);          if(file.length() >= fileLimit){             count++;          }          nextFile = filename + count + \".txt\";          String json = UtilsJson.objToStringJson(adress);         UtilsFileSaveRead.save(json + \"\\n\", nextFile);      }      public static Set<String> readLineObject(String filename ) throws IOException, NoSuchAlgorithmException, InvalidKeySpecException, SignatureException, NoSuchProviderException, InvalidKeyException {         Set<String> allAddresses = new HashSet<>();         File folder = new File(filename);         for (final File fileEntry : folder.listFiles()) {             if (fileEntry.isDirectory()) {                 System.out.println(\"is directory \" + fileEntry.getAbsolutePath());             } else {                 Set<String> list = UtilsFileSaveRead.readSet(fileEntry.getAbsolutePath())                         .stream().collect(Collectors.toSet());                 for (String s : list) {                     allAddresses.add(s);                 }              }         }          allAddresses = allAddresses                 .stream()                 .collect(Collectors.toSet());           return allAddresses;     }  }","package International_Trade_Union.utils;    import International_Trade_Union.entity.DtoTransaction.DtoTransaction; import International_Trade_Union.entity.blockchain.Blockchain; import International_Trade_Union.entity.blockchain.block.Block; import International_Trade_Union.setings.Seting; import International_Trade_Union.model.Account; import International_Trade_Union.vote.VoteEnum;  import java.io.IOException; import java.security.*; import java.security.spec.InvalidKeySpecException; import java.util.*;   public class UtilsBalance {      //подсчет по штучно баланса     public  static Map<String, Account> calculateBalance(Map<String, Account> balances, Block block) throws IOException, NoSuchAlgorithmException, SignatureException, InvalidKeySpecException, NoSuchProviderException, InvalidKeyException {           double percent = Seting.ANNUAL_MAINTENANCE_FREE_DIGITAL_DOLLAR_YEAR / Seting.HALF_YEAR;         double digitalReputationPercent = Seting.ANNUAL_MAINTENANCE_FREE_DIGITAL_STOCK_YEAR / Seting.HALF_YEAR;             int i = (int) block.getIndex();               for (int j = 0; j < block.getDtoTransactions().size(); j++) {                 int BasisSendCount = 0;                   DtoTransaction transaction = block.getDtoTransactions().get(j);                  if(transaction.getSender().startsWith(Seting.NAME_LAW_ADDRESS_START)){                     System.out.println(\"law balance cannot be sender\");                     continue;                 }                 if (transaction.verify()) {                     if(transaction.getSender().equals(Seting.BASIS_ADDRESS))                         BasisSendCount++;                       Account sender = getBalance(transaction.getSender(), balances);                     Account customer = getBalance(transaction.getCustomer(), balances);                      boolean sendTrue = true;                     if(sender.getAccount().equals(Seting.BASIS_ADDRESS) && BasisSendCount > 2){                         System.out.println(\"Basis address can send only two the base address can send no more than two times per block:\" + Seting.BASIS_ADDRESS);                         continue;                     }                      double minerRewards = Seting.DIGITAL_DOLLAR_REWARDS_BEFORE;                     double digitalReputationForMiner = Seting.DIGITAL_STOCK_REWARDS_BEFORE;                        if(sender.getAccount().equals(Seting.BASIS_ADDRESS) ){                        if(i > 1 && (transaction.getDigitalDollar() > minerRewards || transaction.getDigitalStockBalance() > digitalReputationForMiner )){                            System.out.println(\"rewards cannot be upper than \" + minerRewards);                            continue;                        }                         if(!customer.getAccount().equals(block.getFounderAddress()) && !customer.getAccount().equals(block.getMinerAddress())){                             System.out.println(\"Basis address can send only to founder or miner\");                             continue;                         }                     }                     sendTrue = UtilsBalance.sendMoney(sender, customer, transaction.getDigitalDollar(), transaction.getDigitalStockBalance(), transaction.getBonusForMiner(), transaction.getVoteEnum());                      //если транзация валидная то записать данн иыезменения в баланс                     if(sendTrue){                         balances.put(sender.getAccount(), sender);                         balances.put(customer.getAccount(), customer);                     }                  }              }           if (i != 0 && i / Seting.COUNT_BLOCK_IN_DAY % (Seting.YEAR / Seting.HALF_YEAR) == 0.0) {              for (Map.Entry<String, Account> changeBalance : balances.entrySet()) {                 Account change = changeBalance.getValue();                 change.setDigitalStockBalance(change.getDigitalStockBalance() - UtilsUse.countPercents(change.getDigitalStockBalance(), digitalReputationPercent));                 change.setDigitalDollarBalance(change.getDigitalDollarBalance() - UtilsUse.countPercents(change.getDigitalDollarBalance(), percent));             }         }           return balances;      }     //подсчет целиком баланса     public static Map<String, Account> calculateBalances(List<Block> blocks) throws IOException, NoSuchAlgorithmException, SignatureException, InvalidKeySpecException, NoSuchProviderException, InvalidKeyException {         Map<String, Account> balances = new HashMap<>();         for (Block block :  blocks) {             calculateBalance(balances, block);         }          return balances;      }        public static Account getBalance(String address, Map<String, Account> balances) {         if (balances.containsKey(address)) {             return balances.get(address);         } else {             Account account = new Account(address, 0.0, 0.0);             return account;         }     }       public static Account findAccount(Blockchain blockList, String address) throws IOException, NoSuchAlgorithmException, SignatureException, InvalidKeySpecException, NoSuchProviderException, InvalidKeyException {         Map<String, Account> accountMap = calculateBalances(blockList.getBlockchainList());         Account account = accountMap.get(address);         return account != null? account: new Account(address, 0.0, 0.0);     }      public static boolean sendMoney(Account senderAddress, Account recipientAddress, double digitalDollar, double digitalReputation, double minerRewards) throws NoSuchAlgorithmException, InvalidKeySpecException, IOException, SignatureException, NoSuchProviderException, InvalidKeyException {         return sendMoney(senderAddress, recipientAddress, digitalDollar, digitalReputation, minerRewards, VoteEnum.YES);     }      public static boolean sendMoney(Account senderAddress, Account recipientAddress, double digitalDollar, double digitalReputation, double minerRewards, VoteEnum voteEnum) throws NoSuchAlgorithmException, InvalidKeySpecException, NoSuchProviderException, IOException, SignatureException, InvalidKeyException {         double remnantDigitalDollar = 0.0;         double remnantDigitalReputation = 0.0;         boolean sendTrue = true;         if (senderAddress.getAccount().equals(recipientAddress.getAccount())) {             System.out.println(\"sender %s, recipient %s cannot be equals! Error!\".format(senderAddress.getAccount(), recipientAddress.getAccount()));             sendTrue = false;         }          remnantDigitalDollar = senderAddress.getDigitalDollarBalance();         remnantDigitalReputation = senderAddress.getDigitalStockBalance();          if (!senderAddress.getAccount().equals(Seting.BASIS_ADDRESS)) {             if(remnantDigitalDollar < digitalDollar + minerRewards){                 sendTrue = false;             }             else if(remnantDigitalReputation < digitalReputation){                     System.out.printf(\"sender power %f, les than powerSend:  %f\\n\",                             senderAddress.getDigitalStockBalance(), digitalReputation);                     sendTrue = false;              } else if (recipientAddress.getAccount().equals(Seting.BASIS_ADDRESS)) {                 System.out.println(\"Basis canot to be recipient;\");                 sendTrue = false;             } else {                  senderAddress.setDigitalDollarBalance(senderAddress.getDigitalDollarBalance() - digitalDollar);                 senderAddress.setDigitalStockBalance(senderAddress.getDigitalStockBalance() - digitalReputation);                 recipientAddress.setDigitalDollarBalance(recipientAddress.getDigitalDollarBalance() + digitalDollar);                 //сделано чтобы можно было увеличить или отнять власть                 if (voteEnum.equals(VoteEnum.YES)) {                     recipientAddress.setDigitalStockBalance(recipientAddress.getDigitalStockBalance() + digitalReputation);                 } else if (voteEnum.equals(VoteEnum.NO)) {                     //политика сдерживания.                     recipientAddress.setDigitalStockBalance(recipientAddress.getDigitalStockBalance() - digitalReputation);                 }              }           }  else if (senderAddress.getAccount().equals(Seting.BASIS_ADDRESS)) {              recipientAddress.setDigitalDollarBalance(recipientAddress.getDigitalDollarBalance() + digitalDollar);             recipientAddress.setDigitalStockBalance(recipientAddress.getDigitalStockBalance() + digitalReputation);          }         return sendTrue;     } }","package International_Trade_Union.utils;   import com.fasterxml.jackson.core.JsonProcessingException; import International_Trade_Union.config.BLockchainFactory; import International_Trade_Union.config.BlockchainFactoryEnum; import International_Trade_Union.entity.DtoTransaction.DtoTransaction; import International_Trade_Union.entity.blockchain.Blockchain; import International_Trade_Union.entity.blockchain.block.Block; import International_Trade_Union.setings.Seting;   import java.io.*; import java.security.*; import java.security.spec.InvalidKeySpecException; import java.util.*; import java.util.stream.Collectors;  public class UtilsBlock {      public static void saveBlocks(List<Block> blocks, String filename) throws IOException {         int fileLimit = Seting.SIZE_FILE_LIMIT * 1024 * 1024;          //папка чтобы проверить есть ли         File folder = new File(filename);         List<String> files = new ArrayList<>();         for (File file : folder.listFiles()) {             if(!file.isDirectory()){                 files.add(file.getAbsolutePath());             }         }          int count = 0;         files = files.stream().sorted().collect(Collectors.toList());         String nextFile = \"\";          if (files.size() > 0) {             nextFile = files.get(files.size()-1);              count = Integer.parseInt(nextFile.replaceAll(\"[^\\\\d]\", \"\"));           }          File file = new File(nextFile);          if(file.length() >= fileLimit){             count++;          }          nextFile = filename + count + \".txt\";          List<String> jsons = new ArrayList<>();         for (Block block: blocks) {             String json = UtilsJson.objToStringJson(block);             jsons.add(json);         }  //        String json = UtilsJson.objToStringJson(minerAccount); //        UtilsFileSaveRead.save(json + \"\\n\", nextFile);         UtilsFileSaveRead.saves(jsons, nextFile, true);     }     public static void saveBLock(Block block, String filename) throws IOException, NoSuchAlgorithmException, SignatureException, InvalidKeySpecException, NoSuchProviderException, InvalidKeyException {         int fileLimit = Seting.SIZE_FILE_LIMIT * 1024 * 1024;          //папка чтобы проверить есть ли         File folder = new File(filename);         List<String> files = new ArrayList<>();         for (File file : folder.listFiles()) {             if(!file.isDirectory()){                 files.add(file.getAbsolutePath());             }         }           int count = 0;         files = files.stream().sorted().collect(Collectors.toList());         String nextFile = \"\";          if (files.size() > 0) {             nextFile = files.get(files.size()-1);              count = Integer.parseInt(nextFile.replaceAll(\"[^\\\\d]\", \"\"));           }          File file = new File(nextFile);          if(file.length() >= fileLimit){             count++;          }           nextFile = filename + count + \".txt\";          String json = UtilsJson.objToStringJson(block);         UtilsFileSaveRead.save(json + \"\\n\", nextFile);      }        public static List<Block> read(String nameFile) throws FileNotFoundException, JsonProcessingException {         return  UtilsJson.jsonToListBLock(UtilsFileSaveRead.read(nameFile));     }      public static List<Block> readLineObject(String filename ) throws IOException, NoSuchAlgorithmException, InvalidKeySpecException, SignatureException, NoSuchProviderException, InvalidKeyException {         List<Block> blocks = new ArrayList<>();         File folder = new File(filename);          for (final File fileEntry : folder.listFiles()) {             if (fileEntry.isDirectory()) {                 System.out.println(\"is directory \" + fileEntry.getAbsolutePath());             } else {                List<String> list = UtilsFileSaveRead.reads(fileEntry.getAbsolutePath());                 for (String s : list) {                      Block block = UtilsJson.jsonToBLock(s);                     blocks.add(block);                 }              }         }         blocks = blocks                 .stream()                 .sorted(Comparator.comparing(Block::getIndex))                 .collect(Collectors.toList());          return blocks;     }     public static Blockchain readBLock(String nameFile, long BLOCK_GENERATION_INTERVAL, int DIFFICULTY_ADJUSTMENT_INTERVAL, long INTERVAL_TARGET , String ADDRESS_FOUNDER) throws NoSuchAlgorithmException, InvalidKeySpecException, IOException, SignatureException, NoSuchProviderException, InvalidKeyException {         List<Block> blocks = null;         List<List<Block>> list = new ArrayList<>();          File folder = new File(nameFile);          for (final File fileEntry : folder.listFiles()) {             if (fileEntry.isDirectory()) {                 System.out.println(\"is directory \" + fileEntry.getAbsolutePath());             } else {                 blocks = UtilsJson.jsonToListBLock(UtilsFileSaveRead.read(fileEntry.getAbsolutePath()));                 list.add(blocks);             }         }          // new Blockchain(BLOCK_GENERATION_INTERVAL, DIFFICULTY_ADJUSTMENT_INTERVAL, INTERVAL_TARGET, ADDRESS_FOUNDER);         Blockchain blockchain = BLockchainFactory.getBlockchain(BlockchainFactoryEnum.ORIGINAL);         blockchain.setBlockchainList(new ArrayList<>());          for (List<Block> lists : list) {             for (int i = 0; i < lists.size(); i++) {                 blockchain.addBlock(lists.get(i));             }          }          List<Block> blockList = blockchain.getBlockchainList()                 .stream()                 .sorted(Comparator.comparing(Block::getIndex))                 .collect(Collectors.toList());         blockchain.setBlockchainList(blockList);          return blockchain;     }      public static Blockchain readBLock() throws IOException, NoSuchAlgorithmException, InvalidKeySpecException, SignatureException, NoSuchProviderException, InvalidKeyException {        return readBLock(Seting.TEST_FILE_WRITE_INFO, Seting.BLOCK_GENERATION_INTERVAL,  Seting.DIFFICULTY_ADJUSTMENT_INTERVAL, Seting.INTERVAL_TARGET, Seting.ADDRESS_FOUNDER );     }      public static boolean isValidTimestamp(Block newBlock, Block prevBLock, long timestamp){         return (prevBLock.getTimestamp().getTime() - timestamp <newBlock.getTimestamp().getTime())                 && newBlock.getTimestamp().getTime() < System.currentTimeMillis();     }      //https://lhartikk.github.io/jekyll/update/2017/07/13/chapter2.html     //сайт сложности     //https://lhartikk.github.io/jekyll/update/2017/07/13/chapter2.html     //https://tproger.ru/translations/blockchain-explained/      //new https://guicommits.com/building-blockchain-with-python/     public static int difficulty(List<Block> blocks, long BLOCK_GENERATION_INTERVAL, int  DIFFICULTY_ADJUSTMENT_INTERVAL ){          //секунды как часто создается блоки         int difficulty = 1;         Block latestBlock = blocks.get(blocks.size() -1);         if(latestBlock.getIndex() != 0 && latestBlock.getIndex() % DIFFICULTY_ADJUSTMENT_INTERVAL == 0){             difficulty = getAdjustedDifficulty(latestBlock, blocks, BLOCK_GENERATION_INTERVAL, DIFFICULTY_ADJUSTMENT_INTERVAL);             System.out.println(\"difficulty: change dificulty: \" + difficulty);         }         else {             difficulty =  latestBlock.getHashCompexity();         }         return difficulty == 0? 1: difficulty;     }       private static int getAdjustedDifficulty(Block latestBlock, List<Block> blocks, long BLOCK_GENERATION_INTERVAL, int DIFFICULTY_ADJUSTMENT_INTERVAL){         Block prevAdjustmentBlock = blocks.get(blocks.size() - DIFFICULTY_ADJUSTMENT_INTERVAL);          long timeExpected = BLOCK_GENERATION_INTERVAL * DIFFICULTY_ADJUSTMENT_INTERVAL;         long timeTaken = latestBlock.getTimestamp().getTime() - prevAdjustmentBlock.getTimestamp().getTime();          if(timeTaken < timeExpected / 2){              return prevAdjustmentBlock.getHashCompexity() + 1;         }else if(timeTaken > timeExpected * 2){              return prevAdjustmentBlock.getHashCompexity() - 1;         }else {             return prevAdjustmentBlock.getHashCompexity();         }     }      public static boolean validationOneBlock(             String addressFounder,             Block previusblock,             Block thisBlock,             long blockGenerationInterval,             int difficultyAdjustmentInterval,             List<Block> lastBlock) throws IOException, NoSuchAlgorithmException, SignatureException, InvalidKeySpecException, NoSuchProviderException, InvalidKeyException {          boolean addressFounderReward = false;         boolean addressMinerReward = false;         if(!addressFounder.equals(thisBlock.getFounderAddress())){             System.out.println(\"genesis address not equals block founder: \");             System.out.println(\"genesis address: \" + addressFounder);             System.out.println(\"block address: \" + thisBlock.getFounderAddress());             return false;          }               String actualPrevHash = previusblock.hashForBlockchain();             String recordedPrevHash = thisBlock.getPreviousHash();            boolean validated = true;         int countBasisSendFounder = 0;         int countBasisSendAll = 0;         finished:         for (DtoTransaction transaction : thisBlock.getDtoTransactions()) {             if(transaction.verify() && transaction.getSender().equals(Seting.BASIS_ADDRESS)){                 double minerReward = Seting.DIGITAL_DOLLAR_REWARDS_BEFORE;                 double minerPowerReward = Seting.DIGITAL_STOCK_REWARDS_BEFORE;                    if(transaction.getSender().equals(Seting.BASIS_ADDRESS)&&                         transaction.getCustomer().equals(thisBlock.getMinerAddress()) && transaction.getDigitalDollar() > minerReward                         && thisBlock.getIndex() > 1){                     System.out.println(\"wrong transaction: reward miner wrong digital dollar: \" + minerReward + \" index: \" + thisBlock.getIndex());                     System.out.println(\"sendmoney \" + transaction.getDigitalDollar());                     validated = false;                     break;                 }                 if(transaction.getSender().equals(Seting.BASIS_ADDRESS) &&                         transaction.getCustomer().equals(thisBlock.getMinerAddress()) && transaction.getDigitalStockBalance()                         > minerPowerReward                         && thisBlock.getIndex() > 1){                     System.out.println(\"wrong transaction: reward miner wrong digital stock: \" + minerPowerReward + \" need: \" + transaction.getDigitalStockBalance());                     System.out.println(transaction);                     validated = false;                     break;                 }                   if(transaction.getSender().equals(Seting.BASIS_ADDRESS)                         &&transaction.getCustomer().equals(addressFounder)){                     countBasisSendFounder += 1;                 }                  if(transaction.getSender().equals(Seting.BASIS_ADDRESS)&&!transaction.getCustomer().equals(addressFounder))                 {                     countBasisSendAll +=1;                 }                  if(countBasisSendFounder > 2 && thisBlock.getIndex() > 1){                     System.out.println(\"basis sender send for founder uper one: \" + countBasisSendFounder);                     validated = false;                     break;                 }                  if(countBasisSendAll > 1 && thisBlock.getIndex() > 1){                     System.out.println(\"basis sender send uper two: \" + countBasisSendAll + \" block index: \" + thisBlock.getIndex());                     validated = false;                     break;                 }             }             else if(!transaction.verify()){                 System.out.println(\"wrong transaction: \" + transaction + \" verify: \" + transaction.verify());                 validated = false;                 break finished;             }          }             if(!UtilsUse.hashComplexity(thisBlock.getHashBlock(), thisBlock.getHashCompexity())){                 System.out.println(\"does't start hash with 0\");                 System.out.println(\"this block hash: \" + thisBlock.getHashBlock());                 return false;             }              if(!actualPrevHash.equals(recordedPrevHash)){                 System.out.println(\"Blockchain is invalid, expected: \" + recordedPrevHash + \" actual: \" + actualPrevHash );                 System.out.println(\"index block: \" + thisBlock.getIndex());                 System.out.println(\"wrong chain hash\");                 return false;             }          return validated;     }      public static void deleteFiles(){         System.out.println(\"UtilsBlock: deleteFiles: \");         UtilsFileSaveRead.deleteAllFiles(Seting.ORIGINAL_BLOCKCHAIN_FILE);          UtilsFileSaveRead.deleteAllFiles(Seting.ORIGINAL_BALANCE_FILE);         UtilsFileSaveRead.deleteAllFiles(Seting.ORIGINAL_ALL_CORPORATION_LAWS_FILE);         UtilsFileSaveRead.deleteAllFiles(Seting.ORIGINAL_ALL_CORPORATION_LAWS_WITH_BALANCE_FILE);     }      public static boolean validation(List<Block> blocks, long BLOCK_GENERATION_INTERVAL, int DIFFICULTY_ADJUSTMENT_INTERVAL ) throws IOException, NoSuchAlgorithmException, SignatureException, InvalidKeySpecException, NoSuchProviderException, InvalidKeyException {         boolean validated = true;         List<Block> temporary = new ArrayList<>();         Block prevBlock  = null;         for (Block block : blocks) {             if(prevBlock == null){                 prevBlock = block;                 temporary.add(block);                 continue;             }              temporary.add(block);              validated = validationOneBlock(block.getFounderAddress(),                     prevBlock,                     block,                     BLOCK_GENERATION_INTERVAL,                     DIFFICULTY_ADJUSTMENT_INTERVAL,                     temporary );             if(validated == false){                  System.out.println(\"ERROR: UtilsBlock: validation: prevBLock.Hash():\" + prevBlock.getHashBlock());                 System.out.println(\"ERROR: UtilsBlock: validation: index:\" + block.getIndex());                 System.out.println(\"ERROR: UtilsBlock: validation: block.Hash():\" + block.getHashBlock());                 System.out.println(\"ERROR: UtilsBlock: validation: BLOCK_GENERATION_INTERVAL:\" + BLOCK_GENERATION_INTERVAL);                 System.out.println(\"ERROR: UtilsBlock: validation: DIFFICULTY_ADJUSTMENT_INTERVAL:\" + DIFFICULTY_ADJUSTMENT_INTERVAL);                 System.out.println(\"ERROR: UtilsBlock: validation: temporary:\" + temporary.size());                 return false;             }             prevBlock = block;         }         return validated;     } }","package International_Trade_Union.utils;  public class UtilsCheckDtoTransaction {  }","package International_Trade_Union.utils;  import java.io.*; import java.util.ArrayList; import java.util.HashSet; import java.util.List; import java.util.Set;  public class UtilsFileSaveRead {      public static void save(String object, String fileName) throws IOException {        save(object, fileName, true);     }     public static void save(String object, String fileName, boolean save){         try(BufferedWriter writer = new BufferedWriter(new FileWriter(fileName, save))) {             writer.write(object);             writer.flush();          }catch (IOException e){             e.printStackTrace();         }       }      public static void saves(List<String> objects, String fileName, boolean save){          try(BufferedWriter writer = new BufferedWriter(new FileWriter(fileName, save))) {              for (String s : objects) {                 writer.write(s + \"\\n\");             }             writer.flush();          }catch (IOException e){             e.printStackTrace();         }     }      public static String read(String file) throws FileNotFoundException {         String text = \"\";         File file1 = new File(file);         if(!file1.exists()){             System.out.println(\"file dosn't have\");             return text;         }         try( BufferedReader reader = new BufferedReader(new FileReader(file))){             while (reader.ready()){                 text += reader.readLine();             }         }catch (IOException e){             e.printStackTrace();         }         return text;     }     public static Set<String> readSet(String file){         Set<String> list = new HashSet<>();          try( BufferedReader reader = new BufferedReader(new FileReader(file))){             while (reader.ready()){                 list.add(reader.readLine());             }         }catch (IOException e){             e.printStackTrace();         }         return list;     }     public static List<String> reads(String file){         List<String> list = new ArrayList<>();          try( BufferedReader reader = new BufferedReader(new FileReader(file))){             while (reader.ready()){                 list.add(reader.readLine());             }         }catch (IOException e){             e.printStackTrace();         }         return list;     }         public static void deleteAllFiles(String path){         File folder = new File(path);         for (File file : folder.listFiles()) {             if(!file.isDirectory()){                 System.out.println(\"UtilsFileSaveRead: delete: \" + file);                 file.delete();              }         }     }      public static void deleteFile(String path){         File file = new File(path);         file.delete();     }  }","package International_Trade_Union.utils;  import com.fasterxml.jackson.core.JsonProcessingException; import com.fasterxml.jackson.core.type.TypeReference; import com.fasterxml.jackson.databind.ObjectMapper; import International_Trade_Union.entity.DtoTransaction.DtoTransaction; import International_Trade_Union.entity.EntityChain; import International_Trade_Union.entity.blockchain.block.Block; import International_Trade_Union.model.Account; import International_Trade_Union.vote.CurrentLawVotes; import International_Trade_Union.vote.LawEligibleForParliamentaryApproval; import International_Trade_Union.vote.Laws;   import java.io.IOException; import java.io.StringWriter; import java.util.List; import java.util.Set;  public class UtilsJson {     public static String objToStringJson(Object object) throws IOException {         ObjectMapper mapper = new ObjectMapper();         StringWriter writer = new StringWriter();         mapper.writeValue(writer, object);         return writer.toString();     }      public static Object jsonToListBLock(String json, Class cls) throws JsonProcessingException {         ObjectMapper mapper = new ObjectMapper();         return mapper.readValue(json, cls);     }      public static List<Block> jsonToListBLock(String json) throws JsonProcessingException {         ObjectMapper mapper = new ObjectMapper();         return mapper.readValue(json, new TypeReference<List<Block>>(){});     }     public static List<Account> jsonToListAccounts(String json) throws JsonProcessingException {         ObjectMapper mapper = new ObjectMapper();         return mapper.readValue(json, new TypeReference<List<Account>>(){});     }      public static Set<String> jsonToSetAddresses(String json) throws  JsonProcessingException{         ObjectMapper mapper = new ObjectMapper();         return mapper.readValue(json, new TypeReference<Set<String>>(){});     }     public static Block jsonToBLock(String json) throws JsonProcessingException {         ObjectMapper mapper = new ObjectMapper();         return mapper.readValue(json, Block.class);     }      public static Laws jsonToLaw(String json) throws JsonProcessingException {         ObjectMapper mapper = new ObjectMapper();         return mapper.readValue(json, Laws.class);     }      public static CurrentLawVotes jsonToVote(String json) throws  JsonProcessingException{         ObjectMapper mapper = new ObjectMapper();         return mapper.readValue(json, CurrentLawVotes.class);     }      public static LawEligibleForParliamentaryApproval jsonToCurrentLaw(String json) throws JsonProcessingException {         ObjectMapper mapper = new ObjectMapper();         return mapper.readValue(json, LawEligibleForParliamentaryApproval.class);     }     public static Account jsonToAccount(String json) throws JsonProcessingException {         ObjectMapper mapper = new ObjectMapper();         return mapper.readValue(json, Account.class);     }     public static EntityChain jsonToEntityChain(String json) throws  JsonProcessingException{         ObjectMapper mapper = new ObjectMapper();         return mapper.readValue(json, EntityChain.class);     }      public static DtoTransaction jsonToDtoTransaction(String json) throws  JsonProcessingException{         ObjectMapper mapper = new ObjectMapper();         return mapper.readValue(json, DtoTransaction.class);      }      public static List<DtoTransaction> jsonToDtoTransactionList(String json) throws  JsonProcessingException{         ObjectMapper mapper = new ObjectMapper();         return mapper.readValue(json, new TypeReference<List<DtoTransaction>>(){});     } }","package International_Trade_Union.utils;    import International_Trade_Union.model.Keys; import International_Trade_Union.utils.base.Base; import International_Trade_Union.utils.base.Base58;  import org.bouncycastle.asn1.ASN1ObjectIdentifier; import org.bouncycastle.asn1.x9.ECNamedCurveTable; import org.bouncycastle.asn1.x9.X9ECParameters; import org.bouncycastle.crypto.params.ECNamedDomainParameters; import org.bouncycastle.crypto.params.ECPublicKeyParameters; import org.bouncycastle.jcajce.provider.asymmetric.ec.BCECPublicKey; import org.bouncycastle.jce.provider.BouncyCastleProvider; import org.bouncycastle.jce.spec.ECNamedCurveParameterSpec; import org.bouncycastle.jce.spec.ECPublicKeySpec; import org.bouncycastle.math.ec.ECCurve; import org.bouncycastle.math.ec.ECPoint;  import java.io.IOException; import java.math.BigInteger; import java.nio.charset.StandardCharsets; import java.security.*; import java.security.interfaces.ECPublicKey; import java.security.spec.*;  //https://metamug.com/article/security/sign-verify-digital-signature-ecdsa-java.html //https://stackoverflow.com/questions/8451205/create-privatekey-and-publickey-having-a-byte-array-encoded-in-base-64 public class UtilsSecurity {     private static final String SPEC = \"secp256k1\";     private static final String ALGO_ECDSA = \"ECDSA\";     private static final String PROVIDER = \"BC\";      static {         Security.addProvider(new org.bouncycastle.jce.provider.BouncyCastleProvider());     }     public static Keys generateKeyPair() throws NoSuchAlgorithmException, InvalidAlgorithmParameterException, NoSuchProviderException, InvalidKeySpecException {        Base base = new Base58();         Security.addProvider(new org.bouncycastle.jce.provider.BouncyCastleProvider());         ECGenParameterSpec ecSpec = new ECGenParameterSpec(SPEC);         KeyPairGenerator g = KeyPairGenerator.getInstance(ALGO_ECDSA, PROVIDER);         g.initialize(ecSpec, new SecureRandom());         KeyPair keyPair = g.generateKeyPair();         String pub = base.encode(UtilsSecurity.compressed(keyPair.getPublic().getEncoded()));         String priv = base.encode(keyPair.getPrivate().getEncoded());         Keys keys = new Keys(pub, priv);         return keys;     }      public static PrivateKey privateBytToPrivateKey(byte[] bytes) throws NoSuchAlgorithmException, InvalidKeySpecException, NoSuchProviderException {         EncodedKeySpec privateKeySpec = new PKCS8EncodedKeySpec(bytes);         KeyFactory generator = KeyFactory.getInstance(ALGO_ECDSA, PROVIDER);         return generator.generatePrivate(privateKeySpec);     }      public static PublicKey publicByteToPublicKey(byte[] bytes) throws NoSuchAlgorithmException, InvalidKeySpecException, NoSuchProviderException {         //new X509EncodedKeySpec         EncodedKeySpec publicKeySpec = new X509EncodedKeySpec(bytes);         KeyFactory generator = KeyFactory.getInstance(ALGO_ECDSA, PROVIDER);         return generator.generatePublic(publicKeySpec);     }       public static KeyPair createKeyPairWithPrivkeyPubKey(PrivateKey privateKey, PublicKey publicKey){         return new KeyPair(publicKey, privateKey);     }       public static byte[] sign(PrivateKey privateKey, String hex) throws NoSuchAlgorithmException, NoSuchProviderException, InvalidKeyException, SignatureException, IOException {         Signature signature = Signature.getInstance(ALGO_ECDSA, PROVIDER);         signature.initSign(privateKey);         signature.update(hex.getBytes(StandardCharsets.UTF_8));         byte[] signByte = signature.sign();         return signByte;     }      public static boolean verify(String sha256message, byte[] sign, PublicKey publicKey) throws NoSuchAlgorithmException, NoSuchProviderException, InvalidKeyException, SignatureException {         Signature signature = Signature.getInstance(ALGO_ECDSA, PROVIDER);         signature.initVerify(publicKey);         signature.update(sha256message.getBytes(StandardCharsets.UTF_8));         return signature.verify(sign);     }       public static byte[] compressed(byte[] pub) throws NoSuchAlgorithmException, NoSuchProviderException, InvalidAlgorithmParameterException, InvalidKeySpecException {          // === NOT PART OF THE CODE, JUST GETTING TEST VECTOR ===         PublicKey publicKey = UtilsSecurity.publicByteToPublicKey(pub);          ECPublicKey key = (ECPublicKey) publicKey;         byte[] x = key.getW().getAffineX().toByteArray();         byte[] y = key.getW().getAffineY().toByteArray();          // assumes that x and y are (unsigned) big endian encoded         BigInteger xbi = new BigInteger(1, x);         BigInteger ybi = new BigInteger(1, y);         X9ECParameters x9 = ECNamedCurveTable.getByName(SPEC);         ASN1ObjectIdentifier oid = ECNamedCurveTable.getOID(SPEC);         ECCurve curve = x9.getCurve();         ECPoint point = curve.createPoint(xbi, ybi);         ECNamedDomainParameters dParams = new ECNamedDomainParameters(oid,                 x9.getCurve(), x9.getG(), x9.getN(), x9.getH(), x9.getSeed());         ECPublicKeyParameters pubKey = new ECPublicKeyParameters(point, dParams);         System.out.println(pubKey);          // some additional encoding tricks         byte[] compressed = point.getEncoded(true);         return compressed;     }     public static ECPublicKey decodeKey(byte[] encoded) {          ECNamedCurveParameterSpec params = org.bouncycastle.jce.ECNamedCurveTable.getParameterSpec(SPEC);         org.bouncycastle.jce.spec.ECPublicKeySpec keySpec = new ECPublicKeySpec(params.getCurve().decodePoint(encoded), params);         return new BCECPublicKey(ALGO_ECDSA, keySpec, BouncyCastleProvider.CONFIGURATION);     } }","package International_Trade_Union.utils;  import International_Trade_Union.entity.DtoTransaction.DtoTransaction; import International_Trade_Union.entity.blockchain.block.Block; import International_Trade_Union.setings.Seting;  import java.io.File; import java.io.IOException; import java.security.InvalidKeyException; import java.security.NoSuchAlgorithmException; import java.security.NoSuchProviderException; import java.security.SignatureException; import java.security.spec.InvalidKeySpecException; import java.util.ArrayList; import java.util.Comparator; import java.util.List; import java.util.stream.Collectors;  public class UtilsTransaction {     public static void saveAllTransaction(DtoTransaction dtoTransaction, String filename) throws IOException, NoSuchAlgorithmException, SignatureException, InvalidKeySpecException, NoSuchProviderException, InvalidKeyException {         int fileLimit = Seting.SIZE_FILE_LIMIT * 1024 * 1024;          //папка чтобы проверить есть ли         File folder = new File(filename);         List<String> files = new ArrayList<>();         for (File file : folder.listFiles()) {             if(!file.isDirectory()){                 files.add(file.getAbsolutePath());             }         }           int count = 0;         files = files.stream().sorted().collect(Collectors.toList());         String nextFile = \"\";          if (files.size() > 0) {             nextFile = files.get(files.size()-1);              count = Integer.parseInt(nextFile.replaceAll(\"[^\\\\d]\", \"\"));           }          File file = new File(nextFile);          if(file.length() >= fileLimit){             count++;          }          nextFile = filename + count + \".txt\";          String json = UtilsJson.objToStringJson(dtoTransaction);         UtilsFileSaveRead.save(json + \"\\n\", nextFile);      }      public static List<DtoTransaction> readLineObject(String filename ) throws IOException, NoSuchAlgorithmException, InvalidKeySpecException, SignatureException, NoSuchProviderException, InvalidKeyException {         List<DtoTransaction> dtoTransactions = new ArrayList<>();         File folder = new File(filename);         for (final File fileEntry : folder.listFiles()) {             if (fileEntry.isDirectory()) {                 System.out.println(\"is directory \" + fileEntry.getAbsolutePath());             } else {                 List<String> list = UtilsFileSaveRead.reads(fileEntry.getAbsolutePath());                 for (String s : list) {                      DtoTransaction dtoTransaction = UtilsJson.jsonToDtoTransaction(s);                     dtoTransactions.add(dtoTransaction);                 }              }         }         dtoTransactions = dtoTransactions                 .stream()                 .collect(Collectors.toList());          return dtoTransactions;     }  }","package International_Trade_Union.utils;    import International_Trade_Union.setings.Seting;  import java.io.IOException;  import java.math.BigDecimal; import java.nio.charset.Charset; import java.nio.charset.StandardCharsets; import java.security.MessageDigest; import java.security.NoSuchAlgorithmException; import java.util.HashMap; import java.util.List; import java.util.Random; import java.util.Set; import java.util.concurrent.ConcurrentHashMap; import java.util.function.Function; import java.util.function.Predicate; import java.util.regex.Matcher; import java.util.regex.Pattern;  public class UtilsUse {     private static MessageDigest digest;      static {         try {             digest = MessageDigest.getInstance(\"SHA-256\");         } catch (NoSuchAlgorithmException e) {             e.printStackTrace();         }     } //    одно число от другого в процентах     public static Double percentDifferent(Double first, Double second){         return (first / second - 1) * Seting.HUNDRED_PERCENT;     }      //найти моду     public static int mode(List<Integer> array)     {         HashMap<Integer,Integer> hm = new HashMap<Integer,Integer>();         int max  = 1;         int temp = 0;          for(int i = 0; i < array.size(); i++) {              if (hm.get(array.get(i)) != null) {                  int count = hm.get(array.get(i));                 count++;                 hm.put(array.get(i), count);                  if(count > max) {                     max  = count;                     temp = array.get(i);                 }             }              else                 hm.put(array.get(i),1);         }         return temp;     }      public static BigDecimal percentDifferent(BigDecimal first, BigDecimal second){         return first.divide(second).subtract(new BigDecimal(1)).multiply(new BigDecimal(Seting.HUNDRED_PERCENT));     }      public static byte[] sha256(String text){         return digest.digest(text.getBytes(StandardCharsets.UTF_8));     }     public static String sha256hash(String text){         byte[] bytes = sha256(text);         return bytesToHex(bytes);     }      private static String bytesToHex(byte[] hash) {         StringBuilder hexString = new StringBuilder(2 * hash.length);         for (int i = 0; i < hash.length; i++) {             String hex = Integer.toHexString(0xff & hash[i]);             if(hex.length() == 1) {                 hexString.append('0');             }             hexString.append(hex);         }         return hexString.toString();     }      public static String generateRandomStr() {         byte[] array = new byte[7]; // length is bounded by 7         new Random().nextBytes(array);         String generatedString = new String(array, Charset.forName(\"UTF-8\"));          return generatedString;     }      public static double countPercents(double sum, double percent){         return sum * percent / Seting.HUNDRED_PERCENT;     }     public static BigDecimal countPercents(BigDecimal sum, BigDecimal percent){         return sum.multiply(percent).divide(new BigDecimal(Seting.HUNDRED_PERCENT));     }      public  static double countGrowth(long block, double percent, double money){         long year = (long) (block / Seting.COUNT_BLOCK_IN_DAY / (Seting.YEAR / Seting.HALF_YEAR));         double opeartion1 = 1+ (percent / Seting.HALF_YEAR)/Seting.HUNDRED_PERCENT;         double operation2 = Math.pow(opeartion1, year);         double result = money * operation2;         return result;     }      public static boolean hashComplexity(String literral, int hashComplexity){          String regex = \"^[0]{\" + Integer.toString(hashComplexity) + \"}\";         Pattern pattern = Pattern.compile(regex);         Matcher matcher = pattern.matcher(literral);         return matcher.find();     }      public static String hashComplexityStr(String str, int hashComplexity) throws IOException {         int randomNumberProof = 0;         String hash = \"\";         while (true){             randomNumberProof++;             hash = UtilsUse.sha256hash(UtilsJson.objToStringJson(str + randomNumberProof));             if(UtilsUse.hashComplexity(hash.substring(0, hashComplexity), hashComplexity))             {                 break;             }          }         return hash;     }      //для филтрации в стриме, чтобы получить уникальные обекты по полям     public static <T> Predicate<T> distinctByKey(Function<? super T, ?> keyExtractor) {         Set<Object> seen = ConcurrentHashMap.newKeySet();         return t -> seen.add(keyExtractor.apply(t));     }     //подсчитать количество нулей идущих подряд в hash     public static long hashCount(String hash) {         long count = 0;         for (int i = 0; i < hash.length(); i++) {             if(hash.charAt(i) == '0') count++;             else return count;         }         return count;     }      //подсчитывает долю в процентах одного числа от другого     public static double percentageShare(double first, double allNumber){         return (first/allNumber)*Seting.HUNDRED_PERCENT;     }      //опреледеляет ближайщее число к году     public static long nearestDateToYear(long block){         long period = (long) (Seting.COUNT_BLOCK_IN_DAY * Seting.YEAR);         return block / period * period;     }   }","package International_Trade_Union.utils;  import com.fasterxml.jackson.databind.ObjectMapper; import org.apache.http.NameValuePair; import org.apache.http.client.methods.HttpPost; import org.apache.http.message.BasicNameValuePair; import org.json.JSONException;  import javax.net.ssl.HttpsURLConnection; import java.io.*; import java.net.*; import java.nio.charset.Charset; import java.util.ArrayList; import java.util.Base64; import java.util.List;  public class UtilUrl {     public static String readJsonFromUrl(String url) throws IOException, JSONException {         InputStream is = new URL(url).openStream();         try {             BufferedReader rd = new BufferedReader(new InputStreamReader(is, Charset.forName(\"UTF-8\")));             String jsonText = readAll(rd);             ObjectMapper mapper = new ObjectMapper();             return jsonText;         } finally {             is.close();         }     }      private static String readAll(Reader rd) throws IOException {         StringBuilder sb = new StringBuilder();         int cp;         while ((cp = rd.read()) != -1) {             sb.append((char) cp);         }         return sb.toString();     }      public static String getObject(String jsonObject, String requstStr) throws IOException {         URL url = new URL(requstStr);         HttpURLConnection conn = (HttpURLConnection) url.openConnection(); //        conn.connect();         conn.setReadTimeout(10000);         conn.setConnectTimeout(15000);         conn.setRequestMethod(\"POST\");         conn.setRequestProperty(\"Content-Type\", \"application/json; utf-8\");         conn.setRequestProperty(\"Accept\", \"application/json\");         conn.setDoOutput(true);            try(OutputStream outputStream = conn.getOutputStream()) {             byte[] input = jsonObject.getBytes(\"utf-8\");             outputStream.write(input, 0, input.length);             conn.getResponseCode();         }           conn.connect();         try(BufferedReader br = new BufferedReader(                 new InputStreamReader(conn.getInputStream(), \"utf-8\"))) {             StringBuilder response = new StringBuilder();             String responseLine = null;             while ((responseLine = br.readLine()) != null) {                 response.append(responseLine.trim());             }             return response.toString();          }      }         public static void sendPost(String jsonObject, String requestStr) throws IOException {          URL url = new URL(requestStr);         HttpURLConnection conn = (HttpURLConnection) url.openConnection(); //        conn.connect();         conn.setReadTimeout(10000);         conn.setConnectTimeout(15000);         conn.setRequestMethod(\"POST\");         conn.setRequestProperty(\"Content-Type\", \"application/json; utf-8\");         conn.setRequestProperty(\"Accept\", \"application/json\");         conn.setDoOutput(true);            try(OutputStream outputStream = conn.getOutputStream()) {             byte[] input = jsonObject.getBytes(\"utf-8\");             outputStream.write(input, 0, input.length);             conn.getResponseCode();         }           conn.connect();     }     }","package International_Trade_Union.vote;  import lombok.Data; import International_Trade_Union.model.Account; import International_Trade_Union.setings.Seting; import org.apache.tomcat.util.net.jsse.JSSEUtil;  import java.util.List; import java.util.Map; import java.util.Objects; import java.util.Set; import java.util.stream.Collectors;  @Data public class CurrentLawVotes {     private String addressLaw;     private Set<String> YES;     private Set<String> NO;       public CurrentLawVotes() {     }      public CurrentLawVotes(String addressLaw, Set<String> YES, Set<String> NO) {         this.addressLaw = addressLaw;         this.YES = YES;         this.NO = NO;     }      //подсчет голосов для палат     public int voteGovernment(             Map<String, Account> balances,             List<String> governments      ) {         int yes = 0;         int no = 0;          List<String> addressGovernment = governments;         for (String s : YES) {             if (addressGovernment.contains(s)) {                 yes += Seting.VOTE_GOVERNMENT;             }          }         for (String s : NO) {             if (addressGovernment.contains(s)) {                 no += Seting.VOTE_GOVERNMENT;             }          }           return yes - no;      }      //для избрания должностных лиц     public double votesLaw(Map<String, Account> balances,                            Map<String, Integer> yesAverage, Map<String, Integer> noAverage) {         double yes = 0.0;         double no = 0.0;           //         for (String s : YES) {              int count = 1;             count = yesAverage.get(s) > 0 ? yesAverage.get(s) : 1;             yes += balances.get(s).getDigitalStockBalance() / Math.pow(count, Seting.POWERING_FOR_VOTING);          }         //         for (String s : NO) {             int count = 1;             count = noAverage.get(s) > 0 ? noAverage.get(s) : 1;             no += balances.get(s).getDigitalStockBalance() / Math.pow(count, Seting.POWERING_FOR_VOTING);          }           return yes - no;     }      //для избрания должностных лиц     public double votes(Map<String, Account> balances,                         Map<String, Integer> yesAverage, Map<String, Integer> noAverage) {         double yes = 0.0;         double no = 0.0;         for (String s : YES) {             int count = 1;             count = yesAverage.get(s) > 0 ? yesAverage.get(s) : 1;             yes += balances.get(s).getDigitalStockBalance() / count;          }         for (String s : NO) {             int count = 1;             count = noAverage.get(s) > 0 ? noAverage.get(s) : 1;             no += balances.get(s).getDigitalStockBalance() / count;          }           return yes - no;     }      @Override     public boolean equals(Object o) {         if (this == o) return true;         if (!(o instanceof CurrentLawVotes)) return false;         CurrentLawVotes that = (CurrentLawVotes) o;         return getAddressLaw().equals(that.getAddressLaw());     }      @Override     public int hashCode() {         return Objects.hash(getAddressLaw());     } }","package International_Trade_Union.vote;  public class CurrentLawVotesAverage { }","package International_Trade_Union.vote;  import lombok.Data;  import java.util.List; import java.util.Objects;  @Data public class CurrentLawVotesEndBalance {     private String addressLaw;     private double votes;     //CORPORATE_COUNCIL_OF_REFEREES     private int votesCorporateCouncilOfReferees;      //BOARD_OF_DIRECTORS     private int votesBoardOfDirectors;     private int votesBoardOfShareholders;      //GENERAL_EXECUTIVE_DIRECTOR     private int voteGeneralExecutiveDirector;     private int voteHightJudge;      private int founderVote;     private String packageName;     private List<String> laws;      public CurrentLawVotesEndBalance() {     }      public CurrentLawVotesEndBalance             (String addressLaw,              String packageName,              double votes,              int votesCorporateCouncilOfReferees,              int votesBoardOfDirectors,              int votesBoardOfShareholders,              int voteGeneralExecutiveDirector,              int voteHightJudge,                     int founderVote,              List<String> laws) {         this.addressLaw = addressLaw;         this.packageName = packageName;         this.votesCorporateCouncilOfReferees = votesCorporateCouncilOfReferees;         this.votesBoardOfShareholders = votesBoardOfShareholders;         this.votesBoardOfDirectors = votesBoardOfDirectors;         this.voteGeneralExecutiveDirector = voteGeneralExecutiveDirector;         this.voteHightJudge = voteHightJudge;         this.founderVote = founderVote;          this.votes = votes;         this.laws = laws;      }      @Override     public boolean equals(Object o) {         if (this == o) return true;         if (!(o instanceof CurrentLawVotesEndBalance)) return false;         CurrentLawVotesEndBalance that = (CurrentLawVotesEndBalance) o;         return getAddressLaw().equals(that.getAddressLaw());     }      @Override     public int hashCode() {         return Objects.hash(getAddressLaw());     } }","package International_Trade_Union.vote;   import lombok.Data; import International_Trade_Union.model.Account;  import java.util.Objects;  @Data public class LawEligibleForParliamentaryApproval {     public LawEligibleForParliamentaryApproval(Account account, Laws laws) {         this.account = account;         this.laws = laws;         this.name = account.getAccount();     }      public LawEligibleForParliamentaryApproval() {     }      private String name;     private Account account;     private Laws laws;      @Override     public boolean equals(Object o) {         if (this == o) return true;         if (!(o instanceof LawEligibleForParliamentaryApproval)) return false;         LawEligibleForParliamentaryApproval that = (LawEligibleForParliamentaryApproval) o;         return Objects.equals(getName(), that.getName()) && Objects.equals(getAccount(), that.getAccount()) && Objects.equals(getLaws(), that.getLaws());     }      @Override     public int hashCode() {         return Objects.hash(getName(), getAccount(), getLaws());     } }","package International_Trade_Union.vote;   import lombok.Data; import International_Trade_Union.setings.Seting; import International_Trade_Union.utils.UtilsJson; import International_Trade_Union.utils.UtilsUse;  import java.io.IOException; import java.util.List; import java.util.Objects;  @Data public class Laws {     //название пакета закона     String packetLawName;     List<String> laws;     String hashLaw;      public Laws() {     }      public Laws(String packetLawName, List<String> laws) throws IOException {         this.packetLawName = packetLawName;         this.laws = laws;         this.hashLaw = Seting.NAME_LAW_ADDRESS_START + UtilsUse.sha256hash(UtilsJson.objToStringJson(this));     }      @Override     public boolean equals(Object o) {         if (this == o) return true;         if (!(o instanceof Laws)) return false;         Laws laws = (Laws) o;         return getHashLaw().equals(laws.getHashLaw());     }      @Override     public int hashCode() {         return Objects.hash(getHashLaw());     } }","package International_Trade_Union.vote;  import International_Trade_Union.entity.DtoTransaction.DtoTransaction; import International_Trade_Union.entity.blockchain.Blockchain; import International_Trade_Union.entity.blockchain.block.Block; import International_Trade_Union.governments.Director; import International_Trade_Union.governments.Directors; import International_Trade_Union.governments.UtilsGovernment; import International_Trade_Union.model.Account; import International_Trade_Union.model.FIndPositonHelperData; import International_Trade_Union.setings.Seting;  import java.io.IOException; import java.security.InvalidKeyException; import java.security.NoSuchAlgorithmException; import java.security.NoSuchProviderException; import java.security.SignatureException; import java.security.spec.InvalidKeySpecException; import java.util.*; import java.util.stream.Collectors;  public class UtilsCurrentLaw {     //подсчет по штучно баланса     public static Map<String, CurrentLawVotes> calculateVote(Map<String, CurrentLawVotes> votes, List<Account> governments, Block block) throws IOException, NoSuchAlgorithmException, SignatureException, InvalidKeySpecException, NoSuchProviderException, InvalidKeyException {          for (int j = 0; j < block.getDtoTransactions().size(); j++) {             DtoTransaction transaction = block.getDtoTransactions().get(j);              if (transaction.getSender().startsWith(Seting.NAME_LAW_ADDRESS_START)) {                 System.out.println(\"law balance cannot be sender\");                 continue;             }             if (transaction.verify() && transaction.getCustomer().startsWith(Seting.NAME_LAW_ADDRESS_START)) {                 for (Account account : governments) {                     //основатель не может участвовать в голосовании                     //!block.getFounderAddress().equals(transaction.getSender())                     if (transaction.getSender().equals(account.getAccount())) {                         CurrentLawVotes currentLawVotes = votes.get(transaction.getCustomer());                          if (currentLawVotes == null) {                             currentLawVotes = new CurrentLawVotes();                             currentLawVotes.setAddressLaw(transaction.getCustomer());                             currentLawVotes.setYES(new HashSet<>());                             currentLawVotes.setNO(new HashSet<>());                              votes.put(transaction.getCustomer(), currentLawVotes);                         }                          if (transaction.getVoteEnum().equals(VoteEnum.YES)) {                              currentLawVotes.getYES().add(transaction.getSender());                             currentLawVotes.getNO().remove(transaction.getSender());                          } else if (transaction.getVoteEnum().equals(VoteEnum.NO)) {                             currentLawVotes.getNO().add(transaction.getSender());                             currentLawVotes.getYES().remove(transaction.getSender());                         }                     }                 }              }          }           return votes;      }      //подсчет целиком баланса     public static Map<String, CurrentLawVotes> calculateVotes(List<Account> governments, List<Block> blocks) throws IOException, NoSuchAlgorithmException, SignatureException, InvalidKeySpecException, NoSuchProviderException, InvalidKeyException {         Map<String, CurrentLawVotes> votes = new HashMap<>();         for (Block block : blocks) {             calculateVote(votes, governments, block);         }          return votes;      }      //возвращаяет усредненное количество голосов,     //суть проста если есть один акаунт и он имеет 100 акций     //и проголосовал за один закон то все сто акций будут для этого закона как сто голосов     //если за два закона то 100/2 то есть если он на протяжении трех лет проголосовал     //за n законов, то его голоса делятся на n.     public static Map<String, Integer> calculateAverageVotesYes(Map<String, CurrentLawVotes> votesMap) {         Map<String, Integer> voteAverage = new HashMap<>();         for (Map.Entry<String, CurrentLawVotes> current : votesMap.entrySet()) {             for (String yesVoteAddress : current.getValue().getYES()) {                 if (voteAverage.containsKey(yesVoteAddress)) {                     int count = voteAverage.get(yesVoteAddress);                     voteAverage.put(yesVoteAddress, count + 1);                 } else {                     int count = 1;                     voteAverage.put(yesVoteAddress, count);                 }             }          }         return voteAverage;     }      //подсчитывает голоса No     public static Map<String, Integer> calculateAverageVotesNo(Map<String, CurrentLawVotes> votesMap) {         Map<String, Integer> voteAverage = new HashMap<>();         for (Map.Entry<String, CurrentLawVotes> current : votesMap.entrySet()) {             for (String yesVoteAddress : current.getValue().getNO()) {                 if (voteAverage.containsKey(yesVoteAddress)) {                     int count = voteAverage.get(yesVoteAddress);                     voteAverage.put(yesVoteAddress, count + 1);                 } else {                     int count = 1;                     voteAverage.put(yesVoteAddress, count);                 }             }          }         return voteAverage;     }        //возвращает списки позиций     public static Map<Director, List<String>> findPositions(              Map<String, Account> balances,             Blockchain blockchain,             List<LawEligibleForParliamentaryApproval> allGovernment,             List<Account> BoardOfShareholders,             Map<Director, FIndPositonHelperData> fIndPositonHelperData      ) throws IOException, NoSuchAlgorithmException, InvalidKeySpecException, SignatureException, NoSuchProviderException, InvalidKeyException {         //список должностей         Directors directors = new Directors();         Map<Director, List<LawEligibleForParliamentaryApproval>> positionsListMap = new HashMap<>();         //добавление всех должностей         for (Director higherSpecialPositions : directors.getDirectors()) {             positionsListMap.put(higherSpecialPositions, UtilsLaws.getPossions(allGovernment, higherSpecialPositions));         }         //список законов с голосами         Map<Director, List<CurrentLawVotesEndBalance>> curentLawVotesEndBalance = new HashMap<>();         for (Map.Entry<Director, List<LawEligibleForParliamentaryApproval>> corp : positionsListMap.entrySet()) {             //убрать повторяющиеся должности из списка.             corp.setValue(corp.getValue().stream() //                    .filter(t-> finalBoardOfShareholders.contains(new Account(t.getLaws().getLaws().get(0), 0, 0)))                     .distinct().collect(Collectors.toList()));              //получить баланс и голоса для действующих законов             curentLawVotesEndBalance.put(corp.getKey(), UtilsGovernment.filters(corp.getValue(), balances, BoardOfShareholders,                     blockchain.getBlockchainList(), Seting.POSITION_YEAR_VOTE));             List<CurrentLawVotesEndBalance> temporary;             if (fIndPositonHelperData.get(corp.getKey()).isElectedWithStock()) {                   //отобрать голоса выше лимита                 curentLawVotesEndBalance.put(corp.getKey(), curentLawVotesEndBalance.get(corp.getKey()));                 List<CurrentLawVotesEndBalance> electedByStock =                         curentLawVotesEndBalance.get(corp.getKey())                                 .stream()                                 .filter(t->directors.isElectedByStocks(t.getPackageName()))                                 .filter(t -> t.getVotes() >= Seting.ORIGINAL_LIMIT_MIN_VOTE)                                 .sorted(Comparator.comparing(CurrentLawVotesEndBalance::getVotes).reversed())                                 .limit(corp.getKey().getCount())                                 .collect(Collectors.toList());                  System.out.println(\"UtilsCurrentLaw: findPostion: \");                 System.out.println(\"*******************************\");                 electedByStock.stream().forEach(System.out::println);                 System.out.println(\"*******************************\");                  //отобрать то количество которое соответсвтвует данной должности                 temporary = electedByStock;              } else {                  curentLawVotesEndBalance.put(corp.getKey(), curentLawVotesEndBalance.get(corp.getKey()));                 //отобрать то количество которое соответсвтвует данной должности                 //избираемые премьер министром                 if(fIndPositonHelperData.get(corp.getKey()).isElectedWithPrimeMinister()){                     //отобрать голоса выше лимита                     curentLawVotesEndBalance.put(corp.getKey(), curentLawVotesEndBalance.get(corp.getKey()));                     List<CurrentLawVotesEndBalance> electedByPrimeMinister =                             curentLawVotesEndBalance.get(corp.getKey())                                     .stream()                                     .filter(t->directors.isElectedCEO(t.getPackageName()))                                     .filter(t -> t.getVoteGeneralExecutiveDirector() >= Seting.ORIGINAL_LIMIT_MIN_VOTE_GENERAL_EXECUTIVE_DIRECTOR)                                     .sorted(Comparator.comparing(CurrentLawVotesEndBalance::getVoteGeneralExecutiveDirector).reversed())                                     .collect(Collectors.toList());                       //отобрать то количество которое соответсвтвует данной должности                     temporary = electedByPrimeMinister;                 }                 //избираемые палатой представителей                 else if(fIndPositonHelperData.get(corp.getKey()).isElectedWithHousOfRepresentativies()){                     //отобрать голоса выше лимита                     curentLawVotesEndBalance.put(corp.getKey(), curentLawVotesEndBalance.get(corp.getKey()));                     List<CurrentLawVotesEndBalance> electedByHouseOfRepresentatives =                             curentLawVotesEndBalance.get(corp.getKey())                                     .stream()                                     .filter(t->directors.isElectedByBoardOfDirectors(t.getPackageName()))                                     .filter(t -> t.getVotesBoardOfDirectors() >= Seting.ORIGINAL_LIMIT_MIN_VOTE_BOARD_OF_DIRECTORS)                                     .sorted(Comparator.comparing(CurrentLawVotesEndBalance::getVotesBoardOfDirectors).reversed())                                     .collect(Collectors.toList());                       //отобрать то количество которое соответсвтвует данной должности                     temporary = electedByHouseOfRepresentatives;                    }                 //избираемые палатаой верховных судей                 else if(fIndPositonHelperData.get(corp.getKey()).isElectedWithChamberOfHightJudjes()){                     //отобрать голоса выше лимита                     curentLawVotesEndBalance.put(corp.getKey(), curentLawVotesEndBalance.get(corp.getKey()));                     List<CurrentLawVotesEndBalance> electedByChamberOfSupremeJudges =                             curentLawVotesEndBalance.get(corp.getKey())                                     .stream()                                     .filter(t->directors.isElectedBYCorporateCouncilOfReferees(t.getPackageName()))                                     .filter(t -> t.getVotesCorporateCouncilOfReferees() >= Seting.ORIGINAL_LIMIT_MIN_VOTE_CORPORATE_COUNCIL_OF_REFEREES)                                     .sorted(Comparator.comparing(CurrentLawVotesEndBalance::getVotesCorporateCouncilOfReferees).reversed())                                     .collect(Collectors.toList());                       //отобрать то количество которое соответсвтвует данной должности                     temporary = electedByChamberOfSupremeJudges;                  }                 else {                     temporary = curentLawVotesEndBalance.get(corp.getKey()).stream()                              .collect(Collectors.toList());                 }              }              temporary = temporary.stream().distinct().collect(Collectors.toList());              curentLawVotesEndBalance.put(corp.getKey(), temporary);         }           List<LawEligibleForParliamentaryApproval> lawEligibleForParliamentaryApprovals =                 UtilsLaws.readLineCurrentLaws(Seting.ORIGINAL_ALL_CORPORATION_LAWS_WITH_BALANCE_FILE);           Map<Director, List<String>> currentPossitions = new HashMap<>();         for (Map.Entry<Director, FIndPositonHelperData> fIndPositonHelperData1 : fIndPositonHelperData.entrySet()) {             List<CurrentLawVotesEndBalance> position = curentLawVotesEndBalance.get(fIndPositonHelperData1.getKey());             //список адресов на данную позицию, пример члена палаты представителей             List<String> currntAddress = new ArrayList<>();             for (CurrentLawVotesEndBalance address : position) {                 for (LawEligibleForParliamentaryApproval lawEligibleForParliamentaryApproval : lawEligibleForParliamentaryApprovals) {                       if (lawEligibleForParliamentaryApproval.getLaws().getHashLaw().equals(address.getAddressLaw())) {                          currntAddress.add(lawEligibleForParliamentaryApproval.getLaws().getLaws().get(0));                      }                 }              }             currentPossitions.put(fIndPositonHelperData1.getKey(), currntAddress);          }           return currentPossitions;     }      //найти членов палаты представителей     //возвращает список позиций     public static List<String> findPosition(             Map<String, Account> balances,             Blockchain blockchain,             List<LawEligibleForParliamentaryApproval> allGovernment,             List<Account> BoardOfShareholders,             Directors positions,             boolean withLimit      ) throws IOException, NoSuchAlgorithmException, InvalidKeySpecException, SignatureException, NoSuchProviderException, InvalidKeyException {         //список должностей          Map<Director, List<LawEligibleForParliamentaryApproval>> positionsListMap = new HashMap<>();         //добавление всех должностей         for (Director higherSpecialPositions : positions.getDirectors()) {             positionsListMap.put(higherSpecialPositions, UtilsLaws.getPossions(allGovernment, higherSpecialPositions));         }         //список законов с голосами         Map<Director, List<CurrentLawVotesEndBalance>> curentLawVotesEndBalance = new HashMap<>();         for (Map.Entry<Director, List<LawEligibleForParliamentaryApproval>> corp : positionsListMap.entrySet()) {             //убрать повторяющиеся должности из списка.             corp.setValue(corp.getValue().stream() //                    .filter(t-> finalBoardOfShareholders.contains(new Account(t.getLaws().getLaws().get(0), 0, 0)))                     .distinct().collect(Collectors.toList()));              //получить баланс и голоса для действующих законов             curentLawVotesEndBalance.put(corp.getKey(), UtilsGovernment.filters(corp.getValue(), balances, BoardOfShareholders,                     blockchain.getBlockchainList(), Seting.POSITION_YEAR_VOTE));             List<CurrentLawVotesEndBalance> temporary;             if (withLimit) {                 //отобрать голоса выше лимита                 curentLawVotesEndBalance.put(corp.getKey(), curentLawVotesEndBalance.get(corp.getKey())                         .stream().filter(t -> t.getVotes() >= Seting.ORIGINAL_LIMIT_MIN_VOTE)                         .collect(Collectors.toList()));                  //отобрать то количество которое соответсвтвует данной должности                 temporary = curentLawVotesEndBalance.get(corp.getKey()).stream()                         .filter(t -> !t.getPackageName().equals(corp.getKey()))                         .sorted(Comparator.comparing(CurrentLawVotesEndBalance::getVotes).reversed())                         .limit(corp.getKey().getCount()).collect(Collectors.toList());             } else {                 //отобрать то количество которое соответсвтвует данной должности                 temporary = curentLawVotesEndBalance.get(corp.getKey()).stream()                         .filter(t -> !t.getPackageName().equals(corp.getKey()))                         .sorted(Comparator.comparing(CurrentLawVotesEndBalance::getVotes).reversed())                         .collect(Collectors.toList());             }               curentLawVotesEndBalance.put(corp.getKey(), temporary);         }           List<LawEligibleForParliamentaryApproval> lawEligibleForParliamentaryApprovals =                 UtilsLaws.readLineCurrentLaws(Seting.ORIGINAL_ALL_CORPORATION_LAWS_WITH_BALANCE_FILE);          //список адресов на данную позицию, пример члена палаты представителей         List<String> currntAddress = new ArrayList<>();          List<CurrentLawVotesEndBalance> position = curentLawVotesEndBalance.get(positions);          for (CurrentLawVotesEndBalance address : position) {             for (LawEligibleForParliamentaryApproval lawEligibleForParliamentaryApproval : lawEligibleForParliamentaryApprovals) {                   if (lawEligibleForParliamentaryApproval.getLaws().getHashLaw().equals(address.getAddressLaw())) {                      currntAddress.add(lawEligibleForParliamentaryApproval.getLaws().getLaws().get(0));                  }             }         }           return currntAddress;     } }","package International_Trade_Union.vote;  import International_Trade_Union.governments.Director; import International_Trade_Union.governments.Directors; import com.fasterxml.jackson.core.JsonProcessingException; import International_Trade_Union.entity.DtoTransaction.DtoTransaction; import International_Trade_Union.entity.blockchain.block.Block; import International_Trade_Union.setings.Seting; import International_Trade_Union.model.Account; import International_Trade_Union.utils.UtilsFileSaveRead; import International_Trade_Union.utils.UtilsJson; import International_Trade_Union.utils.UtilsUse;   import java.io.File; import java.io.IOException; import java.security.InvalidKeyException; import java.security.NoSuchAlgorithmException; import java.security.NoSuchProviderException; import java.security.SignatureException; import java.security.spec.InvalidKeySpecException; import java.util.*; import java.util.stream.Collectors;  public class UtilsLaws {     public static void saveLaws(List<Laws> laws, String filename) throws IOException {         int fileLimit = Seting.SIZE_FILE_LIMIT * 1024 * 1024;          //папка чтобы проверить есть ли         File folder = new File(filename);         List<String> files = new ArrayList<>();         for (File file : folder.listFiles()) {             if(!file.isDirectory()){                 files.add(file.getAbsolutePath());             }         }          int count = 0;         files = files.stream().sorted().collect(Collectors.toList());         String nextFile = \"\";          if (files.size() > 0) {             nextFile = files.get(files.size()-1);              count = Integer.parseInt(nextFile.replaceAll(\"[^\\\\d]\", \"\"));           }          File file = new File(nextFile);          if(file.length() >= fileLimit){             count++;          }          nextFile = filename + count + \".txt\";          List<String> jsons = new ArrayList<>();         for (Laws laws1: laws) {             String json = UtilsJson.objToStringJson(laws1);             jsons.add(json);         }  //        String json = UtilsJson.objToStringJson(minerAccount); //        UtilsFileSaveRead.save(json + \"\\n\", nextFile);         UtilsFileSaveRead.saves(jsons, nextFile, true);     }     public static void saveLaw(Laws laws, String filename) throws IOException, NoSuchAlgorithmException, SignatureException, InvalidKeySpecException, NoSuchProviderException, InvalidKeyException {         int fileLimit = Seting.SIZE_FILE_LIMIT * 1024 * 1024;          //папка чтобы проверить есть ли         File folder = new File(filename);         List<String> files = new ArrayList<>();         for (File file : folder.listFiles()) {             if (!file.isDirectory()) {                 files.add(file.getAbsolutePath());             }         }          int count = 0;         files = files.stream().sorted().collect(Collectors.toList());         String nextFile = \"\";          if (files.size() > 0) {             nextFile = files.get(files.size() - 1);              count = Integer.parseInt(nextFile.replaceAll(\"[^\\\\d]\", \"\"));           }          File file = new File(nextFile);          if (file.length() >= fileLimit) {             count++;          }          nextFile = filename + count + \".txt\";          String json = UtilsJson.objToStringJson(laws);         UtilsFileSaveRead.save(json + \"\\n\", nextFile);      }      public static void saveCurrentsLaws(List<LawEligibleForParliamentaryApproval> lawEligibleForParliamentaryApprovals, String filename) throws IOException {         int fileLimit = Seting.SIZE_FILE_LIMIT * 1024 * 1024;          //папка чтобы проверить есть ли         File folder = new File(filename);         List<String> files = new ArrayList<>();         for (File file : folder.listFiles()) {             if(!file.isDirectory()){                 files.add(file.getAbsolutePath());             }         }          int count = 0;         files = files.stream().sorted().collect(Collectors.toList());         String nextFile = \"\";          if (files.size() > 0) {             nextFile = files.get(files.size()-1);              count = Integer.parseInt(nextFile.replaceAll(\"[^\\\\d]\", \"\"));           }          File file = new File(nextFile);          if(file.length() >= fileLimit){             count++;          }          nextFile = filename + count + \".txt\";          List<String> jsons = new ArrayList<>();         for (LawEligibleForParliamentaryApproval lawEligibleForParliamentaryApproval : lawEligibleForParliamentaryApprovals) {             String json = UtilsJson.objToStringJson(lawEligibleForParliamentaryApproval);             jsons.add(json);         }  //        String json = UtilsJson.objToStringJson(minerAccount); //        UtilsFileSaveRead.save(json + \"\\n\", nextFile);         UtilsFileSaveRead.saves(jsons, nextFile, true);     }     public static void saveCurrentLaw(LawEligibleForParliamentaryApproval lawEligibleForParliamentaryApproval, String filename) throws IOException, NoSuchAlgorithmException, SignatureException, InvalidKeySpecException, NoSuchProviderException, InvalidKeyException {         int fileLimit = Seting.SIZE_FILE_LIMIT * 1024 * 1024;          //папка чтобы проверить есть ли         File folder = new File(filename);         List<String> files = new ArrayList<>();         for (File file : folder.listFiles()) {             if (!file.isDirectory()) {                 files.add(file.getAbsolutePath());             }         }          int count = 0;         files = files.stream().sorted().collect(Collectors.toList());         String nextFile = \"\";          if (files.size() > 0) {             nextFile = files.get(files.size() - 1);              count = Integer.parseInt(nextFile.replaceAll(\"[^\\\\d]\", \"\"));           }          File file = new File(nextFile);          if (file.length() >= fileLimit) {             count++;          }          nextFile = filename + count + \".txt\";          String json = UtilsJson.objToStringJson(lawEligibleForParliamentaryApproval);         UtilsFileSaveRead.save(json + \"\\n\", nextFile);      }      public static List<Laws> readLineLaws(String filename) throws IOException, NoSuchAlgorithmException, InvalidKeySpecException, SignatureException, NoSuchProviderException, InvalidKeyException {         List<Laws> laws = new ArrayList<>();         File folder = new File(filename);         for (final File fileEntry : folder.listFiles()) {             if (fileEntry.isDirectory()) {                 System.out.println(\"is directory \" + fileEntry.getAbsolutePath());             } else {                 List<String> list = UtilsFileSaveRead.reads(fileEntry.getAbsolutePath());                 for (String s : list) {                      Laws laws1 = UtilsJson.jsonToLaw(s);                     laws.add(laws1);                 }              }         }         laws = laws                 .stream()                 .sorted(Comparator.comparing(Laws::getPacketLawName))                 .collect(Collectors.toList());          return laws;     }      public static List<LawEligibleForParliamentaryApproval> readLineCurrentLaws(String filename) throws JsonProcessingException {         List<LawEligibleForParliamentaryApproval> laws = new ArrayList<>();         File folder = new File(filename);         for (final File fileEntry : folder.listFiles()) {             if (fileEntry.isDirectory()) {                 System.out.println(\"is directory \" + fileEntry.getAbsolutePath());             } else {                 List<String> list = UtilsFileSaveRead.reads(fileEntry.getAbsolutePath());                 for (String s : list) {                      LawEligibleForParliamentaryApproval laws1 = UtilsJson.jsonToCurrentLaw(s);                     laws.add(laws1);                 }              }         }          return laws;     }       //возвращает все счета законов     public static List<Account> allPackegeLaws(Map<String, Account> balances) {         List<Account> laws = new ArrayList<>();         laws = balances.entrySet()                 .stream()                 .map(t -> t.getValue())                 .filter(t -> t.getAccount().startsWith(Seting.NAME_LAW_ADDRESS_START))                 .collect(Collectors.toList());         return laws;     }      //возвращает пакет законов и их счета     public static Map<String, Laws> getPackageLaws(List<Block> blocks) throws IOException, NoSuchAlgorithmException, SignatureException, InvalidKeySpecException, NoSuchProviderException, InvalidKeyException {         Map<String, Laws> laws = new HashMap<>();         for (Block block : blocks) {             for (DtoTransaction dtoTransaction : block.getDtoTransactions()) {                 if (dtoTransaction.verify()) {                     if (dtoTransaction.getCustomer().startsWith(Seting.NAME_LAW_ADDRESS_START) && dtoTransaction.getBonusForMiner() >= Seting.COST_LAW) {                         if(dtoTransaction.getLaws() != null && !laws.containsKey(dtoTransaction.getCustomer())){                             laws.put(dtoTransaction.getCustomer(), dtoTransaction.getLaws());                         }                      }                 }             }          }         return laws;     }      //проверяет валидность закона     public static boolean isValidHashLaw(Laws laws) throws IOException {         String hash = laws.getHashLaw();         String hashLaw = Seting.NAME_LAW_ADDRESS_START + UtilsUse.sha256hash(UtilsJson.objToStringJson(laws));         System.out.println(\"UtilsLaw: isValidHashLaw: \" + hash.equals(hashLaw));         System.out.println(\"hash: \" + hash);         System.out.println(\"hashLaw: \" + hashLaw);         return hash.equals(hashLaw);     }        public static List<Account> allPackageLaws(List<Account> accounts){         List<Account> currentLaws = accounts.stream()                 .filter(t -> t.getAccount().startsWith(Seting.NAME_LAW_ADDRESS_START))                 .collect(Collectors.toList());         return currentLaws;     }      //возвращяет список всех законов, как действующих, так и не действующих, если закон новый то автоматически сохраняет его     public static Map<String, Laws> getLaws(List<Block> blocks, String fileLaws) throws IOException, NoSuchAlgorithmException, InvalidKeySpecException, SignatureException, NoSuchProviderException, InvalidKeyException {         List<Laws> lawsForSave = new ArrayList<>();         Map<String, Laws> lawsMap = new HashMap<>();         File file = new File(fileLaws);         List<Laws> lawsList = new ArrayList<>();         if (file.exists()) {             lawsList = readLineLaws(fileLaws);         }         lawsMap = getPackageLaws(blocks);          for (Map.Entry<String, Laws> map : lawsMap.entrySet()) {             if (!lawsList.contains(map.getValue())) {                 if( map.getValue() != null &&                         map.getValue().packetLawName != null&&                         map.getValue().getLaws() != null                         && !map.getValue().getHashLaw().isEmpty()                         && (map.getValue().getLaws().size() > 0)){                          lawsForSave.add(map.getValue());                 }              }          }         saveLaws(lawsForSave, fileLaws);         return lawsMap;     }     public static List<LawEligibleForParliamentaryApproval> getCurrentLaws(Map<String, Laws> lawsMap, Map<String, Account> balances, String fileCurrentLaws) throws IOException, NoSuchAlgorithmException, SignatureException, InvalidKeySpecException, NoSuchProviderException, InvalidKeyException {         List<Account> lawsBalances = allPackegeLaws(balances);           List<LawEligibleForParliamentaryApproval> lawEligibleForParliamentaryApprovals = new ArrayList<>();         LawEligibleForParliamentaryApproval lawEligibleForParliamentaryApproval = null;         File file = new File(fileCurrentLaws);         if (file.exists()) {             lawEligibleForParliamentaryApprovals = readLineCurrentLaws(fileCurrentLaws);         }          for (LawEligibleForParliamentaryApproval eligibleForParliamentaryApproval : lawEligibleForParliamentaryApprovals) {             if(lawsBalances.contains(eligibleForParliamentaryApproval.getAccount())){                 eligibleForParliamentaryApproval.getAccount().                         setDigitalStockBalance(balances.get(eligibleForParliamentaryApproval.getAccount().getAccount()).getDigitalStockBalance());                 eligibleForParliamentaryApproval.getAccount().                         setDigitalDollarBalance(balances.get(eligibleForParliamentaryApproval.getAccount().getAccount()).getDigitalDollarBalance());             }          }           List<LawEligibleForParliamentaryApproval> temporary = new ArrayList<>();         for (Account account : lawsBalances) {             lawEligibleForParliamentaryApproval = new LawEligibleForParliamentaryApproval(account, lawsMap.get(account.getAccount()));             temporary.add(lawEligibleForParliamentaryApproval);         }           lawEligibleForParliamentaryApprovals.addAll(temporary);           lawEligibleForParliamentaryApprovals = lawEligibleForParliamentaryApprovals.stream()                 .filter(t->Objects.nonNull(t.getLaws()))                 .filter(t->Objects.nonNull(t.getAccount()))                 .filter(t->Objects.nonNull(t.getLaws().getHashLaw()))                 .filter(t->Objects.nonNull(t.getLaws().getLaws()))                 .filter(t->Objects.nonNull(t.getName()))                 .filter(t->Objects.nonNull(t.getLaws().getPacketLawName()))                 .filter(t->t != null).                 filter(UtilsUse.distinctByKey(LawEligibleForParliamentaryApproval::getName)).collect(Collectors.toList());          return lawEligibleForParliamentaryApprovals;      }         //отбирает позицию вакансий     public static List<LawEligibleForParliamentaryApproval> getPossions(List<LawEligibleForParliamentaryApproval> lawEligibleForParliamentaryApprovals, Director higherSpecialPositions){          List<LawEligibleForParliamentaryApproval> temporary = new ArrayList<>();         temporary = lawEligibleForParliamentaryApprovals.stream()                 .filter(t->Objects.nonNull(t))                 .filter(t->Objects.nonNull(t.getLaws()))                 .filter(t->Objects.nonNull(t.getLaws().getLaws()))                 .filter(t->Objects.nonNull(t.getLaws().getPacketLawName()))                 .filter(t->Objects.nonNull(t.getName()))                 .filter(t->Objects.nonNull(t.getLaws().getHashLaw()))                 .sorted((f1, f2) -> Double.compare(f2.getAccount().getDigitalStockBalance(), f1.getAccount().getDigitalStockBalance()))                 .filter(t-> t.getLaws().getPacketLawName().equals(higherSpecialPositions.getName()))                 .limit(higherSpecialPositions.getCount())                 .collect(Collectors.toList());         return temporary;      }       //удаляет из списка не лигитимные должности     public static List<LawEligibleForParliamentaryApproval> deletePossions(List<LawEligibleForParliamentaryApproval> lawEligibleForParliamentaryApprovals, List<LawEligibleForParliamentaryApproval> forDeleted, Directors higherSpecialPositions){         List<LawEligibleForParliamentaryApproval> temporary = new ArrayList<>();         for (LawEligibleForParliamentaryApproval lawEligibleForParliamentaryApproval : forDeleted) {             if(lawEligibleForParliamentaryApproval != null &&                     lawEligibleForParliamentaryApproval.getLaws() != null &&                     lawEligibleForParliamentaryApproval.getLaws().getPacketLawName() != null &&                     lawEligibleForParliamentaryApproval.getLaws().getHashLaw() != null &&                     lawEligibleForParliamentaryApproval.getLaws().getHashLaw() != null &&                     lawEligibleForParliamentaryApproval.getLaws().getPacketLawName().equals(higherSpecialPositions.getNames())){                 if(lawEligibleForParliamentaryApprovals.contains(lawEligibleForParliamentaryApproval)){                     temporary.add(lawEligibleForParliamentaryApproval);                 }else {                     continue;                 }             }             temporary.add(lawEligibleForParliamentaryApproval);         }         return temporary;     }   }","package International_Trade_Union.vote;  public enum VoteEnum {     YES,     NO }","package International_Trade_Union;  import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication;   @SpringBootApplication public class UnitedStatesApplication { \tpublic static void main(String[] args) { \t\tSpringApplication.run(UnitedStatesApplication.class, args); \t}  }package International_Trade_Union;  import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication;   @SpringBootApplication public class UnitedStatesApplication { \tpublic static void main(String[] args) { \t\tSpringApplication.run(UnitedStatesApplication.class, args); \t}  }","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","",""],"hashLaw":"LIBER38072b8b29e391554d90c407f2b7d17dba649c84c37cff46337d5b450b524d8a"}}
{"name":"LIBER10406f42a16accf222cd8731cf51cbf18ea2c9a9a2517fcb5f17ac4f0c60974d","account":{"account":"LIBER10406f42a16accf222cd8731cf51cbf18ea2c9a9a2517fcb5f17ac4f0c60974d","digitalDollarBalance":0.0,"digitalStockBalance":0.0},"laws":{"packetLawName":"ORIGINAL_CHARTER_CURRENT_ALL_CODE","laws":["Код всех важных классов которые участвуют в программе. The code of all important classes that participate in the program.","package International_Trade_Union.config;   import International_Trade_Union.entity.blockchain.Blockchain; import International_Trade_Union.setings.Seting;  import java.io.IOException; import java.security.InvalidKeyException; import java.security.NoSuchAlgorithmException; import java.security.NoSuchProviderException; import java.security.SignatureException; import java.security.spec.InvalidKeySpecException;  public class BLockchainFactory {      public static Blockchain getBlockchain(BlockchainFactoryEnum factoryEnum) throws NoSuchAlgorithmException, InvalidKeySpecException, IOException, SignatureException, NoSuchProviderException, InvalidKeyException {         switch (factoryEnum){             case TEST:                 return new Blockchain(                         Seting.BLOCK_GENERATION_INTERVAL_TEST,                         Seting.DIFFICULTY_ADJUSTMENT_INTERVAL_TEST,                         Seting.INTERVAL_TARGET_TEST,                         Seting.ADDRESS_FOUNDER_TEST);              case ORIGINAL:                 return new Blockchain(                         Seting.BLOCK_GENERATION_INTERVAL,                         Seting.DIFFICULTY_ADJUSTMENT_INTERVAL,                         Seting.INTERVAL_TARGET,                         Seting.ADDRESS_FOUNDER                 );             default: return null;         }     } }","package International_Trade_Union.config;  public enum BlockchainFactoryEnum {     TEST,     ORIGINAL }","package International_Trade_Union.controllers;  import International_Trade_Union.entity.AddressUrl; import International_Trade_Union.entity.SubBlockchainEntity; import org.json.JSONException;  import org.springframework.http.MediaType; import International_Trade_Union.entity.DtoTransaction.DtoTransaction; import International_Trade_Union.entity.blockchain.Blockchain; import International_Trade_Union.entity.blockchain.block.Block; import International_Trade_Union.config.BLockchainFactory; import International_Trade_Union.config.BlockchainFactoryEnum; import International_Trade_Union.entity.EntityChain; import International_Trade_Union.model.Account; import International_Trade_Union.model.Mining; import International_Trade_Union.model.User; import International_Trade_Union.network.AllTransactions; import International_Trade_Union.setings.Seting; import International_Trade_Union.utils.*; import International_Trade_Union.vote.*; import org.springframework.http.HttpStatus; import org.springframework.http.ResponseEntity; import org.springframework.stereotype.Controller; import org.springframework.ui.Model; import org.springframework.util.Assert; import org.springframework.web.bind.annotation.*; import org.springframework.web.context.request.RequestAttributes; import org.springframework.web.context.request.RequestContextHolder; import org.springframework.web.context.request.ServletRequestAttributes;  import javax.servlet.http.HttpServletRequest; import java.io.IOException;  import java.security.*; import java.security.spec.InvalidKeySpecException;  import java.util.*; import java.util.stream.Collectors;  @Controller public class BasisController {     private static Blockchain blockchain;      private static Set<String> excludedAddresses = new HashSet<>();      public static HttpServletRequest getCurrentRequest() {         RequestAttributes requestAttributes = RequestContextHolder.getRequestAttributes();         if(requestAttributes == null)             return null;         Assert.state(requestAttributes != null, \"Could not find current request via RequestContextHolder\");         Assert.isInstanceOf(ServletRequestAttributes.class, requestAttributes);         HttpServletRequest servletRequest = ((ServletRequestAttributes) requestAttributes).getRequest();         Assert.state(servletRequest != null, \"Could not find current HttpServletRequest\");         return servletRequest;     }       public static Set<String> getExcludedAddresses() {         HttpServletRequest request = getCurrentRequest();         if(request == null)             return excludedAddresses;          String scheme = request.getScheme();         String serverName = request.getServerName();         int serverPort = request.getServerPort();         String contextPath = request.getContextPath();  // includes leading forward slash          String localaddress = scheme + \"://\" + serverName + \":\" + serverPort;          excludedAddresses.add(localaddress);         return excludedAddresses;     }      public static void setExcludedAddresses(Set<String> excludedAddresses) {         BasisController.excludedAddresses = excludedAddresses;     }      private static Set<String> nodes = new HashSet<>(); //    private static Nodes nodes = new Nodes();       public static void setNodes(Set<String> nodes) {         BasisController.nodes = nodes;     }      /**Возвращает список хостов*/     public static Set<String> getNodes() throws IOException, NoSuchAlgorithmException, InvalidKeySpecException, SignatureException, NoSuchProviderException, InvalidKeyException {          nodes = new HashSet<>();          Set<String> temporary = UtilsAllAddresses.readLineObject(Seting.ORIGINAL_POOL_URL_ADDRESS_FILE);           nodes.addAll(temporary);           nodes = nodes.stream()                 .filter(t -> !t.isBlank())                 .filter(t -> t.startsWith(\"\\\"\"))                 .collect(Collectors.toSet());         nodes = nodes.stream().map(t -> t.replaceAll(\"\\\"\", \"\")).collect(Collectors.toSet());         nodes.addAll(Seting.ORIGINAL_ADDRESSES);         return nodes;     }       /**Возвращяет действующий блокчейн*/     public static Blockchain getBlockchain() {         return blockchain;     }      public static synchronized void setBlockchain(Blockchain blockchain) {         BasisController.blockchain = blockchain;     }       static {         try {             blockchain = BLockchainFactory.getBlockchain(BlockchainFactoryEnum.ORIGINAL);         } catch (NoSuchAlgorithmException e) {             throw new RuntimeException(e);         } catch (InvalidKeySpecException e) {             throw new RuntimeException(e);         } catch (IOException e) {             throw new RuntimeException(e);         } catch (SignatureException e) {             throw new RuntimeException(e);         } catch (NoSuchProviderException e) {             throw new RuntimeException(e);         } catch (InvalidKeyException e) {             throw new RuntimeException(e);         }     }       public BasisController() {     }      //TODO если вы прервали mine, то перед следующим вызовом перезапустите сервер и вызовите /addBlock перед mine     //TODO if you interrupted mine, restart the server before next call and call /addBlock before mine     //TODO иначе будет расождение в файле балансов     //TODO otherwise there will be a discrepancy in the balance file        /**Стартует добычу, начинает майнинг*/     @GetMapping(\"/mine\")     public synchronized String mine(Model model) throws NoSuchAlgorithmException, InvalidKeySpecException, IOException, SignatureException, NoSuchProviderException, InvalidKeyException, JSONException, CloneNotSupportedException {         String text = \"\";         //нахождение адрессов         findAddresses();         sendAddress();          //собирает класс список балансов из файла расположенного по пути Seting.ORIGINAL_BALANCE_FILE         Map<String, Account> balances = SaveBalances.readLineObject(Seting.ORIGINAL_BALANCE_FILE);         //собирает объект блокчейн из файла         blockchain = Mining.getBlockchain(                 Seting.ORIGINAL_BLOCKCHAIN_FILE,                 BlockchainFactoryEnum.ORIGINAL);          //если блокчейн работает то продолжить         if (!blockchain.validatedBlockchain()) {             text = \"wrong chain: неправильный блокчейн, добыча прекращена\";             model.addAttribute(\"text\", text);             return \"wrong blockchain\";         }          //Прежде чем добыть новый блок сначала в сети ищет самый длинный блокчейн         resolve_conflicts();          //если размер блокчейна меньше или равно единице, сохранить в файл генезис блок         long index = blockchain.sizeBlockhain();         if (blockchain.sizeBlockhain() <= 1) {             //сохранение генезис блока             if (blockchain.sizeBlockhain() == 1) {                 UtilsBlock.saveBLock(blockchain.getBlock(0), Seting.ORIGINAL_BLOCKCHAIN_FILE);             }              //получить список балансов из файла             balances = Mining.getBalances(Seting.ORIGINAL_BALANCE_FILE, blockchain, balances);             //удалить старые файлы баланса             Mining.deleteFiles(Seting.ORIGINAL_BALANCE_FILE);             //сохранить балансы             SaveBalances.saveBalances(balances, Seting.ORIGINAL_BALANCE_FILE);          }         //скачать список балансов из файла         balances = SaveBalances.readLineObject(Seting.ORIGINAL_BALANCE_FILE);          //получить счет майнера         Account miner = balances.get(User.getUserAddress());         if (miner == null) {             //если в блокчейне не было баланса, то баланс равен нулю             miner = new Account(User.getUserAddress(), 0, 0);         }          //транзакции которые мы добавили в блок и теперь нужно удалить из файла, в папке resources/transactions         List<DtoTransaction> temporaryDtoList = AllTransactions.getInstance();          //раз в три для очищяет файлы в папке resources/sendedTransaction данная папка         //хранит уже добавленые в блокчейн транзации, чтобы повторно не добавлять в         //в блок уже добавленные транзакции         AllTransactions.clearAllSendedTransaction(index);         AllTransactions.clearUsedTransaction(AllTransactions.getInsanceSended());         System.out.println(\"BasisController: start mine:\");          //Сам процесс Майнинга         //DIFFICULTY_ADJUSTMENT_INTERVAL как часто происходит коррекция         //BLOCK_GENERATION_INTERVAL как часто должен находить блок         //temporaryDtoList добавляет транзакции в блок         Block block = Mining.miningDay(                 miner,                 blockchain,                 Seting.BLOCK_GENERATION_INTERVAL,                 Seting.DIFFICULTY_ADJUSTMENT_INTERVAL,                 temporaryDtoList,                 balances,                 index         );         System.out.println(\"BasisController: finish mine:\");         //save sended transaction         //сохранить уже добавленные в блок транзакции,         //чтобы избежать повторного добавления         AllTransactions.addSendedTransaction(temporaryDtoList);          //нужна для корректировки сложности         int diff = Seting.DIFFICULTY_ADJUSTMENT_INTERVAL;         //Тестирование блока         List<Block> testingValidationsBlock = null;          if (blockchain.sizeBlockhain() > diff) {              testingValidationsBlock = blockchain.subBlock(blockchain.sizeBlockhain() - diff, blockchain.sizeBlockhain());         } else {             testingValidationsBlock = blockchain.clone();         }         //проверяет последние 288 блоков на валидность.         if (testingValidationsBlock.size() > 1) {             boolean validationTesting = UtilsBlock.validationOneBlock(                     blockchain.genesisBlock().getFounderAddress(),                     testingValidationsBlock.get(testingValidationsBlock.size() - 1),                     block,                     Seting.BLOCK_GENERATION_INTERVAL,                     diff,                     testingValidationsBlock);              if (validationTesting == false) {                 System.out.println(\"wrong validation block: \" + validationTesting);                 System.out.println(\"index block: \" + block.getIndex());                 text = \"wrong validation\";             }             testingValidationsBlock.add(block.clone());         }          //добавляет последний блок в блокчейн         blockchain.addBlock(block);         //сохраняет последний блок в файл         UtilsBlock.saveBLock(block, Seting.ORIGINAL_BLOCKCHAIN_FILE);          //перерасчет балансов, подсчитывает какие изменения произошли в балансах         balances = Mining.getBalances(Seting.ORIGINAL_BALANCE_FILE, blockchain, balances);         Mining.deleteFiles(Seting.ORIGINAL_BALANCE_FILE);         //сохраняет в файл уже заново посчитанные балансы.         SaveBalances.saveBalances(balances, Seting.ORIGINAL_BALANCE_FILE);          //получает все созданные когда либо законы         Map<String, Laws> allLaws = UtilsLaws.getLaws(blockchain.getBlockchainList(), Seting.ORIGINAL_ALL_CORPORATION_LAWS_FILE);          //возвращает все законы с голосами проголосовавшими за них         List<LawEligibleForParliamentaryApproval> allLawsWithBalance = UtilsLaws.getCurrentLaws(allLaws, balances, Seting.ORIGINAL_ALL_CORPORATION_LAWS_WITH_BALANCE_FILE);         //удаление устаревних законов         Mining.deleteFiles(Seting.ORIGINAL_ALL_CORPORATION_LAWS_WITH_BALANCE_FILE);         //записывает все законы в файл с их голосами.         UtilsLaws.saveCurrentsLaws(allLawsWithBalance, Seting.ORIGINAL_ALL_CORPORATION_LAWS_WITH_BALANCE_FILE);          //отправляет блокчейн во внешние сервера         sendAllBlocksToStorage(blockchain.getBlockchainList());          text = \"success: блок успешно добыт\";         model.addAttribute(\"text\", text);         return \"redirect:/mining\";      }       /**Возвращает EntityChain который хранит в себе размер блокчейна и список блоков*/     @GetMapping(\"/chain\")     @ResponseBody     public EntityChain full_chain() throws IOException, NoSuchAlgorithmException, InvalidKeySpecException, SignatureException, NoSuchProviderException, InvalidKeyException {         blockchain = Mining.getBlockchain(                 Seting.ORIGINAL_BLOCKCHAIN_FILE,                 BlockchainFactoryEnum.ORIGINAL);         return new EntityChain(blockchain.sizeBlockhain(), blockchain.getBlockchainList());     }      /**возвращяет размер локального блокчейна*/     @GetMapping(\"/size\")     @ResponseBody     public Integer sizeBlockchain() throws IOException, NoSuchAlgorithmException, InvalidKeySpecException, SignatureException, NoSuchProviderException, InvalidKeyException {         blockchain = Mining.getBlockchain(                 Seting.ORIGINAL_BLOCKCHAIN_FILE,                 BlockchainFactoryEnum.ORIGINAL);         return blockchain.sizeBlockhain();     }       /**Возвращает список блоков ОТ до ДО,*/     @PostMapping(\"/sub-blocks\")     @ResponseBody     public List<Block> subBlocks(@RequestBody SubBlockchainEntity entity) throws IOException, NoSuchAlgorithmException, InvalidKeySpecException, SignatureException, NoSuchProviderException, InvalidKeyException {         blockchain = Mining.getBlockchain(                 Seting.ORIGINAL_BLOCKCHAIN_FILE,                 BlockchainFactoryEnum.ORIGINAL);         return blockchain.getBlockchainList().subList(entity.getStart(), entity.getFinish());     }      /**Возвращяет блок по индексу*/     @PostMapping(\"/block\")     @ResponseBody     public Block getBlock(@RequestBody Integer index) throws IOException, NoSuchAlgorithmException, InvalidKeySpecException, SignatureException, NoSuchProviderException, InvalidKeyException {         blockchain = Mining.getBlockchain(                 Seting.ORIGINAL_BLOCKCHAIN_FILE,                 BlockchainFactoryEnum.ORIGINAL);         return blockchain.getBlock(index);     }      //TODO нужно чтобы передавался каждый раз не весь блокчейн а часть, как реализованно в биткоин     //TODO is necessary so that not the entire blockchain is transmitted each time, but a part, as implemented in bitcoin     //TODO need to optimization because now not best      @RequestMapping(\"/resolving\")     public String resolving() throws JSONException, NoSuchAlgorithmException, InvalidKeySpecException, IOException, SignatureException, NoSuchProviderException, InvalidKeyException {         resolve_conflicts();         return \"redirect:/\";     }     /**соединяется к внешним хостам, и скачивает самый длинный блокчейн,      * если, локальный блокчейн, меньше других */     @GetMapping(\"/nodes/resolve\")     public synchronized void resolve_conflicts() throws NoSuchAlgorithmException, InvalidKeySpecException, IOException, SignatureException, NoSuchProviderException, InvalidKeyException, JSONException {         Blockchain temporaryBlockchain = BLockchainFactory.getBlockchain(BlockchainFactoryEnum.ORIGINAL);         Blockchain bigBlockchain = BLockchainFactory.getBlockchain(BlockchainFactoryEnum.ORIGINAL);         blockchain = Mining.getBlockchain(                 Seting.ORIGINAL_BLOCKCHAIN_FILE,                 BlockchainFactoryEnum.ORIGINAL);         int blocks_current_size = blockchain.sizeBlockhain();         long hashCountZeroTemporary = 0;         long hashCountZeroBigBlockchain = 0;         EntityChain entityChain = null;          long hashCountZeroAll = 0;         //count hash start with zero all         for (Block block : blockchain.getBlockchainList()) {             hashCountZeroAll += UtilsUse.hashCount(block.getHashBlock());         }          Set<String> nodesAll = getNodes(); //        nodesAll.addAll(Seting.ORIGINAL_ADDRESSES_BLOCKCHAIN_STORAGE);         System.out.println(\"BasisController: resolve: size: \" + getNodes().size());         for (String s : nodesAll) {             System.out.println(\"BasisController: resove: address: \" + s);             String temporaryjson = null;              if (BasisController.getExcludedAddresses().contains(s)) {                 System.out.println(\"its your address or excluded address: \" + s);                 continue;             }             try {                 if(s.contains(\"localhost\") || s.contains(\"127.0.0.1\"))                     continue;                 String address = s + \"/chain\";                 System.out.println(\"BasisController:resolve conflicts: address: \" + s + \"/size\");                 String sizeStr = UtilUrl.readJsonFromUrl(s + \"/size\");                 Integer size = Integer.valueOf(sizeStr);                 if (size > blocks_current_size) {                     System.out.println(\"size from address: \" + s + \" upper than: \" + size + \":blocks_current_size \" + blocks_current_size);                     //Test start algorithm                     SubBlockchainEntity subBlockchainEntity = new SubBlockchainEntity(blocks_current_size, size);                     String subBlockchainJson = UtilsJson.objToStringJson(subBlockchainEntity);                      List<Block> emptyList = new ArrayList<>();                       List<Block> subBlocks = UtilsJson.jsonToListBLock(UtilUrl.getObject(subBlockchainJson, s + \"/sub-blocks\"));                     emptyList.addAll(subBlocks);                     emptyList.addAll(blockchain.getBlockchainList());                      emptyList = emptyList.stream().sorted(Comparator.comparing(Block::getIndex)).collect(Collectors.toList());                     temporaryBlockchain.setBlockchainList(emptyList);                     if (!temporaryBlockchain.validatedBlockchain()) {                         System.out.println(\"first algorithm not worked\");                         emptyList = new ArrayList<>();                         emptyList.addAll(subBlocks);                         for (int i = blockchain.sizeBlockhain() - 1; i > 0; i--) {                             Block block = UtilsJson.jsonToBLock(UtilUrl.getObject(UtilsJson.objToStringJson(i), s + \"/block\"));                             if (!blockchain.getBlock(i).getHashBlock().equals(block.getHashBlock())) {                                 emptyList.add(block);                             } else {                                 emptyList.add(block);                                 emptyList.addAll(blockchain.getBlockchainList().subList(0, i));                                 emptyList = emptyList.stream().sorted(Comparator.comparing(Block::getIndex)).collect(Collectors.toList());                                 temporaryBlockchain.setBlockchainList(emptyList);                                 break;                             }                         }                     }                     if (!temporaryBlockchain.validatedBlockchain()) {                         System.out.println(\"second algorith not worked\");                         temporaryjson = UtilUrl.readJsonFromUrl(address);                         entityChain = UtilsJson.jsonToEntityChain(temporaryjson);                         temporaryBlockchain.setBlockchainList(                                 entityChain.getBlocks().stream().sorted(Comparator.comparing(Block::getIndex)).collect(Collectors.toList()));                     }                 } else {                     System.out.println(\"BasisController: resove: size less: \" + size + \" address: \" + address);                     continue;                 }             } catch (IOException e) {                 e.printStackTrace();                 System.out.println(\"BasisController: resolve_conflicts: Error: \" + s);                 continue;             }               if (temporaryBlockchain.validatedBlockchain()) {                 for (Block block : temporaryBlockchain.getBlockchainList()) {                     hashCountZeroTemporary += UtilsUse.hashCount(block.getHashBlock());                 }                  if (blocks_current_size < temporaryBlockchain.sizeBlockhain() && hashCountZeroAll < hashCountZeroTemporary) {                     blocks_current_size = temporaryBlockchain.sizeBlockhain();                     bigBlockchain = temporaryBlockchain;                     hashCountZeroBigBlockchain = hashCountZeroTemporary;                 }                 hashCountZeroTemporary = 0;             }          }           if (bigBlockchain.sizeBlockhain() > blockchain.sizeBlockhain() && hashCountZeroBigBlockchain > hashCountZeroAll) {              blockchain = bigBlockchain;             UtilsBlock.deleteFiles();             addBlock(bigBlockchain.getBlockchainList(), BLockchainFactory.getBlockchain(BlockchainFactoryEnum.ORIGINAL));             System.out.println(\"BasisController: resolve: bigblockchain size: \" + bigBlockchain.sizeBlockhain());          }      }       /**      * Перезаписывает весь список блоков, и делает перерасчет баланса, а также других данных      * таких как голоса, совет акционеров и т.д. заново записывает в файлы      */      public static void addBlock(List<Block> orignalBlocks, Blockchain blockchain) throws IOException, NoSuchAlgorithmException, SignatureException, InvalidKeySpecException, NoSuchProviderException, InvalidKeyException {          Map<String, Account> balances = new HashMap<>();         Blockchain temporaryForValidation = BLockchainFactory.getBlockchain(BlockchainFactoryEnum.ORIGINAL);         temporaryForValidation.setBlockchainList(orignalBlocks);         UtilsBlock.deleteFiles();         System.out.println(\"addBlock start\");         for (Block block : orignalBlocks) {             UtilsBlock.saveBLock(block, Seting.ORIGINAL_BLOCKCHAIN_FILE);         }          blockchain = Mining.getBlockchain(                 Seting.ORIGINAL_BLOCKCHAIN_FILE,                 BlockchainFactoryEnum.ORIGINAL);          //перерасчет после добычи         balances = UtilsBalance.calculateBalances(blockchain.getBlockchainList());         Mining.deleteFiles(Seting.ORIGINAL_BALANCE_FILE);         SaveBalances.saveBalances(balances, Seting.ORIGINAL_BALANCE_FILE);           //получение и отображение законов, а также сохранение новых законов         //и изменение действующих законов         Map<String, Laws> allLaws = UtilsLaws.getLaws(blockchain.getBlockchainList(), Seting.ORIGINAL_ALL_CORPORATION_LAWS_FILE);           //возвращает все законы с балансом         List<LawEligibleForParliamentaryApproval> allLawsWithBalance = UtilsLaws.getCurrentLaws(allLaws, balances, Seting.ORIGINAL_ALL_CORPORATION_LAWS_WITH_BALANCE_FILE);         //удаление устаревних законов         Mining.deleteFiles(Seting.ORIGINAL_ALL_CORPORATION_LAWS_WITH_BALANCE_FILE);         UtilsLaws.saveCurrentsLaws(allLawsWithBalance, Seting.ORIGINAL_ALL_CORPORATION_LAWS_WITH_BALANCE_FILE);          System.out.println(\"BasisController: addBlock: finish\");     }      /**Регистрирует новый внешний хост*/     @RequestMapping(method = RequestMethod.POST, value = \"/nodes/register\", consumes = MediaType.APPLICATION_JSON_VALUE)     public synchronized void register_node(@RequestBody AddressUrl urlAddrress) throws IOException, NoSuchAlgorithmException, InvalidKeySpecException, SignatureException, NoSuchProviderException, InvalidKeyException {           for (String s : BasisController.getNodes()) {             String original = s;             String url = s + \"/nodes/register\";              try {                 UtilUrl.sendPost(urlAddrress.getAddress(), url);                 sendAddress();               } catch (Exception e) {                 System.out.println(\"BasisController: register node: wrong node: \" + original);                 BasisController.getNodes().remove(original);                 continue;             }         }          Set<String> nodes = BasisController.getNodes();         nodes = nodes.stream()                 .map(t -> t.replaceAll(\"\\\"\", \"\"))                 .map(t -> t.replaceAll(\"\\\\\\\\\", \"\"))                 .collect(Collectors.toSet());         nodes.add(urlAddrress.getAddress());         BasisController.setNodes(nodes);          Mining.deleteFiles(Seting.ORIGINAL_POOL_URL_ADDRESS_FILE);         nodes.stream().forEach(t -> {             try {                 UtilsAllAddresses.saveAllAddresses(t, Seting.ORIGINAL_POOL_URL_ADDRESS_FILE);             } catch (IOException e) {                 throw new RuntimeException(e);             } catch (NoSuchAlgorithmException e) {                 throw new RuntimeException(e);             } catch (SignatureException e) {                 throw new RuntimeException(e);             } catch (InvalidKeySpecException e) {                 throw new RuntimeException(e);             } catch (NoSuchProviderException e) {                 throw new RuntimeException(e);             } catch (InvalidKeyException e) {                 throw new RuntimeException(e);             }         });      }      //TODO если происходить майнинг, то он возвращает false, пока не прекратиться майнинг.     //TODO if mining occurs, it returns false until mining stops.     /** выззывает метод addBlock который перезаписывает весь список блоков, и другие данные*/     @GetMapping(\"/addBlock\")     public boolean getBLock() throws IOException, NoSuchAlgorithmException, InvalidKeySpecException, SignatureException, NoSuchProviderException, InvalidKeyException {         blockchain = Mining.getBlockchain(                 Seting.ORIGINAL_BLOCKCHAIN_FILE,                 BlockchainFactoryEnum.ORIGINAL);         UtilsBlock.deleteFiles();         addBlock(blockchain.getBlockchainList(), BLockchainFactory.getBlockchain(BlockchainFactoryEnum.ORIGINAL));         return true;     }      /**Возвращяет список хостов, сохраненных на локальном сервере*/     @GetMapping(\"/getNodes\")     public Set<String> getAllNodes() throws IOException, NoSuchAlgorithmException, InvalidKeySpecException, SignatureException, NoSuchProviderException, InvalidKeyException {         Set<String> temporary = UtilsAllAddresses.readLineObject(Seting.ORIGINAL_POOL_URL_ADDRESS_FILE);         nodes.addAll(temporary);         nodes.addAll(Seting.ORIGINAL_ADDRESSES);         nodes = nodes.stream().filter(t -> t.startsWith(\"\\\"\"))                 .collect(Collectors.toSet());         return nodes;     }      /**подключается к другим узлам и у них берет их списки хостов, которые храняться у них,      *  и сохраняет эти списки у себя*/     @GetMapping(\"/findAddresses\")     public void findAddresses() throws IOException, NoSuchAlgorithmException, InvalidKeySpecException, SignatureException, NoSuchProviderException, InvalidKeyException {         for (String s : Seting.ORIGINAL_ADDRESSES) {             Set<String> addressesSet = new HashSet<>();             try {                 String addresses = UtilUrl.readJsonFromUrl(s + \"/getDiscoveryAddresses\");                 addressesSet = UtilsJson.jsonToSetAddresses(addresses);             } catch (IOException e) {                 System.out.println(\"BasisController: findAddress: error\");                 continue;             } catch (JSONException e) {                 throw new RuntimeException(e);             }              for (String s1 : addressesSet) {                  register_node(new AddressUrl(s1));             }          }      }      /**Запускает автоматический цикл майнинга, цикл будет идти 2000 шагов*/     @GetMapping(\"/moreMining\")     public void moreMining() throws JSONException, IOException {         for (int i = 1; i < 2000; i++) {             System.out.println(\"block generate i: \" + i);             UtilUrl.readJsonFromUrl(\"http://localhost:8082/mine\");           }     }       /**Отправляет свой список хостов, другим узлам, и пытается автоматически регистрировать у них*/     public static void sendAddress() throws IOException, NoSuchAlgorithmException, InvalidKeySpecException, SignatureException, NoSuchProviderException, InvalidKeyException {         //лист временный для отправки аддресов          for (String s : Seting.ORIGINAL_ADDRESSES) {              String original = s;             String url = s + \"/nodes/register\";              if (BasisController.getExcludedAddresses().contains(url)) {                 System.out.println(\"MainController: its your address or excluded address: \" + url);                 continue;             }             try {                 for (String s1 : BasisController.getNodes()) {                       AddressUrl addressUrl = new AddressUrl(s1);                     String json = UtilsJson.objToStringJson(addressUrl);                     UtilUrl.sendPost(json, url);                 }             } catch (Exception e) {                 System.out.println(\"BasisController: sendAddress: wronge node: \" + original);                  continue;             }           }     }      //должен отправлять блокчейн в хранилище блокчейна     /**Отправляет список блоков в центральные хранилища (пример: http://194.87.236.238:80)*/     public static void sendAllBlocksToStorage(List<Block> blocks) throws IOException, NoSuchAlgorithmException, InvalidKeySpecException, SignatureException, NoSuchProviderException, InvalidKeyException {         String jsonDto;         System.out.println(\"BasisController: sendAllBlocksToStorage: start: \");         try {             jsonDto = UtilsJson.objToStringJson(blocks);         } catch (IOException e) {             throw new RuntimeException(e);         }         int blocks_current_size = blocks.size();         //отправка блокчейна на хранилище блокчейна         System.out.println(\"BasisController: sendAllBlocksToStorage: \");         getNodes().stream().forEach(System.out::println);         for (String s : getNodes()) {               if (BasisController.getExcludedAddresses().contains(s)) {                 System.out.println(\"its your address or excluded address: \" + s);                 continue;             }              try {                 System.out.println(\"BasisController:resolve conflicts: address: \" + s + \"/size\");                 String sizeStr = UtilUrl.readJsonFromUrl(s + \"/size\");                 Integer size =  0;                 if(Integer.valueOf(sizeStr) > 0)                     size = Integer.valueOf(sizeStr);                 System.out.println(\"BasisController: send size: \" + size);                 List<Block> fromToTempBlock = blocks.subList(size, blocks.size());                 String jsonFromTo = UtilsJson.objToStringJson(fromToTempBlock);                 //если блокчейн текущей больше чем в хранилище, то                 //отправить текущий блокчейн отправить в хранилище                 if (size < blocks_current_size) {                     int response = 0;                     //Test start algorithm                     String originalF = s;                     String urlFrom = s + \"/nodes/resolve_from_to_block\";                     try {                         response = UtilUrl.sendPost(jsonFromTo, urlFrom);                     }catch (Exception e){                         System.out.println(\"exception discover: \" + originalF);                         continue;                     }                      System.out.println(\"BasisController: sendAllBlocksStorage: response: \" + response);                      if(response != 0){                         System.out.println(\"BasisController: sendAllBlocks: need change all: \" + response);                         //Test start algorithm                         String original = s;                         String url = s + \"/nodes/resolve_all_blocks\";                         try {                             UtilUrl.sendPost(jsonDto, url);                          }catch (Exception e){                             System.out.println(\"exception discover: \" + original);                             continue;                          }                     }                  }              } catch (JSONException e) {                 e.printStackTrace();                 continue;              } catch (IOException e) {                 e.printStackTrace();                 continue;             }          }      } }","package International_Trade_Union.controllers;  import International_Trade_Union.config.BlockchainFactoryEnum; import International_Trade_Union.entity.blockchain.Blockchain; import International_Trade_Union.model.Mining; import International_Trade_Union.setings.Seting; import org.springframework.web.bind.annotation.GetMapping; import org.springframework.web.bind.annotation.RestController;  import java.io.IOException; import java.security.InvalidKeyException; import java.security.NoSuchAlgorithmException; import java.security.NoSuchProviderException; import java.security.SignatureException; import java.security.spec.InvalidKeySpecException;  @RestController public class BlockchainCheckController {      //TODO во время майнинга, если майнинг не остановлен, он почему то возвращает false, но после остановки true. Нужно исправить.     //TODO during mining, if mining is not stopped, for some reason it returns false, but after stopping it returns true. Need to fix.     //TODO worked after restart server, get true.     //TODO ошибка возникает если прервать mine,     //TODO error occurs if mine is interrupted,      /**Проверяет целостность блокчейна*/     @GetMapping(\"/checkValidation\")     public boolean checkValidation() throws IOException, NoSuchAlgorithmException, SignatureException, InvalidKeySpecException, NoSuchProviderException, InvalidKeyException {         try{             Blockchain blockchain = Mining.getBlockchain(                     Seting.ORIGINAL_BLOCKCHAIN_FILE,                     BlockchainFactoryEnum.ORIGINAL);             System.out.println(\"BlockchainCheckController: checkValidation: size: \" + blockchain.sizeBlockhain());             boolean check = blockchain.validatedBlockchain();             System.out.println(\"check: \" + check);             return check;}         catch (IOException e){             e.printStackTrace();             return false;         }     } }","package International_Trade_Union.controllers;  import International_Trade_Union.config.BlockchainFactoryEnum; import International_Trade_Union.entity.blockchain.Blockchain; import International_Trade_Union.governments.UtilsGovernment; import International_Trade_Union.model.Mining; import International_Trade_Union.utils.SaveBalances; import org.springframework.stereotype.Controller; import org.springframework.ui.Model; import org.springframework.web.bind.annotation.GetMapping; import International_Trade_Union.model.Account; import International_Trade_Union.setings.Seting;  import java.io.IOException; import java.security.InvalidKeyException; import java.security.NoSuchAlgorithmException; import java.security.NoSuchProviderException; import java.security.SignatureException; import java.security.spec.InvalidKeySpecException; import java.util.ArrayList; import java.util.HashMap; import java.util.List; import java.util.Map; import java.util.stream.Collectors;  @Controller public class BoardOfShareholdersController {      /**отображает список Совета Акционеров, отображается в браузере*/     @GetMapping(\"board-of-shareholders\")     public String boardOfShareHolders(Model model) throws NoSuchAlgorithmException, InvalidKeySpecException, IOException, SignatureException, NoSuchProviderException, InvalidKeyException {          Blockchain blockchain = Mining.getBlockchain(                 Seting.ORIGINAL_BLOCKCHAIN_FILE,                 BlockchainFactoryEnum.ORIGINAL);          //Получение баланса         Map<String, Account> balances = new HashMap<>();          balances = SaveBalances.readLineObject(Seting.ORIGINAL_BALANCE_FILE);         List<Account> boardOfShareholders = new ArrayList<>();          boardOfShareholders = UtilsGovernment.findBoardOfShareholders(balances, blockchain.getBlockchainList(), Seting.BOARDS_BLOCK);           model.addAttribute(\"title\", \"Совет акционеров количество: \" + boardOfShareholders.size());         model.addAttribute(\"boardOfShareholders\", boardOfShareholders);         return \"board-of-shareholders\";     }   }","package International_Trade_Union.controllers;  import International_Trade_Union.originalCorporateCharter.OriginalCHARTER; import International_Trade_Union.originalCorporateCharter.OriginalPreamble; import org.springframework.stereotype.Controller; import org.springframework.ui.Model; import org.springframework.web.bind.annotation.GetMapping;  import java.io.IOException; import java.security.InvalidKeyException; import java.security.NoSuchAlgorithmException; import java.security.NoSuchProviderException; import java.security.SignatureException; import java.security.spec.InvalidKeySpecException; import java.util.ArrayList; import java.util.List;  @Controller public class ConstitutionController {      /**Отображает устав в браузере*/     @GetMapping(\"corporate-charter\")     public String constutionRus(Model model) throws NoSuchAlgorithmException, InvalidKeySpecException, IOException, SignatureException, NoSuchProviderException, InvalidKeyException {          model.addAttribute(\"title\", \"corporate charter-корпоративный устав\");         List<String> rus = charterRusList();         List<String> eng = charterEngList();               model.addAttribute(\"rus\", rus);         model.addAttribute(\"eng\", eng);         return \"corporate-charter\";     }      public static String charterRus (){         String string = \"\";         for (String s : charterRusList()) {             string = s + \"\\n\";         }         return string;     }      public static String charterEng(){         String string = \"\";         for (String s : charterEngList()) {             string = s + \"\\n\";         }         return string;     }       public static List<String> charterRusList(){         List<String> rus = new ArrayList<>();           rus.add(\"OriginalPreamble.ARTICLE_0\\n\"+ OriginalPreamble.ARTICLE_0);         rus.add(\"OriginalCHARTER.POWERS_OF_THE_BOARD_OF_DIRECTORS:\\n\"+ OriginalCHARTER.POWERS_OF_THE_BOARD_OF_DIRECTORS);         rus.add(\"OriginalCHARTER.HOW_LAWS_ARE_CHOSEN:\\n\"+ OriginalCHARTER.HOW_LAWS_ARE_CHOSEN);         rus.add(\"OriginalCHARTER.HOW_THE_BOARD_OF_DIRECTORS_IS_ELECTED:\\n\"+ OriginalCHARTER.HOW_THE_BOARD_OF_DIRECTORS_IS_ELECTED);         rus.add(\"OriginalCHARTER.POWERS_OF_THE_BOARD_OF_SHAREHOLDERS:\\n\"+ OriginalCHARTER.POWERS_OF_THE_BOARD_OF_SHAREHOLDERS);         rus.add(\"OriginalCHARTER.HOW_SHAREHOLDERS_BOARD_IS_ELECTED:\\n\"+ OriginalCHARTER.HOW_SHAREHOLDERS_BOARD_IS_ELECTED);         rus.add(\"OriginalCHARTER.VOTE_STOCK:\\n\"+ OriginalCHARTER.VOTE_STOCK);         rus.add(\"OriginalCHARTER.CODE_VOTE_STOCK:\\n\"+ OriginalCHARTER.CODE_VOTE_STOCK);         rus.add(\"OriginalCHARTER.POWERS_OF_DIRECTORS_IN_THE_OFFICE:\\n\"+ OriginalCHARTER.POWERS_OF_THE_CABINET_OF_DIRECTORS);         rus.add(\"OriginalCHARTER.HOW_OFFICE_DIRECTORS_ARE_CHOSEN:\\n\"+ OriginalCHARTER.HOW_CABINET_DIRECTORS_ARE_CHOSEN);         rus.add(\"OriginalCHARTER.ONE_VOTE:\\n\"+ OriginalCHARTER.ONE_VOTE);         rus.add(\"OriginalCHARTER.CODE_VOTE_ONE:\\n\"+ OriginalCHARTER.CODE_VOTE_ONE);         rus.add(\"OriginalCHARTER.MECHANISM_FOR_REDUCING_THE_NUMBER_OF_SHARES:\\n\"+ OriginalCHARTER.MECHANISM_FOR_REDUCING_THE_NUMBER_OF_SHARES);         rus.add(\"OriginalCHARTER.WHO_HAS_THE_RIGHT_TO_CREATE_LAWS:\\n\"+ OriginalCHARTER.WHO_HAS_THE_RIGHT_TO_CREATE_LAWS);         rus.add(\"OriginalCHARTER.POWERS_OF_THE_CORPORATE_COUNCIL_OF_JUDGES:\\n\"+ OriginalCHARTER.POWERS_OF_THE_CORPORATE_COUNCIL_OF_JUDGES);         rus.add(\"OriginalCHARTER.HOW_THE_CORPORATE_BOARD_OF_JUDGES_IS_ELECTED:\\n\"+ OriginalCHARTER.HOW_THE_CORPORATE_BOARD_OF_JUDGES_IS_ELECTED);         rus.add(\"OriginalCHARTER.HOW_THE_CHIEF_JUDGE_IS_CHOSEN:\\n\"+ OriginalCHARTER.HOW_THE_CHIEF_JUDGE_IS_CHOSEN);         rus.add(\"OriginalCHARTER.POWERS_OF_THE_CHIEF_JUDGE:\\n\"+ OriginalCHARTER.POWERS_OF_THE_CHIEF_JUDGE);         rus.add(\"OriginalCHARTER.HOW_IS_THE_PROCESS_OF_AMENDING_THE_CHARTER:\\n\"+ OriginalCHARTER.HOW_IS_THE_PROCESS_OF_AMENDING_THE_CHARTER);         rus.add(\"OriginalCHARTER.HOW_THE_BUDGET_IS_APPROVED:\\n\"+ OriginalCHARTER.HOW_THE_BUDGET_IS_APPROVED);         rus.add(\"OriginalCHARTER.HOW_IS_THE_STRATEGIC:\\n\"+ OriginalCHARTER.HOW_IS_THE_STRATEGIC);         rus.add(\"OriginalCHARTER.HOW_NEW_POSITIONS_ARE_ADDED:\\n\"+ OriginalCHARTER.HOW_NEW_POSITIONS_ARE_ADDED);         rus.add(\"OriginalCHARTER.PROPERTY_OF_THE_CORPORATION:\\n\"+ OriginalCHARTER.PROPERTY_OF_THE_CORPORATION);         rus.add(\"OriginalCHARTER.INTERNET_STORE_DIRECTOR:\\n\"+ OriginalCHARTER.INTERNET_STORE_DIRECTOR);         rus.add(\"OriginalCHARTER.GENERAL_EXECUTIVE_DIRECTOR:\\n\"+ OriginalCHARTER.GENERAL_EXECUTIVE_DIRECTOR);         rus.add(\"OriginalCHARTER.DIRECTOR_OF_THE_DIGITAL_EXCHANGE:\\n\"+ OriginalCHARTER.DIRECTOR_OF_THE_DIGITAL_EXCHANGE);         rus.add(\"OriginalCHARTER.DIRECTOR_OF_DIGITAL_BANK:\\n\"+ OriginalCHARTER.DIRECTOR_OF_DIGITAL_BANK);         rus.add(\"OriginalCHARTER.DIRECTOR_OF_THE_COMMERCIAL_COURT:\\n\"+ OriginalCHARTER.DIRECTOR_OF_THE_COMMERCIAL_COURT);         rus.add(\"OriginalCHARTER.MEDIA_DIRECTOR:\\n\"+ OriginalCHARTER.MEDIA_DIRECTOR);         rus.add(\"OriginalCHARTER.DIRECTOR_OF_THE_DEVELOPMENT_OF_THE_IMPLEMENTATION_OF_CRYPTOCURRENCY_TECHNOLOGIES_OF_THE_INTERNATIONAL_TRADE_UNION_CORPORATION:\\n\"+ OriginalCHARTER.DIRECTOR_OF_THE_DEVELOPMENT_OF_THE_IMPLEMENTATION_OF_CRYPTOCURRENCY_TECHNOLOGIES_OF_THE_INTERNATIONAL_TRADE_UNION_CORPORATION);         rus.add(\"OriginalCHARTER.EXPLANATION_WHY_MONEY_DEMURAGE_IS_USED_HERE:\\n\"+ OriginalCHARTER.EXPLANATION_WHY_MONEY_DEMURAGE_IS_USED_HERE);         rus.add(\"OriginalCHARTER.FREEDOM_OF_SPEECH:\\n\"+ OriginalCHARTER.FREEDOM_OF_SPEECH);         rus.add(\"OriginalCHARTER.RIGHTS:\\n\"+ OriginalCHARTER.RIGHTS);         return rus;     }       public static List<String> charterEngList(){         List<String> eng = new ArrayList<>();         eng.add(\"OriginalPreamble.ARTICLE_0\\n\"+ OriginalPreamble.ARTICLE_0);         eng.add(\"OriginalCHARTER.POWERS_OF_THE_BOARD_OF_DIRECTORS:\\n\"+ OriginalCHARTER.POWERS_OF_THE_BOARD_OF_DIRECTORS);         eng.add(\"OriginalCHARTER.HOW_LAWS_ARE_CHOSEN:\\n\"+ OriginalCHARTER.HOW_LAWS_ARE_CHOSEN);         eng.add(\"OriginalCHARTER.HOW_THE_BOARD_OF_DIRECTORS_IS_ELECTED:\\n\"+ OriginalCHARTER.HOW_THE_BOARD_OF_DIRECTORS_IS_ELECTED);         eng.add(\"OriginalCHARTER.POWERS_OF_THE_BOARD_OF_SHAREHOLDERS:\\n\"+ OriginalCHARTER.POWERS_OF_THE_BOARD_OF_SHAREHOLDERS);         eng.add(\"OriginalCHARTER.HOW_SHAREHOLDERS_BOARD_IS_ELECTED:\\n\"+ OriginalCHARTER.HOW_SHAREHOLDERS_BOARD_IS_ELECTED);         eng.add(\"OriginalCHARTER.VOTE_STOCK:\\n\"+ OriginalCHARTER.VOTE_STOCK);         eng.add(\"OriginalCHARTER.CODE_VOTE_STOCK:\\n\"+ OriginalCHARTER.CODE_VOTE_STOCK);         eng.add(\"OriginalCHARTER.POWERS_OF_DIRECTORS_IN_THE_OFFICE:\\n\"+ OriginalCHARTER.POWERS_OF_THE_CABINET_OF_DIRECTORS);         eng.add(\"OriginalCHARTER.HOW_OFFICE_DIRECTORS_ARE_CHOSEN:\\n\"+ OriginalCHARTER.HOW_CABINET_DIRECTORS_ARE_CHOSEN);         eng.add(\"OriginalCHARTER.ONE_VOTE:\\n\"+ OriginalCHARTER.ONE_VOTE);         eng.add(\"OriginalCHARTER.CODE_VOTE_ONE:\\n\"+ OriginalCHARTER.CODE_VOTE_ONE);         eng.add(\"OriginalCHARTER.MECHANISM_FOR_REDUCING_THE_NUMBER_OF_SHARES:\\n\"+ OriginalCHARTER.MECHANISM_FOR_REDUCING_THE_NUMBER_OF_SHARES);         eng.add(\"OriginalCHARTER.WHO_HAS_THE_RIGHT_TO_CREATE_LAWS:\\n\"+ OriginalCHARTER.WHO_HAS_THE_RIGHT_TO_CREATE_LAWS);         eng.add(\"OriginalCHARTER.POWERS_OF_THE_CORPORATE_COUNCIL_OF_JUDGES:\\n\"+ OriginalCHARTER.POWERS_OF_THE_CORPORATE_COUNCIL_OF_JUDGES);         eng.add(\"OriginalCHARTER.HOW_THE_CORPORATE_BOARD_OF_JUDGES_IS_ELECTED:\\n\"+ OriginalCHARTER.HOW_THE_CORPORATE_BOARD_OF_JUDGES_IS_ELECTED);         eng.add(\"OriginalCHARTER.HOW_THE_CHIEF_JUDGE_IS_CHOSEN:\\n\"+ OriginalCHARTER.HOW_THE_CHIEF_JUDGE_IS_CHOSEN);         eng.add(\"OriginalCHARTER.POWERS_OF_THE_CHIEF_JUDGE:\\n\"+ OriginalCHARTER.POWERS_OF_THE_CHIEF_JUDGE);         eng.add(\"OriginalCHARTER.HOW_IS_THE_PROCESS_OF_AMENDING_THE_CHARTER:\\n\"+ OriginalCHARTER.HOW_IS_THE_PROCESS_OF_AMENDING_THE_CHARTER);         eng.add(\"OriginalCHARTER.HOW_THE_BUDGET_IS_APPROVED:\\n\"+ OriginalCHARTER.HOW_THE_BUDGET_IS_APPROVED);         eng.add(\"OriginalCHARTER.HOW_IS_THE_STRATEGIC:\\n\"+ OriginalCHARTER.HOW_IS_THE_STRATEGIC);         eng.add(\"OriginalCHARTER.HOW_NEW_POSITIONS_ARE_ADDED:\\n\"+ OriginalCHARTER.HOW_NEW_POSITIONS_ARE_ADDED);         eng.add(\"OriginalCHARTER.PROPERTY_OF_THE_CORPORATION:\\n\"+ OriginalCHARTER.PROPERTY_OF_THE_CORPORATION);         eng.add(\"OriginalCHARTER.INTERNET_STORE_DIRECTOR:\\n\"+ OriginalCHARTER.INTERNET_STORE_DIRECTOR);         eng.add(\"OriginalCHARTER.GENERAL_EXECUTIVE_DIRECTOR:\\n\"+ OriginalCHARTER.GENERAL_EXECUTIVE_DIRECTOR);         eng.add(\"OriginalCHARTER.DIRECTOR_OF_THE_DIGITAL_EXCHANGE:\\n\"+ OriginalCHARTER.DIRECTOR_OF_THE_DIGITAL_EXCHANGE);         eng.add(\"OriginalCHARTER.DIRECTOR_OF_DIGITAL_BANK:\\n\"+ OriginalCHARTER.DIRECTOR_OF_DIGITAL_BANK);         eng.add(\"OriginalCHARTER.DIRECTOR_OF_THE_COMMERCIAL_COURT:\\n\"+ OriginalCHARTER.DIRECTOR_OF_THE_COMMERCIAL_COURT);         eng.add(\"OriginalCHARTER.MEDIA_DIRECTOR:\\n\"+ OriginalCHARTER.MEDIA_DIRECTOR);         eng.add(\"OriginalCHARTER.DIRECTOR_OF_THE_DEVELOPMENT_OF_THE_IMPLEMENTATION_OF_CRYPTOCURRENCY_TECHNOLOGIES_OF_THE_INTERNATIONAL_TRADE_UNION_CORPORATION:\\n\"+ OriginalCHARTER.DIRECTOR_OF_THE_DEVELOPMENT_OF_THE_IMPLEMENTATION_OF_CRYPTOCURRENCY_TECHNOLOGIES_OF_THE_INTERNATIONAL_TRADE_UNION_CORPORATION);         eng.add(\"OriginalCHARTER.EXPLANATION_WHY_MONEY_DEMURAGE_IS_USED_HERE:\\n\"+ OriginalCHARTER.EXPLANATION_WHY_MONEY_DEMURAGE_IS_USED_HERE);         eng.add(\"OriginalCHARTER.FREEDOM_OF_SPEECH:\\n\"+ OriginalCHARTER.FREEDOM_OF_SPEECH);         eng.add(\"OriginalCHARTER.RIGHTS:\\n\"+ OriginalCHARTER.RIGHTS);           return eng;     } }","package International_Trade_Union.controllers;  import org.springframework.stereotype.Controller; import org.springframework.ui.Model; import org.springframework.web.bind.annotation.GetMapping; import org.springframework.web.bind.annotation.PostMapping; import org.springframework.web.servlet.mvc.support.RedirectAttributes; import International_Trade_Union.model.CreateAccount;  import java.security.InvalidAlgorithmParameterException; import java.security.NoSuchAlgorithmException; import java.security.NoSuchProviderException; import java.security.spec.InvalidKeySpecException; import java.util.Map;  @Controller public class CreateAccountController {       /**Позвалояет создавать счет, отображается в браузере*/     @GetMapping(\"create-account\")     public String createAccount(Model model) throws InvalidAlgorithmParameterException, NoSuchAlgorithmException, InvalidKeySpecException, NoSuchProviderException {         model.addAttribute(\"title\", \"create minerAccount\");         Map<String, String> newAccount = CreateAccount.create();          model.addAttribute(\"login\", newAccount.get(\"pubKey\"));         model.addAttribute(\"password\", newAccount.get(\"privKey\"));         return \"create-account\";     }       @PostMapping(\"create-account\")     public String createNewAccount(RedirectAttributes redirectAttrs) throws InvalidAlgorithmParameterException, NoSuchAlgorithmException, InvalidKeySpecException, NoSuchProviderException {         redirectAttrs.addFlashAttribute(\"title\", \"create minerAccount\");         Map<String, String> newAccount = CreateAccount.create();          redirectAttrs.addFlashAttribute(\"login\", newAccount.get(\"pubKey\"));         redirectAttrs.addFlashAttribute(\"password\", newAccount.get(\"privKey\"));          return \"redirect:/create-account\";     }  //    @PostMapping(\"save-creating-minerAccount\") //    public String saveNewAccount(Model model, @RequestParam String changeAddress){ //        User.setUserAddress(changeAddress); //        return \"redirect:/\"; //    }    }","package International_Trade_Union.controllers;  import International_Trade_Union.config.BlockchainFactoryEnum; import International_Trade_Union.entity.DtoTransaction.DtoTransaction; import International_Trade_Union.entity.blockchain.Blockchain; import International_Trade_Union.governments.Director; import International_Trade_Union.governments.Directors; import International_Trade_Union.governments.NamePOSITION; import International_Trade_Union.model.FIndPositonHelperData; import International_Trade_Union.model.Mining; import International_Trade_Union.network.AllTransactions; import International_Trade_Union.utils.base.Base; import International_Trade_Union.utils.base.Base58; import org.springframework.stereotype.Controller; import org.springframework.ui.Model; import org.springframework.web.bind.annotation.GetMapping; import International_Trade_Union.governments.UtilsGovernment; import International_Trade_Union.model.Account; import International_Trade_Union.setings.Seting; import International_Trade_Union.utils.*; import International_Trade_Union.vote.*; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RequestMethod; import org.springframework.web.bind.annotation.RequestParam; import org.springframework.web.servlet.mvc.support.RedirectAttributes;  import java.io.IOException; import java.security.*; import java.security.spec.InvalidKeySpecException; import java.util.*; import java.util.stream.Collectors;  @Controller public class GovernmentController {      //TODO если происходит майнинг почему то происходят ошибки, и если вызвать данный метод, то может     //TODO прерываться сам процесс майнинга     //TODO if mining occurs for some reason, errors are observed, and this method appears, then it can     //TODO interrupt the mining process itself      /**Отображает в браузере список действующих должностей*/     @GetMapping(\"/governments\")     public String corporateSeniorpositions(Model model) throws NoSuchAlgorithmException, InvalidKeySpecException, IOException, SignatureException, NoSuchProviderException, InvalidKeyException {         Blockchain blockchain = Mining.getBlockchain(                 Seting.ORIGINAL_BLOCKCHAIN_FILE,                 BlockchainFactoryEnum.ORIGINAL);          //за сколько времени занимает подсчет         Date start = new Date();         //Получение баланса         Map<String, Account> balances = new HashMap<>();          balances = SaveBalances.readLineObject(Seting.ORIGINAL_BALANCE_FILE);          //Нахождение должности         List<LawEligibleForParliamentaryApproval> allGovernment =                 UtilsLaws.readLineCurrentLaws(Seting.ORIGINAL_ALL_CORPORATION_LAWS_WITH_BALANCE_FILE);          //список должностей         Map<Director, List<LawEligibleForParliamentaryApproval>> positionsListMap = new HashMap<>();          Directors directors = new Directors();         //добавление всех должностей         for (Director higherSpecialPositions : directors.getDirectors()) {             positionsListMap.put(higherSpecialPositions, UtilsLaws.getPossions(allGovernment, higherSpecialPositions));         }          //список акционеров         List<Account> BoardOfShareholders = UtilsGovernment.findBoardOfShareholders(balances, blockchain.getBlockchainList(), Seting.BOARDS_BLOCK);          //список законов с голосами         Map<String, List<CurrentLawVotesEndBalance>> curentLawVotesEndBalance = new HashMap<>();          //TODO доработать оптимизацию         //TODO избавиться от find position в данном методе         Map<Director, FIndPositonHelperData> fIndPositonHelperDataMap = new HashMap<>();         for (Director higherSpecialPositions : directors.getDirectors()) {             if(higherSpecialPositions.isElectedByCEO()){                 fIndPositonHelperDataMap.put(higherSpecialPositions,                         new FIndPositonHelperData(higherSpecialPositions, false, false, true, false, false));             }             else if(higherSpecialPositions.isElectedByBoardOfDirectors()){                 fIndPositonHelperDataMap.put(higherSpecialPositions,                         new FIndPositonHelperData(higherSpecialPositions, false, false, false, true, false));             }             else if(higherSpecialPositions.isElectedByCorporateCouncilOfReferees()){                 fIndPositonHelperDataMap.put(higherSpecialPositions,                         new FIndPositonHelperData(higherSpecialPositions, false, false, false, false, true));             }             else {                 fIndPositonHelperDataMap.put(higherSpecialPositions,                         new FIndPositonHelperData(higherSpecialPositions, true, true, false ,false, false));              }          }          List<CurrentLawVotesEndBalance> current = UtilsGovernment.filtersVotes(                 allGovernment,                 balances,                 BoardOfShareholders,                 blockchain.getBlockchainList(),                 Seting.LAW_YEAR_VOTE);            //минимальное значение количество положительных голосов для того чтобы закон действовал,         //позиции избираемые акциями в совет директоров         List<CurrentLawVotesEndBalance> electedByStockBoardOfDirectors = current.stream()                 .filter(t -> directors.isElectedByStocks(t.getPackageName()))                 .filter(t -> t.getPackageName().equals(NamePOSITION.BOARD_OF_DIRECTORS.toString()))                 .filter(t -> t.getVotes() >= Seting.ORIGINAL_LIMIT_MIN_VOTE)                 .sorted(Comparator.comparing(CurrentLawVotesEndBalance::getVotes).reversed())                 .limit(directors.getDirector(NamePOSITION.BOARD_OF_DIRECTORS.toString()).getCount())                 .collect(Collectors.toList());           //минимальное значение количество положительных голосов для того чтобы закон действовал,         //позиции избираемые акциями electedByStockCorporateCouncilOfReferees         List<CurrentLawVotesEndBalance> electedByStockCorporateCouncilOfReferees = current.stream()                 .filter(t -> directors.isElectedByStocks(t.getPackageName()))                 .filter(t -> t.getPackageName().equals(NamePOSITION.CORPORATE_COUNCIL_OF_REFEREES.toString()))                 .filter(t -> t.getVotes() >= Seting.ORIGINAL_LIMIT_MIN_VOTE)                 .sorted(Comparator.comparing(CurrentLawVotesEndBalance::getVotes).reversed())                 .limit(directors.getDirector(NamePOSITION.CORPORATE_COUNCIL_OF_REFEREES.toString()).getCount())                 .collect(Collectors.toList());            //позиции созданные советом директоров         List<CurrentLawVotesEndBalance> createdByBoardOfDirectors = current.stream()                 .filter(t->t.getPackageName().startsWith(Seting.ADD_DIRECTOR))                 .filter(t->t.getVotesBoardOfDirectors() >= Seting.ORIGINAL_LIMIT_MIN_VOTE_BOARD_OF_DIRECTORS)                 .collect(Collectors.toList());         //добавление позиций созданных советом директоров         for (CurrentLawVotesEndBalance currentLawVotesEndBalance : createdByBoardOfDirectors) {             directors.addAllByBoardOfDirectors(currentLawVotesEndBalance.getLaws());         }          //позиции избираемые  только советом директоров в кабинет директоров         List<CurrentLawVotesEndBalance> electedByBoardOfDirectors = current.stream()                 .filter(t -> directors.isElectedByBoardOfDirectors(t.getPackageName()))                 .filter(t -> t.getVotesBoardOfDirectors() >= Seting.ORIGINAL_LIMIT_MIN_VOTE_BOARD_OF_DIRECTORS)                 .sorted(Comparator.comparing(CurrentLawVotesEndBalance::getVotesBoardOfDirectors).reversed())                 .collect(Collectors.toList());          List<CurrentLawVotesEndBalance> addDirectors = current.stream()                         .filter(t->directors.isCabinets(t.getPackageName()))                                 .filter(t->t.getVotesBoardOfDirectors() >= Seting.ORIGINAL_LIMIT_MIN_VOTE_BOARD_OF_DIRECTORS)                                         .collect(Collectors.toList());          System.out.println(\"***************************************\");         System.out.println(\"GovernmentController: corporateSeniorpositions: elected by Board of Directors;\");         electedByBoardOfDirectors.stream().forEach(System.out::println);         System.out.println(\"***************************************\");          //групируем по списку         Map<String, List<CurrentLawVotesEndBalance>> group = electedByBoardOfDirectors.stream()                 .collect(Collectors.groupingBy(CurrentLawVotesEndBalance::getPackageName));          Map<Director, List<CurrentLawVotesEndBalance>> original_group = new HashMap<>();          //оставляем то количество которое описано в данной должности         for (Map.Entry<String, List<CurrentLawVotesEndBalance>> stringListEntry : group.entrySet()) {             List<CurrentLawVotesEndBalance> temporary = stringListEntry.getValue();             temporary = temporary.stream()                     .sorted(Comparator.comparing(CurrentLawVotesEndBalance::getVotesBoardOfDirectors))                     .limit(directors.getDirector(stringListEntry.getKey()).getCount())                     .collect(Collectors.toList());             original_group.put(directors.getDirector(stringListEntry.getKey()), temporary);         }          //позиции избираемые палатой верховных судей         List<CurrentLawVotesEndBalance> electedByChamberOfSupremeJudges = current.stream()                 .filter(t -> directors.isElectedBYCorporateCouncilOfReferees(t.getPackageName()))                 .filter(t -> t.getVotesCorporateCouncilOfReferees() >= Seting.ORIGINAL_LIMIT_MIN_VOTE_CORPORATE_COUNCIL_OF_REFEREES)                 .sorted(Comparator.comparing(CurrentLawVotesEndBalance::getVotesCorporateCouncilOfReferees)).collect(Collectors.toList());            //избираемые премьер министром         List<CurrentLawVotesEndBalance> GENERAL_EXECUTIVE_DIRECTOR = electedByBoardOfDirectors.stream()                 .filter(t -> directors.isElectedCEO(t.getPackageName()))                 .filter(t -> NamePOSITION.GENERAL_EXECUTIVE_DIRECTOR.toString().equals(t.getPackageName()))                 .filter(t -> t.getVoteGeneralExecutiveDirector() >= Seting.ORIGINAL_LIMIT_MIN_VOTE_GENERAL_EXECUTIVE_DIRECTOR)                 .sorted(Comparator.comparing(CurrentLawVotesEndBalance::getVoteGeneralExecutiveDirector))                 .collect(Collectors.toList());          //избираемые верховным судьей         List<CurrentLawVotesEndBalance> electedByHightJudge = electedByChamberOfSupremeJudges.stream()                 .filter(t -> directors.isElectedBYCorporateCouncilOfReferees(t.getPackageName()))                 .filter(t -> t.getVoteHightJudge() >= Seting.ORIGINAL_LIMIT_MIN_VOTE_HIGHT_JUDGE)                 .collect(Collectors.toList());          curentLawVotesEndBalance.put(\"elected by GENERAL_EXECUTIVE_DIRECTOR: \", GENERAL_EXECUTIVE_DIRECTOR);         curentLawVotesEndBalance.put(\"elected by hight judge: \", electedByHightJudge);         curentLawVotesEndBalance.put(NamePOSITION.BOARD_OF_DIRECTORS.toString(), electedByStockBoardOfDirectors);         curentLawVotesEndBalance.put(NamePOSITION.CORPORATE_COUNCIL_OF_REFEREES.toString(), electedByStockCorporateCouncilOfReferees);         curentLawVotesEndBalance.put(NamePOSITION.HIGH_JUDGE.toString(), electedByChamberOfSupremeJudges);          for (Map.Entry<Director, List<CurrentLawVotesEndBalance>> higherSpecialPositionsListMap : original_group.entrySet()) {             curentLawVotesEndBalance.put(higherSpecialPositionsListMap.getKey().toString(), higherSpecialPositionsListMap.getValue());         }           Date finish = new Date();         System.out.println(\"given time: \" + new Date(finish.getTime() - start.getTime()));          model.addAttribute(\"show\", curentLawVotesEndBalance);          model.addAttribute(\"title\", \"current guidance\");          return \"/governments\";     }      @GetMapping(\"/create-position\")     public String createPositionShow(Model model) throws IOException, NoSuchAlgorithmException, InvalidKeySpecException, SignatureException, NoSuchProviderException, InvalidKeyException {         Blockchain blockchain = Mining.getBlockchain(                 Seting.ORIGINAL_BLOCKCHAIN_FILE,                 BlockchainFactoryEnum.ORIGINAL);         Map<String, Account> balances = new HashMap<>();         //считывать баланс         balances = SaveBalances.readLineObject(Seting.ORIGINAL_BALANCE_FILE);          Directors directors = new Directors();          List<LawEligibleForParliamentaryApproval> lawEligibleForParliamentaryApprovals =                 UtilsLaws.readLineCurrentLaws(Seting.ORIGINAL_ALL_CORPORATION_LAWS_WITH_BALANCE_FILE);           List<Account> boardOfShareholders = UtilsGovernment.findBoardOfShareholders(balances, blockchain.getBlockchainList(), Seting.BOARDS_BLOCK);          List<CurrentLawVotesEndBalance> current = UtilsGovernment.filtersVotes(                 lawEligibleForParliamentaryApprovals,                 balances,                 boardOfShareholders,                 blockchain.getBlockchainList(),                 Seting.LAW_YEAR_VOTE);           List<String> positions = directors.getDirectors().stream().map(t->t.getName()).collect(Collectors.toList());         //позиции созданные советом директоров          List<CurrentLawVotesEndBalance> createdByBoardOfDirectors = current.stream()                 .filter(t->t.getPackageName().startsWith(Seting.ADD_DIRECTOR))                 .filter(t->t.getVotesBoardOfDirectors() >= Seting.ORIGINAL_LIMIT_MIN_VOTE_BOARD_OF_DIRECTORS)                 .collect(Collectors.toList());         //добавление позиций созданных советом директоров         for (CurrentLawVotesEndBalance currentLawVotesEndBalance : createdByBoardOfDirectors) {             directors.addAllByBoardOfDirectors(currentLawVotesEndBalance.getLaws());         }           positions.addAll(directors.getNames());         positions = positions.stream().distinct().collect(Collectors.toList());         model.addAttribute(\"positions\", positions);         return \"create-position\";     }      /**Отображается в браузере, позволяет создавать новые должности*/     @RequestMapping(value = \"/create-position\", method = RequestMethod.POST, params = \"action=/send\")     public String createLaw(Model model,                             @RequestParam String sender,                             @RequestParam String reward,                             @RequestParam String nameLaw,                             @RequestParam String[] laws,                             @RequestParam String password,                             RedirectAttributes redirectAttrs) throws IOException, NoSuchAlgorithmException, SignatureException, NoSuchProviderException, InvalidKeyException, InvalidKeySpecException {           Laws law = new Laws(nameLaw, Arrays.asList(laws));         Base base = new Base58();          Double rewardD = Double.parseDouble(reward);           DtoTransaction dtoTransaction = new DtoTransaction(                 sender,                 law.getHashLaw(),                 0.0,                 0.0,                 law,                 rewardD,                 VoteEnum.valueOf(\"YES\"));         PrivateKey privateKey = UtilsSecurity.privateBytToPrivateKey(base.decode(password));         byte[] sign = UtilsSecurity.sign(privateKey, dtoTransaction.toSign());          redirectAttrs.addFlashAttribute(\"title\", \"sending result!!!\");         redirectAttrs.addFlashAttribute(\"sender\", sender);          redirectAttrs.addFlashAttribute(\"recipient\", law.getHashLaw());         redirectAttrs.addFlashAttribute(\"dollar\", 0.0);         redirectAttrs.addFlashAttribute(\"stock\", 0.0);         redirectAttrs.addFlashAttribute(\"reward\", rewardD);         redirectAttrs.addFlashAttribute(\"vote\", \"YES\");         dtoTransaction.setSign(sign);          if (dtoTransaction.verify() && UtilsGovernment.checkPostionSenderEqualsLaw(sender, law)) {             redirectAttrs.addFlashAttribute(\"sending\", \"success\");             AllTransactions.addTransaction(dtoTransaction);             String jsonDto = UtilsJson.objToStringJson(dtoTransaction);              for (String s : Seting.ORIGINAL_ADDRESSES) {                 String original = s;                 String url = s + \"/addTransaction\";                 if (BasisController.getExcludedAddresses().contains(url)) {                     System.out.println(\"its your address or excluded address: \" + url);                     continue;                 }                 try {                     UtilUrl.sendPost(jsonDto, url);                  } catch (Exception e) {                     System.out.println(\"exception discovery: \" + original);                  }             }         } else             redirectAttrs.addFlashAttribute(\"sending\", \"wrong transaction\");          return \"redirect:/result-sending\";      } }","package International_Trade_Union.controllers;  import International_Trade_Union.config.BLockchainFactory; import International_Trade_Union.config.BlockchainFactoryEnum; import International_Trade_Union.entity.blockchain.Blockchain; import International_Trade_Union.entity.blockchain.block.Block; import International_Trade_Union.governments.Director; import International_Trade_Union.governments.Directors; import International_Trade_Union.governments.NamePOSITION; import International_Trade_Union.model.FIndPositonHelperData; import International_Trade_Union.model.Mining; import org.springframework.stereotype.Controller; import org.springframework.ui.Model; import org.springframework.web.bind.annotation.*; import org.springframework.web.servlet.mvc.support.RedirectAttributes; import International_Trade_Union.entity.DtoTransaction.DtoTransaction; import International_Trade_Union.governments.UtilsGovernment; import International_Trade_Union.model.Account; import International_Trade_Union.network.AllTransactions; import International_Trade_Union.setings.Seting; import International_Trade_Union.utils.*; import International_Trade_Union.utils.base.Base; import International_Trade_Union.utils.base.Base58; import International_Trade_Union.vote.*;  import java.io.IOException; import java.security.*; import java.security.spec.InvalidKeySpecException; import java.util.*; import java.util.stream.Collectors;   @Controller public class LawsController {       @GetMapping(\"detail-laws\")     public String details(Model model) {         return \"detail-laws\";     }      //TODO реализовать голосвание       /**Отображается в браузере, позволяет увидеть содержимое пакета законов, список действующих законов*/     @GetMapping(\"/detail-laws-current/{addressLaw}\")     public String lawsDetail(@PathVariable(value = \"addressLaw\") String addressLaw, RedirectAttributes redirectAttrs) throws NoSuchAlgorithmException, InvalidKeySpecException, IOException, SignatureException, NoSuchProviderException, InvalidKeyException {         System.out.println(\"LawsController detail-laws-current/{addressLaw}: \" + addressLaw);         redirectAttrs.addAttribute(\"title\", \"detail laws\");         //Seting.ORIGINAL_CURRENT_FEDERAL_LAWS_FILE         List<LawEligibleForParliamentaryApproval> lawEligibleForParliamentaryApprovals =                 UtilsLaws.readLineCurrentLaws(Seting.ORIGINAL_ALL_CORPORATION_LAWS_WITH_BALANCE_FILE);          List<String> currntLaws = new ArrayList<>();         for (LawEligibleForParliamentaryApproval lawEligibleForParliamentaryApproval : lawEligibleForParliamentaryApprovals) {             int i = 0;             if (lawEligibleForParliamentaryApproval.getLaws().getHashLaw().equals(addressLaw)) {                  for (String str : lawEligibleForParliamentaryApproval.getLaws().getLaws()) {                      currntLaws.add(\"\" + i + \": \" + str);                     ++i;                 }              }         }          currntLaws.forEach(System.out::println);         redirectAttrs.addFlashAttribute(\"laws\", currntLaws);         return \"redirect:/detail-laws\";     }      /**Отображается в браузере, показывает содержимое пакета законов, из  списка всех законов*/     @GetMapping(\"/detail-laws-all/{addressLaw}\")     public String lawsDetailAll(@PathVariable(value = \"addressLaw\") String addressLaw, RedirectAttributes redirectAttrs) throws NoSuchAlgorithmException, InvalidKeySpecException, IOException, SignatureException, NoSuchProviderException, InvalidKeyException {         System.out.println(\"LawsController /detail-laws-all/{addressLaw}: \" + addressLaw);         redirectAttrs.addAttribute(\"title\", \"detail laws\");         //ORIGINAL_ALL_CORPORATION_LAWS_FILE         List<Laws> laws = UtilsLaws.readLineLaws(Seting.ORIGINAL_ALL_CORPORATION_LAWS_FILE);         List<String> allLaws = new ArrayList<>();         for (Laws laws1 : laws) {             int i = 0;             if (laws1.getHashLaw().equals(addressLaw)) {                  for (String s : laws1.getLaws()) {                     allLaws.add(\"\" + i + \": \" + s);                     ++i;                 }              }         }          redirectAttrs.addFlashAttribute(\"laws\", allLaws);         return \"redirect:/detail-laws\";     }       @GetMapping(\"/sanction\")     public String sanction(Model model){         return \"/sanction\";     }      @PostMapping(\"/sanction\")     public String sanction(             @RequestParam             String sender,             String recipient,             Double stock,             Double reward,             String password,             RedirectAttributes redirectAttrs      ) throws IOException, NoSuchAlgorithmException, SignatureException, InvalidKeySpecException, NoSuchProviderException, InvalidKeyException {         Base base = new Base58();          Laws laws =  new Laws();         laws.setLaws(new ArrayList<>());         laws.setHashLaw(\"\");         laws.setPacketLawName(\"\");         DtoTransaction dtoTransaction = new DtoTransaction(                 sender,                 recipient,                 0.0,                 stock,                 laws,                 reward,                 VoteEnum.NO);         PrivateKey privateKey = UtilsSecurity.privateBytToPrivateKey(base.decode(password));         byte[] sign = UtilsSecurity.sign(privateKey, dtoTransaction.toSign());         System.out.println(\"Main Controller: new transaction: vote: \" + VoteEnum.NO);         redirectAttrs.addFlashAttribute(\"title\", \"sending result!!!\");         redirectAttrs.addFlashAttribute(\"sender\", sender);         redirectAttrs.addFlashAttribute(\"recipient\", recipient);         redirectAttrs.addFlashAttribute(\"dollar\", 0.0);         redirectAttrs.addFlashAttribute(\"stock\", stock);         redirectAttrs.addFlashAttribute(\"reward\", reward);         redirectAttrs.addFlashAttribute(\"vote\", VoteEnum.NO);         dtoTransaction.setSign(sign);         Directors directors = new Directors();         if(dtoTransaction.verify()){              //если в названия закона совпадает с корпоративными должностями, то закон является действительным только когда             //отправитель совпадает с законом             List<String> corporateSeniorPositions = directors.getDirectors().stream()                     .map(t->t.getName()).collect(Collectors.toList());             System.out.println(\"LawsController: create_law: \" + laws.getPacketLawName() + \"contains: \" + corporateSeniorPositions.contains(laws.getPacketLawName()));             if(corporateSeniorPositions.contains(laws.getPacketLawName()) && !UtilsGovernment.checkPostionSenderEqualsLaw(sender, laws)){                 redirectAttrs.addFlashAttribute(\"sending\", \"wrong transaction: Position to be equals whith send\");                 return \"redirect:/result-sending\";             }             redirectAttrs.addFlashAttribute(\"sending\", \"success\");             System.out.println(\"dto MainController: \" + dtoTransaction);              AllTransactions.addTransaction(dtoTransaction);             String jsonDto = UtilsJson.objToStringJson(dtoTransaction);             for (String s : Seting.ORIGINAL_ADDRESSES) {                  String original = s;                 String url = s +\"/addTransaction\";                 //если адресс совпадает с внутреним хостом, то не отправляет самому себе                 if(BasisController.getExcludedAddresses().contains(url)){                     System.out.println(\"MainController: its your address or excluded address: \" + url);                     continue;                 }                 try {                     //отправка в сеть                     UtilUrl.sendPost(jsonDto, url);                  }catch (Exception e){                     System.out.println(\"exception discover: \" + original);                  }             }            }          else             redirectAttrs.addFlashAttribute(\"sending\", \"wrong transaction\");         return \"redirect:/result-sending\";     }     /**Голосование учитывает голоса как акций, так и голоса избраных представителей*/     @GetMapping(\"/voting\")     public String lawVoting(){         return \"/voting\";     }     @PostMapping(\"/voting\")     public String lawVoting(             @RequestParam             String sender,             String recipient,             Double reward,             String vote,             String password,             RedirectAttributes redirectAttrs      ) throws IOException, NoSuchAlgorithmException, SignatureException, InvalidKeySpecException, NoSuchProviderException, InvalidKeyException {         Base base = new Base58();         vote = vote.toUpperCase(Locale.ROOT);         Laws laws =  new Laws();         laws.setLaws(new ArrayList<>());         laws.setHashLaw(\"\");         laws.setPacketLawName(\"\");         System.out.println(\"LawController: Voting: \" + VoteEnum.valueOf(vote));         DtoTransaction dtoTransaction = new DtoTransaction(                 sender,                 recipient,                 0.0,                 0.0,                 laws,                 reward,                 VoteEnum.valueOf(vote));         PrivateKey privateKey = UtilsSecurity.privateBytToPrivateKey(base.decode(password));         byte[] sign = UtilsSecurity.sign(privateKey, dtoTransaction.toSign());         System.out.println(\"Main Controller: new transaction: vote: \" + vote);         redirectAttrs.addFlashAttribute(\"title\", \"sending result!!!\");         redirectAttrs.addFlashAttribute(\"sender\", sender);         redirectAttrs.addFlashAttribute(\"recipient\", recipient);         redirectAttrs.addFlashAttribute(\"dollar\", 0.0);         redirectAttrs.addFlashAttribute(\"stock\", 0.0);         redirectAttrs.addFlashAttribute(\"reward\", reward);         redirectAttrs.addFlashAttribute(\"vote\", vote);         dtoTransaction.setSign(sign);         Directors directors = new Directors();         if(dtoTransaction.verify()){              //если в названия закона совпадает с корпоративными должностями, то закон является действительным только когда             //отправитель совпадает с законом             List<String> corporateSeniorPositions = directors.getDirectors().stream()                     .map(t->t.getName()).collect(Collectors.toList());             System.out.println(\"LawsController: create_law: \" + laws.getPacketLawName() + \"contains: \" + corporateSeniorPositions.contains(laws.getPacketLawName()));             if(corporateSeniorPositions.contains(laws.getPacketLawName()) && !UtilsGovernment.checkPostionSenderEqualsLaw(sender, laws)){                 redirectAttrs.addFlashAttribute(\"sending\", \"wrong transaction: Position to be equals whith send\");                 return \"redirect:/result-sending\";             }             redirectAttrs.addFlashAttribute(\"sending\", \"success\");             System.out.println(\"dto MainController: \" + dtoTransaction);              AllTransactions.addTransaction(dtoTransaction);             String jsonDto = UtilsJson.objToStringJson(dtoTransaction);             for (String s : Seting.ORIGINAL_ADDRESSES) {                  String original = s;                 String url = s +\"/addTransaction\";                 //если адресс совпадает с внутреним хостом, то не отправляет самому себе                 if(BasisController.getExcludedAddresses().contains(url)){                     System.out.println(\"MainController: its your address or excluded address: \" + url);                     continue;                 }                 try {                     //отправка в сеть                     UtilUrl.sendPost(jsonDto, url);                  }catch (Exception e){                     System.out.println(\"exception discover: \" + original);                  }             }            }          else             redirectAttrs.addFlashAttribute(\"sending\", \"wrong transaction\");         return \"redirect:/result-sending\";     }     /**Отображается в браузере, список все действующих законов*/     @GetMapping(\"/current-laws\")     public String currentLaw(Model model) throws IOException, NoSuchAlgorithmException, InvalidKeySpecException, SignatureException, NoSuchProviderException, InvalidKeyException, CloneNotSupportedException {         Directors directors = new Directors();         Blockchain blockchain = Mining.getBlockchain(                 Seting.ORIGINAL_BLOCKCHAIN_FILE,                 BlockchainFactoryEnum.ORIGINAL);          Map<String, Account> balances = new HashMap<>();         //считывать баланс         balances = SaveBalances.readLineObject(Seting.ORIGINAL_BALANCE_FILE);          List<LawEligibleForParliamentaryApproval> lawEligibleForParliamentaryApprovals =                 UtilsLaws.readLineCurrentLaws(Seting.ORIGINAL_ALL_CORPORATION_LAWS_WITH_BALANCE_FILE);          //получить совет акционеров из файла         List<Account> boardOfShareholders = UtilsGovernment.findBoardOfShareholders(balances, blockchain.getBlockchainList(), Seting.BOARDS_BLOCK);           //TODO доработать оптимизацию         //TODO избавиться от find position в данном методе         //отфильтровать по типам голосов         Map<Director, FIndPositonHelperData> fIndPositonHelperDataMap = new HashMap<>();         for (Director higherSpecialPositions : directors.getDirectors()) {             if (higherSpecialPositions.isElectedByCEO()) {                 fIndPositonHelperDataMap.put(higherSpecialPositions,                         new FIndPositonHelperData(higherSpecialPositions, false, false, true, false, false));             } else if (higherSpecialPositions.isElectedByBoardOfDirectors()) {                 fIndPositonHelperDataMap.put(higherSpecialPositions,                         new FIndPositonHelperData(higherSpecialPositions, false, false, false, true, false));             } else if (higherSpecialPositions.isElectedByCorporateCouncilOfReferees()) {                 fIndPositonHelperDataMap.put(higherSpecialPositions,                         new FIndPositonHelperData(higherSpecialPositions, false, false, false, false, true));             } else {                 fIndPositonHelperDataMap.put(higherSpecialPositions,                         new FIndPositonHelperData(higherSpecialPositions, true, true, false, false, false));              }          }         //подсчитать голоса за все проголосованные заканы         List<CurrentLawVotesEndBalance> current = UtilsGovernment.filtersVotes(                 lawEligibleForParliamentaryApprovals,                 balances,                 boardOfShareholders,                 blockchain.getBlockchainList(),                 Seting.LAW_YEAR_VOTE);             //минимальное значение количество положительных голосов для того чтобы закон действовал,         //позиции избираемые акциями совета директоров         List<CurrentLawVotesEndBalance> electedByStockBoardOfDirectors = current.stream()                 .filter(t -> directors.isElectedByStocks(t.getPackageName()))                 .filter(t -> t.getPackageName().equals(NamePOSITION.BOARD_OF_DIRECTORS.toString()))                 .filter(t -> t.getVotes() >= Seting.ORIGINAL_LIMIT_MIN_VOTE)                 .sorted(Comparator.comparing(CurrentLawVotesEndBalance::getVotes).reversed())                 .limit(directors.getDirector(NamePOSITION.BOARD_OF_DIRECTORS.toString()).getCount())                 .collect(Collectors.toList());           //минимальное значение количество положительных голосов для того чтобы закон действовал,         //позиции избираемые акциями CORPORATE_COUNCIL_OF_REFEREES         List<CurrentLawVotesEndBalance> electedByStockCorporateCouncilOfReferees = current.stream()                 .filter(t -> directors.isElectedByStocks(t.getPackageName()))                 .filter(t -> t.getPackageName().equals(NamePOSITION.CORPORATE_COUNCIL_OF_REFEREES.toString()))                 .filter(t -> t.getVotes() >= Seting.ORIGINAL_LIMIT_MIN_VOTE)                 .sorted(Comparator.comparing(CurrentLawVotesEndBalance::getVotes).reversed())                 .limit(directors.getDirector(NamePOSITION.CORPORATE_COUNCIL_OF_REFEREES.toString()).getCount())                 .collect(Collectors.toList());            //позиции созданные советом директоров         List<CurrentLawVotesEndBalance> createdByBoardOfDirectors = current.stream()                 .filter(t->t.getPackageName().startsWith(Seting.ADD_DIRECTOR))                 .filter(t->t.getVotesBoardOfDirectors() >= Seting.ORIGINAL_LIMIT_MIN_VOTE_BOARD_OF_DIRECTORS)                 .collect(Collectors.toList());         //добавление позиций созданных советом директоров         for (CurrentLawVotesEndBalance currentLawVotesEndBalance : createdByBoardOfDirectors) {             directors.addAllByBoardOfDirectors(currentLawVotesEndBalance.getLaws());         }          //позиции избираемые только советом директоров         List<CurrentLawVotesEndBalance> electedByBoardOfDirectors = current.stream()                 .filter(t -> directors.isElectedByBoardOfDirectors(t.getPackageName()) || directors.isCabinets(t.getPackageName()))                 .filter(t -> t.getVotesBoardOfDirectors() >= Seting.ORIGINAL_LIMIT_MIN_VOTE_BOARD_OF_DIRECTORS)                 .sorted(Comparator.comparing(CurrentLawVotesEndBalance::getVotesBoardOfDirectors).reversed())                 .collect(Collectors.toList());           //групируем по списку         Map<String, List<CurrentLawVotesEndBalance>> group = electedByBoardOfDirectors.stream()                 .collect(Collectors.groupingBy(CurrentLawVotesEndBalance::getPackageName));          Map<Director, List<CurrentLawVotesEndBalance>> original_group = new HashMap<>();          //оставляем то количество которое описано в данной должности         for (Map.Entry<String, List<CurrentLawVotesEndBalance>> stringListEntry : group.entrySet()) {             List<CurrentLawVotesEndBalance> temporary = stringListEntry.getValue();             temporary = temporary.stream()                     .sorted(Comparator.comparing(CurrentLawVotesEndBalance::getVotesBoardOfDirectors))                     .limit(directors.getDirector(stringListEntry.getKey()).getCount())                     .collect(Collectors.toList());             original_group.put(directors.getDirector(stringListEntry.getKey()), temporary);         }            //позиции избираемые советом корпоративных верховных судей         List<CurrentLawVotesEndBalance> electedByCorporateCouncilOfReferees = current.stream()                 .filter(t -> directors.isElectedBYCorporateCouncilOfReferees(t.getPackageName()))                 .filter(t -> t.getVotesCorporateCouncilOfReferees() >= Seting.ORIGINAL_LIMIT_MIN_VOTE_CORPORATE_COUNCIL_OF_REFEREES)                 .sorted(Comparator.comparing(CurrentLawVotesEndBalance::getVotesCorporateCouncilOfReferees)).collect(Collectors.toList());           //избираемые GENERAL_EXECUTIVE_DIRECTOR         List<CurrentLawVotesEndBalance> electedByGeneralExecutiveDirector = electedByBoardOfDirectors.stream()                 .filter(t -> directors.isElectedCEO(t.getPackageName()))                 .filter(t -> NamePOSITION.GENERAL_EXECUTIVE_DIRECTOR.toString().equals(t.getPackageName()))                 .filter(t -> t.getVoteGeneralExecutiveDirector() >= Seting.ORIGINAL_LIMIT_MIN_VOTE_GENERAL_EXECUTIVE_DIRECTOR)                 .sorted(Comparator.comparing(CurrentLawVotesEndBalance::getVoteGeneralExecutiveDirector))                 .collect(Collectors.toList());          //голос верховного судьи         List<CurrentLawVotesEndBalance> electedByHightJudge = electedByCorporateCouncilOfReferees.stream()                 .filter(t -> directors.isElectedBYCorporateCouncilOfReferees(t.getPackageName()))                 .filter(t -> t.getVoteHightJudge() >= Seting.ORIGINAL_LIMIT_MIN_VOTE_HIGHT_JUDGE)                 .collect(Collectors.toList());          //ЗАКОНЫ КОТОРЫЕ БЫЛИ ОДОБРЕНЫ ЧЕРЕЗ ПРЯМОЕ ГОЛОСОВАНИЕ         List<CurrentLawVotesEndBalance> allVotes = current.stream()                 .filter(t->!directors.contains(t.getPackageName()))                 .filter(t->!Seting.AMENDMENT_TO_THE_CHARTER.equals(t.getPackageName()))                 .filter(t->!directors.isCabinets(t.getPackageName()))                 .filter(t->!Seting.ORIGINAL_CHARTER_CURRENT_LAW_PACKAGE_NAME.equals(t.getPackageName()))                 .filter(t->!Seting.ORIGINAL_CHARTER_CURRENT_ALL_CODE.equals(t.getPackageName()))                 .filter(t->t.getVotes() > Seting.ALL_STOCK_VOTE)                 .collect(Collectors.toList());          //законы которые получили не достаточно голосов которые могут пройти только если верховный судья одобрет         List<CurrentLawVotesEndBalance> notEnoughVotes = current.stream()                 .filter(t -> !directors.contains(t.getPackageName()))                 .filter(t->!Seting.AMENDMENT_TO_THE_CHARTER.equals(t.getPackageName()))                 .filter(t->!directors.isCabinets(t.getPackageName()))                 .filter(t -> !Seting.ORIGINAL_CHARTER_CURRENT_LAW_PACKAGE_NAME.equals(t.getPackageName()))                 .filter(t->!Seting.ORIGINAL_CHARTER_CURRENT_ALL_CODE.equals(t.getPackageName()))                 .filter(t -> t.getVotesBoardOfShareholders() >= Seting.ORIGINAL_LIMIT_MIN_VOTE_BOARD_OF_SHAREHOLDERS)                 .filter(t -> t.getVotesBoardOfDirectors() >= Seting.ORIGINAL_LIMIT_MIN_VOTE_BOARD_OF_DIRECTORS)                 .filter(t -> t.getVoteHightJudge() >= Seting.ORIGINAL_LIMIT_MIN_VOTE_HIGHT_JUDGE)                 .sorted(Comparator.comparing(CurrentLawVotesEndBalance::getVotes).reversed()).collect(Collectors.toList());           //законы которые получили достаточно голосов и не требуют одобрения верховного судьи         List<CurrentLawVotesEndBalance> powerfulVotes = current.stream()                 .filter(t -> !directors.contains(t.getPackageName()))                 .filter(t-> !Seting.AMENDMENT_TO_THE_CHARTER.equals(t.getPackageName()))                 .filter(t-> !directors.isCabinets(t.getPackageName()))                 .filter(t -> !Seting.ORIGINAL_CHARTER_CURRENT_LAW_PACKAGE_NAME.equals(t.getPackageName()))                 .filter(t->!Seting.ORIGINAL_CHARTER_CURRENT_ALL_CODE.equals(t.getPackageName()))                 .filter(t -> t.getVotesBoardOfShareholders() >= (Seting.ORIGINAL_LIMIT_MIN_VOTE_BOARD_OF_SHAREHOLDERS * Seting.POWERFUL_VOTE))                 .filter(t -> t.getVotesBoardOfDirectors() >= (Seting.ORIGINAL_LIMIT_MIN_VOTE_BOARD_OF_DIRECTORS * Seting.POWERFUL_VOTE))                 .sorted(Comparator.comparing(CurrentLawVotesEndBalance::getVotes).reversed()).collect(Collectors.toList());          //удаление совпадающих голосов         notEnoughVotes.addAll(powerfulVotes);         notEnoughVotes = notEnoughVotes.stream().distinct().collect(Collectors.toList());          //внедрение поправок в устав         List<CurrentLawVotesEndBalance> chapter_amendment = current.stream()                 .filter(t -> !directors.contains(t.getPackageName()))                 .filter(t-> Seting.AMENDMENT_TO_THE_CHARTER.equals(t.getPackageName()))                 .filter(t->!directors.isCabinets(t.getPackageName()))                 .filter(t -> t.getVotesBoardOfShareholders() >= Seting.ORIGINAL_LIMIT_MINT_VOTE_BOARD_OF_SHAREHOLDERS_AMENDMENT)                 .filter(t -> t.getVotesBoardOfDirectors() >= Seting.ORIGINAL_LIMIT_MIN_VOTE_BOARD_OF_DIRECTORS_AMENDMENT)                 .filter(t -> t.getVotesCorporateCouncilOfReferees() >= Seting.ORIGINAL_LIMIT_MIN_VOTE_CORPORATE_COUNCIL_OF_REFEREES_AMENDMENT)                 .sorted(Comparator.comparing(CurrentLawVotesEndBalance::getVotesBoardOfDirectors).reversed()).collect(Collectors.toList());          //бюджет утверждается только советом директоров.         List<CurrentLawVotesEndBalance> budjet = current.stream()                 .filter(t-> !directors.contains(t.getPackageName()))                 .filter(t->Seting.BUDGET.equals(t.getPackageName()))                 .filter(t->!directors.isCabinets(t.getPackageName()))                 .filter(t-> t.getVotesBoardOfDirectors() >= Seting.ORIGINAL_LIMIT_MIN_VOTE_BOARD_OF_DIRECTORS)                 .sorted(Comparator.comparing(CurrentLawVotesEndBalance::getVotesBoardOfDirectors).reversed())                 .limit(1)                 .collect(Collectors.toList());           //добавляет законы, которые создают новые должности директоров         List<CurrentLawVotesEndBalance> addDirectors = current.stream()                 .filter(t->t.getPackageName().startsWith(Seting.ADD_DIRECTOR))                 .filter(t->t.getVotesBoardOfDirectors() >= Seting.ORIGINAL_LIMIT_MIN_VOTE_BOARD_OF_DIRECTORS)                 .collect(Collectors.toList());          //план утверждается только палатой Советом Директоров         List<CurrentLawVotesEndBalance> planFourYears = current.stream()                 .filter(t->!directors.contains(t.getPackageName()))                 .filter(t->Seting.STRATEGIC_PLAN.equals(t.getPackageName()))                 .filter(t->!directors.isCabinets(t.getPackageName()))                 .filter(t->t.getVotesBoardOfDirectors() >= Seting.ORIGINAL_LIMIT_MIN_VOTE_BOARD_OF_DIRECTORS)                 .sorted(Comparator.comparing(CurrentLawVotesEndBalance::getVotesBoardOfDirectors).reversed())                 .limit(1)                 .collect(Collectors.toList());           //устав всегда действующий он подписан основателем         List<CurrentLawVotesEndBalance> CHARTER_ORIGINAL = current.stream()                 .filter(t -> !directors.contains(t.getPackageName()) && Seting.ORIGINAL_CHARTER_CURRENT_LAW_PACKAGE_NAME.equals(t.getPackageName()))                 .filter(t->!directors.isCabinets(t.getPackageName()))                 .filter(t->t.getFounderVote()>=1)                 .sorted(Comparator.comparing(CurrentLawVotesEndBalance::getVotes).reversed())                 .limit(1)                 .collect(Collectors.toList());          //ИСХОДНЫЙ КОД СОЗДАННЫЙ ОСНОВАТЕЛЕМ         List<CurrentLawVotesEndBalance> CHARTER_ORIGINAL_CODE = current.stream()                 .filter(t -> !directors.contains(t.getPackageName()) && Seting.ORIGINAL_CHARTER_CURRENT_ALL_CODE.equals(t.getPackageName()))                 .filter(t->!directors.isCabinets(t.getPackageName()))                 .filter(t->t.getFounderVote()>=1)                 .sorted(Comparator.comparing(CurrentLawVotesEndBalance::getVotes).reversed())                 .limit(1)                 .collect(Collectors.toList());           int startBlock = 22820;         int finishBlock = 22830;         if(blockchain.sizeBlockhain() > finishBlock){             List<Block> blocksCharter = blockchain.subBlock(startBlock, finishBlock);             //учитывает отрезок блоков для выяснения подлиности устава             List<CurrentLawVotesEndBalance> charterBlocks = UtilsGovernment.filtersVotes(                     lawEligibleForParliamentaryApprovals,                     balances,                     boardOfShareholders,                     blocksCharter,                     Seting.LAW_YEAR_VOTE             );             List<CurrentLawVotesEndBalance> charterCheckBlock = charterBlocks.stream()                     .filter(t -> !directors.contains(t.getPackageName()) && Seting.ORIGINAL_CHARTER_CURRENT_LAW_PACKAGE_NAME.equals(t.getPackageName()))                     .filter(t->!directors.isCabinets(t.getPackageName()))                     .filter(t->t.getFounderVote()>=1)                     .sorted(Comparator.comparing(CurrentLawVotesEndBalance::getVotes).reversed())                     .limit(1)                     .collect(Collectors.toList());              CHARTER_ORIGINAL.addAll(charterCheckBlock);               List<CurrentLawVotesEndBalance> charterOriginalCode = charterBlocks.stream()                     .filter(t -> !directors.contains(t.getPackageName()) && Seting.ORIGINAL_CHARTER_CURRENT_ALL_CODE.equals(t.getPackageName()))                     .filter(t->!directors.isCabinets(t.getPackageName()))                     .filter(t->t.getFounderVote()>=1)                     .sorted(Comparator.comparing(CurrentLawVotesEndBalance::getVotes).reversed())                     .limit(1)                     .collect(Collectors.toList());              CHARTER_ORIGINAL_CODE.addAll(charterOriginalCode);         }           for (Map.Entry<Director, List<CurrentLawVotesEndBalance>> higherSpecialPositionsListMap : original_group.entrySet()) {             current.addAll(higherSpecialPositionsListMap.getValue());         }           current = new ArrayList<>();         current.addAll(addDirectors);         current.addAll(allVotes);         current.addAll(budjet);         current.addAll(planFourYears);         current.addAll(electedByStockBoardOfDirectors);         current.addAll(electedByStockCorporateCouncilOfReferees);         current.addAll(electedByBoardOfDirectors);         current.addAll(electedByCorporateCouncilOfReferees);         current.addAll(electedByGeneralExecutiveDirector);         current.addAll(electedByHightJudge);         current.addAll(notEnoughVotes);         current.addAll(CHARTER_ORIGINAL);         current.addAll(CHARTER_ORIGINAL_CODE);         current.addAll(chapter_amendment);         current = current.stream()                 .filter(UtilsUse.distinctByKey(CurrentLawVotesEndBalance::getAddressLaw))                 .collect(Collectors.toList());         System.out.println(\"notEnoughVotes: \" + notEnoughVotes);          model.addAttribute(\"title\", \"Как принимаются действующие законы, описано в уставе.\" +                 \" \");         model.addAttribute(\"currentLaw\", current);         return \"current-laws\";     }      /**Отображается в браузере, список всех пакета законов*/     @GetMapping(\"/all-laws\")     public String allLaws(Model model) throws IOException, NoSuchAlgorithmException, InvalidKeySpecException, SignatureException, NoSuchProviderException, InvalidKeyException {         Blockchain blockchain = Mining.getBlockchain(                 Seting.ORIGINAL_BLOCKCHAIN_FILE,                 BlockchainFactoryEnum.ORIGINAL);          Map<String, Account> balances = new HashMap<>();         balances = SaveBalances.readLineObject(Seting.ORIGINAL_BALANCE_FILE);           List<Account> boardOfShareholders = UtilsGovernment.findBoardOfShareholders(balances, blockchain.getBlockchainList(), Seting.BOARDS_BLOCK);           List<LawEligibleForParliamentaryApproval> lawEligibleForParliamentaryApprovals =                 UtilsLaws.readLineCurrentLaws(Seting.ORIGINAL_ALL_CORPORATION_LAWS_WITH_BALANCE_FILE);         //данные для отображения           Directors directors = new Directors();         //TODO доработать оптимизацию         //TODO избавиться от find position в данном методе         //TODO доработать оптимизацию         //TODO избавиться от find position в данном методе         Map<Director, FIndPositonHelperData> fIndPositonHelperDataMap = new HashMap<>();         for (Director higherSpecialPositions : directors.getDirectors()) {             if (higherSpecialPositions.isElectedByCEO()) {                 fIndPositonHelperDataMap.put(higherSpecialPositions,                         new FIndPositonHelperData(higherSpecialPositions, false, false, true, false, false));             } else if (higherSpecialPositions.isElectedByBoardOfDirectors()) {                 fIndPositonHelperDataMap.put(higherSpecialPositions,                         new FIndPositonHelperData(higherSpecialPositions, false, false, false, true, false));             } else if (higherSpecialPositions.isElectedByCorporateCouncilOfReferees()) {                 fIndPositonHelperDataMap.put(higherSpecialPositions,                         new FIndPositonHelperData(higherSpecialPositions, false, false, false, false, true));             } else if (higherSpecialPositions.isElectedByStocks()) {                 fIndPositonHelperDataMap.put(higherSpecialPositions,                         new FIndPositonHelperData(higherSpecialPositions, true, true, false, false, false));              }          }           List<CurrentLawVotesEndBalance> current = UtilsGovernment.filtersVotes(                 lawEligibleForParliamentaryApprovals,                 balances,                 boardOfShareholders,                 blockchain.getBlockchainList(),                 Seting.LAW_YEAR_VOTE);           current = current.stream().distinct().collect(Collectors.toList());          current = current.stream().sorted(Comparator.comparing(CurrentLawVotesEndBalance::getVotes).reversed()).collect(Collectors.toList());         model.addAttribute(\"allLaws\", current);         return \"all-laws\";     }       /**Создать новую должность*/     @GetMapping(\"/add_position\")     public String addPostion(Model model){         model.addAttribute(\"title\", \"Создание новой должности\");         return \"add_position\";     }      @PostMapping(\"/add_position\")     public String addPosition( @RequestParam String sender,                                @RequestParam String reward,                                @RequestParam String nameLaw,                                @RequestParam String[] laws,                                @RequestParam String password,                                RedirectAttributes redirectAttrs) throws IOException, NoSuchAlgorithmException, SignatureException, InvalidKeySpecException, NoSuchProviderException, InvalidKeyException {          nameLaw = Seting.ADD_DIRECTOR + nameLaw;         String[] lawsAdd = new String[laws.length];         for (int i = 0; i < laws.length; i++) {             lawsAdd[i] = Seting.ADD_DIRECTOR + laws[i];         }         laws = lawsAdd;          Laws law = new Laws(nameLaw, Arrays.asList(laws));         Base base = new Base58();          Double rewardD = Double.parseDouble(reward);           DtoTransaction dtoTransaction = new DtoTransaction(                 sender,                 law.getHashLaw(),                 0.0,                 0.0,                 law,                 rewardD,                 VoteEnum.valueOf(\"YES\"));         PrivateKey privateKey = UtilsSecurity.privateBytToPrivateKey(base.decode(password));         byte[] sign = UtilsSecurity.sign(privateKey, dtoTransaction.toSign());          redirectAttrs.addFlashAttribute(\"title\", \"sending result!!!\");         redirectAttrs.addFlashAttribute(\"sender\", sender);          redirectAttrs.addFlashAttribute(\"recipient\", law.getHashLaw());         redirectAttrs.addFlashAttribute(\"dollar\", 0.0);         redirectAttrs.addFlashAttribute(\"stock\", 0.0);         redirectAttrs.addFlashAttribute(\"reward\", rewardD);         redirectAttrs.addFlashAttribute(\"vote\", \"YES\");         dtoTransaction.setSign(sign);          Directors directors = new Directors();         if (dtoTransaction.verify()) {              //если в названия закона совпадает с корпоративными должностями, то закон является действительным только когда             //отправитель совпадает с законом             List<Director> enumPosition = directors.getDirectors();             List<String> corporateSeniorPositions = enumPosition.stream()                     .map(t->t.getName())                     .collect(Collectors.toList());              if (corporateSeniorPositions.contains(law.getPacketLawName()) && !UtilsGovernment.checkPostionSenderEqualsLaw(sender, law)) {                 redirectAttrs.addFlashAttribute(\"sending\", \"wrong transaction: Position to be equals whith send\");                 return \"redirect:/result-sending\";             }              redirectAttrs.addFlashAttribute(\"sending\", \"success\");             AllTransactions.addTransaction(dtoTransaction);             String jsonDto = UtilsJson.objToStringJson(dtoTransaction);              for (String s : Seting.ORIGINAL_ADDRESSES) {                 String original = s;                 String url = s + \"/addTransaction\";                 if (BasisController.getExcludedAddresses().contains(url)) {                     System.out.println(\"its your address or excluded address: \" + url);                     continue;                 }                 try {                     UtilUrl.sendPost(jsonDto, url);                  } catch (Exception e) {                     System.out.println(\"exception discovery: \" + original);                  }             }         } else             redirectAttrs.addFlashAttribute(\"sending\", \"wrong transaction\");          return \"redirect:/result-sending\";      }      /**Отображается в браузере, позволяет создать новый пакет законов*/     @GetMapping(\"/create-law\")     public String createLawsShow(Model model) {         return \"create-law\";     }       @RequestMapping(value = \"/create-law\", method = RequestMethod.POST, params = \"action=/send\")     public String createLaw(Model model,                             @RequestParam String sender,                             @RequestParam String reward,                             @RequestParam String nameLaw,                             @RequestParam String[] laws,                             @RequestParam String password,                             RedirectAttributes redirectAttrs) throws IOException, NoSuchAlgorithmException, SignatureException, NoSuchProviderException, InvalidKeyException, InvalidKeySpecException {           Laws law = new Laws(nameLaw, Arrays.asList(laws));         Base base = new Base58();          Double rewardD = Double.parseDouble(reward);           DtoTransaction dtoTransaction = new DtoTransaction(                 sender,                 law.getHashLaw(),                 0.0,                 0.0,                 law,                 rewardD,                 VoteEnum.valueOf(\"YES\"));         PrivateKey privateKey = UtilsSecurity.privateBytToPrivateKey(base.decode(password));         byte[] sign = UtilsSecurity.sign(privateKey, dtoTransaction.toSign());          redirectAttrs.addFlashAttribute(\"title\", \"sending result!!!\");         redirectAttrs.addFlashAttribute(\"sender\", sender);          redirectAttrs.addFlashAttribute(\"recipient\", law.getHashLaw());         redirectAttrs.addFlashAttribute(\"dollar\", 0.0);         redirectAttrs.addFlashAttribute(\"stock\", 0.0);         redirectAttrs.addFlashAttribute(\"reward\", rewardD);         redirectAttrs.addFlashAttribute(\"vote\", \"YES\");         dtoTransaction.setSign(sign);          Directors directors = new Directors();         if (dtoTransaction.verify()) {              //если в названия закона совпадает с корпоративными должностями, то закон является действительным только когда             //отправитель совпадает с законом             List<Director> enumPosition = directors.getDirectors();             List<String> corporateSeniorPositions = enumPosition.stream()                     .map(t->t.getName())                     .collect(Collectors.toList());              if (corporateSeniorPositions.contains(law.getPacketLawName()) && !UtilsGovernment.checkPostionSenderEqualsLaw(sender, law)) {                 redirectAttrs.addFlashAttribute(\"sending\", \"wrong transaction: Position to be equals whith send\");                 return \"redirect:/result-sending\";             }              redirectAttrs.addFlashAttribute(\"sending\", \"success\");             AllTransactions.addTransaction(dtoTransaction);             String jsonDto = UtilsJson.objToStringJson(dtoTransaction);              for (String s : Seting.ORIGINAL_ADDRESSES) {                 String original = s;                 String url = s + \"/addTransaction\";                 if (BasisController.getExcludedAddresses().contains(url)) {                     System.out.println(\"its your address or excluded address: \" + url);                     continue;                 }                 try {                     UtilUrl.sendPost(jsonDto, url);                  } catch (Exception e) {                     System.out.println(\"exception discovery: \" + original);                  }             }         } else             redirectAttrs.addFlashAttribute(\"sending\", \"wrong transaction\");          return \"redirect:/result-sending\";      }  }","package International_Trade_Union.controllers;  import International_Trade_Union.about_us_engDraft.AboutUsEngDraft; import International_Trade_Union.governments.Director; import International_Trade_Union.governments.Directors; import International_Trade_Union.governments.UtilsGovernment; import International_Trade_Union.originalCorporateCharter.OriginalPreamble; import International_Trade_Union.originalCorporateCharter.OriginalPreambleEng;  import org.json.JSONException; import org.springframework.http.HttpStatus; import org.springframework.http.ResponseEntity; import org.springframework.stereotype.Controller; import org.springframework.ui.Model; import org.springframework.web.bind.annotation.GetMapping; import org.springframework.web.bind.annotation.PostMapping; import org.springframework.web.bind.annotation.RequestParam; import org.springframework.web.servlet.mvc.support.RedirectAttributes; import International_Trade_Union.entity.DtoTransaction.DtoTransaction; import International_Trade_Union.model.Account; import International_Trade_Union.model.User; import International_Trade_Union.network.AllTransactions; import International_Trade_Union.setings.Seting; import International_Trade_Union.utils.*; import International_Trade_Union.utils.base.Base; import International_Trade_Union.utils.base.Base58; import International_Trade_Union.vote.Laws; import International_Trade_Union.vote.VoteEnum;   import java.io.IOException; import java.net.http.WebSocket; import java.security.*; import java.security.spec.InvalidKeySpecException; import java.util.*; import java.util.stream.Collectors;  @Controller public class MainController {      @GetMapping(\"/\")     public String home(Model model) throws IOException, NoSuchAlgorithmException, InvalidKeySpecException, SignatureException, NoSuchProviderException, InvalidKeyException {           model.addAttribute(\"title\", \"Corporation International Trade Union.\");         Map<String, Account> balances = new HashMap<>();          //догрузить блокчейн //        List<Block> blocks = UtilsBlock.readLineObject(Seting.ORIGINAL_BLOCKCHAIN_FILE); //        balances = UtilsBalance.calculateBalances(blocks);         balances = SaveBalances.readLineObject(Seting.ORIGINAL_BALANCE_FILE);           Account account = UtilsBalance.getBalance(User.getUserAddress(), balances);         model.addAttribute(\"account\", account);          return \"home\";     }       @PostMapping(\"/setMinner\")     public String setMinnerAddress(@RequestParam(value = \"setMinner\") String setMinner, RedirectAttributes redirectAttrs){         System.out.println(\"MainController:  \" + setMinner);         UtilsFileSaveRead.save(setMinner, Seting.ORIGINAL_ACCOUNT, false);         return \"redirect:/home\";     }        @GetMapping(\"about\")     public String aboutUs(Model model){         model.addAttribute(\"title\", \"ABOUT US\");         model.addAttribute(\"eng\", OriginalPreambleEng.ARTICLE_0);         model.addAttribute(\"rus\", OriginalPreamble.ARTICLE_0);         return \"about\";     }     @GetMapping(\"result-sending\")     public String resultSending(Model model){          return \"result-sending\";     }      @PostMapping(\"/\")     public String new_transaction(             @RequestParam  String sender,             @RequestParam  String recipient,                                    Double dollar,                                    Double stock,                                    Double reward,                                    @RequestParam  String password,                                   RedirectAttributes redirectAttrs) throws IOException, NoSuchAlgorithmException, SignatureException, InvalidKeySpecException, NoSuchProviderException, InvalidKeyException {         Base base = new Base58();          Laws laws =  new Laws();         laws.setLaws(new ArrayList<>());         laws.setHashLaw(\"\");         laws.setPacketLawName(\"\");         DtoTransaction dtoTransaction = new DtoTransaction(                 sender,                 recipient,                 dollar,                 stock,                 laws,                 reward,                 VoteEnum.YES);         PrivateKey privateKey = UtilsSecurity.privateBytToPrivateKey(base.decode(password));         byte[] sign = UtilsSecurity.sign(privateKey, dtoTransaction.toSign());         System.out.println(\"Main Controller: new transaction: vote: \" +VoteEnum.YES);         redirectAttrs.addFlashAttribute(\"title\", \"sending result!!!\");         redirectAttrs.addFlashAttribute(\"sender\", sender);         redirectAttrs.addFlashAttribute(\"recipient\", recipient);         redirectAttrs.addFlashAttribute(\"dollar\", dollar);         redirectAttrs.addFlashAttribute(\"stock\", stock);         redirectAttrs.addFlashAttribute(\"reward\", reward);         redirectAttrs.addFlashAttribute(\"vote\", VoteEnum.YES);         dtoTransaction.setSign(sign);         Directors directors = new Directors();         if(dtoTransaction.verify()){              //если в названия закона совпадает с корпоративными должностями, то закон является действительным только когда             //отправитель совпадает с законом             List<String> corporateSeniorPositions = directors.getDirectors().stream()                     .map(t->t.getName()).collect(Collectors.toList());             System.out.println(\"LawsController: create_law: \" + laws.getPacketLawName() + \"contains: \" + corporateSeniorPositions.contains(laws.getPacketLawName()));             if(corporateSeniorPositions.contains(laws.getPacketLawName()) && !UtilsGovernment.checkPostionSenderEqualsLaw(sender, laws)){                 redirectAttrs.addFlashAttribute(\"sending\", \"wrong transaction: Position to be equals whith send\");                 return \"redirect:/result-sending\";             }             redirectAttrs.addFlashAttribute(\"sending\", \"success\");             System.out.println(\"dto MainController: \" + dtoTransaction);              AllTransactions.addTransaction(dtoTransaction);             String jsonDto = UtilsJson.objToStringJson(dtoTransaction);             for (String s : Seting.ORIGINAL_ADDRESSES) {                  String original = s;                 String url = s +\"/addTransaction\";                 //если адресс совпадает с внутреним хостом, то не отправляет самому себе                 if(BasisController.getExcludedAddresses().contains(url)){                     System.out.println(\"MainController: its your address or excluded address: \" + url);                     continue;                 }                 try {                     //отправка в сеть                     UtilUrl.sendPost(jsonDto, url);                  }catch (Exception e){                     System.out.println(\"exception discover: \" + original);                  }             }            }          else             redirectAttrs.addFlashAttribute(\"sending\", \"wrong transaction\");         return \"redirect:/result-sending\";     }       @GetMapping(\"/seting\")     public String seting(Model model){         model.addAttribute(\"title\", \"Настройки\");         return \"seting\";     }   }","package International_Trade_Union.controllers;  import International_Trade_Union.config.BLockchainFactory; import International_Trade_Union.config.BlockchainFactoryEnum; import International_Trade_Union.entity.blockchain.Blockchain; import International_Trade_Union.model.Account; import International_Trade_Union.model.User; import International_Trade_Union.setings.Seting; import International_Trade_Union.utils.SaveBalances; import International_Trade_Union.utils.UtilsBalance; import org.springframework.stereotype.Controller; import org.springframework.ui.Model; import org.springframework.web.bind.annotation.GetMapping; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RestController;  import java.io.IOException; import java.security.InvalidKeyException; import java.security.NoSuchAlgorithmException; import java.security.NoSuchProviderException; import java.security.SignatureException; import java.security.spec.InvalidKeySpecException; import java.util.HashMap; import java.util.Map;  @Controller public class MineController {     private static Blockchain blockchain;     static {         try {             blockchain = BLockchainFactory.getBlockchain(BlockchainFactoryEnum.ORIGINAL);         } catch (NoSuchAlgorithmException e) {             throw new RuntimeException(e);         } catch (InvalidKeySpecException e) {             throw new RuntimeException(e);         } catch (IOException e) {             throw new RuntimeException(e);         } catch (SignatureException e) {             throw new RuntimeException(e);         } catch (NoSuchProviderException e) {             throw new RuntimeException(e);         } catch (InvalidKeyException e) {             throw new RuntimeException(e);         }     }      @RequestMapping(\"/mining\")     public String miming(Model model) throws IOException, NoSuchAlgorithmException, InvalidKeySpecException, SignatureException, NoSuchProviderException, InvalidKeyException {         model.addAttribute(\"title\", \"Corporation International Trade Union.\");          return \"mining\";     }    }","package International_Trade_Union.controllers;  import International_Trade_Union.entity.DtoTransaction.DtoTransaction; import International_Trade_Union.network.AllTransactions; import org.springframework.http.MediaType; import org.springframework.web.bind.annotation.RequestBody; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RequestMethod; import org.springframework.web.bind.annotation.RestController;  import java.io.IOException; import java.security.InvalidKeyException; import java.security.NoSuchAlgorithmException; import java.security.NoSuchProviderException; import java.security.SignatureException; import java.security.spec.InvalidKeySpecException;  @RestController public class TransactionController {     @RequestMapping(method = RequestMethod.POST, value = \"/addTransaction\", consumes = MediaType.APPLICATION_JSON_VALUE)     public  void add(@RequestBody DtoTransaction data) throws IOException, NoSuchAlgorithmException, SignatureException, InvalidKeySpecException, NoSuchProviderException, InvalidKeyException {         System.out.println(\"add transaction: \" + data);         AllTransactions.getInstance();         AllTransactions.addTransaction(data);         System.out.println(\"TransactionController: add: \" + AllTransactions.getInstance().size());     }  }","package International_Trade_Union.entity.blockchain.block;  import International_Trade_Union.entity.DtoTransaction.DtoTransaction; import International_Trade_Union.exception.NotValidTransactionException; import International_Trade_Union.utils.UtilsJson; import International_Trade_Union.utils.UtilsUse; import com.fasterxml.jackson.annotation.JsonAutoDetect;  import lombok.Data;  import java.io.IOException; import java.security.InvalidKeyException; import java.security.NoSuchAlgorithmException; import java.security.NoSuchProviderException; import java.security.SignatureException; import java.security.spec.InvalidKeySpecException; import java.sql.Timestamp; import java.util.List; import java.util.Objects;  @JsonAutoDetect @Data public final class Block implements Cloneable {     private List<DtoTransaction> dtoTransactions;     private String previousHash;     private String minerAddress;     private String founderAddress;     private long randomNumberProof;     private double minerRewards;     private int hashCompexity;     private Timestamp timestamp;     private long index;     private String hashBlock;      public Block(List<DtoTransaction> dtoTransactions,  String previousHex, String minerAddress, String founderAddress, int hashCompexity, long index) throws IOException, NoSuchAlgorithmException, SignatureException, NoSuchProviderException, InvalidKeyException, InvalidKeySpecException {         this.dtoTransactions = dtoTransactions;         this.previousHash = previousHex;         this.minerAddress = minerAddress;         this.minerRewards = miningRewardsCount();         this.hashCompexity = hashCompexity;         this.founderAddress = founderAddress;         this.timestamp = new Timestamp(System.currentTimeMillis());         this.index = index;         this.hashBlock = findHash(hashCompexity);      }      public Block(List<DtoTransaction> dtoTransactions, String previousHash, String minerAddress, String founderAddress, long randomNumberProof, double minerRewards, int hashCompexity, Timestamp timestamp, long index, String hashBlock) {         this.dtoTransactions = dtoTransactions;         this.previousHash = previousHash;         this.minerAddress = minerAddress;         this.founderAddress = founderAddress;         this.randomNumberProof = randomNumberProof;         this.minerRewards = minerRewards;         this.hashCompexity = hashCompexity;         this.timestamp = timestamp;         this.index = index;         this.hashBlock = hashBlock;     }      @JsonAutoDetect     @Data     private class BlockForHash{         private List<DtoTransaction> transactions;         private String previousHash;         private String minerAddress;         private String founderAddress;         private long randomNumberProof;         private double minerRewards;         private int hashCompexity;         private Timestamp timestamp;         private long index;           public BlockForHash() {         }           public BlockForHash(List<DtoTransaction> transactions,                             String previousHash,                             String minerAddress,                             String founderAddress,                             long randomNumberProof,                             double minerRewards,                             int hashCompexity,                             Timestamp timestamp,                             long index) {             this.transactions = transactions;             this.previousHash = previousHash;             this.minerAddress = minerAddress;             this.founderAddress = founderAddress;             this.randomNumberProof = randomNumberProof;             this.minerRewards = minerRewards;             this.hashCompexity = hashCompexity;             this.timestamp = timestamp;             this.index = index;          }          public String hashForTransaction() throws IOException {             return UtilsUse.sha256hash(jsonString());         }          public String jsonString() throws IOException {             return UtilsJson.objToStringJson(this);         }     }      public Block() {     }      public String hashForBlockchain()             throws             IOException{         return this.hashBlock;     }       public boolean verifyesTransSign() throws IOException, NoSuchAlgorithmException, SignatureException, NoSuchProviderException, InvalidKeyException, InvalidKeySpecException {         for (DtoTransaction dtoTransaction : dtoTransactions) {             if(!dtoTransaction.verify())                 return false;         }         return true;     }      private double miningRewardsCount(){         double rewards = 0.0;         for (DtoTransaction dtoTransaction : dtoTransactions) {              rewards += dtoTransaction.getBonusForMiner();         }          return rewards;     }      public String jsonString() throws IOException {         return UtilsJson.objToStringJson(this);     }     //TODO     public String findHash(int hashCoplexity) throws IOException, NoSuchAlgorithmException, SignatureException, NoSuchProviderException, InvalidKeyException, InvalidKeySpecException {         if (!verifyesTransSign()){             throw new NotValidTransactionException();         }          this.randomNumberProof = 0;         String hash = \"\";         while (true){             this.randomNumberProof++;             BlockForHash block = new BlockForHash(this.dtoTransactions,                     this.previousHash, this.minerAddress, this.founderAddress,                     this.randomNumberProof, this.minerRewards, this.hashCompexity, this.timestamp, this.index);             hash = block.hashForTransaction();             if(UtilsUse.hashComplexity(hash.substring(0, hashCoplexity), hashCoplexity))             {                 break;             }          }         return hash;     }      @Override     public boolean equals(Object o) {           if (this == o) return true;         if (!(o instanceof Block)) return false;         Block block = (Block) o;         return getRandomNumberProof() == block.getRandomNumberProof() && Double.compare(block.getMinerRewards(), getMinerRewards()) == 0 && getHashCompexity() == block.getHashCompexity() && getIndex() == block.getIndex() && Objects.equals(getDtoTransactions(), block.getDtoTransactions()) && Objects.equals(getPreviousHash(), block.getPreviousHash()) && Objects.equals(getMinerAddress(), block.getMinerAddress()) && Objects.equals(getFounderAddress(), block.getFounderAddress()) && Objects.equals(getTimestamp(), block.getTimestamp()) && Objects.equals(getHashBlock(), block.getHashBlock());     }      @Override     public int hashCode() {         return Objects.hash(getDtoTransactions(), getPreviousHash(), getMinerAddress(), getFounderAddress(), getRandomNumberProof(), getMinerRewards(), getHashCompexity(), getTimestamp(), getIndex(), getHashBlock());     }      @Override     public Block clone() throws CloneNotSupportedException {         return new Block(this.dtoTransactions, this.previousHash, this.minerAddress, this.founderAddress,                 this.randomNumberProof, this.minerRewards, this.hashCompexity, this.timestamp, this.index,                 this.hashBlock);     } }","package International_Trade_Union.entity.blockchain;  import International_Trade_Union.entity.DtoTransaction.DtoTransaction; import International_Trade_Union.entity.blockchain.block.Block; import International_Trade_Union.setings.Seting; import International_Trade_Union.utils.UtilsBlock; import International_Trade_Union.utils.UtilsJson; import International_Trade_Union.utils.UtilsSecurity; import International_Trade_Union.utils.UtilsUse; import International_Trade_Union.utils.base.Base; import International_Trade_Union.utils.base.Base58; import International_Trade_Union.vote.Laws; import International_Trade_Union.vote.VoteEnum; import com.fasterxml.jackson.annotation.JsonAutoDetect;  import lombok.Data;  import java.io.IOException; import java.security.*; import java.security.spec.InvalidKeySpecException; import java.util.ArrayList; import java.util.List; import java.util.Objects;   @JsonAutoDetect @Data public class Blockchain implements Cloneable{     private List<Block> blockchainList;     //как часто должно создаваться блок в миллисекундах 1000 миллисекунд = 1 секунд     private long BLOCK_GENERATION_INTERVAL;     //каждые сколько блоков должен происходить перерасчет сложности     private int DIFFICULTY_ADJUSTMENT_INTERVAL;     //блок действителен, если значение блока меньше данного занчения в миллисекунда     private long INTERVAL_TARGET;     private String ADDRESS_FOUNDER;     public int sizeBlockhain(){          return blockchainList.size();     }      public void setBlockchainList(List<Block> blockchainList) throws IOException, NoSuchAlgorithmException, InvalidKeySpecException, SignatureException, NoSuchProviderException, InvalidKeyException {         this.blockchainList = blockchainList;      }      public Blockchain(long BLOCK_GENERATION_INTERVAL, int DIFFICULTY_ADJUSTMENT_INTERVAL, long INTERVAL_TARGET, String ADDRESS_FOUNDER) throws NoSuchAlgorithmException, InvalidKeySpecException, NoSuchProviderException, IOException, SignatureException, InvalidKeyException {         this(new ArrayList<>(), BLOCK_GENERATION_INTERVAL, DIFFICULTY_ADJUSTMENT_INTERVAL, INTERVAL_TARGET, ADDRESS_FOUNDER);      }     public Blockchain(List<Block> blockchainList, long BLOCK_GENERATION_INTERVAL, int DIFFICULTY_ADJUSTMENT_INTERVAL, long INTERVAL_TARGET,String ADDRESS_FOUNDER) throws IOException, NoSuchAlgorithmException, InvalidKeySpecException, SignatureException, NoSuchProviderException, InvalidKeyException {         this.blockchainList = blockchainList;         this.BLOCK_GENERATION_INTERVAL = BLOCK_GENERATION_INTERVAL;         this.DIFFICULTY_ADJUSTMENT_INTERVAL = DIFFICULTY_ADJUSTMENT_INTERVAL;         this.INTERVAL_TARGET = INTERVAL_TARGET;         this.ADDRESS_FOUNDER = ADDRESS_FOUNDER;         Block block = genesisBlock();         addBlock(block);     }      public void addBlock(Block newBlock) throws IOException, NoSuchAlgorithmException, SignatureException, InvalidKeySpecException, NoSuchProviderException, InvalidKeyException { //        if(blockchainList.size() > 2){ //            boolean time = UtilsBlock.isValidTimestamp(blockchainList.get(blockchainList.size()-1), newBlock, INTERVAL_TARGET); //            if(!time){ //                System.out.println(\"time out block add \" + time); //               return; //            } //        }         blockchainList.add(newBlock);       }      public Block genesisBlock() throws IOException, NoSuchAlgorithmException, InvalidKeySpecException, NoSuchProviderException, SignatureException, InvalidKeyException {         Base base = new Base58();         //dto sign         //pub byte keys         //transactions         List<DtoTransaction> transactions = new ArrayList<>();          DtoTransaction gold = new DtoTransaction(Seting.BASIS_ADDRESS, ADDRESS_FOUNDER,                 Seting.FOUNDERS_REMUNERATION_DIGITAL_DOLLAR, Seting.FOUNDERS_REMNUNERATION_DIGITAL_STOCK, new Laws(), 0.0, VoteEnum.YES);         PrivateKey privateKey = UtilsSecurity.privateBytToPrivateKey(base.decode(Seting.BASIS_PASSWORD));         byte[] signGold = UtilsSecurity.sign(privateKey, gold.toSign());         gold.setSign(signGold);         transactions.add(gold);          String genesisHash = genesisPrevHash();         Block block = new Block(transactions,  genesisHash, ADDRESS_FOUNDER, ADDRESS_FOUNDER,  Seting.HASH_COMPLEXITY_GENESIS, blockchainList.size());         return block;     }        public String genesisPrevHash() throws IOException {         return UtilsUse.hashComplexityStr(Seting.CORPORATE_CHARTER_DRAFT, Seting.HASH_COMPLEXITY_GENESIS);     }      public String getHashBlock(int index) throws IOException {         return blockchainList.get(index).hashForBlockchain();     }     public Block getBlock(int index){         return blockchainList.get(index);     }        public boolean validatedBlockchain() throws IOException, NoSuchAlgorithmException, SignatureException, InvalidKeySpecException, NoSuchProviderException, InvalidKeyException {        return UtilsBlock.validation(blockchainList, BLOCK_GENERATION_INTERVAL, DIFFICULTY_ADJUSTMENT_INTERVAL);     }      public String jsonString() throws IOException {         return UtilsJson.objToStringJson(blockchainList);     }     @Override     public boolean equals(Object o) {         if (this == o) return true;         if (!(o instanceof Blockchain)) return false;         Blockchain that = (Blockchain) o;         return getBlockchainList().equals(that.getBlockchainList());     }      @Override     public int hashCode() {         return Objects.hash(getBlockchainList());     }      public  List<Block> subBlock(int startIndex, int finishIndex) throws CloneNotSupportedException {         List<Block> temporary = this.getBlockchainList().subList(startIndex, finishIndex);         List<Block> result = new ArrayList<>();         for (Block block : temporary) {             result.add(block.clone());         }         return result;     }       @Override     public List<Block> clone() throws CloneNotSupportedException {         List<Block> result = new ArrayList<>();         for (Block block : blockchainList) {             result.add(block.clone());         }         return result;      } }","package International_Trade_Union.entity.DtoTransaction;  import org.bouncycastle.jcajce.provider.asymmetric.ec.BCECPublicKey; import International_Trade_Union.setings.Seting; import International_Trade_Union.utils.UtilsJson; import International_Trade_Union.utils.UtilsSecurity; import International_Trade_Union.utils.UtilsUse; import International_Trade_Union.utils.base.Base; import International_Trade_Union.utils.base.Base58; import International_Trade_Union.vote.Laws; import International_Trade_Union.vote.VoteEnum; import com.fasterxml.jackson.annotation.JsonAutoDetect;  import lombok.Data;   import java.io.IOException; import java.security.*; import java.security.spec.InvalidKeySpecException; import java.util.Arrays; import java.util.Objects;   @JsonAutoDetect @Data public class DtoTransaction {     private String sender;     private String customer;     private double digitalDollar;     private double digitalStockBalance;     private Laws laws;     private double bonusForMiner;     private VoteEnum voteEnum;     private byte[] sign;        public DtoTransaction(String sender, String customer, double digitalDollar, double digitalStockBalance, Laws laws, double bonusForMiner, VoteEnum voteEnum) {         this.sender = sender;         this.customer = customer;         this.digitalDollar = digitalDollar;         this.digitalStockBalance = digitalStockBalance;         this.laws = laws;         this.bonusForMiner = bonusForMiner;         this.voteEnum = voteEnum;     }      public DtoTransaction() {     }      //TODO возможно стоит перевести проверку подписи в отдельный utils, под вопросом!!     public boolean verify() throws IOException, NoSuchAlgorithmException, SignatureException, NoSuchProviderException, InvalidKeyException, InvalidKeySpecException {         Base base = new Base58();         byte[] pub = base.decode(sender);         BCECPublicKey publicKey = (BCECPublicKey) UtilsSecurity.decodeKey(pub); //        PublicKey publicKey = UtilsSecurity.publicByteToPublicKey(pub);         String sha = sender + customer + digitalDollar + digitalStockBalance + laws + bonusForMiner;         sha = UtilsUse.sha256hash(sha);         if(sender.isBlank() || customer.isBlank() || digitalDollar < 0 || digitalStockBalance < 0 || bonusForMiner < 0 || laws == null){             System.out.println(\"wrong dto transaction sender or customer blank? or dollar, reputation or reward less then 0\");             return false;         }         if(Seting.BASIS_ADDRESS.equals(publicKey))             return true;         return UtilsSecurity.verify(sha, sign, publicKey);     }      public String toSign(){         String sha = sender + customer + digitalDollar + digitalStockBalance + laws + bonusForMiner;         return UtilsUse.sha256hash(sha);     }  //    public String hashForBlock() throws IOException { //        return UtilsUse.sha256hash(jsonString()); //    }      public String jsonString() throws IOException {         return UtilsJson.objToStringJson(this);     }      @Override     public boolean equals(Object o) {         if (this == o) return true;         if (!(o instanceof DtoTransaction)) return false;         DtoTransaction that = (DtoTransaction) o;         return Double.compare(that.getDigitalDollar(), getDigitalDollar()) == 0 && Double.compare(that.getDigitalStockBalance(), getDigitalStockBalance()) == 0 && Double.compare(that.getBonusForMiner(), getBonusForMiner()) == 0 && getSender().equals(that.getSender()) && getCustomer().equals(that.getCustomer()) && getLaws().equals(that.getLaws()) && getVoteEnum() == that.getVoteEnum() && Arrays.equals(getSign(), that.getSign());     }      @Override     public int hashCode() {         int result = Objects.hash(getSender(), getCustomer(), getDigitalDollar(), getDigitalStockBalance(), getLaws(), getBonusForMiner(), getVoteEnum());         result = 31 * result + Arrays.hashCode(getSign());         return result;     } }","package International_Trade_Union.entity;   import lombok.Data; import International_Trade_Union.entity.blockchain.block.Block;  import java.util.List;  @Data public class EntityChain {      private int size;     private List<Block> blocks;      public EntityChain() {     }      public EntityChain(int sizeBlockhain, List<Block> blockchainList) {         this.size = sizeBlockhain;         this.blocks = blockchainList;     } }","package International_Trade_Union.entity;   import lombok.Data; import International_Trade_Union.entity.blockchain.Blockchain; import International_Trade_Union.entity.blockchain.block.Block; import International_Trade_Union.model.Account;  import java.util.List; import java.util.Map;  @Data public class ResultMiningData {     private Map<String, Account> balance;     private Blockchain blockchain;     private Block miningBlock;     private List<Block> lastBlock;     private Account governments;  }","package International_Trade_Union.entity;  import lombok.Data;  @Data public class SubBlockchainEntity {     private int start;     private int finish;      public SubBlockchainEntity(int start, int finish) {         this.start = start;         this.finish = finish;     }      public SubBlockchainEntity() {     } }","package International_Trade_Union.exception;  import java.io.IOException;  public class NotValidTransactionException extends IOException { }","package International_Trade_Union.governments;   import International_Trade_Union.model.Account;  public class CompareObject {      public int compare(Account o1, Account o2) {         double x1 = o1.getDigitalStockBalance();         double x2 = o2.getDigitalStockBalance();         int power = Double.compare(x1, x2);         if (power != 0)             return power;         double gold1 = o1.getDigitalDollarBalance();         double gold2 = o2.getDigitalDollarBalance();         int gold = Double.compare(gold1, gold2);         if(gold != 0)             return gold;         double first = x1 + gold1;         double second = x2 + gold2;         return Double.compare(first, second);     }      @Override     public boolean equals(Object obj) {         return false;     } }","package International_Trade_Union.governments;  import lombok.AllArgsConstructor; import lombok.Data; import lombok.NoArgsConstructor;  import java.util.Arrays; import java.util.List; import java.util.Locale; import java.util.Objects; import java.util.stream.Collectors;  @Data @NoArgsConstructor @AllArgsConstructor public class Director {     //количество юридических или физических лиц в данной должности     //количество юридических или физических лиц в данной должности     private String name;     private  int count;      private boolean electedByCEO;     private boolean electedByBoardOfDirectors;       private boolean electedByCorporateCouncilOfReferees;     private boolean electedByStocks;     private boolean officeOfDirectors;       @Override     public boolean equals(Object o) {         if (this == o) return true;         if (!(o instanceof Director)) return false;         Director director = (Director) o;         return getName().equals(director.getName());     }      @Override     public int hashCode() {         return Objects.hash(getName());     }      public boolean isAppointedByTheGovernment(){         if(electedByCEO || electedByBoardOfDirectors || electedByCorporateCouncilOfReferees)             return true;         else return false;     }     public int getCount() {         return count;     }     }","package International_Trade_Union.governments;  import International_Trade_Union.setings.Seting; import International_Trade_Union.utils.UtilsUse; import lombok.Data;  import java.util.ArrayList; import java.util.List; import java.util.Locale; import java.util.stream.Collectors;  @Data  public class Directors {     public Directors() {          directors = new ArrayList<>();         Director CORPORATE_COUNCIL_OF_REFEREES = new Director(\"CORPORATE_COUNCIL_OF_REFEREES\", 55, false, false, false, true, false);         Director BOARD_OF_DIRECTORS = new Director(\"BOARD_OF_DIRECTORS\", 301, false, false, false, true, false);          Director GENERAL_EXECUTIVE_DIRECTOR = new Director(\"GENERAL_EXECUTIVE_DIRECTOR\", 1, false, true, false, false, true);         Director HIGH_JUDGE = new Director(\"HIGH_JUDGE\",1, false, false, true, false, false);          Director INTERNET_STORE_DIRECTOR = new Director(\"INTERNET_STORE_DIRECTOR\",1, false, true, false, false, true);         Director DIRECTOR_OF_THE_DIGITAL_EXCHANGE = new Director(\"DIRECTOR_OF_THE_DIGITAL_EXCHANGE\",1, false, true, false, false, true);         Director DIRECTOR_OF_DIGITAL_BANK = new Director(\"DIRECTOR_OF_DIGITAL_BANK\",1, false, true, false, false, true);         Director DIRECTOR_OF_THE_COMMERCIAL_COURT = new Director(\"DIRECTOR_OF_THE_COMMERCIAL_COURT\",1, false, true, false, false, true);         Director MEDIA_DIRECTOR = new Director(\"MEDIA_DIRECTOR\",1, false, true, false, false, true);         Director DIRECTOR_OF_THE_DEVELOPMENT_OF_THE_IMPLEMENTATION_OF_CRYPTOCURRENCY_TECHNOLOGIES_OF_THE_INTERNATIONAL_TRADE_UNION_CORPORATION = new Director(\"DIRECTOR_OF_THE_DEVELOPMENT_OF_THE_IMPLEMENTATION_OF_CRYPTOCURRENCY_TECHNOLOGIES_OF_THE_INTERNATIONAL_TRADE_UNION_CORPORATION\",1, false, true, false, false, true);          directors.add(CORPORATE_COUNCIL_OF_REFEREES);         directors.add(BOARD_OF_DIRECTORS);          directors.add(GENERAL_EXECUTIVE_DIRECTOR);         directors.add(HIGH_JUDGE);          directors.add(INTERNET_STORE_DIRECTOR);         directors.add(DIRECTOR_OF_THE_DIGITAL_EXCHANGE);         directors.add(DIRECTOR_OF_DIGITAL_BANK);         directors.add(DIRECTOR_OF_THE_COMMERCIAL_COURT);         directors.add(MEDIA_DIRECTOR);         directors.add(DIRECTOR_OF_THE_DEVELOPMENT_OF_THE_IMPLEMENTATION_OF_CRYPTOCURRENCY_TECHNOLOGIES_OF_THE_INTERNATIONAL_TRADE_UNION_CORPORATION);     }       public Director getDirector(String str){        List<Director> director = directors                .stream()                .filter(t->t.getName().equals(str))                .collect(Collectors.toList());        return director.get(0);      }     private List<Director> directors;      public boolean contains(String str) {         str = str.toUpperCase();         directors = directors.stream().filter(UtilsUse.distinctByKey(Director::getName)).collect(Collectors.toList());         List<String> strings = directors.stream().map(t->t.getName()).collect(Collectors.toList());        return strings.contains(str);     }      public boolean isCabinets(String str) {         List<String> list = directors.stream()                 .filter(t->t.isOfficeOfDirectors())                 .filter(UtilsUse.distinctByKey(Director::getName))                 .map(t->t.getName())                 .collect(Collectors.toList());         return list.contains(str.toUpperCase(Locale.ROOT));     }       //должности которые добавляются только советом директоров     public void addByBoardOfDirectors(String str) {         if (str.startsWith(Seting.ADD_DIRECTOR)) {             Director director = new Director(str, 1, false, true, false, false, true);             directors.add(director);             directors = directors.stream().filter(UtilsUse.distinctByKey(Director::getName)).collect(Collectors.toList());         }      }      public void addAllByBoardOfDirectors(List<String> strings) {         strings = strings.stream()                 .filter(t -> t.startsWith(Seting.ADD_DIRECTOR))                 .distinct()                 .collect(Collectors.toList());         for (String s : strings) {             Director director = new Director(s, 1, false, true, false, false, true);             directors.add(director);         }         directors = directors.stream().filter(UtilsUse.distinctByKey(Director::getName)).collect(Collectors.toList());      }       public List<String> getNames() {         return directors.stream().map(t -> t.getName()).collect(Collectors.toList());     }       public  boolean isElectedByStocks(String str){         List<String> list = directors.stream()                 .filter(t->t.isElectedByStocks())                 .map(t->t.getName())                 .collect(Collectors.toList());          return list.contains(str.toUpperCase(Locale.ROOT));     }     public boolean isElectedCEO(String str){         List<String> list = directors.stream()                 .filter(t->t.isElectedByCEO())                 .map(t->t.getName())                 .collect(Collectors.toList());          return list.contains(str.toUpperCase(Locale.ROOT));     }      public  boolean isElectedByBoardOfDirectors(String  str){         List<String> list = directors.stream()                 .filter(t->t.isElectedByBoardOfDirectors())                 .map(t->t.getName())                 .collect(Collectors.toList());          return list.contains(str.toUpperCase(Locale.ROOT));     }      public boolean isElectedBYCorporateCouncilOfReferees(String  str){         List<String> list = directors.stream()                 .filter(t->t.isElectedByCorporateCouncilOfReferees())                 .map(t->t.getName())                 .collect(Collectors.toList());          return list.contains(str.toUpperCase(Locale.ROOT));     }      public boolean isofficeOfDirectors(String str){         List<String> list = directors.stream()                 .filter(t->t.isOfficeOfDirectors())                 .map(t->t.getName())                 .collect(Collectors.toList());          return list.contains(str.toUpperCase(Locale.ROOT));     } }","package International_Trade_Union.governments;  public enum NamePOSITION {     BOARD_OF_DIRECTORS,     CORPORATE_COUNCIL_OF_REFEREES,     GENERAL_EXECUTIVE_DIRECTOR,     HIGH_JUDGE }","package International_Trade_Union.governments;   import International_Trade_Union.entity.DtoTransaction.DtoTransaction; import International_Trade_Union.entity.blockchain.block.Block; import International_Trade_Union.model.Account; import International_Trade_Union.setings.Seting; import International_Trade_Union.vote.*;  import java.io.IOException; import java.security.InvalidKeyException; import java.security.NoSuchAlgorithmException; import java.security.NoSuchProviderException; import java.security.SignatureException; import java.security.spec.InvalidKeySpecException; import java.util.*; import java.util.stream.Collectors;  public class UtilsGovernment {      //для корпоративных позиций, адресс отправителя должен совпадать с первой строкой закона     public static boolean checkPostionSenderEqualsLaw(String addressSender, Laws laws) {         Directors directors = new Directors();         List<Director> enumPosition = directors.getDirectors();         List<String> corporateSeniorPositions = enumPosition.stream().map(t->t.getName()).collect(Collectors.toList());         if (corporateSeniorPositions.contains(laws.getPacketLawName())) {             if (laws.getLaws().get(0) != null && addressSender.equals(laws.getLaws().get(0))) {                 System.out.println(\"UtilsBogernment: checkPostionSenderEqualsLaw: \" + laws.getLaws().get(0) + \" true:\");                 return true;             } else {                 System.out.println(\"UtilsBogernment: checkPostionSenderEqualsLaw: \" + laws.getLaws().get(0) + \" false:\");                 return false;             }         }         System.out.println(\"UtilsBogernment: checkPostionSenderEqualsLaw: \" + laws.getLaws().get(0) + \" not position:\");         return true;     }       //определение совета акционеров     public static List<Account> findBoardOfShareholders(Map<String, Account> balances, List<Block> blocks, int limit) {         List<Block> minersHaveMoreStock = null;         if (blocks.size() > limit) {             minersHaveMoreStock = blocks.subList(blocks.size() - limit, blocks.size());         } else {             minersHaveMoreStock = blocks;         }         List<Account> boardAccounts = minersHaveMoreStock.stream().map(                         t -> new Account(t.getMinerAddress(), 0, 0))                 .collect(Collectors.toList());          for (Block block : minersHaveMoreStock) {             for (DtoTransaction dtoTransaction : block.getDtoTransactions()) {                 boardAccounts.add(new Account(dtoTransaction.getSender(), 0, 0));             }          }           CompareObject compareObject = new CompareObject();          List<Account> boardOfShareholders = balances.entrySet().stream()                 .filter(t -> boardAccounts.contains(t.getValue()))                 .map(t -> t.getValue()).collect(Collectors.toList());           boardOfShareholders = boardOfShareholders                 .stream()                 .filter(t -> !t.getAccount().startsWith(Seting.NAME_LAW_ADDRESS_START))                 .filter(t -> t.getDigitalStockBalance() > 0)                 .sorted(Comparator.comparing(Account::getDigitalStockBalance).reversed())                 .collect(Collectors.toList());          boardOfShareholders = boardOfShareholders                 .stream()                 .limit(Seting.BOARD_OF_SHAREHOLDERS)                 .collect(Collectors.toList());          return boardOfShareholders;     }       public static List<CurrentLawVotesEndBalance> filtersVotes(             List<LawEligibleForParliamentaryApproval> approvalList,             Map<String, Account> balances,             List<Account> BoardOfShareholders,             List<Block> blocks,             int limitBlocks     ) throws IOException, NoSuchAlgorithmException, SignatureException, InvalidKeySpecException, NoSuchProviderException, InvalidKeyException {         //действующие законы чьи голоса больше ORIGINAL_LIMIT_MIN_VOTE         List<CurrentLawVotesEndBalance> current = new ArrayList<>();         Map<String, CurrentLawVotes> votesMap = null;         List<Account> accounts = balances.entrySet().stream().map(t -> t.getValue()).collect(Collectors.toList());         if (blocks.size() > limitBlocks) {             votesMap = UtilsCurrentLaw.calculateVotes(accounts, blocks.subList(blocks.size() - limitBlocks, blocks.size()));         } else {             votesMap = UtilsCurrentLaw.calculateVotes(accounts, blocks);         }          //подсчитать средннее количество раз сколько он проголосовал за         Map<String, Integer> yesAverage = UtilsCurrentLaw.calculateAverageVotesYes(votesMap);         //подсчитать среднее количество раз сколько он проголосовал против         Map<String, Integer> noAverage = UtilsCurrentLaw.calculateAverageVotesNo(votesMap);           //подсчитываем голоса для для обычных законов и законов позиций         for (LawEligibleForParliamentaryApproval lawEligibleForParliamentaryApproval : approvalList) {             if (votesMap.containsKey(lawEligibleForParliamentaryApproval.getLaws().getHashLaw())) {                 String address = lawEligibleForParliamentaryApproval.getLaws().getHashLaw();                 String packageName = lawEligibleForParliamentaryApproval.getLaws().getPacketLawName();                 List<String> laws = lawEligibleForParliamentaryApproval.getLaws().getLaws();                 double vote = 0;                 int supremeVotes = 0;                 int boafdOfShareholderVotes = 0;                 int houseOfRepresentativiesVotes = 0;                 int primeMinisterVotes = 0;                 int hightJudgesVotes = 0;                 int founderVote = 0;                  //для законов подсчитываем специальные голоса                 vote = votesMap.get(lawEligibleForParliamentaryApproval.getLaws().getHashLaw()).votesLaw(balances, yesAverage, noAverage);                 List<String> boardOfShareholdersAddress = BoardOfShareholders.stream().map(t -> t.getAccount()).collect(Collectors.toList());                 boafdOfShareholderVotes = votesMap.get(lawEligibleForParliamentaryApproval.getLaws().getHashLaw()).voteGovernment(balances, boardOfShareholdersAddress);                  List<String> founder = List.of(Seting.ADDRESS_FOUNDER);                 founderVote = votesMap.get(lawEligibleForParliamentaryApproval.getLaws().getHashLaw()).voteGovernment(balances, founder);                 CurrentLawVotesEndBalance currentLawVotesEndBalance = new CurrentLawVotesEndBalance(                         address,                         packageName,                         vote,                         supremeVotes,                         houseOfRepresentativiesVotes,                         boafdOfShareholderVotes,                         primeMinisterVotes,                         hightJudgesVotes,                         founderVote,                         laws);                 current.add(currentLawVotesEndBalance);              }         }          List<String> houseOfRepresentativies = new ArrayList<>();         List<String> chamberOfSumpremeJudges = new ArrayList<>();          for (CurrentLawVotesEndBalance currentLawVotesEndBalance: current) {             if(currentLawVotesEndBalance.getPackageName().equals(NamePOSITION.BOARD_OF_DIRECTORS.toString())){                 if(currentLawVotesEndBalance.getVotes() >= Seting.ORIGINAL_LIMIT_MIN_VOTE){                      houseOfRepresentativies.add(currentLawVotesEndBalance.getLaws().get(0));                 }              }             if(currentLawVotesEndBalance.getPackageName().equals(NamePOSITION.CORPORATE_COUNCIL_OF_REFEREES.toString())){                 if(currentLawVotesEndBalance.getVotes() >= Seting.ORIGINAL_LIMIT_MIN_VOTE){                     chamberOfSumpremeJudges.add(currentLawVotesEndBalance.getLaws().get(0));                 }              }         }            for (CurrentLawVotesEndBalance currentLawVotesEndBalance : current) {             if(votesMap.containsKey(currentLawVotesEndBalance.getAddressLaw())){                   double vote = votesMap.get(currentLawVotesEndBalance.getAddressLaw()).votesLaw(balances, yesAverage, noAverage);                 int supremeVotes  = votesMap.get(currentLawVotesEndBalance.getAddressLaw()).voteGovernment(balances, chamberOfSumpremeJudges);                 int houseOfRepresentativiesVotes = votesMap.get(currentLawVotesEndBalance.getAddressLaw()).voteGovernment(balances, houseOfRepresentativies);                  currentLawVotesEndBalance.setVotes(vote);                 currentLawVotesEndBalance.setVotesBoardOfDirectors(houseOfRepresentativiesVotes);                 currentLawVotesEndBalance.setVotesCorporateCouncilOfReferees(supremeVotes);             }          }          List<String> primeMinister = new ArrayList<>();         List<String> hightJudge = new ArrayList<>();         for (CurrentLawVotesEndBalance currentLawVotesEndBalance : current) {             if(currentLawVotesEndBalance.getPackageName().equals(NamePOSITION.GENERAL_EXECUTIVE_DIRECTOR.toString())){                 if(currentLawVotesEndBalance.getVotesBoardOfDirectors() >= Seting.ORIGINAL_LIMIT_MIN_VOTE_BOARD_OF_DIRECTORS){                     primeMinister.add(currentLawVotesEndBalance.getLaws().get(0));                 }             }              if(currentLawVotesEndBalance.getPackageName().equals(NamePOSITION.HIGH_JUDGE.toString())){                 if(currentLawVotesEndBalance.getVotesCorporateCouncilOfReferees() >= Seting.ORIGINAL_LIMIT_MIN_VOTE_CORPORATE_COUNCIL_OF_REFEREES){                     hightJudge.add(currentLawVotesEndBalance.getLaws().get(0));                 }             }         }         for (CurrentLawVotesEndBalance currentLawVotesEndBalance : current) {             if(votesMap.containsKey(currentLawVotesEndBalance.getAddressLaw())){                 int primeMinisterVotes = votesMap.get(currentLawVotesEndBalance.getAddressLaw()).voteGovernment(balances, primeMinister);                 int hightJudgeVotes = votesMap.get(currentLawVotesEndBalance.getAddressLaw()).voteGovernment(balances, hightJudge);                  currentLawVotesEndBalance.setVoteGeneralExecutiveDirector(primeMinisterVotes);                 currentLawVotesEndBalance.setVoteHightJudge(hightJudgeVotes);             }          }           return current;      }          //без учета палаты представителей     public static List<CurrentLawVotesEndBalance> filters(List<LawEligibleForParliamentaryApproval> approvalList, Map<String, Account> balances,                                                           List<Account> BoardOfShareholders, List<Block> blocks, int limitBlocks) throws IOException, NoSuchAlgorithmException, InvalidKeySpecException, SignatureException, NoSuchProviderException, InvalidKeyException {         //действующие законы чьи голоса больше ORIGINAL_LIMIT_MIN_VOTE         List<CurrentLawVotesEndBalance> current = new ArrayList<>();         Map<String, CurrentLawVotes> votesMap = null;         List<Account> accounts = balances.entrySet().stream().map(t -> t.getValue()).collect(Collectors.toList());         if (blocks.size() > limitBlocks) {             votesMap = UtilsCurrentLaw.calculateVotes(accounts, blocks.subList(blocks.size() - limitBlocks, blocks.size()));         } else {             votesMap = UtilsCurrentLaw.calculateVotes(accounts, blocks);         }          //подсчитать средннее количество раз сколько он проголосовал за         Map<String, Integer> yesAverage = UtilsCurrentLaw.calculateAverageVotesYes(votesMap);         //подсчитать среднее количество раз сколько он проголосовал против         Map<String, Integer> noAverage = UtilsCurrentLaw.calculateAverageVotesNo(votesMap);          for (LawEligibleForParliamentaryApproval lawEligibleForParliamentaryApproval : approvalList) {             if (votesMap.containsKey(lawEligibleForParliamentaryApproval.getLaws().getHashLaw())) {                 String address = lawEligibleForParliamentaryApproval.getLaws().getHashLaw();                 String packageName = lawEligibleForParliamentaryApproval.getLaws().getPacketLawName();                 List<String> laws = lawEligibleForParliamentaryApproval.getLaws().getLaws();                 double vote = votesMap.get(lawEligibleForParliamentaryApproval.getLaws().getHashLaw()).votes(balances, yesAverage, noAverage);                  CurrentLawVotesEndBalance currentLawVotesEndBalance = new CurrentLawVotesEndBalance(address, packageName, vote, 0, 0, 0, 0, 0, 0,  laws);                 current.add(currentLawVotesEndBalance);              }         }         return current;     }   }","package International_Trade_Union.model;   import lombok.Data; import International_Trade_Union.entity.DtoTransaction.DtoTransaction; import International_Trade_Union.utils.UtilsSecurity; import International_Trade_Union.utils.base.Base; import International_Trade_Union.utils.base.Base58; import International_Trade_Union.vote.Laws; import International_Trade_Union.vote.VoteEnum;  import java.io.IOException; import java.security.*; import java.security.spec.InvalidKeySpecException; import java.util.Objects;   @Data public class Account {     private String account;     private double digitalDollarBalance;     private double digitalStockBalance;       public Account(String account, double digitalDollarBalance) {         this(account, digitalDollarBalance, 0.0);      }      public Account(String account, double digitalDollarBalance, double digitalStockBalance) {         this.account = account;         this.digitalDollarBalance = digitalDollarBalance;         this.digitalStockBalance = digitalStockBalance;     }      public Account() {     }      @Override     public boolean equals(Object o) {         if (this == o) return true;         if (!(o instanceof Account)) return false;         Account account1 = (Account) o;         return getAccount().equals(account1.getAccount());     }      @Override     public int hashCode() {         return Objects.hash(getAccount());     }      private DtoTransaction sendMoney(String recipient, String privatekey, double digitalDollar, double digitalStock, Laws laws, double minerRewards, VoteEnum voteEnum) throws NoSuchAlgorithmException, InvalidKeySpecException, NoSuchProviderException, SignatureException, IOException, InvalidKeyException {          DtoTransaction transaction = null;         if (account.equals(recipient)){             System.out.println(\"sender %s, recipient %s cannot be equals! Error!\".format(account,recipient));             return transaction;         }              if(digitalDollarBalance < digitalDollar + minerRewards  ){                 System.out.println(\"sender don't have digitalDollar\");                 return transaction;             }             if(digitalStockBalance < digitalStock){                 System.out.println(\"sender don't have digitalReputation\");                 return transaction;             }             else{                 Base base = new Base58();                 PrivateKey privateKey = UtilsSecurity.privateBytToPrivateKey(base.decode(privatekey));                  transaction = new DtoTransaction(this.getAccount(), recipient, digitalDollar, digitalStock, laws, minerRewards, voteEnum);                 byte[] signGold = UtilsSecurity.sign(privateKey, transaction.toSign());                 transaction.setSign(signGold);             }         return transaction;     }  //      recipient - получатель //      gold сумма отправки, last Block - это послдний блок.     public DtoTransaction send(String recipient, String privateKey, double digitalDollar, double digitalReputation, Laws laws,  double minerRewards, VoteEnum voteEnum) throws NoSuchAlgorithmException, InvalidKeySpecException, SignatureException, IOException, NoSuchProviderException, InvalidKeyException {          return sendMoney(recipient,privateKey, digitalDollar, digitalReputation, laws, minerRewards, voteEnum);     }      }","package International_Trade_Union.model;  import International_Trade_Union.utils.UtilsSecurity; import International_Trade_Union.utils.base.Base; import International_Trade_Union.utils.base.Base58;  import java.security.InvalidAlgorithmParameterException; import java.security.NoSuchAlgorithmException; import java.security.NoSuchProviderException; import java.security.spec.InvalidKeySpecException; import java.util.HashMap; import java.util.Map;  public class CreateAccount {     public static Map<String, String> create() throws InvalidAlgorithmParameterException, NoSuchAlgorithmException, InvalidKeySpecException, NoSuchProviderException {         Map<String, String> create = new HashMap<>();         Base base = new Base58();         Keys keyPair = UtilsSecurity.generateKeyPair();         String pubkey = keyPair.getPubkey();         String privKey = keyPair.getPrivkey();         System.out.println(\"pubkey: \" + pubkey);         System.out.println(\"privKey: \" + privKey);         create.put(\"pubKey\", pubkey);         create.put(\"privKey\", privKey);         return create;     } }","package International_Trade_Union.model;  import International_Trade_Union.governments.Director; import lombok.AllArgsConstructor; import lombok.Data; import lombok.NoArgsConstructor;  @Data @AllArgsConstructor @NoArgsConstructor public class FIndPositonHelperData {     Director addressPosition;     boolean withLimited;     boolean electedWithStock;     boolean electedWithPrimeMinister;     boolean electedWithHousOfRepresentativies;     boolean electedWithChamberOfHightJudjes;  }","package International_Trade_Union.model;  import lombok.Data;  @Data public class Keys {     private String pubkey;     private String privkey;      public Keys(String pubkey, String privkey) {         this.pubkey = pubkey;         this.privkey = privkey;     } }","package International_Trade_Union.model;    import International_Trade_Union.config.BLockchainFactory; import International_Trade_Union.config.BlockchainFactoryEnum; import International_Trade_Union.entity.DtoTransaction.DtoTransaction; import International_Trade_Union.entity.blockchain.Blockchain; import International_Trade_Union.entity.blockchain.block.Block; import International_Trade_Union.governments.Director; import International_Trade_Union.governments.Directors; import International_Trade_Union.governments.UtilsGovernment; import International_Trade_Union.setings.Seting; import International_Trade_Union.utils.base.Base; import International_Trade_Union.utils.base.Base58; import International_Trade_Union.vote.Laws; import International_Trade_Union.vote.VoteEnum; import International_Trade_Union.utils.*;  import java.io.File; import java.io.IOException; import java.security.*; import java.security.spec.InvalidKeySpecException; import java.util.*; import java.util.stream.Collectors;  public class Mining {      public static Blockchain getBlockchain(String filename, BlockchainFactoryEnum factoryEnum) throws IOException, NoSuchAlgorithmException, InvalidKeySpecException, SignatureException, NoSuchProviderException, InvalidKeyException {          List<Block> blocks = UtilsBlock.readLineObject(filename);         Blockchain blockchain = null;         blockchain = BLockchainFactory.getBlockchain(factoryEnum);          if (blocks.size() != 0) {            blockchain.setBlockchainList(blocks);         }         return blockchain;     }      public static Map<String, Account> getBalances(String filename, Blockchain blockchain, Map<String, Account> balances) throws IOException, NoSuchAlgorithmException, SignatureException, InvalidKeySpecException, NoSuchProviderException, InvalidKeyException {         //start test           //папка чтобы проверить есть ли         File folder = new File(filename);         List<String> files = new ArrayList<>();         for (File file : folder.listFiles()) {             if(!file.isDirectory()){                 files.add(file.getAbsolutePath());             }         }          if (files.size() > 0 ){             File file = new File(files.get(files.size()-1));             if(file.exists() && file.length() > 0){                 balances = SaveBalances.readLineObject(filename);             }          }          if (balances == null) {             balances = new HashMap<>();         }          Block block;         if(blockchain != null && blockchain.sizeBlockhain() > 0){             block = blockchain.getBlock(blockchain.sizeBlockhain() - 1);             balances = UtilsBalance.calculateBalance(balances, block);           }           return balances;     }      public static void deleteFiles(String fileDelit) {         UtilsFileSaveRead.deleteAllFiles(fileDelit);     }       public static Block miningDay(             Account minner,             Blockchain blockchain,             long blockGenerationInterval,             int DIFFICULTY_ADJUSTMENT_INTERVAL,             List<DtoTransaction> transactionList,             Map<String, Account> balances,             long index     ) throws IOException, NoSuchAlgorithmException, SignatureException, InvalidKeySpecException, NoSuchProviderException, InvalidKeyException {         Directors directors = new Directors();         //получение транзакций с сети         List<DtoTransaction> listTransactions = transactionList;          //определение валидных транзакций         List<DtoTransaction> forAdd = new ArrayList<>();          //проверяет целостность транзакции, что они подписаны правильно         cicle:         for (DtoTransaction transaction : listTransactions) {             if (transaction.verify()) {                  Account account = balances.get(transaction.getSender());                 if (account == null) {                     System.out.println(\"minerAccount null\");                     continue cicle;                 }                 //NAME_LAW_ADDRESS_START если адресс  означает правила выбранные сетью                 if(transaction.getCustomer().startsWith(Seting.NAME_LAW_ADDRESS_START) && !balances.containsKey(transaction.getCustomer())){                     //если в названия закона совпадает с корпоративными должностями, то закон является действительным только когда                     //отправитель совпадает с законом //                    List<Director> enumPosition = directors.getDirectors();                     List<String> corporateSeniorPositions = directors.getDirectors().stream()                             .map(t->t.getName()).collect(Collectors.toList());                     System.out.println(\"LawsController: create_law: \" + transaction.getLaws().getPacketLawName()                             + \"contains: \" + corporateSeniorPositions.contains(transaction.getLaws().getPacketLawName()));                     if(corporateSeniorPositions.contains(transaction.getLaws().getPacketLawName())                             && !UtilsGovernment.checkPostionSenderEqualsLaw(transaction.getSender(), transaction.getLaws())){                         System.out.println(\"if your create special corporate position, you need \" +                                 \"sender to be equals with first law: now its wrong\");                         continue cicle;                     }                 }                 if(transaction.getLaws() == null){                     System.out.println(\"law cannot to be null: \");                     continue cicle;                 }                  if (account != null) {                     if(transaction.getSender().equals(Seting.BASIS_ADDRESS)){                         System.out.println(\"only this miner can input basis adress in this block\");                         continue cicle;                     }                     if(transaction.getCustomer().equals(Seting.BASIS_ADDRESS)){                         System.out.println(\"basis address canot to be customer(recipient)\");                         continue cicle;                     }                      if( account.getDigitalDollarBalance() < transaction.getDigitalDollar() + transaction.getBonusForMiner()){                         System.out.println(\"sender don't have digital dollar: \" + account.getAccount() + \" balance: \" + account.getDigitalDollarBalance() );                         System.out.println(\"digital dollar for send: \" + (transaction.getDigitalDollar() + transaction.getBonusForMiner()));                         continue cicle;                     }                     if (account.getDigitalStockBalance() < transaction.getDigitalStockBalance()){                         System.out.println(\"sender don't have digital reputation: \" + account.getAccount() + \" balance: \" + account.getDigitalStockBalance());                         System.out.println(\"digital reputation for send: \" + (transaction.getDigitalDollar() + transaction.getBonusForMiner()));                         continue cicle;                     }                     if(transaction.getSender().equals(transaction.getCustomer()) ){                         System.out.println(\"sender end recipient equals \" + transaction.getSender() + \" : recipient: \" + transaction.getCustomer());                         continue cicle;                     }                     forAdd.add(transaction);                 }              }         }           //доход майнера         double minerRewards = Seting.DIGITAL_DOLLAR_REWARDS_BEFORE;         double digitalReputationForMiner = Seting.DIGITAL_STOCK_REWARDS_BEFORE;          //доход основателя         double founderReward = Seting.DIGITAL_DOLLAR_FOUNDER_REWARDS_BEFORE;         double founderDigigtalReputationReward = Seting.DIGITAL_REPUTATION_FOUNDER_REWARDS_BEFORE;          Base base = new Base58();          //суммирует все вознаграждения майнеров         PrivateKey privateKey = UtilsSecurity.privateBytToPrivateKey(base.decode(Seting.BASIS_PASSWORD));         double sumRewards = forAdd.stream().collect(Collectors.summingDouble(DtoTransaction::getBonusForMiner));          //вознаграждения майнера         DtoTransaction minerRew = new DtoTransaction(Seting.BASIS_ADDRESS, minner.getAccount(),                 minerRewards, digitalReputationForMiner, new Laws(), sumRewards, VoteEnum.YES );          //подписывает         byte[] signGold = UtilsSecurity.sign(privateKey, minerRew.toSign());         minerRew.setSign(signGold);          //вознаграждение основателя         DtoTransaction founderRew = new DtoTransaction(Seting.BASIS_ADDRESS, blockchain.getADDRESS_FOUNDER(),                 founderReward, founderDigigtalReputationReward, new Laws(), 0.0, VoteEnum.YES);         byte[] signFounder = UtilsSecurity.sign(privateKey, founderRew.toSign());          founderRew.setSign(signFounder);           forAdd.add(minerRew);         forAdd.add(founderRew);           //определение сложности и создание блока         int difficulty = UtilsBlock.difficulty(blockchain.getBlockchainList(), blockGenerationInterval, DIFFICULTY_ADJUSTMENT_INTERVAL);          System.out.println(\"Mining: miningBlock: difficulty: \" + difficulty + \" index: \" + index);           //blockchain.getHashBlock(blockchain.sizeBlockhain() - 1)         Block block = new Block(                 forAdd,                 blockchain.getHashBlock(blockchain.sizeBlockhain() - 1),                 minner.getAccount(),                 blockchain.getADDRESS_FOUNDER(),                 difficulty,                 index);          return block;     } }","package International_Trade_Union.model;  import International_Trade_Union.setings.Seting; import International_Trade_Union.utils.UtilsFileSaveRead;  import java.io.FileNotFoundException;   public class User {     private static String addressMiner=\"\";      public static void setUserAddress(String addressMiner) { //        System.out.println(\"change minerAccount: \" + addressMiner); //        UtilsFileSaveRead.save(addressMiner, Seting.ORIGINAL_ACCOUNT, false);         User.addressMiner = addressMiner;     }      public static String getUserAddress() throws FileNotFoundException {         addressMiner = UtilsFileSaveRead.read(Seting.ORIGINAL_ACCOUNT);         System.out.println(\"user: \" + addressMiner);         if(addressMiner.isEmpty() || addressMiner == null)             addressMiner = \"empty \";         return addressMiner;     } }","package International_Trade_Union.network;  import International_Trade_Union.entity.DtoTransaction.DtoTransaction; import International_Trade_Union.model.Mining; import International_Trade_Union.setings.Seting; import International_Trade_Union.utils.*; import org.json.JSONException;  import java.io.File; import java.io.IOException; import java.security.InvalidKeyException; import java.security.NoSuchAlgorithmException; import java.security.NoSuchProviderException; import java.security.SignatureException; import java.security.spec.InvalidKeySpecException; import java.util.ArrayList; import java.util.List; import java.util.stream.Collectors;  public class AllTransactions {     private static List<DtoTransaction> instance = new ArrayList<>();     //все транзакции которые уже добавлены в блок, нужно чтобы повторно     //не добавлялись в блок если они скачены с дисковери.     private static List<DtoTransaction> sendedTransaction = new ArrayList<>();      public static List<DtoTransaction> readFrom() throws IOException, NoSuchAlgorithmException, InvalidKeySpecException, SignatureException, NoSuchProviderException, InvalidKeyException {         return UtilsTransaction.readLineObject(Seting.ORGINAL_ALL_TRANSACTION_FILE);     }      public static synchronized List<DtoTransaction> getInstance() throws IOException, NoSuchAlgorithmException, InvalidKeySpecException, SignatureException, NoSuchProviderException, InvalidKeyException {         if (instance == null) {             instance = new ArrayList<>();         }         instance = new ArrayList<>();          //считываем с пула транзакции из дисковери.         for (String s : Seting.ORIGINAL_ADDRESSES) {             try {                 String json = UtilUrl.readJsonFromUrl(s + \"/getTransactions\");                 List<DtoTransaction> list = UtilsJson.jsonToDtoTransactionList(json);                  instance.addAll(list);               } catch (IOException | JSONException e) {                  System.out.println(\"AllTransaction: getInstance: Error\");                 continue;             }           }          instance.addAll(UtilsTransaction.readLineObject(Seting.ORGINAL_ALL_TRANSACTION_FILE));         instance = instance.stream().distinct().collect(Collectors.toList());          sendedTransaction = getInsanceSended();          instance.removeAll(sendedTransaction);         return instance;     }      public static synchronized void clearAllTransaction() {         instance = new ArrayList<>();         Mining.deleteFiles(Seting.ORGINAL_ALL_TRANSACTION_FILE);     }      public static synchronized void clearAllSendedTransaction(long index) {         if(index % (Seting.COUNT_BLOCK_IN_DAY * Seting.DAY_DELETED_SENDED_FILE) == 0){             sendedTransaction = new ArrayList<>();             Mining.deleteFiles(Seting.ORIGINAL_ALL_SENDED_TRANSACTION_FILE);             System.out.println(\"clear delete sended transaction\");         }      }      public static synchronized void clearUsedTransaction(List<DtoTransaction> transactions) throws IOException, NoSuchAlgorithmException, SignatureException, InvalidKeySpecException, NoSuchProviderException, InvalidKeyException {         instance = getInstance();         List<DtoTransaction> temporaryDto = new ArrayList<>();          instance = temporaryDto;         instance.removeAll(transactions);         Mining.deleteFiles(Seting.ORGINAL_ALL_TRANSACTION_FILE);         for (DtoTransaction dtoTransaction : instance) {              UtilsTransaction.saveAllTransaction(dtoTransaction, Seting.ORGINAL_ALL_TRANSACTION_FILE);         }       }      public static synchronized void addTransaction(DtoTransaction transaction) throws IOException, NoSuchAlgorithmException, SignatureException, InvalidKeySpecException, NoSuchProviderException, InvalidKeyException {          instance = getInstance();         instance.add(transaction);         Mining.deleteFiles(Seting.ORGINAL_ALL_TRANSACTION_FILE);         instance = instance.stream().filter(UtilsUse.distinctByKey(DtoTransaction::toSign)).collect(Collectors.toList());         for (DtoTransaction dtoTransaction : instance) {             UtilsTransaction.saveAllTransaction(dtoTransaction, Seting.ORGINAL_ALL_TRANSACTION_FILE);         }       }      public static synchronized void addSendedTransaction(List<DtoTransaction> transactions) throws IOException, NoSuchAlgorithmException, InvalidKeySpecException, SignatureException, NoSuchProviderException, InvalidKeyException {         sendedTransaction = getInsanceSended();         sendedTransaction.addAll(transactions);          Mining.deleteFiles(Seting.ORIGINAL_ALL_SENDED_TRANSACTION_FILE);         for (DtoTransaction dtoTransaction : sendedTransaction) {             UtilsTransaction.saveAllTransaction(dtoTransaction, Seting.ORIGINAL_ALL_SENDED_TRANSACTION_FILE);         }          System.out.println(\"AllTransaction: addSendedTransaction: \" + sendedTransaction.size());      }      public static List<DtoTransaction> getInsanceSended() throws IOException, NoSuchAlgorithmException, InvalidKeySpecException, SignatureException, NoSuchProviderException, InvalidKeyException {         if (sendedTransaction == null) {             sendedTransaction = new ArrayList<>();         }         sendedTransaction = UtilsTransaction.readLineObject(Seting.ORIGINAL_ALL_SENDED_TRANSACTION_FILE);         sendedTransaction = sendedTransaction.stream().distinct().collect(Collectors.toList());         return sendedTransaction;     }  }","package International_Trade_Union.network;    import International_Trade_Union.entity.DtoTransaction.DtoTransaction;  import java.util.ArrayList; import java.util.List;  public class Transactions {     public  List<DtoTransaction> getTransactions() {         List<DtoTransaction> transactions = new ArrayList<>();         return transactions;     } }","package International_Trade_Union.node;  import java.util.HashSet; import java.util.Set;  public class Nodes {      public int size(){         return urlAddress.size();     }      public Nodes() {         this.urlAddress = new HashSet<>();     }      public Nodes(Set<String> urlAddress) {         this.urlAddress = urlAddress;     }      private  Set<String> urlAddress = new HashSet<>();      public  void setUrlAddress(Set<String> urlAddress) {         this.urlAddress = urlAddress;     }     public void addAddress(String addressUrl){         urlAddress.add(addressUrl);     }      public  Set<String> getUrlAddresses() {         return urlAddress;     }      public void clear(){         urlAddress = new HashSet<>();     } }","package International_Trade_Union.setings;  import International_Trade_Union.about_usDraft.AboutUsDraft; import International_Trade_Union.about_us_engDraft.AboutUsEngDraft; import International_Trade_Union.CorporateCharterEngDraft.CorporateCharter; import International_Trade_Union.governments.Directors; import International_Trade_Union.governments.NamePOSITION; import International_Trade_Union.utils.UtilsUse;  import java.util.Set;  public interface Seting {     // значение используется для вычисления процентов     int HUNDRED_PERCENT = 100;     // значение используется как константа года,     // в данной системе отсутствует високосный год     int YEAR = 360;      Directors directors = new Directors();       //используется для очистки из файла, где хранятся отправленные транзакции,     //чтобы предотвратить добавление повторно уже отправленных транзакций     int DAY_DELETED_SENDED_FILE = 3;        //За какой период последних блоков учитывать для отбора акционеров.     //Акционерами могут быть только с наибольшим количеством баланса     //отправители и майнеры.     int BOARDS_BLOCK = (int) (Seting.COUNT_BLOCK_IN_DAY * YEAR);       //минимальное значение количество положительных голосов, для того чтобы избрать     // Совет Директоров и Совет Корпоративных Верховных Судей,     int ORIGINAL_LIMIT_MIN_VOTE = 1; //(int) (200 * Seting.COUNT_BLOCK_IN_DAY * 1 / 8);       //прямая демократия, сколько голосов нужно, чтобы правило вступило в силу,     //без необходимости правительства     double ALL_STOCK_VOTE = 100000.0;        //Минимальное значение чтобы Совет Корпоративных Верховных Судей могла избрать Верховного Судью     int ORIGINAL_LIMIT_MIN_VOTE_CORPORATE_COUNCIL_OF_REFEREES = 3;      //Минимальное значение остатка голосов чтобы Совет директоров утверждал бюджет,     //стратегический план, в создании новых должностей и назначении новых должностей,     //и т.д. Также участвовал в утверждении законов, вместе с другими участниками.     int ORIGINAL_LIMIT_MIN_VOTE_BOARD_OF_DIRECTORS = 15;//15;      //Минимальное количество остатка голосов чтобы Совет Акционеров     //утверждал вместе с остальными участниками в утверждении законов.     int ORIGINAL_LIMIT_MIN_VOTE_BOARD_OF_SHAREHOLDERS = 100; //100;      //голос Генерального Исполнительного Директора     int ORIGINAL_LIMIT_MIN_VOTE_GENERAL_EXECUTIVE_DIRECTOR = 1;      //голос Верховного Судьи     int ORIGINAL_LIMIT_MIN_VOTE_HIGHT_JUDGE = 1;      //для преодоления верховного судьи, если Верховный Судья не одобрил закон     //то нужно получить в два раза больше голосов, чтобы преодолеть вето Верховного Судьи     int POWERFUL_VOTE = 2;      //данная мера нужна чтобы если один счет голосует за несколько кандидатов,     //его голос не делился равномерно, а становился значительно сильнее,     //чтобы не допустить монополии, если очень богатый человек захочет должностные лица поставить к власти     //то он не сможет пример: счет X проголосовал ЗА = 2 закона и ПРОТИВ = 3 закона     //100 = voteYES, 100 = voteNO, voteYES / (2^3) = 12.5 , voteNO / (3^3) = 3.7     //таким образом чем больше голосует, тем меньше голосов остается для избрания     //должностных лиц, это защита от сверхбогатых участников Совета Акционеров     int POWERING_FOR_VOTING = 3;       //голос должностных лиц,     int VOTE_GOVERNMENT = 1;     //голос должностных лиц вместо акций учитывается только один     //голос, как будто у них одна акция     double STOCK_VOTE_GOVERNMENT = 1;      //    процент который получает основатель от добычи     Double FOUNDERS_REWARD = 2.0;      //address for send rewards     String BASIS_ADDRESS = \"faErFrDnBhfSfNnj1hYjxydKNH28cRw1PBwDQEXH3QsJ\";     String BASIS_PASSWORD = \"3hupFSQNWwiJuQNc68HiWzPgyNpQA2yy9iiwhytMS7rZyfPddNRwtvExeevhayzN6xL2YmTXN6NCA8jBhV9ge1w8KciHedGUMgZyq2T7rDdvekVNwEgf5pQrELv8VAEvQ4Kb5uviXJFuMyuD1kRAGExrZym5nppyibEVnTC9Uiw8YzUh2JmVT9iUajnVV3wJ5foMs\";      //сложность коррекция каждые n блоков     int DIFFICULTY_ADJUSTMENT_INTERVAL = (int) (Seting.COUNT_BLOCK_IN_DAY / 2);     int DIFFICULTY_ADJUSTMENT_INTERVAL_TEST = 10;      long BLOCK_GENERATION_INTERVAL = Seting.BLOCK_TIME * 1000;// after Seting.BLOCK_TIME     long BLOCK_GENERATION_INTERVAL_TEST = 0 * 1000;       long INTERVAL_TARGET = 600000;     long INTERVAL_TARGET_TEST = 25000;      // плата за обслуживание каждые 6 месяцев.     Double ANNUAL_MAINTENANCE_FREE_DIGITAL_DOLLAR_YEAR = 0.2;     //отрицательная ставка для цифровой акции     double ANNUAL_MAINTENANCE_FREE_DIGITAL_STOCK_YEAR = 0.4;     //каждые сколько месяцев снимать     int HALF_YEAR = 2;      //стоимость создания закона 5     double COST_LAW = 5;     //с чего начинается адрес пакета закона     //сокращенно корпорация     String NAME_LAW_ADDRESS_START = \"LIBER\";      int HASH_COMPLEXITY_GENESIS = 1;      //совет акционеров    int BOARD_OF_SHAREHOLDERS = 1500;      //ПОПРАВКА В УСТАВЕ    //требования к поправкам     String AMENDMENT_TO_THE_CHARTER = \"AMENDMENT_TO_THE_CHARTER\";      //директора созданные Советом директоров     String ADD_DIRECTOR = \"ADD_DIRECTOR\";      //бюджет должен формировать только палата представителей     String BUDGET = \"BUDGET\";      //план также утверждается на четыре года и утверждается только палатой представителей     //каждый план обязан содержать дату начала планирования с какого числа вступает в силу.     //FOUR-YEAR PLAN     String STRATEGIC_PLAN = \"STRATEGIC_PLAN\";       //лимиты для ведения поправок     //палата судей минимум 5 голосов     int ORIGINAL_LIMIT_MIN_VOTE_CORPORATE_COUNCIL_OF_REFEREES_AMENDMENT = 5;// 5;     //палата представителей 20% голосов     int ORIGINAL_LIMIT_MIN_VOTE_BOARD_OF_DIRECTORS_AMENDMENT =            directors.getDirector(NamePOSITION.BOARD_OF_DIRECTORS.toString()).getCount() * 20 / 100;      //Совет акционеров минимум 20% голосов     int ORIGINAL_LIMIT_MINT_VOTE_BOARD_OF_SHAREHOLDERS_AMENDMENT = BOARD_OF_SHAREHOLDERS * 20 / 100;       //    адресс основателя: здесь будет мой адрес. Сейчас заглушка     String ADDRESS_FOUNDER_TEST = \"stExZb8ifLfnFoq4JJuTifpAcscegATH8znhwW26zyTa\";     String ADDRESS_FOUNDER = \"stExZb8ifLfnFoq4JJuTifpAcscegATH8znhwW26zyTa\";      String CORPORATE_CHARTER_DRAFT = International_Trade_Union.CorporateCharterDraft.CorporateCharter.getAllConstitution() + \"\\n\" + CorporateCharter.getAllConstitution() + AboutUsDraft.getAboutUs()             + AboutUsEngDraft.getAboutUs();      //КЛЮЧЕВОЕ НАЗВАНИЕ ПАКЕТА ЧТО ЭТО УСТАВ, ДЕЙСТВУЮЩИЙ УСТАВ ПОДПИСАН ОСНОВАТЕЛЕМ.     String ORIGINAL_CHARTER_CURRENT_LAW_PACKAGE_NAME = \"ORIGINAL_CHARTER_CURRENT_LAW_PACKAGE_NAME\";      //КЛЮЧЕВОЕ НАЗВАНИЕ ДЛЯ КОДА КОТОРЫЙ СОПРОВОЖДАЕТСЯ С УСТАВОМ     String ORIGINAL_CHARTER_CURRENT_ALL_CODE = \"ORIGINAL_CHARTER_CURRENT_ALL_CODE\";      //начальная сумма основателя     Double FOUNDERS_REMUNERATION_DIGITAL_DOLLAR = 30000000.0;     double FOUNDERS_REMNUNERATION_DIGITAL_STOCK = 30000000.0;       // сколько секунд в сутках     int DAY_SECOND = 86400;      //    за сколько секунд добывается каждый блок     int BLOCK_TIME = 150;       //сколько блоков добывается в сутки     double COUNT_BLOCK_IN_DAY = (DAY_SECOND / BLOCK_TIME);      //подсчет голосов для должности в годах, учитываются только те голоса     //которые не позже четырех лет для законов и должностей,     //голоса отданные за законы должны обновляться каждые четыре года     //как и за должности     int POSITION_YEAR_VOTE = (int) Seting.COUNT_BLOCK_IN_DAY * YEAR * 4;     //подсчет голосов для законов в годах     int LAW_YEAR_VOTE = (int) Seting.COUNT_BLOCK_IN_DAY * YEAR * 4;      String ORIGINAL_BLOCKCHAIN_FILE = \"C:\\\\resources\\\\blockchain\\\\\";     String ORIGINAL_BALANCE_FILE = \"C:\\\\resources\\\\balance\\\\\";     String ORIGINAL_BOARD_0F_SHAREHOLDERS_FILE = \"C:\\\\resources\\\\federalGovernment\\\\federalGovernment.txt\";     String ORIGINAL_ALL_CORPORATION_LAWS_FILE = \"C:\\\\resources\\\\federalLaws\\\\\";     String ORIGINAL_ACCOUNT = \"C:\\\\resources\\\\minerAccount\\\\minerAccount.txt\";     String ORIGINAL_CORPORATE_VOTE_FILE = \"C:\\\\resources\\\\vote\\\\\";      String ORIGINAL_ALL_CORPORATION_LAWS_WITH_BALANCE_FILE = \"C:\\\\resources\\\\allLawsWithBalance\\\\\";     String ORGINAL_ALL_TRANSACTION_FILE = \"C:\\\\resources\\\\transactions\\\\\";     String ORIGINAL_ALL_SENDED_TRANSACTION_FILE = \"C:\\\\resources\\\\sendedTransaction\\\\\";     String ORIGINAL_POOL_URL_ADDRESS_FILE = \"C:\\\\resources\\\\poolAddress\\\\\";      //адресса внешних сервисов     Set<String> ORIGINAL_ADDRESSES = Set.of(\"http://194.87.236.238:80\");       int SIZE_FILE_LIMIT = 100;      //папки файла для тестирования с сохранениям файла     String TEST_LAST_BLOCK = \".\\\\src\\\\test\\\\java\\\\unitted_states_of_mankind\\\\resourceTestingFileSaved\\\\lastBlock\\\\\";     String INDEX_TEST = \".\\\\src\\\\test\\\\java\\\\unitted_states_of_mankind\\\\resourceTestingFileSaved\\\\index\\\\index.txt\";     String TEST_BLOCKCHAIN_SAVED = \".\\\\src\\\\test\\\\java\\\\unitted_states_of_mankind\\\\resourceTestingFileSaved\\\\network\\\\\";     String TEST_BLOCKCHAIN_BALANCES = \".\\\\src\\\\test\\\\java\\\\unitted_states_of_mankind\\\\resourceTestingFileSaved\\\\balances\\\\\";     String TEST_FEDERAL_GOVERNMENT = \".\\\\src\\\\test\\\\java\\\\unitted_states_of_mankind\\\\resourceTestingFileSaved\\\\federal government\\\\federalGovernment.txt\";     String TEST_FEDERAL_LAWS = \".\\\\src\\\\test\\\\java\\\\unitted_states_of_mankind\\\\resourceTestingFileSaved\\\\laws\\\\\";     String TEST_CURRENT_LAWS = \".\\\\src\\\\test\\\\java\\\\unitted_states_of_mankind\\\\resourceTestingFileSaved\\\\current laws\\\\\";     String TEST_FEDERAL_VOTE = \".\\\\src\\\\test\\\\java\\\\unitted_states_of_mankind\\\\resourceTestingFileSaved\\\\vote\\\\\";     String TEST_ALL_FEDERAL_LAWS_WITH_BALANCE_FILE = \".\\\\src\\\\test\\\\java\\\\unitted_states_of_mankind\\\\resourceTestingFileSaved\\\\allLawsWithBalance\\\\\";      //Временный блокчейн для тестирования     String TEST_LAST_BLOCK_TEMPORARY = \".\\\\src\\\\test\\\\java\\\\unitted_states_of_mankind\\\\resourceTestingFileWithoutSave\\\\lastBlock\\\\\";     String TEST_INDEX_TEMPORARY = \".\\\\src\\\\test\\\\java\\\\unitted_states_of_mankind\\\\resourceTestingFileWithoutSave\\\\index\\\\index.txt\";     String TEST_TEMPORARY_BLOCKCHAIN = \".\\\\src\\\\test\\\\java\\\\unitted_states_of_mankind\\\\resourceTestingFileWithoutSave\\\\temporary blockchain\\\\\";     String TEST_BLOCKCHAIN_BALANCES_TEMPORARY = \".\\\\src\\\\test\\\\java\\\\unitted_states_of_mankind\\\\resourceTestingFileWithoutSave\\\\balances\\\\\";     String TEST_FEDERAL_GOVERNMENT_TEMPORARY = \".\\\\src\\\\test\\\\java\\\\unitted_states_of_mankind\\\\resourceTestingFileWithoutSave\\\\federal government\\\\federalGovernment.txt\";     String TEST_FEDERAL_LAWS_TEMPORARY = \".\\\\src\\\\test\\\\java\\\\unitted_states_of_mankind\\\\resourceTestingFileWithoutSave\\\\laws\\\\\";     String TEST_CURRENT_LAWS_TEMPORARY = \".\\\\src\\\\test\\\\java\\\\unitted_states_of_mankind\\\\resourceTestingFileWithoutSave\\\\current laws\\\\\";     String TEST_FEDERAL_VOTE_TEMPORARY = \".\\\\src\\\\test\\\\java\\\\unitted_states_of_mankind\\\\resourceTestingFileSaved\\\\vote\\\\\";     String TEST_ALL_FEDERAL_LAWS_WITH_BALANCE_TEMPORARY = \".\\\\unitedStates\\\\src\\\\test\\\\java\\\\unitted_states_of_mankind\\\\resourceTestingFileWithoutSave\\\\allLawsWithBalance\\\\\";      String TEST_FILE_WRITE_INFO = \".\\\\src\\\\test\\\\java\\\\unitted_states_of_mankind\\\\blockchainTwentyYearTest\\\\\";     double DIGITAL_DOLLAR_REWARDS_BEFORE = 200.0;     double DIGITAL_STOCK_REWARDS_BEFORE = 200.0;     double DIGITAL_DOLLAR_FOUNDER_REWARDS_BEFORE = Math.round(UtilsUse.countPercents(Seting.DIGITAL_DOLLAR_REWARDS_BEFORE, Seting.FOUNDERS_REWARD));     double DIGITAL_REPUTATION_FOUNDER_REWARDS_BEFORE = Math.round(UtilsUse.countPercents(Seting.DIGITAL_STOCK_REWARDS_BEFORE, Seting.FOUNDERS_REWARD));    }","package International_Trade_Union.sheduled;  import org.springframework.context.annotation.Configuration; import org.springframework.scheduling.annotation.EnableScheduling;  @EnableScheduling @Configuration public class SchedulerConfig { }","package International_Trade_Union.utils.base;  public interface Base {     String encode(byte[] input);     byte[] decode(String input); }","package International_Trade_Union.utils.base;    /*  * Copyright 2011 Google Inc.  * Copyright 2018 Andreas Schildbach  *  * From https://github.com/bitcoinj/bitcoinj/blob/master/core/src/main/java/org/bitcoinj/core/Base58.java  *  * Licensed under the Apache License, Version 2.0 (the \"License\");  * you may not use this file except in compliance with the License.  * You may obtain a copy of the License at  *  *    http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an \"AS IS\" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */  import java.math.BigInteger; import java.util.Arrays;  /**  * Base58 is a way to encode Bitcoin addresses (or arbitrary data) as alphanumeric strings.  * <p>  * Note that this is not the same base58 as used by Flickr, which you may find referenced around the Internet.  * <p>  * Satoshi explains: why base-58 instead of standard base-64 encoding?  * <ul>  * <li>Don't want 0OIl characters that look the same in some fonts and  *     could be used to create visually identical looking minerAccount numbers.</li>  * <li>A string with non-alphanumeric characters is not as easily accepted as an minerAccount number.</li>  * <li>E-mail usually won't line-break if there's no punctuation to break at.</li>  * <li>Doubleclicking selects the whole number as one word if it's all alphanumeric.</li>  * </ul>  * <p>  * However, note that the encoding/decoding runs in O(n&sup2;) time, so it is not useful for large data.  * <p>  * The basic idea of the encoding is to treat the data bytes as a large number represented using  * base-256 digits, convert the number to be represented using base-58 digits, preserve the exact  * number of leading zeros (which are otherwise lost during the mathematical operations on the  * numbers), and finally represent the resulting base-58 digits as alphanumeric ASCII characters.  */ public class Base58 implements Base {     public static final char[] ALPHABET = \"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz\".toCharArray();     private static final char ENCODED_ZERO = ALPHABET[0];     private static final int[] INDEXES = new int[128];     static {         Arrays.fill(INDEXES, -1);         for (int i = 0; i < ALPHABET.length; i++) {             INDEXES[ALPHABET[i]] = i;         }     }      /**      * Encodes the given bytes as a base58 string (no checksum is appended).      *      * @param input the bytes to encode      * @return the base58-encoded string      */     public String encode(byte[] input) {         if (input.length == 0) {             return \"\";         }         // Count leading zeros.         int zeros = 0;         while (zeros < input.length && input[zeros] == 0) {             ++zeros;         }         // Convert base-256 digits to base-58 digits (plus conversion to ASCII characters)         input = Arrays.copyOf(input, input.length); // since we modify it in-place         char[] encoded = new char[input.length * 2]; // upper bound         int outputStart = encoded.length;         for (int inputStart = zeros; inputStart < input.length; ) {             encoded[--outputStart] = ALPHABET[divmod(input, inputStart, 256, 58)];             if (input[inputStart] == 0) {                 ++inputStart; // optimization - skip leading zeros             }         }         // Preserve exactly as many leading encoded zeros in output as there were leading zeros in input.         while (outputStart < encoded.length && encoded[outputStart] == ENCODED_ZERO) {             ++outputStart;         }         while (--zeros >= 0) {             encoded[--outputStart] = ENCODED_ZERO;         }         // Return encoded string (including encoded leading zeros).         return new String(encoded, outputStart, encoded.length - outputStart);     }      /**      * Decodes the given base58 string into the original data bytes.      *      * @param input the base58-encoded string to decode      * @return the decoded data bytes      */     public byte[] decode(String input) {         if (input.length() == 0) {             return new byte[0];         }         // Convert the base58-encoded ASCII chars to a base58 byte sequence (base58 digits).         byte[] input58 = new byte[input.length()];         for (int i = 0; i < input.length(); ++i) {             char c = input.charAt(i);             int digit = c < 128 ? INDEXES[c] : -1;             if (digit < 0) {                 throw new IllegalStateException(\"InvalidCharacter in base 58\");             }             input58[i] = (byte) digit;         }         // Count leading zeros.         int zeros = 0;         while (zeros < input58.length && input58[zeros] == 0) {             ++zeros;         }         // Convert base-58 digits to base-256 digits.         byte[] decoded = new byte[input.length()];         int outputStart = decoded.length;         for (int inputStart = zeros; inputStart < input58.length; ) {             decoded[--outputStart] = divmod(input58, inputStart, 58, 256);             if (input58[inputStart] == 0) {                 ++inputStart; // optimization - skip leading zeros             }         }         // Ignore extra leading zeroes that were added during the calculation.         while (outputStart < decoded.length && decoded[outputStart] == 0) {             ++outputStart;         }         // Return decoded data (including original number of leading zeros).         return Arrays.copyOfRange(decoded, outputStart - zeros, decoded.length);     }      public  BigInteger decodeToBigInteger(String input) {         return new BigInteger(1, decode(input));     }      /**      * Divides a number, represented as an array of bytes each containing a single digit      * in the specified base, by the given divisor. The given number is modified in-place      * to contain the quotient, and the return value is the remainder.      *      * @param number the number to divide      * @param firstDigit the index within the array of the first non-zero digit      *        (this is used for optimization by skipping the leading zeros)      * @param base the base in which the number's digits are represented (up to 256)      * @param divisor the number to divide by (up to 256)      * @return the remainder of the division operation      */     private byte divmod(byte[] number, int firstDigit, int base, int divisor) {         // this is just long division which accounts for the base of the input digits         int remainder = 0;         for (int i = firstDigit; i < number.length; i++) {             int digit = (int) number[i] & 0xFF;             int temp = remainder * base + digit;             number[i] = (byte) (temp / divisor);             remainder = temp % divisor;         }         return (byte) remainder;     } }","package International_Trade_Union.utils;    import International_Trade_Union.setings.Seting; import International_Trade_Union.model.Account;  import java.io.File; import java.io.IOException; import java.security.InvalidKeyException; import java.security.NoSuchAlgorithmException; import java.security.NoSuchProviderException; import java.security.SignatureException; import java.security.spec.InvalidKeySpecException; import java.util.ArrayList; import java.util.List; import java.util.Map; import java.util.stream.Collectors;  public class SaveBalances {      public static void saveBalances(Map<String, Account> balances, String filename) throws IOException, NoSuchAlgorithmException, SignatureException, InvalidKeySpecException, NoSuchProviderException, InvalidKeyException {         int fileLimit = Seting.SIZE_FILE_LIMIT * 1024 * 1024;          //папка чтобы проверить есть ли         File folder = new File(filename);         List<String> files = new ArrayList<>();         for (File file : folder.listFiles()) {             if(!file.isDirectory()){                 files.add(file.getAbsolutePath());             }         }          int count = 0;         files = files.stream().sorted().collect(Collectors.toList());         String nextFile = \"\";          if (files.size() > 0) {             nextFile = files.get(files.size()-1);              count = Integer.parseInt(nextFile.replaceAll(\"[^\\\\d]\", \"\"));           }          File file = new File(nextFile);          if(file.length() >= fileLimit){             count++;          }          nextFile = filename + count + \".txt\";          List<String> jsons = new ArrayList<>();         for (Map.Entry<String, Account> stringAccountEntry : balances.entrySet()) {             String json = UtilsJson.objToStringJson(stringAccountEntry.getValue());             jsons.add(json);         }  //        String json = UtilsJson.objToStringJson(minerAccount); //        UtilsFileSaveRead.save(json + \"\\n\", nextFile);         UtilsFileSaveRead.saves(jsons, nextFile, true);      }      public static Map<String, Account> readLineObject(String filename ) throws IOException, NoSuchAlgorithmException, InvalidKeySpecException, SignatureException, NoSuchProviderException, InvalidKeyException {         List<Account> accounts = new ArrayList<>();         File folder = new File(filename);         for (final File fileEntry : folder.listFiles()) {             if (fileEntry.isDirectory()) {                 System.out.println(\"is directory \" + fileEntry.getAbsolutePath());             } else {                 List<String> list = UtilsFileSaveRead.reads(fileEntry.getAbsolutePath());                 for (String s : list) {                    Account account = UtilsJson.jsonToAccount(s);                     accounts.add(account);                 }              }         }         Map<String, Account> balances = accounts                 .stream()                 .collect(Collectors.toMap(Account::getAccount, t->t, (v1, v2) -> v1));         return balances;     } }","package International_Trade_Union.utils;    import International_Trade_Union.model.Account; import International_Trade_Union.setings.Seting;  import java.util.ArrayList; import java.util.List;  public class UtilAccounts {  //    поиск аккаунта по адрессу     public static Account serchAccountByAddress(List<Account> accountList, String address){         Account result = null;         for (Account account : accountList) {             if(account.getAccount().equals(address)){                 result = account; //                System.out.println(String.format(\"find minerAccount: %s, address %s\", minerAccount.getAccount(), address));                 return result;             }         }         return result;     } //    возвращает список счетов чья наличность больше n     public static List<Account> allAccountsRemnantUpperLimit(              List<Account> accountList, double bottomLineMoney){         List<Account> accounts = new ArrayList<>();                  for (Account account : accountList) {                      if(account.getDigitalDollarBalance()>bottomLineMoney)                         accounts.add(account);                 }               return accounts;     }  //    подсчитывает общий баланс всех участников     public static double getAllBalance( List<Account> accountList){         double allBalance = 0.0;              for (Account account : accountList) {                 if(!account.getAccount().equals(Seting.BASIS_ADDRESS))                     allBalance+=account.getDigitalDollarBalance();             }           return allBalance;     }     }","package International_Trade_Union.utils;  import International_Trade_Union.entity.DtoTransaction.DtoTransaction; import International_Trade_Union.setings.Seting;  import java.io.File; import java.io.IOException; import java.security.InvalidKeyException; import java.security.NoSuchAlgorithmException; import java.security.NoSuchProviderException; import java.security.SignatureException; import java.security.spec.InvalidKeySpecException; import java.util.ArrayList; import java.util.HashSet; import java.util.List; import java.util.Set; import java.util.stream.Collectors;  public class UtilsAllAddresses {     public static void saveAllAddresses(String adress, String filename) throws IOException, NoSuchAlgorithmException, SignatureException, InvalidKeySpecException, NoSuchProviderException, InvalidKeyException {         int fileLimit = Seting.SIZE_FILE_LIMIT * 1024 * 1024;          //папка чтобы проверить есть ли         File folder = new File(filename);         List<String> files = new ArrayList<>();         for (File file : folder.listFiles()) {             if(!file.isDirectory()){                 files.add(file.getAbsolutePath());             }         }           int count = 0;         files = files.stream().sorted().collect(Collectors.toList());         String nextFile = \"\";          if (files.size() > 0) {             nextFile = files.get(files.size()-1);              count = Integer.parseInt(nextFile.replaceAll(\"[^\\\\d]\", \"\"));           }          File file = new File(nextFile);          if(file.length() >= fileLimit){             count++;          }          nextFile = filename + count + \".txt\";          String json = UtilsJson.objToStringJson(adress);         UtilsFileSaveRead.save(json + \"\\n\", nextFile);      }      public static Set<String> readLineObject(String filename ) throws IOException, NoSuchAlgorithmException, InvalidKeySpecException, SignatureException, NoSuchProviderException, InvalidKeyException {         Set<String> allAddresses = new HashSet<>();         File folder = new File(filename);         for (final File fileEntry : folder.listFiles()) {             if (fileEntry.isDirectory()) {                 System.out.println(\"is directory \" + fileEntry.getAbsolutePath());             } else {                 Set<String> list = UtilsFileSaveRead.readSet(fileEntry.getAbsolutePath())                         .stream().collect(Collectors.toSet());                 for (String s : list) {                     allAddresses.add(s);                 }              }         }          allAddresses = allAddresses                 .stream()                 .collect(Collectors.toSet());           return allAddresses;     }  }","package International_Trade_Union.utils;    import International_Trade_Union.entity.DtoTransaction.DtoTransaction; import International_Trade_Union.entity.blockchain.Blockchain; import International_Trade_Union.entity.blockchain.block.Block; import International_Trade_Union.setings.Seting; import International_Trade_Union.model.Account; import International_Trade_Union.vote.VoteEnum;  import java.io.IOException; import java.security.*; import java.security.spec.InvalidKeySpecException; import java.util.*;   public class UtilsBalance {      //подсчет по штучно баланса     public  static Map<String, Account> calculateBalance(Map<String, Account> balances, Block block) throws IOException, NoSuchAlgorithmException, SignatureException, InvalidKeySpecException, NoSuchProviderException, InvalidKeyException {           double percent = Seting.ANNUAL_MAINTENANCE_FREE_DIGITAL_DOLLAR_YEAR / Seting.HALF_YEAR;         double digitalReputationPercent = Seting.ANNUAL_MAINTENANCE_FREE_DIGITAL_STOCK_YEAR / Seting.HALF_YEAR;             int i = (int) block.getIndex();               for (int j = 0; j < block.getDtoTransactions().size(); j++) {                 int BasisSendCount = 0;                   DtoTransaction transaction = block.getDtoTransactions().get(j);                  if(transaction.getSender().startsWith(Seting.NAME_LAW_ADDRESS_START)){                     System.out.println(\"law balance cannot be sender\");                     continue;                 }                 if (transaction.verify()) {                     if(transaction.getSender().equals(Seting.BASIS_ADDRESS))                         BasisSendCount++;                       Account sender = getBalance(transaction.getSender(), balances);                     Account customer = getBalance(transaction.getCustomer(), balances);                      boolean sendTrue = true;                     if(sender.getAccount().equals(Seting.BASIS_ADDRESS) && BasisSendCount > 2){                         System.out.println(\"Basis address can send only two the base address can send no more than two times per block:\" + Seting.BASIS_ADDRESS);                         continue;                     }                      double minerRewards = Seting.DIGITAL_DOLLAR_REWARDS_BEFORE;                     double digitalReputationForMiner = Seting.DIGITAL_STOCK_REWARDS_BEFORE;                        if(sender.getAccount().equals(Seting.BASIS_ADDRESS) ){                        if(i > 1 && (transaction.getDigitalDollar() > minerRewards || transaction.getDigitalStockBalance() > digitalReputationForMiner )){                            System.out.println(\"rewards cannot be upper than \" + minerRewards);                            continue;                        }                         if(!customer.getAccount().equals(block.getFounderAddress()) && !customer.getAccount().equals(block.getMinerAddress())){                             System.out.println(\"Basis address can send only to founder or miner\");                             continue;                         }                     }                     sendTrue = UtilsBalance.sendMoney(sender, customer, transaction.getDigitalDollar(), transaction.getDigitalStockBalance(), transaction.getBonusForMiner(), transaction.getVoteEnum());                      //если транзация валидная то записать данн иыезменения в баланс                     if(sendTrue){                         balances.put(sender.getAccount(), sender);                         balances.put(customer.getAccount(), customer);                     }                  }              }           if (i != 0 && i / Seting.COUNT_BLOCK_IN_DAY % (Seting.YEAR / Seting.HALF_YEAR) == 0.0) {              for (Map.Entry<String, Account> changeBalance : balances.entrySet()) {                 Account change = changeBalance.getValue();                 change.setDigitalStockBalance(change.getDigitalStockBalance() - UtilsUse.countPercents(change.getDigitalStockBalance(), digitalReputationPercent));                 change.setDigitalDollarBalance(change.getDigitalDollarBalance() - UtilsUse.countPercents(change.getDigitalDollarBalance(), percent));             }         }           return balances;      }     //подсчет целиком баланса     public static Map<String, Account> calculateBalances(List<Block> blocks) throws IOException, NoSuchAlgorithmException, SignatureException, InvalidKeySpecException, NoSuchProviderException, InvalidKeyException {         Map<String, Account> balances = new HashMap<>();         for (Block block :  blocks) {             calculateBalance(balances, block);         }          return balances;      }        public static Account getBalance(String address, Map<String, Account> balances) {         if (balances.containsKey(address)) {             return balances.get(address);         } else {             Account account = new Account(address, 0.0, 0.0);             return account;         }     }       public static Account findAccount(Blockchain blockList, String address) throws IOException, NoSuchAlgorithmException, SignatureException, InvalidKeySpecException, NoSuchProviderException, InvalidKeyException {         Map<String, Account> accountMap = calculateBalances(blockList.getBlockchainList());         Account account = accountMap.get(address);         return account != null? account: new Account(address, 0.0, 0.0);     }      public static boolean sendMoney(Account senderAddress, Account recipientAddress, double digitalDollar, double digitalReputation, double minerRewards) throws NoSuchAlgorithmException, InvalidKeySpecException, IOException, SignatureException, NoSuchProviderException, InvalidKeyException {         return sendMoney(senderAddress, recipientAddress, digitalDollar, digitalReputation, minerRewards, VoteEnum.YES);     }      public static boolean sendMoney(Account senderAddress, Account recipientAddress, double digitalDollar, double digitalReputation, double minerRewards, VoteEnum voteEnum) throws NoSuchAlgorithmException, InvalidKeySpecException, NoSuchProviderException, IOException, SignatureException, InvalidKeyException {         double remnantDigitalDollar = 0.0;         double remnantDigitalReputation = 0.0;         boolean sendTrue = true;         if (senderAddress.getAccount().equals(recipientAddress.getAccount())) {             System.out.println(\"sender %s, recipient %s cannot be equals! Error!\".format(senderAddress.getAccount(), recipientAddress.getAccount()));             sendTrue = false;         }          remnantDigitalDollar = senderAddress.getDigitalDollarBalance();         remnantDigitalReputation = senderAddress.getDigitalStockBalance();          if (!senderAddress.getAccount().equals(Seting.BASIS_ADDRESS)) {             if(remnantDigitalDollar < digitalDollar + minerRewards){                 sendTrue = false;             }             else if(remnantDigitalReputation < digitalReputation){                     System.out.printf(\"sender power %f, les than powerSend:  %f\\n\",                             senderAddress.getDigitalStockBalance(), digitalReputation);                     sendTrue = false;              } else if (recipientAddress.getAccount().equals(Seting.BASIS_ADDRESS)) {                 System.out.println(\"Basis canot to be recipient;\");                 sendTrue = false;             } else {                  senderAddress.setDigitalDollarBalance(senderAddress.getDigitalDollarBalance() - digitalDollar);                 senderAddress.setDigitalStockBalance(senderAddress.getDigitalStockBalance() - digitalReputation);                 recipientAddress.setDigitalDollarBalance(recipientAddress.getDigitalDollarBalance() + digitalDollar);                 //сделано чтобы можно было увеличить или отнять власть                 if (voteEnum.equals(VoteEnum.YES)) {                     recipientAddress.setDigitalStockBalance(recipientAddress.getDigitalStockBalance() + digitalReputation);                 } else if (voteEnum.equals(VoteEnum.NO)) {                     //политика сдерживания.                     recipientAddress.setDigitalStockBalance(recipientAddress.getDigitalStockBalance() - digitalReputation);                 }              }           }  else if (senderAddress.getAccount().equals(Seting.BASIS_ADDRESS)) {              recipientAddress.setDigitalDollarBalance(recipientAddress.getDigitalDollarBalance() + digitalDollar);             recipientAddress.setDigitalStockBalance(recipientAddress.getDigitalStockBalance() + digitalReputation);          }         return sendTrue;     } }","package International_Trade_Union.utils;   import com.fasterxml.jackson.core.JsonProcessingException; import International_Trade_Union.config.BLockchainFactory; import International_Trade_Union.config.BlockchainFactoryEnum; import International_Trade_Union.entity.DtoTransaction.DtoTransaction; import International_Trade_Union.entity.blockchain.Blockchain; import International_Trade_Union.entity.blockchain.block.Block; import International_Trade_Union.setings.Seting;   import java.io.*; import java.security.*; import java.security.spec.InvalidKeySpecException; import java.util.*; import java.util.stream.Collectors;  public class UtilsBlock {      public static void saveBlocks(List<Block> blocks, String filename) throws IOException {         int fileLimit = Seting.SIZE_FILE_LIMIT * 1024 * 1024;          //папка чтобы проверить есть ли         File folder = new File(filename);         List<String> files = new ArrayList<>();         for (File file : folder.listFiles()) {             if(!file.isDirectory()){                 files.add(file.getAbsolutePath());             }         }          int count = 0;         files = files.stream().sorted().collect(Collectors.toList());         String nextFile = \"\";          if (files.size() > 0) {             nextFile = files.get(files.size()-1);              count = Integer.parseInt(nextFile.replaceAll(\"[^\\\\d]\", \"\"));           }          File file = new File(nextFile);          if(file.length() >= fileLimit){             count++;          }          nextFile = filename + count + \".txt\";          List<String> jsons = new ArrayList<>();         for (Block block: blocks) {             String json = UtilsJson.objToStringJson(block);             jsons.add(json);         }  //        String json = UtilsJson.objToStringJson(minerAccount); //        UtilsFileSaveRead.save(json + \"\\n\", nextFile);         UtilsFileSaveRead.saves(jsons, nextFile, true);     }     public static void saveBLock(Block block, String filename) throws IOException, NoSuchAlgorithmException, SignatureException, InvalidKeySpecException, NoSuchProviderException, InvalidKeyException {         int fileLimit = Seting.SIZE_FILE_LIMIT * 1024 * 1024;          //папка чтобы проверить есть ли         File folder = new File(filename);         List<String> files = new ArrayList<>();         for (File file : folder.listFiles()) {             if(!file.isDirectory()){                 files.add(file.getAbsolutePath());             }         }           int count = 0;         files = files.stream().sorted().collect(Collectors.toList());         String nextFile = \"\";          if (files.size() > 0) {             nextFile = files.get(files.size()-1);              count = Integer.parseInt(nextFile.replaceAll(\"[^\\\\d]\", \"\"));           }          File file = new File(nextFile);          if(file.length() >= fileLimit){             count++;          }           nextFile = filename + count + \".txt\";          String json = UtilsJson.objToStringJson(block);         UtilsFileSaveRead.save(json + \"\\n\", nextFile);      }        public static List<Block> read(String nameFile) throws FileNotFoundException, JsonProcessingException {         return  UtilsJson.jsonToListBLock(UtilsFileSaveRead.read(nameFile));     }      public static List<Block> readLineObject(String filename ) throws IOException, NoSuchAlgorithmException, InvalidKeySpecException, SignatureException, NoSuchProviderException, InvalidKeyException {         List<Block> blocks = new ArrayList<>();         File folder = new File(filename);          for (final File fileEntry : folder.listFiles()) {             if (fileEntry.isDirectory()) {                 System.out.println(\"is directory \" + fileEntry.getAbsolutePath());             } else {                List<String> list = UtilsFileSaveRead.reads(fileEntry.getAbsolutePath());                 for (String s : list) {                      Block block = UtilsJson.jsonToBLock(s);                     blocks.add(block);                 }              }         }         blocks = blocks                 .stream()                 .sorted(Comparator.comparing(Block::getIndex))                 .collect(Collectors.toList());          return blocks;     }     public static Blockchain readBLock(String nameFile, long BLOCK_GENERATION_INTERVAL, int DIFFICULTY_ADJUSTMENT_INTERVAL, long INTERVAL_TARGET , String ADDRESS_FOUNDER) throws NoSuchAlgorithmException, InvalidKeySpecException, IOException, SignatureException, NoSuchProviderException, InvalidKeyException {         List<Block> blocks = null;         List<List<Block>> list = new ArrayList<>();          File folder = new File(nameFile);          for (final File fileEntry : folder.listFiles()) {             if (fileEntry.isDirectory()) {                 System.out.println(\"is directory \" + fileEntry.getAbsolutePath());             } else {                 blocks = UtilsJson.jsonToListBLock(UtilsFileSaveRead.read(fileEntry.getAbsolutePath()));                 list.add(blocks);             }         }          // new Blockchain(BLOCK_GENERATION_INTERVAL, DIFFICULTY_ADJUSTMENT_INTERVAL, INTERVAL_TARGET, ADDRESS_FOUNDER);         Blockchain blockchain = BLockchainFactory.getBlockchain(BlockchainFactoryEnum.ORIGINAL);         blockchain.setBlockchainList(new ArrayList<>());          for (List<Block> lists : list) {             for (int i = 0; i < lists.size(); i++) {                 blockchain.addBlock(lists.get(i));             }          }          List<Block> blockList = blockchain.getBlockchainList()                 .stream()                 .sorted(Comparator.comparing(Block::getIndex))                 .collect(Collectors.toList());         blockchain.setBlockchainList(blockList);          return blockchain;     }      public static Blockchain readBLock() throws IOException, NoSuchAlgorithmException, InvalidKeySpecException, SignatureException, NoSuchProviderException, InvalidKeyException {        return readBLock(Seting.TEST_FILE_WRITE_INFO, Seting.BLOCK_GENERATION_INTERVAL,  Seting.DIFFICULTY_ADJUSTMENT_INTERVAL, Seting.INTERVAL_TARGET, Seting.ADDRESS_FOUNDER );     }      public static boolean isValidTimestamp(Block newBlock, Block prevBLock, long timestamp){         return (prevBLock.getTimestamp().getTime() - timestamp <newBlock.getTimestamp().getTime())                 && newBlock.getTimestamp().getTime() < System.currentTimeMillis();     }      //https://lhartikk.github.io/jekyll/update/2017/07/13/chapter2.html     //сайт сложности     //https://lhartikk.github.io/jekyll/update/2017/07/13/chapter2.html     //https://tproger.ru/translations/blockchain-explained/      //new https://guicommits.com/building-blockchain-with-python/      /**определяет сложность, раз пол дня корректирует сложность. В сутках 576 блоков.      * каждый блок добывается примерно 2.3 минуты*/     public static int difficulty(List<Block> blocks, long BLOCK_GENERATION_INTERVAL, int  DIFFICULTY_ADJUSTMENT_INTERVAL ){          //секунды как часто создается блоки         int difficulty = 1;         Block latestBlock = blocks.get(blocks.size() -1);         if(latestBlock.getIndex() != 0 && latestBlock.getIndex() % DIFFICULTY_ADJUSTMENT_INTERVAL == 0){             difficulty = getAdjustedDifficulty(latestBlock, blocks, BLOCK_GENERATION_INTERVAL, DIFFICULTY_ADJUSTMENT_INTERVAL);             System.out.println(\"difficulty: change dificulty: \" + difficulty);         }         else {             difficulty =  latestBlock.getHashCompexity();         }         return difficulty == 0? 1: difficulty;     }       /**получить сложность*/     private static int getAdjustedDifficulty(Block latestBlock, List<Block> blocks, long BLOCK_GENERATION_INTERVAL, int DIFFICULTY_ADJUSTMENT_INTERVAL){         Block prevAdjustmentBlock = blocks.get(blocks.size() - DIFFICULTY_ADJUSTMENT_INTERVAL);          long timeExpected = BLOCK_GENERATION_INTERVAL * DIFFICULTY_ADJUSTMENT_INTERVAL;         long timeTaken = latestBlock.getTimestamp().getTime() - prevAdjustmentBlock.getTimestamp().getTime();          if(timeTaken < timeExpected / 2){              return prevAdjustmentBlock.getHashCompexity() + 1;         }else if(timeTaken > timeExpected * 2){              return prevAdjustmentBlock.getHashCompexity() - 1;         }else {             return prevAdjustmentBlock.getHashCompexity();         }     }      public static boolean validationOneBlock(             String addressFounder,             Block previusblock,             Block thisBlock,             long blockGenerationInterval,             int difficultyAdjustmentInterval,             List<Block> lastBlock) throws IOException, NoSuchAlgorithmException, SignatureException, InvalidKeySpecException, NoSuchProviderException, InvalidKeyException {          boolean addressFounderReward = false;         boolean addressMinerReward = false;         if(!addressFounder.equals(thisBlock.getFounderAddress())){             System.out.println(\"genesis address not equals block founder: \");             System.out.println(\"genesis address: \" + addressFounder);             System.out.println(\"block address: \" + thisBlock.getFounderAddress());             return false;          }               String actualPrevHash = previusblock.hashForBlockchain();             String recordedPrevHash = thisBlock.getPreviousHash();            boolean validated = true;         int countBasisSendFounder = 0;         int countBasisSendAll = 0;         finished:         for (DtoTransaction transaction : thisBlock.getDtoTransactions()) {             if(transaction.verify() && transaction.getSender().equals(Seting.BASIS_ADDRESS)){                 double minerReward = Seting.DIGITAL_DOLLAR_REWARDS_BEFORE;                 double minerPowerReward = Seting.DIGITAL_STOCK_REWARDS_BEFORE;                    if(transaction.getSender().equals(Seting.BASIS_ADDRESS)&&                         transaction.getCustomer().equals(thisBlock.getMinerAddress()) && transaction.getDigitalDollar() > minerReward                         && thisBlock.getIndex() > 1){                     System.out.println(\"wrong transaction: reward miner wrong digital dollar: \" + minerReward + \" index: \" + thisBlock.getIndex());                     System.out.println(\"sendmoney \" + transaction.getDigitalDollar());                     validated = false;                     break;                 }                 if(transaction.getSender().equals(Seting.BASIS_ADDRESS) &&                         transaction.getCustomer().equals(thisBlock.getMinerAddress()) && transaction.getDigitalStockBalance()                         > minerPowerReward                         && thisBlock.getIndex() > 1){                     System.out.println(\"wrong transaction: reward miner wrong digital stock: \" + minerPowerReward + \" need: \" + transaction.getDigitalStockBalance());                     System.out.println(transaction);                     validated = false;                     break;                 }                   if(transaction.getSender().equals(Seting.BASIS_ADDRESS)                         &&transaction.getCustomer().equals(addressFounder)){                     countBasisSendFounder += 1;                 }                  if(transaction.getSender().equals(Seting.BASIS_ADDRESS)&&!transaction.getCustomer().equals(addressFounder))                 {                     countBasisSendAll +=1;                 }                  if(countBasisSendFounder > 2 && thisBlock.getIndex() > 1){                     System.out.println(\"basis sender send for founder uper one: \" + countBasisSendFounder);                     validated = false;                     break;                 }                  if(countBasisSendAll > 1 && thisBlock.getIndex() > 1){                     System.out.println(\"basis sender send uper two: \" + countBasisSendAll + \" block index: \" + thisBlock.getIndex());                     validated = false;                     break;                 }             }             else if(!transaction.verify()){                 System.out.println(\"wrong transaction: \" + transaction + \" verify: \" + transaction.verify());                 validated = false;                 break finished;             }          }             if(!UtilsUse.hashComplexity(thisBlock.getHashBlock(), thisBlock.getHashCompexity())){                 System.out.println(\"does't start hash with 0\");                 System.out.println(\"this block hash: \" + thisBlock.getHashBlock());                 return false;             }              if(!actualPrevHash.equals(recordedPrevHash)){                 System.out.println(\"Blockchain is invalid, expected: \" + recordedPrevHash + \" actual: \" + actualPrevHash );                 System.out.println(\"index block: \" + thisBlock.getIndex());                 System.out.println(\"wrong chain hash\");                 return false;             }          return validated;     }      public static void deleteFiles(){         UtilsFileSaveRead.deleteAllFiles(Seting.ORIGINAL_BLOCKCHAIN_FILE);          UtilsFileSaveRead.deleteAllFiles(Seting.ORIGINAL_BALANCE_FILE);         UtilsFileSaveRead.deleteAllFiles(Seting.ORIGINAL_ALL_CORPORATION_LAWS_FILE);         UtilsFileSaveRead.deleteAllFiles(Seting.ORIGINAL_ALL_CORPORATION_LAWS_WITH_BALANCE_FILE);     }      public static boolean validation(List<Block> blocks, long BLOCK_GENERATION_INTERVAL, int DIFFICULTY_ADJUSTMENT_INTERVAL ) throws IOException, NoSuchAlgorithmException, SignatureException, InvalidKeySpecException, NoSuchProviderException, InvalidKeyException {         boolean validated = true;         List<Block> temporary = new ArrayList<>();         Block prevBlock  = null;         for (Block block : blocks) {             if(prevBlock == null){                 prevBlock = block;                 temporary.add(block);                 continue;             }              temporary.add(block);              validated = validationOneBlock(block.getFounderAddress(),                     prevBlock,                     block,                     BLOCK_GENERATION_INTERVAL,                     DIFFICULTY_ADJUSTMENT_INTERVAL,                     temporary );             if(validated == false){                  System.out.println(\"ERROR: UtilsBlock: validation: prevBLock.Hash():\" + prevBlock.getHashBlock());                 System.out.println(\"ERROR: UtilsBlock: validation: index:\" + block.getIndex());                 System.out.println(\"ERROR: UtilsBlock: validation: block.Hash():\" + block.getHashBlock());                 System.out.println(\"ERROR: UtilsBlock: validation: BLOCK_GENERATION_INTERVAL:\" + BLOCK_GENERATION_INTERVAL);                 System.out.println(\"ERROR: UtilsBlock: validation: DIFFICULTY_ADJUSTMENT_INTERVAL:\" + DIFFICULTY_ADJUSTMENT_INTERVAL);                 System.out.println(\"ERROR: UtilsBlock: validation: temporary:\" + temporary.size());                 return false;             }             prevBlock = block;         }         return validated;     } }","package International_Trade_Union.utils;  public class UtilsCheckDtoTransaction {  }","package International_Trade_Union.utils;  import java.io.*; import java.util.ArrayList; import java.util.HashSet; import java.util.List; import java.util.Set;  public class UtilsFileSaveRead {      public static void save(String object, String fileName) throws IOException {        save(object, fileName, true);     }     public static void save(String object, String fileName, boolean save){         try(BufferedWriter writer = new BufferedWriter(new FileWriter(fileName, save))) {             writer.write(object);             writer.flush();          }catch (IOException e){             e.printStackTrace();         }       }      public static void saves(List<String> objects, String fileName, boolean save){          try(BufferedWriter writer = new BufferedWriter(new FileWriter(fileName, save))) {              for (String s : objects) {                 writer.write(s + \"\\n\");             }             writer.flush();          }catch (IOException e){             e.printStackTrace();         }     }      public static String read(String file) throws FileNotFoundException {         String text = \"\";         File file1 = new File(file);         if(!file1.exists()){             System.out.println(\"file dosn't have\");             return text;         }         try( BufferedReader reader = new BufferedReader(new FileReader(file))){             while (reader.ready()){                 text += reader.readLine();             }         }catch (IOException e){             e.printStackTrace();         }         return text;     }     public static Set<String> readSet(String file){         Set<String> list = new HashSet<>();          try( BufferedReader reader = new BufferedReader(new FileReader(file))){             while (reader.ready()){                 list.add(reader.readLine());             }         }catch (IOException e){             e.printStackTrace();         }         return list;     }     public static List<String> reads(String file){         List<String> list = new ArrayList<>();          try( BufferedReader reader = new BufferedReader(new FileReader(file))){             while (reader.ready()){                 list.add(reader.readLine());             }         }catch (IOException e){             e.printStackTrace();         }         return list;     }         public static void deleteAllFiles(String path){         File folder = new File(path);         for (File file : folder.listFiles()) {             if(!file.isDirectory()){                 file.delete();             }         }     }      public static void deleteFile(String path){         File file = new File(path);         file.delete();     }  }","package International_Trade_Union.utils;  import com.fasterxml.jackson.core.JsonProcessingException; import com.fasterxml.jackson.core.type.TypeReference; import com.fasterxml.jackson.databind.ObjectMapper; import International_Trade_Union.entity.DtoTransaction.DtoTransaction; import International_Trade_Union.entity.EntityChain; import International_Trade_Union.entity.blockchain.block.Block; import International_Trade_Union.model.Account; import International_Trade_Union.vote.CurrentLawVotes; import International_Trade_Union.vote.LawEligibleForParliamentaryApproval; import International_Trade_Union.vote.Laws;   import java.io.IOException; import java.io.StringWriter; import java.util.List; import java.util.Set;  public class UtilsJson {     public static String objToStringJson(Object object) throws IOException {         ObjectMapper mapper = new ObjectMapper();         StringWriter writer = new StringWriter();         mapper.writeValue(writer, object);         return writer.toString();     }      public static Object jsonToListBLock(String json, Class cls) throws JsonProcessingException {         ObjectMapper mapper = new ObjectMapper();         return mapper.readValue(json, cls);     }      public static List<Block> jsonToListBLock(String json) throws JsonProcessingException {         ObjectMapper mapper = new ObjectMapper();         return mapper.readValue(json, new TypeReference<List<Block>>(){});     }     public static List<Account> jsonToListAccounts(String json) throws JsonProcessingException {         ObjectMapper mapper = new ObjectMapper();         return mapper.readValue(json, new TypeReference<List<Account>>(){});     }      public static Set<String> jsonToSetAddresses(String json) throws  JsonProcessingException{         ObjectMapper mapper = new ObjectMapper();         return mapper.readValue(json, new TypeReference<Set<String>>(){});     }     public static Block jsonToBLock(String json) throws JsonProcessingException {         ObjectMapper mapper = new ObjectMapper();         return mapper.readValue(json, Block.class);     }      public static Laws jsonToLaw(String json) throws JsonProcessingException {         ObjectMapper mapper = new ObjectMapper();         return mapper.readValue(json, Laws.class);     }      public static CurrentLawVotes jsonToVote(String json) throws  JsonProcessingException{         ObjectMapper mapper = new ObjectMapper();         return mapper.readValue(json, CurrentLawVotes.class);     }      public static LawEligibleForParliamentaryApproval jsonToCurrentLaw(String json) throws JsonProcessingException {         ObjectMapper mapper = new ObjectMapper();         return mapper.readValue(json, LawEligibleForParliamentaryApproval.class);     }     public static Account jsonToAccount(String json) throws JsonProcessingException {         ObjectMapper mapper = new ObjectMapper();         return mapper.readValue(json, Account.class);     }     public static EntityChain jsonToEntityChain(String json) throws  JsonProcessingException{         ObjectMapper mapper = new ObjectMapper();         return mapper.readValue(json, EntityChain.class);     }      public static DtoTransaction jsonToDtoTransaction(String json) throws  JsonProcessingException{         ObjectMapper mapper = new ObjectMapper();         return mapper.readValue(json, DtoTransaction.class);      }      public static List<DtoTransaction> jsonToDtoTransactionList(String json) throws  JsonProcessingException{         ObjectMapper mapper = new ObjectMapper();         return mapper.readValue(json, new TypeReference<List<DtoTransaction>>(){});     } }","package International_Trade_Union.utils;    import International_Trade_Union.model.Keys; import International_Trade_Union.utils.base.Base; import International_Trade_Union.utils.base.Base58;  import org.bouncycastle.asn1.ASN1ObjectIdentifier; import org.bouncycastle.asn1.x9.ECNamedCurveTable; import org.bouncycastle.asn1.x9.X9ECParameters; import org.bouncycastle.crypto.params.ECNamedDomainParameters; import org.bouncycastle.crypto.params.ECPublicKeyParameters; import org.bouncycastle.jcajce.provider.asymmetric.ec.BCECPublicKey; import org.bouncycastle.jce.provider.BouncyCastleProvider; import org.bouncycastle.jce.spec.ECNamedCurveParameterSpec; import org.bouncycastle.jce.spec.ECPublicKeySpec; import org.bouncycastle.math.ec.ECCurve; import org.bouncycastle.math.ec.ECPoint;  import java.io.IOException; import java.math.BigInteger; import java.nio.charset.StandardCharsets; import java.security.*; import java.security.interfaces.ECPublicKey; import java.security.spec.*;  //https://metamug.com/article/security/sign-verify-digital-signature-ecdsa-java.html //https://stackoverflow.com/questions/8451205/create-privatekey-and-publickey-having-a-byte-array-encoded-in-base-64 public class UtilsSecurity {     private static final String SPEC = \"secp256k1\";     private static final String ALGO_ECDSA = \"ECDSA\";     private static final String PROVIDER = \"BC\";      static {         Security.addProvider(new org.bouncycastle.jce.provider.BouncyCastleProvider());     }     public static Keys generateKeyPair() throws NoSuchAlgorithmException, InvalidAlgorithmParameterException, NoSuchProviderException, InvalidKeySpecException {        Base base = new Base58();         Security.addProvider(new org.bouncycastle.jce.provider.BouncyCastleProvider());         ECGenParameterSpec ecSpec = new ECGenParameterSpec(SPEC);         KeyPairGenerator g = KeyPairGenerator.getInstance(ALGO_ECDSA, PROVIDER);         g.initialize(ecSpec, new SecureRandom());         KeyPair keyPair = g.generateKeyPair();         String pub = base.encode(UtilsSecurity.compressed(keyPair.getPublic().getEncoded()));         String priv = base.encode(keyPair.getPrivate().getEncoded());         Keys keys = new Keys(pub, priv);         return keys;     }      public static PrivateKey privateBytToPrivateKey(byte[] bytes) throws NoSuchAlgorithmException, InvalidKeySpecException, NoSuchProviderException {         EncodedKeySpec privateKeySpec = new PKCS8EncodedKeySpec(bytes);         KeyFactory generator = KeyFactory.getInstance(ALGO_ECDSA, PROVIDER);         return generator.generatePrivate(privateKeySpec);     }      public static PublicKey publicByteToPublicKey(byte[] bytes) throws NoSuchAlgorithmException, InvalidKeySpecException, NoSuchProviderException {         //new X509EncodedKeySpec         EncodedKeySpec publicKeySpec = new X509EncodedKeySpec(bytes);         KeyFactory generator = KeyFactory.getInstance(ALGO_ECDSA, PROVIDER);         return generator.generatePublic(publicKeySpec);     }       public static KeyPair createKeyPairWithPrivkeyPubKey(PrivateKey privateKey, PublicKey publicKey){         return new KeyPair(publicKey, privateKey);     }       public static byte[] sign(PrivateKey privateKey, String hex) throws NoSuchAlgorithmException, NoSuchProviderException, InvalidKeyException, SignatureException, IOException {         Signature signature = Signature.getInstance(ALGO_ECDSA, PROVIDER);         signature.initSign(privateKey);         signature.update(hex.getBytes(StandardCharsets.UTF_8));         byte[] signByte = signature.sign();         return signByte;     }      public static boolean verify(String sha256message, byte[] sign, PublicKey publicKey) throws NoSuchAlgorithmException, NoSuchProviderException, InvalidKeyException, SignatureException {         Signature signature = Signature.getInstance(ALGO_ECDSA, PROVIDER);         signature.initVerify(publicKey);         signature.update(sha256message.getBytes(StandardCharsets.UTF_8));         return signature.verify(sign);     }       public static byte[] compressed(byte[] pub) throws NoSuchAlgorithmException, NoSuchProviderException, InvalidAlgorithmParameterException, InvalidKeySpecException {          // === NOT PART OF THE CODE, JUST GETTING TEST VECTOR ===         PublicKey publicKey = UtilsSecurity.publicByteToPublicKey(pub);          ECPublicKey key = (ECPublicKey) publicKey;         byte[] x = key.getW().getAffineX().toByteArray();         byte[] y = key.getW().getAffineY().toByteArray();          // assumes that x and y are (unsigned) big endian encoded         BigInteger xbi = new BigInteger(1, x);         BigInteger ybi = new BigInteger(1, y);         X9ECParameters x9 = ECNamedCurveTable.getByName(SPEC);         ASN1ObjectIdentifier oid = ECNamedCurveTable.getOID(SPEC);         ECCurve curve = x9.getCurve();         ECPoint point = curve.createPoint(xbi, ybi);         ECNamedDomainParameters dParams = new ECNamedDomainParameters(oid,                 x9.getCurve(), x9.getG(), x9.getN(), x9.getH(), x9.getSeed());         ECPublicKeyParameters pubKey = new ECPublicKeyParameters(point, dParams);         System.out.println(pubKey);          // some additional encoding tricks         byte[] compressed = point.getEncoded(true);         return compressed;     }     public static ECPublicKey decodeKey(byte[] encoded) {          ECNamedCurveParameterSpec params = org.bouncycastle.jce.ECNamedCurveTable.getParameterSpec(SPEC);         org.bouncycastle.jce.spec.ECPublicKeySpec keySpec = new ECPublicKeySpec(params.getCurve().decodePoint(encoded), params);         return new BCECPublicKey(ALGO_ECDSA, keySpec, BouncyCastleProvider.CONFIGURATION);     } }","package International_Trade_Union.utils;  import International_Trade_Union.controllers.BasisController; import International_Trade_Union.entity.DtoTransaction.DtoTransaction; import International_Trade_Union.entity.blockchain.block.Block; import International_Trade_Union.governments.Directors; import International_Trade_Union.governments.UtilsGovernment; import International_Trade_Union.network.AllTransactions; import International_Trade_Union.setings.Seting;  import java.io.File; import java.io.IOException; import java.security.InvalidKeyException; import java.security.NoSuchAlgorithmException; import java.security.NoSuchProviderException; import java.security.SignatureException; import java.security.spec.InvalidKeySpecException; import java.util.ArrayList; import java.util.Comparator; import java.util.List; import java.util.stream.Collectors;  public class UtilsTransaction {     public static void saveAllTransaction(DtoTransaction dtoTransaction, String filename) throws IOException, NoSuchAlgorithmException, SignatureException, InvalidKeySpecException, NoSuchProviderException, InvalidKeyException {         int fileLimit = Seting.SIZE_FILE_LIMIT * 1024 * 1024;          //папка чтобы проверить есть ли         File folder = new File(filename);         List<String> files = new ArrayList<>();         for (File file : folder.listFiles()) {             if(!file.isDirectory()){                 files.add(file.getAbsolutePath());             }         }           int count = 0;         files = files.stream().sorted().collect(Collectors.toList());         String nextFile = \"\";          if (files.size() > 0) {             nextFile = files.get(files.size()-1);              count = Integer.parseInt(nextFile.replaceAll(\"[^\\\\d]\", \"\"));           }          File file = new File(nextFile);          if(file.length() >= fileLimit){             count++;          }          nextFile = filename + count + \".txt\";          String json = UtilsJson.objToStringJson(dtoTransaction);         UtilsFileSaveRead.save(json + \"\\n\", nextFile);      }      public static List<DtoTransaction> readLineObject(String filename ) throws IOException, NoSuchAlgorithmException, InvalidKeySpecException, SignatureException, NoSuchProviderException, InvalidKeyException {         List<DtoTransaction> dtoTransactions = new ArrayList<>();         File folder = new File(filename);         for (final File fileEntry : folder.listFiles()) {             if (fileEntry.isDirectory()) {                 System.out.println(\"is directory \" + fileEntry.getAbsolutePath());             } else {                 List<String> list = UtilsFileSaveRead.reads(fileEntry.getAbsolutePath());                 for (String s : list) {                      DtoTransaction dtoTransaction = UtilsJson.jsonToDtoTransaction(s);                     dtoTransactions.add(dtoTransaction);                 }              }         }         dtoTransactions = dtoTransactions                 .stream()                 .collect(Collectors.toList());          return dtoTransactions;     }       public static void sendTransaction(DtoTransaction dtoTransaction){      } }","package International_Trade_Union.utils;    import International_Trade_Union.setings.Seting;  import java.io.IOException;  import java.math.BigDecimal; import java.nio.charset.Charset; import java.nio.charset.StandardCharsets; import java.security.MessageDigest; import java.security.NoSuchAlgorithmException; import java.util.HashMap; import java.util.List; import java.util.Random; import java.util.Set; import java.util.concurrent.ConcurrentHashMap; import java.util.function.Function; import java.util.function.Predicate; import java.util.regex.Matcher; import java.util.regex.Pattern;  public class UtilsUse {     private static MessageDigest digest;      static {         try {             digest = MessageDigest.getInstance(\"SHA-256\");         } catch (NoSuchAlgorithmException e) {             e.printStackTrace();         }     } //    одно число от другого в процентах     public static Double percentDifferent(Double first, Double second){         return (first / second - 1) * Seting.HUNDRED_PERCENT;     }      //найти моду     public static int mode(List<Integer> array)     {         HashMap<Integer,Integer> hm = new HashMap<Integer,Integer>();         int max  = 1;         int temp = 0;          for(int i = 0; i < array.size(); i++) {              if (hm.get(array.get(i)) != null) {                  int count = hm.get(array.get(i));                 count++;                 hm.put(array.get(i), count);                  if(count > max) {                     max  = count;                     temp = array.get(i);                 }             }              else                 hm.put(array.get(i),1);         }         return temp;     }      public static BigDecimal percentDifferent(BigDecimal first, BigDecimal second){         return first.divide(second).subtract(new BigDecimal(1)).multiply(new BigDecimal(Seting.HUNDRED_PERCENT));     }      public static byte[] sha256(String text){         return digest.digest(text.getBytes(StandardCharsets.UTF_8));     }     public static String sha256hash(String text){         byte[] bytes = sha256(text);         return bytesToHex(bytes);     }      private static String bytesToHex(byte[] hash) {         StringBuilder hexString = new StringBuilder(2 * hash.length);         for (int i = 0; i < hash.length; i++) {             String hex = Integer.toHexString(0xff & hash[i]);             if(hex.length() == 1) {                 hexString.append('0');             }             hexString.append(hex);         }         return hexString.toString();     }      public static String generateRandomStr() {         byte[] array = new byte[7]; // length is bounded by 7         new Random().nextBytes(array);         String generatedString = new String(array, Charset.forName(\"UTF-8\"));          return generatedString;     }      public static double countPercents(double sum, double percent){         return sum * percent / Seting.HUNDRED_PERCENT;     }     public static BigDecimal countPercents(BigDecimal sum, BigDecimal percent){         return sum.multiply(percent).divide(new BigDecimal(Seting.HUNDRED_PERCENT));     }      public  static double countGrowth(long block, double percent, double money){         long year = (long) (block / Seting.COUNT_BLOCK_IN_DAY / (Seting.YEAR / Seting.HALF_YEAR));         double opeartion1 = 1+ (percent / Seting.HALF_YEAR)/Seting.HUNDRED_PERCENT;         double operation2 = Math.pow(opeartion1, year);         double result = money * operation2;         return result;     }      public static boolean hashComplexity(String literral, int hashComplexity){          String regex = \"^[0]{\" + Integer.toString(hashComplexity) + \"}\";         Pattern pattern = Pattern.compile(regex);         Matcher matcher = pattern.matcher(literral);         return matcher.find();     }      public static String hashComplexityStr(String str, int hashComplexity) throws IOException {         int randomNumberProof = 0;         String hash = \"\";         while (true){             randomNumberProof++;             hash = UtilsUse.sha256hash(UtilsJson.objToStringJson(str + randomNumberProof));             if(UtilsUse.hashComplexity(hash.substring(0, hashComplexity), hashComplexity))             {                 break;             }          }         return hash;     }      //для филтрации в стриме, чтобы получить уникальные обекты по полям     public static <T> Predicate<T> distinctByKey(Function<? super T, ?> keyExtractor) {         Set<Object> seen = ConcurrentHashMap.newKeySet();         return t -> seen.add(keyExtractor.apply(t));     }     //подсчитать количество нулей идущих подряд в hash     public static long hashCount(String hash) {         long count = 0;         for (int i = 0; i < hash.length(); i++) {             if(hash.charAt(i) == '0') count++;             else return count;         }         return count;     }      //подсчитывает долю в процентах одного числа от другого     public static double percentageShare(double first, double allNumber){         return (first/allNumber)*Seting.HUNDRED_PERCENT;     }      //опреледеляет ближайщее число к году     public static long nearestDateToYear(long block){         long period = (long) (Seting.COUNT_BLOCK_IN_DAY * Seting.YEAR);         return block / period * period;     }   }","package International_Trade_Union.utils;  import com.fasterxml.jackson.databind.ObjectMapper; import org.apache.http.NameValuePair; import org.apache.http.client.methods.HttpPost; import org.apache.http.message.BasicNameValuePair; import org.json.JSONException;  import javax.net.ssl.HttpsURLConnection; import java.io.*; import java.net.*; import java.nio.charset.Charset; import java.util.ArrayList; import java.util.Base64; import java.util.List;  public class UtilUrl {     public static String readJsonFromUrl(String url) throws IOException, JSONException {         InputStream is = new URL(url).openStream();         try {             BufferedReader rd = new BufferedReader(new InputStreamReader(is, Charset.forName(\"UTF-8\")));             String jsonText = readAll(rd);             ObjectMapper mapper = new ObjectMapper();             return jsonText;         } finally {             System.out.println(\"UtilUrl: readJsonFromUrl: \" + url );             is.close();         }     }      private static String readAll(Reader rd) throws IOException {         StringBuilder sb = new StringBuilder();         int cp;         while ((cp = rd.read()) != -1) {             sb.append((char) cp);         }         return sb.toString();     }      public static String getObject(String jsonObject, String requstStr) throws IOException {         URL url = new URL(requstStr);         HttpURLConnection conn = (HttpURLConnection) url.openConnection(); //        conn.connect();         conn.setReadTimeout(10000);         conn.setConnectTimeout(15000);         conn.setRequestMethod(\"POST\");         conn.setRequestProperty(\"Content-Type\", \"application/json; utf-8\");         conn.setRequestProperty(\"Accept\", \"application/json\");         conn.setDoOutput(true);            try(OutputStream outputStream = conn.getOutputStream()) {             byte[] input = jsonObject.getBytes(\"utf-8\");             outputStream.write(input, 0, input.length);             conn.getResponseCode();         }           conn.connect();         try(BufferedReader br = new BufferedReader(                 new InputStreamReader(conn.getInputStream(), \"utf-8\"))) {             StringBuilder response = new StringBuilder();             String responseLine = null;             while ((responseLine = br.readLine()) != null) {                 response.append(responseLine.trim());             }             return response.toString();          }      }         public static int sendPost(String jsonObject, String requestStr) throws IOException {         int response;         URL url = new URL(requestStr);         HttpURLConnection conn = (HttpURLConnection) url.openConnection(); //        conn.connect();         conn.setReadTimeout(10000);         conn.setConnectTimeout(15000);         conn.setRequestMethod(\"POST\");         conn.setRequestProperty(\"Content-Type\", \"application/json; utf-8\");         conn.setRequestProperty(\"Accept\", \"application/json\");         conn.setDoOutput(true);            try(OutputStream outputStream = conn.getOutputStream()) {             byte[] input = jsonObject.getBytes(\"utf-8\");             outputStream.write(input, 0, input.length);              response = conn.getResponseCode();          }           conn.connect();         return response;     }     }","package International_Trade_Union.vote;  import lombok.Data; import International_Trade_Union.model.Account; import International_Trade_Union.setings.Seting; import org.apache.tomcat.util.net.jsse.JSSEUtil;  import java.util.List; import java.util.Map; import java.util.Objects; import java.util.Set; import java.util.stream.Collectors;  @Data public class CurrentLawVotes {     private String addressLaw;     private Set<String> YES;     private Set<String> NO;       public CurrentLawVotes() {     }      public CurrentLawVotes(String addressLaw, Set<String> YES, Set<String> NO) {         this.addressLaw = addressLaw;         this.YES = YES;         this.NO = NO;     }      //подсчет голосов для палат     public int voteGovernment(             Map<String, Account> balances,             List<String> governments      ) {         int yes = 0;         int no = 0;          List<String> addressGovernment = governments;         for (String s : YES) {             if (addressGovernment.contains(s)) {                 yes += Seting.VOTE_GOVERNMENT;             }          }         for (String s : NO) {             if (addressGovernment.contains(s)) {                 no += Seting.VOTE_GOVERNMENT;             }          }           return yes - no;      }      //для избрания должностных лиц     public double votesLaw(Map<String, Account> balances,                            Map<String, Integer> yesAverage, Map<String, Integer> noAverage) {         double yes = 0.0;         double no = 0.0;           //         for (String s : YES) {              int count = 1;             count = yesAverage.get(s) > 0 ? yesAverage.get(s) : 1;             yes += balances.get(s).getDigitalStockBalance() / count;          }         //         for (String s : NO) {             int count = 1;             count = noAverage.get(s) > 0 ? noAverage.get(s) : 1;             no += balances.get(s).getDigitalStockBalance() / count;          }           return yes - no;     }      //для избрания должностных лиц     public double votes(Map<String, Account> balances,                         Map<String, Integer> yesAverage, Map<String, Integer> noAverage) {         double yes = 0.0;         double no = 0.0;         for (String s : YES) {             int count = 1;             count = yesAverage.get(s) > 0 ? yesAverage.get(s) : 1;             yes += balances.get(s).getDigitalStockBalance() / count;          }         for (String s : NO) {             int count = 1;             count = noAverage.get(s) > 0 ? noAverage.get(s) : 1;             no += balances.get(s).getDigitalStockBalance() / count;          }           return yes - no;     }      @Override     public boolean equals(Object o) {         if (this == o) return true;         if (!(o instanceof CurrentLawVotes)) return false;         CurrentLawVotes that = (CurrentLawVotes) o;         return getAddressLaw().equals(that.getAddressLaw());     }      @Override     public int hashCode() {         return Objects.hash(getAddressLaw());     } }","package International_Trade_Union.vote;  public class CurrentLawVotesAverage { }","package International_Trade_Union.vote;  import lombok.Data;  import java.util.List; import java.util.Objects;  @Data public class CurrentLawVotesEndBalance {     private String addressLaw;     private double votes;     //CORPORATE_COUNCIL_OF_REFEREES     private int votesCorporateCouncilOfReferees;      //BOARD_OF_DIRECTORS     private int votesBoardOfDirectors;     private int votesBoardOfShareholders;      //GENERAL_EXECUTIVE_DIRECTOR     private int voteGeneralExecutiveDirector;     private int voteHightJudge;      private int founderVote;     private String packageName;     private List<String> laws;      public CurrentLawVotesEndBalance() {     }      public CurrentLawVotesEndBalance             (String addressLaw,              String packageName,              double votes,              int votesCorporateCouncilOfReferees,              int votesBoardOfDirectors,              int votesBoardOfShareholders,              int voteGeneralExecutiveDirector,              int voteHightJudge,                     int founderVote,              List<String> laws) {         this.addressLaw = addressLaw;         this.packageName = packageName;         this.votesCorporateCouncilOfReferees = votesCorporateCouncilOfReferees;         this.votesBoardOfShareholders = votesBoardOfShareholders;         this.votesBoardOfDirectors = votesBoardOfDirectors;         this.voteGeneralExecutiveDirector = voteGeneralExecutiveDirector;         this.voteHightJudge = voteHightJudge;         this.founderVote = founderVote;          this.votes = votes;         this.laws = laws;      }      @Override     public boolean equals(Object o) {         if (this == o) return true;         if (!(o instanceof CurrentLawVotesEndBalance)) return false;         CurrentLawVotesEndBalance that = (CurrentLawVotesEndBalance) o;         return getAddressLaw().equals(that.getAddressLaw());     }      @Override     public int hashCode() {         return Objects.hash(getAddressLaw());     } }","package International_Trade_Union.vote;   import lombok.Data; import International_Trade_Union.model.Account;  import java.util.Objects;  @Data public class LawEligibleForParliamentaryApproval {     public LawEligibleForParliamentaryApproval(Account account, Laws laws) {         this.account = account;         this.laws = laws;         this.name = account.getAccount();     }      public LawEligibleForParliamentaryApproval() {     }      private String name;     private Account account;     private Laws laws;      @Override     public boolean equals(Object o) {         if (this == o) return true;         if (!(o instanceof LawEligibleForParliamentaryApproval)) return false;         LawEligibleForParliamentaryApproval that = (LawEligibleForParliamentaryApproval) o;         return Objects.equals(getName(), that.getName()) && Objects.equals(getAccount(), that.getAccount()) && Objects.equals(getLaws(), that.getLaws());     }      @Override     public int hashCode() {         return Objects.hash(getName(), getAccount(), getLaws());     } }","package International_Trade_Union.vote;   import lombok.Data; import International_Trade_Union.setings.Seting; import International_Trade_Union.utils.UtilsJson; import International_Trade_Union.utils.UtilsUse;  import java.io.IOException; import java.util.List; import java.util.Objects;  @Data public class Laws {     //название пакета закона     String packetLawName;     List<String> laws;     String hashLaw;      public Laws() {     }      public Laws(String packetLawName, List<String> laws) throws IOException {         this.packetLawName = packetLawName;         this.laws = laws;         this.hashLaw = Seting.NAME_LAW_ADDRESS_START + UtilsUse.sha256hash(UtilsJson.objToStringJson(this));     }      @Override     public boolean equals(Object o) {         if (this == o) return true;         if (!(o instanceof Laws)) return false;         Laws laws = (Laws) o;         return getHashLaw().equals(laws.getHashLaw());     }      @Override     public int hashCode() {         return Objects.hash(getHashLaw());     } }","package International_Trade_Union.vote;  import International_Trade_Union.entity.DtoTransaction.DtoTransaction; import International_Trade_Union.entity.blockchain.Blockchain; import International_Trade_Union.entity.blockchain.block.Block; import International_Trade_Union.governments.Director; import International_Trade_Union.governments.Directors; import International_Trade_Union.governments.UtilsGovernment; import International_Trade_Union.model.Account; import International_Trade_Union.model.FIndPositonHelperData; import International_Trade_Union.setings.Seting;  import java.io.IOException; import java.security.InvalidKeyException; import java.security.NoSuchAlgorithmException; import java.security.NoSuchProviderException; import java.security.SignatureException; import java.security.spec.InvalidKeySpecException; import java.util.*; import java.util.stream.Collectors;  public class UtilsCurrentLaw {     //подсчет по штучно баланса     public static Map<String, CurrentLawVotes> calculateVote(Map<String, CurrentLawVotes> votes, List<Account> governments, Block block) throws IOException, NoSuchAlgorithmException, SignatureException, InvalidKeySpecException, NoSuchProviderException, InvalidKeyException {          for (int j = 0; j < block.getDtoTransactions().size(); j++) {             DtoTransaction transaction = block.getDtoTransactions().get(j);              if (transaction.getSender().startsWith(Seting.NAME_LAW_ADDRESS_START)) {                 System.out.println(\"law balance cannot be sender\");                 continue;             }             if (transaction.verify() && transaction.getCustomer().startsWith(Seting.NAME_LAW_ADDRESS_START)) {                 for (Account account : governments) {                     //основатель не может участвовать в голосовании                     //!block.getFounderAddress().equals(transaction.getSender())                     if (transaction.getSender().equals(account.getAccount())) {                         CurrentLawVotes currentLawVotes = votes.get(transaction.getCustomer());                          if (currentLawVotes == null) {                             currentLawVotes = new CurrentLawVotes();                             currentLawVotes.setAddressLaw(transaction.getCustomer());                             currentLawVotes.setYES(new HashSet<>());                             currentLawVotes.setNO(new HashSet<>());                              votes.put(transaction.getCustomer(), currentLawVotes);                         }                          if (transaction.getVoteEnum().equals(VoteEnum.YES)) {                              currentLawVotes.getYES().add(transaction.getSender());                             currentLawVotes.getNO().remove(transaction.getSender());                          } else if (transaction.getVoteEnum().equals(VoteEnum.NO)) {                             currentLawVotes.getNO().add(transaction.getSender());                             currentLawVotes.getYES().remove(transaction.getSender());                         }                     }                 }              }          }           return votes;      }      //подсчет целиком баланса     public static Map<String, CurrentLawVotes> calculateVotes(List<Account> governments, List<Block> blocks) throws IOException, NoSuchAlgorithmException, SignatureException, InvalidKeySpecException, NoSuchProviderException, InvalidKeyException {         Map<String, CurrentLawVotes> votes = new HashMap<>();         for (Block block : blocks) {             calculateVote(votes, governments, block);         }          return votes;      }      //возвращаяет усредненное количество голосов,     //суть проста если есть один акаунт и он имеет 100 акций     //и проголосовал за один закон то все сто акций будут для этого закона как сто голосов     //если за два закона то 100/2 то есть если он на протяжении трех лет проголосовал     //за n законов, то его голоса делятся на n.     public static Map<String, Integer> calculateAverageVotesYes(Map<String, CurrentLawVotes> votesMap) {         Map<String, Integer> voteAverage = new HashMap<>();         for (Map.Entry<String, CurrentLawVotes> current : votesMap.entrySet()) {             for (String yesVoteAddress : current.getValue().getYES()) {                 if (voteAverage.containsKey(yesVoteAddress)) {                     int count = voteAverage.get(yesVoteAddress);                     voteAverage.put(yesVoteAddress, count + 1);                 } else {                     int count = 1;                     voteAverage.put(yesVoteAddress, count);                 }             }          }         return voteAverage;     }      //подсчитывает голоса No     public static Map<String, Integer> calculateAverageVotesNo(Map<String, CurrentLawVotes> votesMap) {         Map<String, Integer> voteAverage = new HashMap<>();         for (Map.Entry<String, CurrentLawVotes> current : votesMap.entrySet()) {             for (String yesVoteAddress : current.getValue().getNO()) {                 if (voteAverage.containsKey(yesVoteAddress)) {                     int count = voteAverage.get(yesVoteAddress);                     voteAverage.put(yesVoteAddress, count + 1);                 } else {                     int count = 1;                     voteAverage.put(yesVoteAddress, count);                 }             }          }         return voteAverage;     }        //возвращает списки позиций     public static Map<Director, List<String>> findPositions(              Map<String, Account> balances,             Blockchain blockchain,             List<LawEligibleForParliamentaryApproval> allGovernment,             List<Account> BoardOfShareholders,             Map<Director, FIndPositonHelperData> fIndPositonHelperData      ) throws IOException, NoSuchAlgorithmException, InvalidKeySpecException, SignatureException, NoSuchProviderException, InvalidKeyException {         //список должностей         Directors directors = new Directors();         Map<Director, List<LawEligibleForParliamentaryApproval>> positionsListMap = new HashMap<>();         //добавление всех должностей         for (Director higherSpecialPositions : directors.getDirectors()) {             positionsListMap.put(higherSpecialPositions, UtilsLaws.getPossions(allGovernment, higherSpecialPositions));         }         //список законов с голосами         Map<Director, List<CurrentLawVotesEndBalance>> curentLawVotesEndBalance = new HashMap<>();         for (Map.Entry<Director, List<LawEligibleForParliamentaryApproval>> corp : positionsListMap.entrySet()) {             //убрать повторяющиеся должности из списка.             corp.setValue(corp.getValue().stream() //                    .filter(t-> finalBoardOfShareholders.contains(new Account(t.getLaws().getLaws().get(0), 0, 0)))                     .distinct().collect(Collectors.toList()));              //получить баланс и голоса для действующих законов             curentLawVotesEndBalance.put(corp.getKey(), UtilsGovernment.filters(corp.getValue(), balances, BoardOfShareholders,                     blockchain.getBlockchainList(), Seting.POSITION_YEAR_VOTE));             List<CurrentLawVotesEndBalance> temporary;             if (fIndPositonHelperData.get(corp.getKey()).isElectedWithStock()) {                   //отобрать голоса выше лимита                 curentLawVotesEndBalance.put(corp.getKey(), curentLawVotesEndBalance.get(corp.getKey()));                 List<CurrentLawVotesEndBalance> electedByStock =                         curentLawVotesEndBalance.get(corp.getKey())                                 .stream()                                 .filter(t->directors.isElectedByStocks(t.getPackageName()))                                 .filter(t -> t.getVotes() >= Seting.ORIGINAL_LIMIT_MIN_VOTE)                                 .sorted(Comparator.comparing(CurrentLawVotesEndBalance::getVotes).reversed())                                 .limit(corp.getKey().getCount())                                 .collect(Collectors.toList());                  System.out.println(\"UtilsCurrentLaw: findPostion: \");                 System.out.println(\"*******************************\");                 electedByStock.stream().forEach(System.out::println);                 System.out.println(\"*******************************\");                  //отобрать то количество которое соответсвтвует данной должности                 temporary = electedByStock;              } else {                  curentLawVotesEndBalance.put(corp.getKey(), curentLawVotesEndBalance.get(corp.getKey()));                 //отобрать то количество которое соответсвтвует данной должности                 //избираемые премьер министром                 if(fIndPositonHelperData.get(corp.getKey()).isElectedWithPrimeMinister()){                     //отобрать голоса выше лимита                     curentLawVotesEndBalance.put(corp.getKey(), curentLawVotesEndBalance.get(corp.getKey()));                     List<CurrentLawVotesEndBalance> electedByPrimeMinister =                             curentLawVotesEndBalance.get(corp.getKey())                                     .stream()                                     .filter(t->directors.isElectedCEO(t.getPackageName()))                                     .filter(t -> t.getVoteGeneralExecutiveDirector() >= Seting.ORIGINAL_LIMIT_MIN_VOTE_GENERAL_EXECUTIVE_DIRECTOR)                                     .sorted(Comparator.comparing(CurrentLawVotesEndBalance::getVoteGeneralExecutiveDirector).reversed())                                     .collect(Collectors.toList());                       //отобрать то количество которое соответсвтвует данной должности                     temporary = electedByPrimeMinister;                 }                 //избираемые палатой представителей                 else if(fIndPositonHelperData.get(corp.getKey()).isElectedWithHousOfRepresentativies()){                     //отобрать голоса выше лимита                     curentLawVotesEndBalance.put(corp.getKey(), curentLawVotesEndBalance.get(corp.getKey()));                     List<CurrentLawVotesEndBalance> electedByHouseOfRepresentatives =                             curentLawVotesEndBalance.get(corp.getKey())                                     .stream()                                     .filter(t->directors.isElectedByBoardOfDirectors(t.getPackageName()))                                     .filter(t -> t.getVotesBoardOfDirectors() >= Seting.ORIGINAL_LIMIT_MIN_VOTE_BOARD_OF_DIRECTORS)                                     .sorted(Comparator.comparing(CurrentLawVotesEndBalance::getVotesBoardOfDirectors).reversed())                                     .collect(Collectors.toList());                       //отобрать то количество которое соответсвтвует данной должности                     temporary = electedByHouseOfRepresentatives;                    }                 //избираемые палатаой верховных судей                 else if(fIndPositonHelperData.get(corp.getKey()).isElectedWithChamberOfHightJudjes()){                     //отобрать голоса выше лимита                     curentLawVotesEndBalance.put(corp.getKey(), curentLawVotesEndBalance.get(corp.getKey()));                     List<CurrentLawVotesEndBalance> electedByChamberOfSupremeJudges =                             curentLawVotesEndBalance.get(corp.getKey())                                     .stream()                                     .filter(t->directors.isElectedBYCorporateCouncilOfReferees(t.getPackageName()))                                     .filter(t -> t.getVotesCorporateCouncilOfReferees() >= Seting.ORIGINAL_LIMIT_MIN_VOTE_CORPORATE_COUNCIL_OF_REFEREES)                                     .sorted(Comparator.comparing(CurrentLawVotesEndBalance::getVotesCorporateCouncilOfReferees).reversed())                                     .collect(Collectors.toList());                       //отобрать то количество которое соответсвтвует данной должности                     temporary = electedByChamberOfSupremeJudges;                  }                 else {                     temporary = curentLawVotesEndBalance.get(corp.getKey()).stream()                              .collect(Collectors.toList());                 }              }              temporary = temporary.stream().distinct().collect(Collectors.toList());              curentLawVotesEndBalance.put(corp.getKey(), temporary);         }           List<LawEligibleForParliamentaryApproval> lawEligibleForParliamentaryApprovals =                 UtilsLaws.readLineCurrentLaws(Seting.ORIGINAL_ALL_CORPORATION_LAWS_WITH_BALANCE_FILE);           Map<Director, List<String>> currentPossitions = new HashMap<>();         for (Map.Entry<Director, FIndPositonHelperData> fIndPositonHelperData1 : fIndPositonHelperData.entrySet()) {             List<CurrentLawVotesEndBalance> position = curentLawVotesEndBalance.get(fIndPositonHelperData1.getKey());             //список адресов на данную позицию, пример члена палаты представителей             List<String> currntAddress = new ArrayList<>();             for (CurrentLawVotesEndBalance address : position) {                 for (LawEligibleForParliamentaryApproval lawEligibleForParliamentaryApproval : lawEligibleForParliamentaryApprovals) {                       if (lawEligibleForParliamentaryApproval.getLaws().getHashLaw().equals(address.getAddressLaw())) {                          currntAddress.add(lawEligibleForParliamentaryApproval.getLaws().getLaws().get(0));                      }                 }              }             currentPossitions.put(fIndPositonHelperData1.getKey(), currntAddress);          }           return currentPossitions;     }      //найти членов палаты представителей     //возвращает список позиций     public static List<String> findPosition(             Map<String, Account> balances,             Blockchain blockchain,             List<LawEligibleForParliamentaryApproval> allGovernment,             List<Account> BoardOfShareholders,             Directors positions,             boolean withLimit      ) throws IOException, NoSuchAlgorithmException, InvalidKeySpecException, SignatureException, NoSuchProviderException, InvalidKeyException {         //список должностей          Map<Director, List<LawEligibleForParliamentaryApproval>> positionsListMap = new HashMap<>();         //добавление всех должностей         for (Director higherSpecialPositions : positions.getDirectors()) {             positionsListMap.put(higherSpecialPositions, UtilsLaws.getPossions(allGovernment, higherSpecialPositions));         }         //список законов с голосами         Map<Director, List<CurrentLawVotesEndBalance>> curentLawVotesEndBalance = new HashMap<>();         for (Map.Entry<Director, List<LawEligibleForParliamentaryApproval>> corp : positionsListMap.entrySet()) {             //убрать повторяющиеся должности из списка.             corp.setValue(corp.getValue().stream() //                    .filter(t-> finalBoardOfShareholders.contains(new Account(t.getLaws().getLaws().get(0), 0, 0)))                     .distinct().collect(Collectors.toList()));              //получить баланс и голоса для действующих законов             curentLawVotesEndBalance.put(corp.getKey(), UtilsGovernment.filters(corp.getValue(), balances, BoardOfShareholders,                     blockchain.getBlockchainList(), Seting.POSITION_YEAR_VOTE));             List<CurrentLawVotesEndBalance> temporary;             if (withLimit) {                 //отобрать голоса выше лимита                 curentLawVotesEndBalance.put(corp.getKey(), curentLawVotesEndBalance.get(corp.getKey())                         .stream().filter(t -> t.getVotes() >= Seting.ORIGINAL_LIMIT_MIN_VOTE)                         .collect(Collectors.toList()));                  //отобрать то количество которое соответсвтвует данной должности                 temporary = curentLawVotesEndBalance.get(corp.getKey()).stream()                         .filter(t -> !t.getPackageName().equals(corp.getKey()))                         .sorted(Comparator.comparing(CurrentLawVotesEndBalance::getVotes).reversed())                         .limit(corp.getKey().getCount()).collect(Collectors.toList());             } else {                 //отобрать то количество которое соответсвтвует данной должности                 temporary = curentLawVotesEndBalance.get(corp.getKey()).stream()                         .filter(t -> !t.getPackageName().equals(corp.getKey()))                         .sorted(Comparator.comparing(CurrentLawVotesEndBalance::getVotes).reversed())                         .collect(Collectors.toList());             }               curentLawVotesEndBalance.put(corp.getKey(), temporary);         }           List<LawEligibleForParliamentaryApproval> lawEligibleForParliamentaryApprovals =                 UtilsLaws.readLineCurrentLaws(Seting.ORIGINAL_ALL_CORPORATION_LAWS_WITH_BALANCE_FILE);          //список адресов на данную позицию, пример члена палаты представителей         List<String> currntAddress = new ArrayList<>();          List<CurrentLawVotesEndBalance> position = curentLawVotesEndBalance.get(positions);          for (CurrentLawVotesEndBalance address : position) {             for (LawEligibleForParliamentaryApproval lawEligibleForParliamentaryApproval : lawEligibleForParliamentaryApprovals) {                   if (lawEligibleForParliamentaryApproval.getLaws().getHashLaw().equals(address.getAddressLaw())) {                      currntAddress.add(lawEligibleForParliamentaryApproval.getLaws().getLaws().get(0));                  }             }         }           return currntAddress;     } }","package International_Trade_Union.vote;  import International_Trade_Union.governments.Director; import International_Trade_Union.governments.Directors; import com.fasterxml.jackson.core.JsonProcessingException; import International_Trade_Union.entity.DtoTransaction.DtoTransaction; import International_Trade_Union.entity.blockchain.block.Block; import International_Trade_Union.setings.Seting; import International_Trade_Union.model.Account; import International_Trade_Union.utils.UtilsFileSaveRead; import International_Trade_Union.utils.UtilsJson; import International_Trade_Union.utils.UtilsUse;   import java.io.File; import java.io.IOException; import java.security.InvalidKeyException; import java.security.NoSuchAlgorithmException; import java.security.NoSuchProviderException; import java.security.SignatureException; import java.security.spec.InvalidKeySpecException; import java.util.*; import java.util.stream.Collectors;  public class UtilsLaws {     public static void saveLaws(List<Laws> laws, String filename) throws IOException {         int fileLimit = Seting.SIZE_FILE_LIMIT * 1024 * 1024;          //папка чтобы проверить есть ли         File folder = new File(filename);         List<String> files = new ArrayList<>();         for (File file : folder.listFiles()) {             if(!file.isDirectory()){                 files.add(file.getAbsolutePath());             }         }          int count = 0;         files = files.stream().sorted().collect(Collectors.toList());         String nextFile = \"\";          if (files.size() > 0) {             nextFile = files.get(files.size()-1);              count = Integer.parseInt(nextFile.replaceAll(\"[^\\\\d]\", \"\"));           }          File file = new File(nextFile);          if(file.length() >= fileLimit){             count++;          }          nextFile = filename + count + \".txt\";          List<String> jsons = new ArrayList<>();         for (Laws laws1: laws) {             String json = UtilsJson.objToStringJson(laws1);             jsons.add(json);         }  //        String json = UtilsJson.objToStringJson(minerAccount); //        UtilsFileSaveRead.save(json + \"\\n\", nextFile);         UtilsFileSaveRead.saves(jsons, nextFile, true);     }     public static void saveLaw(Laws laws, String filename) throws IOException, NoSuchAlgorithmException, SignatureException, InvalidKeySpecException, NoSuchProviderException, InvalidKeyException {         int fileLimit = Seting.SIZE_FILE_LIMIT * 1024 * 1024;          //папка чтобы проверить есть ли         File folder = new File(filename);         List<String> files = new ArrayList<>();         for (File file : folder.listFiles()) {             if (!file.isDirectory()) {                 files.add(file.getAbsolutePath());             }         }          int count = 0;         files = files.stream().sorted().collect(Collectors.toList());         String nextFile = \"\";          if (files.size() > 0) {             nextFile = files.get(files.size() - 1);              count = Integer.parseInt(nextFile.replaceAll(\"[^\\\\d]\", \"\"));           }          File file = new File(nextFile);          if (file.length() >= fileLimit) {             count++;          }          nextFile = filename + count + \".txt\";          String json = UtilsJson.objToStringJson(laws);         UtilsFileSaveRead.save(json + \"\\n\", nextFile);      }      public static void saveCurrentsLaws(List<LawEligibleForParliamentaryApproval> lawEligibleForParliamentaryApprovals, String filename) throws IOException {         int fileLimit = Seting.SIZE_FILE_LIMIT * 1024 * 1024;          //папка чтобы проверить есть ли         File folder = new File(filename);         List<String> files = new ArrayList<>();         for (File file : folder.listFiles()) {             if(!file.isDirectory()){                 files.add(file.getAbsolutePath());             }         }          int count = 0;         files = files.stream().sorted().collect(Collectors.toList());         String nextFile = \"\";          if (files.size() > 0) {             nextFile = files.get(files.size()-1);              count = Integer.parseInt(nextFile.replaceAll(\"[^\\\\d]\", \"\"));           }          File file = new File(nextFile);          if(file.length() >= fileLimit){             count++;          }          nextFile = filename + count + \".txt\";          List<String> jsons = new ArrayList<>();         for (LawEligibleForParliamentaryApproval lawEligibleForParliamentaryApproval : lawEligibleForParliamentaryApprovals) {             String json = UtilsJson.objToStringJson(lawEligibleForParliamentaryApproval);             jsons.add(json);         }  //        String json = UtilsJson.objToStringJson(minerAccount); //        UtilsFileSaveRead.save(json + \"\\n\", nextFile);         UtilsFileSaveRead.saves(jsons, nextFile, true);     }     public static void saveCurrentLaw(LawEligibleForParliamentaryApproval lawEligibleForParliamentaryApproval, String filename) throws IOException, NoSuchAlgorithmException, SignatureException, InvalidKeySpecException, NoSuchProviderException, InvalidKeyException {         int fileLimit = Seting.SIZE_FILE_LIMIT * 1024 * 1024;          //папка чтобы проверить есть ли         File folder = new File(filename);         List<String> files = new ArrayList<>();         for (File file : folder.listFiles()) {             if (!file.isDirectory()) {                 files.add(file.getAbsolutePath());             }         }          int count = 0;         files = files.stream().sorted().collect(Collectors.toList());         String nextFile = \"\";          if (files.size() > 0) {             nextFile = files.get(files.size() - 1);              count = Integer.parseInt(nextFile.replaceAll(\"[^\\\\d]\", \"\"));           }          File file = new File(nextFile);          if (file.length() >= fileLimit) {             count++;          }          nextFile = filename + count + \".txt\";          String json = UtilsJson.objToStringJson(lawEligibleForParliamentaryApproval);         UtilsFileSaveRead.save(json + \"\\n\", nextFile);      }      public static List<Laws> readLineLaws(String filename) throws IOException, NoSuchAlgorithmException, InvalidKeySpecException, SignatureException, NoSuchProviderException, InvalidKeyException {         List<Laws> laws = new ArrayList<>();         File folder = new File(filename);         for (final File fileEntry : folder.listFiles()) {             if (fileEntry.isDirectory()) {                 System.out.println(\"is directory \" + fileEntry.getAbsolutePath());             } else {                 List<String> list = UtilsFileSaveRead.reads(fileEntry.getAbsolutePath());                 for (String s : list) {                      Laws laws1 = UtilsJson.jsonToLaw(s);                     laws.add(laws1);                 }              }         }         laws = laws                 .stream()                 .sorted(Comparator.comparing(Laws::getPacketLawName))                 .collect(Collectors.toList());          return laws;     }      public static List<LawEligibleForParliamentaryApproval> readLineCurrentLaws(String filename) throws JsonProcessingException {         List<LawEligibleForParliamentaryApproval> laws = new ArrayList<>();         File folder = new File(filename);         for (final File fileEntry : folder.listFiles()) {             if (fileEntry.isDirectory()) {                 System.out.println(\"is directory \" + fileEntry.getAbsolutePath());             } else {                 List<String> list = UtilsFileSaveRead.reads(fileEntry.getAbsolutePath());                 for (String s : list) {                      LawEligibleForParliamentaryApproval laws1 = UtilsJson.jsonToCurrentLaw(s);                     laws.add(laws1);                 }              }         }          return laws;     }       //возвращает все счета законов     public static List<Account> allPackegeLaws(Map<String, Account> balances) {         List<Account> laws = new ArrayList<>();         laws = balances.entrySet()                 .stream()                 .map(t -> t.getValue())                 .filter(t -> t.getAccount().startsWith(Seting.NAME_LAW_ADDRESS_START))                 .collect(Collectors.toList());         return laws;     }      //возвращает пакет законов и их счета     public static Map<String, Laws> getPackageLaws(List<Block> blocks) throws IOException, NoSuchAlgorithmException, SignatureException, InvalidKeySpecException, NoSuchProviderException, InvalidKeyException {         Map<String, Laws> laws = new HashMap<>();         for (Block block : blocks) {             for (DtoTransaction dtoTransaction : block.getDtoTransactions()) {                 if (dtoTransaction.verify()) {                     if (dtoTransaction.getCustomer().startsWith(Seting.NAME_LAW_ADDRESS_START) && dtoTransaction.getBonusForMiner() >= Seting.COST_LAW) {                         if(dtoTransaction.getLaws() != null && !laws.containsKey(dtoTransaction.getCustomer())){                             laws.put(dtoTransaction.getCustomer(), dtoTransaction.getLaws());                         }                      }                 }             }          }         return laws;     }      //проверяет валидность закона     public static boolean isValidHashLaw(Laws laws) throws IOException {         String hash = laws.getHashLaw();         String hashLaw = Seting.NAME_LAW_ADDRESS_START + UtilsUse.sha256hash(UtilsJson.objToStringJson(laws));         System.out.println(\"UtilsLaw: isValidHashLaw: \" + hash.equals(hashLaw));         System.out.println(\"hash: \" + hash);         System.out.println(\"hashLaw: \" + hashLaw);         return hash.equals(hashLaw);     }        public static List<Account> allPackageLaws(List<Account> accounts){         List<Account> currentLaws = accounts.stream()                 .filter(t -> t.getAccount().startsWith(Seting.NAME_LAW_ADDRESS_START))                 .collect(Collectors.toList());         return currentLaws;     }      //возвращяет список всех законов, как действующих, так и не действующих, если закон новый то автоматически сохраняет его     public static Map<String, Laws> getLaws(List<Block> blocks, String fileLaws) throws IOException, NoSuchAlgorithmException, InvalidKeySpecException, SignatureException, NoSuchProviderException, InvalidKeyException {         List<Laws> lawsForSave = new ArrayList<>();         Map<String, Laws> lawsMap = new HashMap<>();         File file = new File(fileLaws);         List<Laws> lawsList = new ArrayList<>();         if (file.exists()) {             lawsList = readLineLaws(fileLaws);         }         lawsMap = getPackageLaws(blocks);          for (Map.Entry<String, Laws> map : lawsMap.entrySet()) {             if (!lawsList.contains(map.getValue())) {                 if( map.getValue() != null &&                         map.getValue().packetLawName != null&&                         map.getValue().getLaws() != null                         && !map.getValue().getHashLaw().isEmpty()                         && (map.getValue().getLaws().size() > 0)){                          lawsForSave.add(map.getValue());                 }              }          }         saveLaws(lawsForSave, fileLaws);         return lawsMap;     }     public static List<LawEligibleForParliamentaryApproval> getCurrentLaws(Map<String, Laws> lawsMap, Map<String, Account> balances, String fileCurrentLaws) throws IOException, NoSuchAlgorithmException, SignatureException, InvalidKeySpecException, NoSuchProviderException, InvalidKeyException {         List<Account> lawsBalances = allPackegeLaws(balances);           List<LawEligibleForParliamentaryApproval> lawEligibleForParliamentaryApprovals = new ArrayList<>();         LawEligibleForParliamentaryApproval lawEligibleForParliamentaryApproval = null;         File file = new File(fileCurrentLaws);         if (file.exists()) {             lawEligibleForParliamentaryApprovals = readLineCurrentLaws(fileCurrentLaws);         }          for (LawEligibleForParliamentaryApproval eligibleForParliamentaryApproval : lawEligibleForParliamentaryApprovals) {             if(lawsBalances.contains(eligibleForParliamentaryApproval.getAccount())){                 eligibleForParliamentaryApproval.getAccount().                         setDigitalStockBalance(balances.get(eligibleForParliamentaryApproval.getAccount().getAccount()).getDigitalStockBalance());                 eligibleForParliamentaryApproval.getAccount().                         setDigitalDollarBalance(balances.get(eligibleForParliamentaryApproval.getAccount().getAccount()).getDigitalDollarBalance());             }          }           List<LawEligibleForParliamentaryApproval> temporary = new ArrayList<>();         for (Account account : lawsBalances) {             lawEligibleForParliamentaryApproval = new LawEligibleForParliamentaryApproval(account, lawsMap.get(account.getAccount()));             temporary.add(lawEligibleForParliamentaryApproval);         }           lawEligibleForParliamentaryApprovals.addAll(temporary);           lawEligibleForParliamentaryApprovals = lawEligibleForParliamentaryApprovals.stream()                 .filter(t->Objects.nonNull(t.getLaws()))                 .filter(t->Objects.nonNull(t.getAccount()))                 .filter(t->Objects.nonNull(t.getLaws().getHashLaw()))                 .filter(t->Objects.nonNull(t.getLaws().getLaws()))                 .filter(t->Objects.nonNull(t.getName()))                 .filter(t->Objects.nonNull(t.getLaws().getPacketLawName()))                 .filter(t->t != null).                 filter(UtilsUse.distinctByKey(LawEligibleForParliamentaryApproval::getName)).collect(Collectors.toList());          return lawEligibleForParliamentaryApprovals;      }         //отбирает позицию вакансий     public static List<LawEligibleForParliamentaryApproval> getPossions(List<LawEligibleForParliamentaryApproval> lawEligibleForParliamentaryApprovals, Director higherSpecialPositions){          List<LawEligibleForParliamentaryApproval> temporary = new ArrayList<>();         temporary = lawEligibleForParliamentaryApprovals.stream()                 .filter(t->Objects.nonNull(t))                 .filter(t->Objects.nonNull(t.getLaws()))                 .filter(t->Objects.nonNull(t.getLaws().getLaws()))                 .filter(t->Objects.nonNull(t.getLaws().getPacketLawName()))                 .filter(t->Objects.nonNull(t.getName()))                 .filter(t->Objects.nonNull(t.getLaws().getHashLaw()))                 .sorted((f1, f2) -> Double.compare(f2.getAccount().getDigitalStockBalance(), f1.getAccount().getDigitalStockBalance()))                 .filter(t-> t.getLaws().getPacketLawName().equals(higherSpecialPositions.getName()))                 .limit(higherSpecialPositions.getCount())                 .collect(Collectors.toList());         return temporary;      }       //удаляет из списка не лигитимные должности     public static List<LawEligibleForParliamentaryApproval> deletePossions(List<LawEligibleForParliamentaryApproval> lawEligibleForParliamentaryApprovals, List<LawEligibleForParliamentaryApproval> forDeleted, Directors higherSpecialPositions){         List<LawEligibleForParliamentaryApproval> temporary = new ArrayList<>();         for (LawEligibleForParliamentaryApproval lawEligibleForParliamentaryApproval : forDeleted) {             if(lawEligibleForParliamentaryApproval != null &&                     lawEligibleForParliamentaryApproval.getLaws() != null &&                     lawEligibleForParliamentaryApproval.getLaws().getPacketLawName() != null &&                     lawEligibleForParliamentaryApproval.getLaws().getHashLaw() != null &&                     lawEligibleForParliamentaryApproval.getLaws().getHashLaw() != null &&                     lawEligibleForParliamentaryApproval.getLaws().getPacketLawName().equals(higherSpecialPositions.getNames())){                 if(lawEligibleForParliamentaryApprovals.contains(lawEligibleForParliamentaryApproval)){                     temporary.add(lawEligibleForParliamentaryApproval);                 }else {                     continue;                 }             }             temporary.add(lawEligibleForParliamentaryApproval);         }         return temporary;     }   }","package International_Trade_Union.vote;  public enum VoteEnum {     YES,     NO }","package International_Trade_Union;  import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication;   @SpringBootApplication public class UnitedStatesApplication { \tpublic static void main(String[] args) { \t\tSpringApplication.run(UnitedStatesApplication.class, args); \t}  }","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","",""],"hashLaw":"LIBER10406f42a16accf222cd8731cf51cbf18ea2c9a9a2517fcb5f17ac4f0c60974d"}}
{"name":"LIBERb867962d8c3c78c1bc0a8bdcf61db37ca3358d30748b8a732a9d1ffc01e3a3b7","account":{"account":"LIBERb867962d8c3c78c1bc0a8bdcf61db37ca3358d30748b8a732a9d1ffc01e3a3b7","digitalDollarBalance":0.0,"digitalStockBalance":0.0},"laws":{"packetLawName":"BOARD_OF_DIRECTORS","laws":["stExZb8ifLfnFoq4JJuTifpAcscegATH8znhwW26zyTa","mercurygermes@gmail.com"],"hashLaw":"LIBERb867962d8c3c78c1bc0a8bdcf61db37ca3358d30748b8a732a9d1ffc01e3a3b7"}}
{"name":"LIBER489cd5a211fc67177e79a10a882120e3b3cb1cc90a053d40cd1ce4bda5f31f9a","account":{"account":"LIBER489cd5a211fc67177e79a10a882120e3b3cb1cc90a053d40cd1ce4bda5f31f9a","digitalDollarBalance":0.0,"digitalStockBalance":0.0},"laws":{"packetLawName":"ORIGINAL_CHARTER_CURRENT_LAW_PACKAGE_NAME","laws":["  String POWERS_OF_THE_BOARD_OF_DIRECTORS = \" Полномочия Совета Директоров. \" +             \" Совет Директоров может утверждать счета которые подали на должности из списка Directors. \" +             \" Также Законы название пакетов начинаются с ADD_DIRECTOR являются пакетами которые содержать \" +             \" список новых директоров которые должны управлять новыми линейками продукции. Данные \" +             \" Законы может утверждать только Совет директоров и оттуда будет взять список законов, где \" +             \" каждая строка которая начинается ADD_DIRECTOR будет добавлена в список Directors в качестве новой \" +             \" должности на которую можно подать. \" +             \" пакет который начинается  BUDGET является бюджетом и может его утвердить только Совет директоров. \" +             \" Действующий бюджет может быть только один. \" +             \" Совет директоров также утверждает стратегический план STRATEGIC_PLAN. Действующим может быть только \" +             \" один стратегический план. \" +             \" Совет директоров также участвует в утверждении законов (правил по которым должны действовать \" +             \" все участники корпорации), а также участвует в утверждении внедрения поправок в устав AMENDMENT_TO_THE_CHARTER.\" +             \"\" +             \" Совет имеет право устанавливать и собирать комиссию от продаж внутри платформ принадлежащих Корпорации \" +             \" Международного Торгового Союза, при условии что данная комиссия не будет выше двадцати процентов (20%). \" +             \" Все сборы должны быть направлены на расходы которые установлены бюджетом. \" +             \" Также источником дохода является продажа своих товаров и услуг, для этого есть Директора офисов которые избираются \" +             \" советом директоров и они должны реализовать продукцию Корпорации Международного Торгового Союза. \" +             \"\" ;"," String HOW_LAWS_ARE_CHOSEN =  \" КАК ИЗБИРАЮТСЯ ЗАКОНЫ. \" +             \" Ни один закон не имеет обратной силы. Ни один закон не должен нарушать действующий устав или противоречит \" +             \" другим действующим законам. Если есть противотечение между несколькими законами из одного пакета законов, \" +             \" то действующим является тот который списке находится выше по индексу. Пример: пакет по продаже алкоголя \" +             \" закон под индексом 3 противоречит закону из индекса 17, в даном случае закон под индексом три будет действующим, так как он более выше по статусу. \" +             \" если законы противоречат из разных пакетов, то действующим является тот пакет, который получил больше голосов \" +             \" от Совета акционеров, если есть паритет, то тот который получил больше голосов Совета Директоров, если и здесь \" +             \" есть паритет то данный спор должен решить Верховный Судья, если он также не определил который из двух пакетов \" +             \" где законы противоречат друг другу является законы одно из пакетов более действующими, то в приоритете становиться \" +             \" тот который начал действовать раньше, отсчет определяется именно с последнего момента вступления в силу. \" +             \" Все обычные законы являются действующими если за них проголосовали таким способом ONE_VOTE Совет Акционеров, Совет Директоров и возможно \" +             \" Верховный Судья. Чтобы закон был действующим он должен получить равно или больше 100 остатка голосов Совета Акционеров, \" +             \" равно или больше 15 остатка голосов Совета Директоров и Один голос Верховного Судьи, но если Верховный Судья не проголосовал или проголосовал против \" +             \" то можно обойти вето верховного судьи получив 200 и более остаток голосов Совета Акционеров и 30 и более остаток голосов Совета Директоров. \" +             \" \" +             \" Закон является действующим пока он соответствует количеству голосов как описано выше. Каждый раз как кто то теряет свою должность \" +             \" также теряется все его голоса за все законы которые он проголосовал.\" +             \"\" +             \" Пример кода в LawsController current law:\" +             \" //законы которые получили не достаточно голосов которые могут пройти только если верховный судья одобрит\\n\" +             \"        List<CurrentLawVotesEndBalance> notEnoughVotes = current.stream()\\n\" +             \"                .filter(t -> !directors.contains(t.getPackageName()))\\n\" +             \"                .filter(t->!Seting.AMENDMENT_TO_THE_CHARTER.equals(t.getPackageName()))\\n\" +             \"                .filter(t->!directors.isCabinets(t.getPackageName()))\\n\" +             \"                .filter(t -> !Seting.ORIGINAL_CHARTER_CURRENT_LAW_PACKAGE_NAME.equals(t.getPackageName()))\\n\" +             \"                .filter(t -> t.getVotesBoardOfShareholders() >= Seting.ORIGINAL_LIMIT_MIN_VOTE_BOARD_OF_SHAREHOLDERS)\\n\" +             \"                .filter(t -> t.getVotesBoardOfDirectors() >= Seting.ORIGINAL_LIMIT_MIN_VOTE_BOARD_OF_DIRECTORS)\\n\" +             \"                .filter(t -> t.getVoteHightJudge() >= Seting.ORIGINAL_LIMIT_MIN_VOTE_HIGHT_JUDGE)\\n\" +             \"                .sorted(Comparator.comparing(CurrentLawVotesEndBalance::getVotes).reversed()).collect(Collectors.toList());\\n\" +             \"\\n\" +             \"\\n\" +             \"        //законы которые получили достаточно голосов и не требуют одобрения верховного судьи\\n\" +             \"        List<CurrentLawVotesEndBalance> powerfulVotes = current.stream()\\n\" +             \"                .filter(t -> !directors.contains(t.getPackageName()))\\n\" +             \"                .filter(t-> !Seting.AMENDMENT_TO_THE_CHARTER.equals(t.getPackageName()))\\n\" +             \"                .filter(t-> !directors.isCabinets(t.getPackageName()))\\n\" +             \"                .filter(t -> !Seting.ORIGINAL_CHARTER_CURRENT_LAW_PACKAGE_NAME.equals(t.getPackageName()))\\n\" +             \"                .filter(t -> t.getVotesBoardOfShareholders() >= (Seting.ORIGINAL_LIMIT_MIN_VOTE_BOARD_OF_SHAREHOLDERS * Seting.POWERFUL_VOTE))\\n\" +             \"                .filter(t -> t.getVotesBoardOfDirectors() >= (Seting.ORIGINAL_LIMIT_MIN_VOTE_BOARD_OF_DIRECTORS * Seting.POWERFUL_VOTE))\\n\" +             \"                .sorted(Comparator.comparing(CurrentLawVotesEndBalance::getVotes).reversed()).collect(Collectors.toList()); \";","String HOW_THE_BOARD_OF_DIRECTORS_IS_ELECTED = \" Как избирается Совет Директоров.\" +             \"\" +             \" Совет директоров состоит из 301 счетов BOARD_OF_DIRECTORS. \" +             \" Каждый участник сети может подать на должность совета директоров, создав пакет закона, где \" +             \" название пакета BOARD_OF_DIRECTORS и счет отправителя должен совпадать счетом который указан \" +             \" в первой строке закона который содержится в списке данного пакета. \" +             \" 301 счет с наибольшим количеством остатка голосов получает должность. \" +             \" Стоимость подачи на создание закона(должность) стоит пять цифровых долларов (5) в качестве вознаграждения добытчику. \" +             \" Процесс голосования описан в VOTE_STOCK \" +             \"\" +             \" Пример кода: LawController: method currentLaw: \" +             \" участок кода отвечающий за избрание совета директоров \" +             \"  //минимальное значение количество положительных голосов для того чтобы закон действовал, \\n\" +             \"        //позиции избираемые акциями членов Совета Директоров\\n\" +             \"        List<CurrentLawVotesEndBalance> electedByStockBoardOfDirectors = current.stream()\\n\" +             \"                .filter(t -> directors.isElectedByStocks(t.getPackageName()))\\n\" +             \"                .filter(t -> t.getPackageName().equals(NamePOSITION.BOARD_OF_DIRECTORS.toString()))\\n\" +             \"                .filter(t -> t.getVotes() >= Seting.ORIGINAL_LIMIT_MIN_VOTE)\\n\" +             \"                .sorted(Comparator.comparing(CurrentLawVotesEndBalance::getVotes).reversed())\\n\" +             \"                .limit(directors.getDirector(NamePOSITION.BOARD_OF_DIRECTORS.toString()).getCount())\\n\" +             \"                .collect(Collectors.toList()); \";","String POWERS_OF_THE_BOARD_OF_SHAREHOLDERS = \" Полномочия совета акционеров.  \" +             \" Совет Акционеров Участвует в утверждении Законов (правил которые должны соблюдать все участники данной Корпорации). \" +             \" Также Совет Акционеров участвует в утверждении поправок в устав Корпорации Международного Торгового Союза AMENDMENT_TO_THE_CHARTER. \" +             \" Совет Акционеров также может участвовать в голосовании при избрании кандидатов CORPORATE_COUNCIL_OF_REFEREES и BOARD_OF_DIRECTORS \" +             \" используя эти правила для голосования за кандидатов VOTE_STOCK. \" +             \"\";","String HOW_SHAREHOLDERS_BOARD_IS_ELECTED = \" КАК ИЗБИРАЕТСЯ СОВЕТ АКЦИОНЕРОВ. \" +             \" Совет Акционеров состоит из тысячи пятьсот счетов (1500) с наибольшим количеством акций, но учитываются только те счета \" +             \" от чьей активности не прошло больше года. формула: текущий год - один год, и если счет был активен в этом диапазоне, он \" +             \" учитывается. Все счета сортируются по убыванию количества цифровых акций, и отбираются 1500 счетов с наибольшим количеством  \" +             \" акций. Перерасчет происходит Каждый блок. \" +             \"\" +             \"  Пример участка кода как избирается Совет Акционеров: \" +             \" class UtilsGovernment method findBoardOfShareholders: \" +             \"  //определение совета акционеров\\n\" +             \"    public static List<Account> findBoardOfShareholders(Map<String, Account> balances, List<Block> blocks, int limit) {\\n\" +             \"        List<Block> minersHaveMoreStock = null;\\n\" +             \"        if (blocks.size() > limit) {\\n\" +             \"            minersHaveMoreStock = blocks.subList(blocks.size() - limit, blocks.size());\\n\" +             \"        } else {\\n\" +             \"            minersHaveMoreStock = blocks;\\n\" +             \"        }\\n\" +             \"        List<Account> boardAccounts = minersHaveMoreStock.stream().map(\\n\" +             \"                        t -> new Account(t.getMinerAddress(), 0, 0))\\n\" +             \"                .collect(Collectors.toList());\\n\" +             \"\\n\" +             \"        for (Block block : minersHaveMoreStock) {\\n\" +             \"            for (DtoTransaction dtoTransaction : block.getDtoTransactions()) {\\n\" +             \"                boardAccounts.add(new Account(dtoTransaction.getSender(), 0, 0));\\n\" +             \"            }\\n\" +             \"\\n\" +             \"        }\\n\" +             \"\\n\" +             \"\\n\" +             \"        CompareObject compareObject = new CompareObject();\\n\" +             \"\\n\" +             \"        List<Account> boardOfShareholders = balances.entrySet().stream()\\n\" +             \"                .filter(t -> boardAccounts.contains(t.getValue()))\\n\" +             \"                .map(t -> t.getValue()).collect(Collectors.toList());\\n\" +             \"\\n\" +             \"\\n\" +             \"        boardOfShareholders = boardOfShareholders\\n\" +             \"                .stream()\\n\" +             \"                .filter(t -> !t.getAccount().startsWith(Seting.NAME_LAW_ADDRESS_START))\\n\" +             \"                .filter(t -> t.getDigitalStockBalance() > 0)\\n\" +             \"                .sorted(Comparator.comparing(Account::getDigitalStockBalance).reversed())\\n\" +             \"                .collect(Collectors.toList());\\n\" +             \"\\n\" +             \"        boardOfShareholders = boardOfShareholders\\n\" +             \"                .stream()\\n\" +             \"                .limit(Seting.BOARD_OF_SHAREHOLDERS)\\n\" +             \"                .collect(Collectors.toList());\\n\" +             \"\\n\" +             \"        return boardOfShareholders;\\n\" +             \"    } \";","String VOTE_STOCK = \" Как с помощью акций происходит голосование. \" +             \" Все акции которым счет владеет, приравниваются такому же количеству голосов. \" +             \" каждый раз когда кто то делает транзакцию на счет, который является адресом пакета который начинается с \" +             \" LIBER он голосует за данный пакет. Учитываются только те голоса, с которых не прошло больше четырех лет. \" +             \" если транзакция была совершена VoteEnum.YES то данный счет получает голоса за по формуле \" +             \" yesV = количество голосов равные количеству акций отправителя.\" +             \" yesN = за сколько законов данный счет проголосовал с VoteEnum.YES\" +             \" resultYES = yesV / math.pow(yesN, 3). Пример: счет проголосовал за три счета которые начинаются с LIBER,\" +             \" на счету сто акций, значит сто голосов. 100 / math.pow(3, 3) = 3.7 значит каждый счет получит по 3.7 голоса. \" +             \"\" +             \" если транзакция была совершена с VoteEnum.NO \" +             \" то используется такая же формула, но учитываются теперь все счета за которые он проголосовал против \" +             \" пример тот же счет проголосовал за два счет против, у него те же сто акций. \" +             \" resultNO = noV / math.pow(noN, 3) = 100/ math.pow(2,3) = 12.5 значит каждый счет за который он проголосовал, \" +             \" против получит 12.5 голосов против. \" +             \" дальше каждый счет подсчитывает все отданные ему голоса ЗА (VoteEnum.YES)  и ПРОТИВ (VoteEnum.NO). \" +             \" Потом используется данная формула remainder = resultYES - resultNO. \" +             \" сначала данные должности отбираются все счета которые получили больше или равно четырнадцать тысяч \" +             \" четыреста голосов остатка (14400) remainder >= 14400.\" +             \" Дальше все счета сортируются по убыванию remainder и оттуда отбираются то количество счетов на \" +             \" данные должности, сколько это оговорено в данной должности. Пример: \" +             \" Для Совета Директоров это 301 счет с наибольшим количеством остатка. \" +             \" \" +             \" В любой момент можно изменить свой голос, но только на противоположный, что значит если \" +             \" вы проголосовали за кандидата YES то вы можете изменить только на NO и обратно. \" +             \" Количество раз сколько вы можете изменить свой голос не ограничено. \" +             \" С каждым блоком происходит перерасчет голосов, если вы теряете свои акции, ваши кандидаты \" +             \" также теряют свои голоса. Данная мера специально так реализовано чтобы избираемые должности \" +             \" были заинтересованы в том чтобы вы процветали. \" +             \" Таким способом избираются Только CORPORATE_COUNCIL_OF_REFEREES и BOARD_OF_DIRECTORS\" +             \" Учитывается только последняя транзакция отданная за каждый счет, если вы не обновляли свой голос, \" +             \" то по прошествии четырех лет он аннулируется. \";"," String CODE_VOTE_STOCK = \" class CurrentLawVotes method: votesLaw \" +             \" public double votesLaw(Map<String, Account> balances,\\n\" +             \"                           Map<String, Integer> yesAverage, Map<String, Integer> noAverage) {\\n\" +             \"        double yes = 0.0;\\n\" +             \"        double no = 0.0;\\n\" +             \"\\n\" +             \"        //\\n\" +             \"        for (String s : YES) {\\n\" +             \"\\n\" +             \"            int count = 1;\\n\" +             \"            count = yesAverage.get(s) > 0 ? yesAverage.get(s) : 1;\\n\" +             \"            yes += balances.get(s).getDigitalStockBalance() / Math.pow(count, Seting.POWERING_FOR_VOTING);\\n\" +             \"\\n\" +             \"        }\\n\" +             \"        //\\n\" +             \"        for (String s : NO) {\\n\" +             \"            int count = 1;\\n\" +             \"            count = noAverage.get(s) > 0 ? noAverage.get(s) : 1;\\n\" +             \"            no += balances.get(s).getDigitalStockBalance() / Math.pow(count, Seting.POWERING_FOR_VOTING);\\n\" +             \"\\n\" +             \"        }\\n\" +             \"\\n\" +             \"\\n\" +             \"        return yes - no;\\n\" +             \"    } \";"," String POWERS_OF_DIRECTORS_IN_THE_OFFICE = \" ПОЛНОМОЧИЯ ДИРЕКТОРОВ В ОФИС. \" +             \" Директорами офиса, называются высшие директора которые являются директорами своих дивизионов. \" +             \" Полномочия каждого директора должны быть описаны действующими законами. Но каждый директор должен управлять \" +             \" только своим дивизионом. Координацией всех директоров должен руководить Генеральный Исполнительный Директор GENERAL_EXECUTIVE_DIRECTOR. \" +             \" \" +             \" Совет Директоров, CORPORATE_COUNCIL_OF_REFEREES, HIGH_JUDGE, Совет Акционеров и GENERAL_EXECUTIVE_DIRECTOR могут быть как \" +             \" физическими лицами, так и юридическими лицами, но один счет будет учитываться как один голос. \";","String HOW_OFFICE_DIRECTORS_ARE_CHOSEN = \" КАК ИЗБИРАЮТСЯ ОФИСНЫЕ ДИРЕКТОРА. \" +             \" Все Директора офиса, это высшие директора которые управляют своими дивизионами, избираются только Советом Директоров. \" +             \" Каждый участник сети может подать на должность высшего директора, создав закон, с названием пакета который совпадает с допустимыми \" +             \" должностями, где адрес отправителя данной транзакции должен совпадать с первой строкой из списка законов данного пакета. \" +             \" стоимость закона пять цифровых долларов в качестве вознаграждения добытчику.  \" +             \" счет с наибольшим количеством голосов остатка получает данную должность. \" +             \" Механизм голосования описан ONE_VOTE. \" +             \"\" +             \" Пример участка кода как избирается должности class LawsController: method currentLaw: \" +             \"\" +             \" //позиции созданные советом директоров\\n\" +             \"        List<CurrentLawVotesEndBalance> createdByBoardOfDirectors = current.stream()\\n\" +             \"                .filter(t->t.getPackageName().startsWith(Seting.ADD_DIRECTOR))\\n\" +             \"                .filter(t->t.getVotesBoardOfDirectors() >= Seting.ORIGINAL_LIMIT_MIN_VOTE_BOARD_OF_DIRECTORS)\\n\" +             \"                .collect(Collectors.toList());\\n\" +             \"        //добавление позиций созданных советом директоров\\n\" +             \"        for (CurrentLawVotesEndBalance currentLawVotesEndBalance : createdByBoardOfDirectors) {\\n\" +             \"            directors.addAllByBoardOfDirectors(currentLawVotesEndBalance.getLaws());\\n\" +             \"        }\\n\" +             \"\\n\" +             \"        //позиции избираемые только советом директоров\\n\" +             \"        List<CurrentLawVotesEndBalance> electedByBoardOfDirectors = current.stream()\\n\" +             \"                .filter(t -> directors.isElectedByBoardOfDirectors(t.getPackageName()) || directors.isCabinets(t.getPackageName()))\\n\" +             \"                .filter(t -> t.getVotesBoardOfDirectors() >= Seting.ORIGINAL_LIMIT_MIN_VOTE_BOARD_OF_DIRECTORS)\\n\" +             \"                .sorted(Comparator.comparing(CurrentLawVotesEndBalance::getVotesBoardOfDirectors).reversed())\\n\" +             \"                .collect(Collectors.toList());\";","  String ONE_VOTE = \" ОДИН ГОЛОС. \" +             \"\" +             \" Когда голосуют данные должности, учитывается как один счет = один голос \" +             \" (CORPORATE_COUNCIL_OF_REFEREES, BOARD_OF_DIRECTORS, GENERAL_EXECUTIVE_DIRECTOR, HIGH_JUDGE и Совет Акционеров). \" +             \" каждый счет который начинается с LIBER учитывает все голоса ЗА (VoteEnum.YES) и ПРОТИВ (VoteEnum.NO) за него \" +             \" дальше отнимается от ЗА - ПРОТИВ = если остатков выше порога, то он становиться действующим законом, но если избирается должности \" +             \" то после сортируется от наибольшего к наименьшим и отбираются то количество наибольших, которое описано для данной должности. \" +             \" Перерасчет голосов происходит каждый блок. После голосования голос можно поменять только на противоположный. \" +             \" Ограничений на количество сколько раз можно поменять свой голос нет. Учитываются только те голоса которые даны счетами \" +             \" находящимися в своей должности, к примеру если счет перестал быть в Совете Директор, его голос как в качестве \" +             \" Совета Директоров не учитывается, и не будет учитываться в голосовании. Все голоса действуют, пока счета \" +             \" проголосовавшие находятся в своих должностях. Учитываются также только те голоса, от которых прошло не более \" +             \" четырех лет, но каждый участник, может в любой момент времени обновить свой голос.  \";"," String CODE_VOTE_ONE = \" КОД class CurrentLawVotes: method voteGovernment \" +             \"\" +             \" public int voteGovernment(\\n\" +             \"            Map<String, Account> balances,\\n\" +             \"            List<String> governments\\n\" +             \"\\n\" +             \"    ) {\\n\" +             \"        int yes = 0;\\n\" +             \"        int no = 0;\\n\" +             \"\\n\" +             \"        List<String> addressGovernment = governments;\\n\" +             \"        for (String s : YES) {\\n\" +             \"            if (addressGovernment.contains(s)) {\\n\" +             \"                yes += Seting.VOTE_GOVERNMENT;\\n\" +             \"            }\\n\" +             \"\\n\" +             \"        }\\n\" +             \"        for (String s : NO) {\\n\" +             \"            if (addressGovernment.contains(s)) {\\n\" +             \"                no += Seting.VOTE_GOVERNMENT;\\n\" +             \"            }\\n\" +             \"\\n\" +             \"        }\\n\" +             \"\\n\" +             \"\\n\" +             \"        return yes - no;\\n\" +             \"\\n\" +             \"    } \";","  String MECHANISM_FOR_REDUCING_THE_NUMBER_OF_SHARES = \" МЕХАНИЗМ СНИЖЕНИЯ КОЛИЧЕСТВА АКЦИЙ. \" +             \" Каждый раз когда один счет отправляет на другой счет цифровую акцию, но использует VoteEnum.NO, счет \" +             \" цифровых акций получателя снижается на то количество которое отправил отправитель акций. \" +             \" Пример счет А отправил на счет Б 100 цифровых акций с VoteEnum.NO, тогда счет А и счет Б оба теряют 100 \" +             \" цифровых акций. Данная мера нужна чтобы был механизм снять с должности Совета акционеров и также позволяет снижать голоса \" +             \" деструктивных счетов, так как количество голосов, равно количеству акций, при Избрании Совета Директоров и \" +             \" при избрании CORPORATE_COUNCIL_OF_REFEREES. \" +             \" Данный механизм действует только на цифровые акции и только в том случае, что отправитель отправил с знаком \" +             \" VoteEnum.NO \";"," String WHO_HAS_THE_RIGHT_TO_CREATE_LAWS = \" Создавать законы в криптовалюте Корпорации Международный Торговый Союз имеют права \" +             \" все участники сети, которые имеют минимум пять цифровых долларов. \" +             \" Для создания закона через механизм криптовалюты Корпорации Международного торгового Союза \" +             \" Нужно внутри данной криптовалюты Создать объект класса Laws, где packetLawName - является названием пакета законов. \" +             \" List<String> laws - является списком законов, String hashLaw - является адресом данного пакета законов и начинается с LIBER. \" +             \" Чтобы Закон попал в пул законов нужно создать транзакцию где получателем является hashLaw данного закона и вознаграждение \" +             \" майнера равно пять цифровых доллара (5)  данной криптовалюты. После этого как закон попадет в блок, он окажется в пуле \" +             \" законов и за него можно будет голосовать. \" +             \" Количество строк в пакете законов может быть столько, сколько понадобиться и нет никаких ограничений. \";","String POWERS_OF_THE_CORPORATE_COUNCIL_OF_JUDGES = \" ПОЛНОМОЧИЯ КОРПОРАТИВНОГО СОВЕТА СУДЕЙ. \" +             \" Утверждает Верховного судью. \" +             \" Участвует в голосовании внедрения поправок. \" +             \" \" +             \" Судебная власть Корпорации Международного Торгового Союза принадлежит \" +             \" одному Верховному суду и таким нижестоящим судам, которые Корпорация Международный \" +             \" Торговый Союз может время от времени издавать и учреждать. \" +             \" Судьи как верховных, так и нижестоящих судов занимают свои должности при хорошем поведении и \" +             \" в установленные сроки получают за свои услуги вознаграждение. \" +             \" Судебная власть распространяется на все дела по закону и справедливости, \" +             \" в том числе инициированные членами для оспаривания незаконного расходования средств, \" +             \" возникающего в соответствии с настоящем Уставом, законами Корпорации Международного Торгового Союза и договорами, \" +             \" заключенными или которые будут заключены в соответствии с их авторитетом. \" +             \" К спорам, \" +             \" в которых Международный Торговый Союз будут стороной к разногласиям между двумя или более участников сети. \" +             \" Ни один суд не должен быть тайным, но правосудие должно вершиться открыто и бесплатно, полностью и безотлагательно, \" +             \" и каждый человек должен иметь правовую правовую защиту от вреда, причиненного жизни, свободе или имуществу. \" +             \" Верховный Суд CORPORATE_COUNCIL_OF_REFEREES и верховный судья HIGH_JUDGE \";"," String HOW_THE_CORPORATE_BOARD_OF_JUDGES_IS_ELECTED = \" КАК ИЗБИРАЮТСЯ КОРПОРАТИВНЫЙ СОВЕТ СУДЕЙ. \" +             \" CORPORATE_COUNCIL_OF_REFEREES \" +             \"  состоит из 55 счетов. \" +             \" каждый участник сети может подать на должность CORPORATE_COUNCIL_OF_REFEREES , создав пакет закона, где \" +             \" название пакета CORPORATE_COUNCIL_OF_REFEREES и счет отправителя должен совпадать счетом который указан \" +             \" в первой строке закона который содержится в списке данного пакета \" +             \" 55 счет с наибольшим количеством остатка голосов получает должность. \" +             \" стоимость подачи на создание закона(должность) стоит пять цифровых долларов (5) в качестве вознаграждения добытчику. \" +             \" Процесс голосования описан в VOTE_STOCK \" +             \"\" +             \" Пример участка кода: class LawsController: method currentLaw: \" +             \"  //минимальное значение количество положительных голосов для того чтобы закон действовал,\\n\" +             \"        //позиции избираемые акциями CORPORATE_COUNCIL_OF_REFEREES\\n\" +             \"        List<CurrentLawVotesEndBalance> electedByStockCorporateCouncilOfReferees = current.stream()\\n\" +             \"                .filter(t -> directors.isElectedByStocks(t.getPackageName()))\\n\" +             \"                .filter(t -> t.getPackageName().equals(NamePOSITION.CORPORATE_COUNCIL_OF_REFEREES.toString()))\\n\" +             \"                .filter(t -> t.getVotes() >= Seting.ORIGINAL_LIMIT_MIN_VOTE)\\n\" +             \"                .sorted(Comparator.comparing(CurrentLawVotesEndBalance::getVotes).reversed())\\n\" +             \"                .limit(directors.getDirector(NamePOSITION.CORPORATE_COUNCIL_OF_REFEREES.toString()).getCount())\\n\" +             \"                .collect(Collectors.toList());\\n\";"," String HOW_THE_CHIEF_JUDGE_IS_CHOSEN = \" КАК ИЗБИРАЕТСЯ ВЕРХОВНЫЙ СУДЬЯ HIGH_JUDGE. \" +             \" Верховный Судья избирается CORPORATE_COUNCIL_OF_REFEREES. \" +             \" Каждый участник сети может подать на должность Верховного Судьи, создав закон, с названием пакета который совпадает с допустимым \" +             \" должностью, где адрес отправителя данной транзакции должен совпадать с первой строкой из списка законов данного пакета. \" +             \" стоимость закона пять цифровых долларов в качестве вознаграждения добытчику.  \" +             \" счет с наибольшим количеством голосов остатка получает данную должность. \" +             \" Механизм голосования описан ONE_VOTE. \" +             \"\" +             \" Пример кода как утверждается верховный судья. class LawsController: method currentLaw. Участок кода \" +             \"   //позиции избираемые советом корпоративных верховных судей\\n\" +             \"        List<CurrentLawVotesEndBalance> electedByCorporateCouncilOfReferees = current.stream()\\n\" +             \"                .filter(t -> directors.isElectedBYCorporateCouncilOfReferees(t.getPackageName()))\\n\" +             \"                .filter(t -> t.getVotesCorporateCouncilOfReferees() >= Seting.ORIGINAL_LIMIT_MIN_VOTE_CORPORATE_COUNCIL_OF_REFEREES)\\n\" +             \"                .sorted(Comparator.comparing(CurrentLawVotesEndBalance::getVotesCorporateCouncilOfReferees)).collect(Collectors.toList()); \";","     String POWERS_OF_THE_CHIEF_JUDGE = \" ПОЛНОМОЧИЯ ВЕРХОВНОГО СУДЬИ. \" +             \" Верховный судья участвует в утверждении законов, а также \" +             \" может участвовать в решении споров внутри членов сети как и CORPORATE_COUNCIL_OF_REFEREES, \" +             \" но его голос выше чем голос CORPORATE_COUNCIL_OF_REFEREES. \";"," String HOW_IS_THE_PROCESS_OF_AMENDING_THE_CHARTER = \" КАК ПРОИСХОДИТ ПРОЦЕСС ВНЕСЕНИЯ ПОПРАВОК В УСТАВ. \" +             \" Для внесения поправок, нужно создать закон с названием пакета AMENDMENT_TO_THE_CHARTER, \" +             \" дальше за этот закон должны проголосовать методом описанным в VOTE_ONE \" +             \" Совет Акционеров и остаток голосов должен быть равен или выше 300 участников, \" +             \" также должны проголосовать Совет Директоров и остаток голосов должен быть 60 или больше, \" +             \" также должны проголосовать корпоративные верховные судьи (CORPORATE_COUNCIL_OF_REFEREES) и \" +             \" остаток голосов должен быть равен или больше 5. \" +             \" Но поправки не должны касаться способа установления правил действующих законов, а также \" +             \" избрания Совета Директоров, Совета Акционеров, Генерального Исполнительного Директора, \" +             \" Совета Корпоративных Судей и Верховного Судьи. Поправки могут изменять код, если сохраняются правила \" +             \" избрания действующих должностей (включая правил голосования), законов и добычи денег (добыча цифровых долларов и цифровых акции),\" +             \" Ни одна поправка не должна наделять из выше перечисленных должностей большей властью. \" +             \" Также поправки не должны ущемлять Естественные Права Человека. \" +             \" \" +             \" Пример кода. class LawsController: method currentLaw: участок кода утверждающий действующие поправки\" +             \"  //внедрение поправок в устав\\n\" +             \"        List<CurrentLawVotesEndBalance> chapter_amendment = current.stream()\\n\" +             \"                .filter(t -> !directors.contains(t.getPackageName()))\\n\" +             \"                .filter(t-> Seting.AMENDMENT_TO_THE_CHARTER.equals(t.getPackageName()))\\n\" +             \"                .filter(t->!directors.isCabinets(t.getPackageName()))\\n\" +             \"                .filter(t -> t.getVotesBoardOfShareholders() >= Seting.ORIGINAL_LIMIT_MINT_VOTE_BOARD_OF_SHAREHOLDERS_AMENDMENT)\\n\" +             \"                .filter(t -> t.getVotesBoardOfDirectors() >= Seting.ORIGINAL_LIMIT_MIN_VOTE_BOARD_OF_DIRECTORS_AMENDMENT)\\n\" +             \"                .filter(t -> t.getVotesCorporateCouncilOfReferees() >= Seting.ORIGINAL_LIMIT_MIN_VOTE_CORPORATE_COUNCIL_OF_REFEREES_AMENDMENT)\\n\" +             \"                .sorted(Comparator.comparing(CurrentLawVotesEndBalance::getVotesBoardOfDirectors).reversed()).collect(Collectors.toList());\\n \";","String HOW_THE_BUDGET_IS_APPROVED = \" КАК УТВЕРЖДАЕТСЯ БЮДЖЕТ. \" +             \" Действующий бюджет может быть только один. Бюджет утверждает только Совет Директоров. \" +             \" Для утверждения бюджета нужно получить методом описанным в VOTE_ONE 15 и больше голосов. \" +             \" сам процесс происходит так: \" +             \" 1. Сначала отбираются все пакеты законов где название пакета совпадает с BUDGET. \" +             \" 2. Дальше отбираются все пакеты которые остаток голосов получили 15 или больше. \" +             \" 3. Дальше все эти пакеты сортируются по убыванию, с наибольшим количеством голосов. \" +             \" 4. Дальше отбирается самый первый с наибольшим количеством голосов. \" +             \"\" +             \" Пример кода утверждающий бюджет. class LawsController: method: currentLaw. \" +             \"   //бюджет утверждается только советом директоров.\\n\" +             \"        List<CurrentLawVotesEndBalance> budjet = current.stream()\\n\" +             \"                .filter(t-> !directors.contains(t.getPackageName()))\\n\" +             \"                .filter(t->Seting.BUDGET.equals(t.getPackageName()))\\n\" +             \"                .filter(t->!directors.isCabinets(t.getPackageName()))\\n\" +             \"                .filter(t-> t.getVotesBoardOfDirectors() >= Seting.ORIGINAL_LIMIT_MIN_VOTE_BOARD_OF_DIRECTORS)\\n\" +             \"                .sorted(Comparator.comparing(CurrentLawVotesEndBalance::getVotesBoardOfDirectors).reversed())\\n\" +             \"                .limit(1)\\n\" +             \"                .collect(Collectors.toList());\";"," String HOW_IS_THE_STRATEGIC = \" КАК УТВЕРЖДАЕТСЯ СТРАТЕГИЧЕСКИЙ ПЛАН. \" +             \" Стратегический план утверждает Совет Директоров, стратегический план может быть действующим \" +             \" только в единственном экземпляре. Чтобы Стратегический План был действующим, нужно остаток голосов \" +             \" Совета Директоров 15 или больше. Способ голосования VOTE_ONE. \" +             \"  \" +             \" Совет Директоров в любой момент может отменить Стратегический План. Стратегический План действует \" +             \" пока количество голосов 15 или больше. Стратегический План может включать в себя общее направление \" +             \" Корпорации, а также что нужно реализовать. \" +             \"\" +             \" участок кода который показывает как утверждается Стратегический План. \" +             \" class LawsController: method currentLaw: \" +             \" \\n\" +             \"        //план утверждается только палатой Советом Директоров\\n\" +             \"        List<CurrentLawVotesEndBalance> planFourYears = current.stream()\\n\" +             \"                .filter(t->!directors.contains(t.getPackageName()))\\n\" +             \"                .filter(t->Seting.STRATEGIC_PLAN.equals(t.getPackageName()))\\n\" +             \"                .filter(t->!directors.isCabinets(t.getPackageName()))\\n\" +             \"                .filter(t->t.getVotesBoardOfDirectors() >= Seting.ORIGINAL_LIMIT_MIN_VOTE_BOARD_OF_DIRECTORS)\\n\" +             \"                .sorted(Comparator.comparing(CurrentLawVotesEndBalance::getVotesBoardOfDirectors).reversed())\\n\" +             \"                .limit(1)\\n\" +             \"                .collect(Collectors.toList());\";","String HOW_NEW_POSITIONS_ARE_ADDED = \" КАК ДОБАВЛЯЮТСЯ НОВЫЕ ДОЛЖНОСТИ. \" +             \" Таким способом добавляются только высшее руководство, подчиненные каждого руководителя \" +             \" нанимают без использования блокчейна, их может нанять сам директор, или иным способом как \" +             \" описано действующими законами. Высшее руководство добавляется в список class Directors. \" +             \" все новые добавленные должности действуют пока их законы которые создают данные должности \" +             \" действуют. Добавлять новые должности может только Совет директоров. \" +             \" Каждый пакет законов который начинается с ADD_DIRECTOR определяется как добавление должности. \" +             \" список законов который находиться внутри данного пакета являются должностями если название в \" +             \" строке начинается с ADD_DIRECTOR. Пример: название пакета ADD_DIRECTOR_PACKAGE\" +             \" название первой третьей и четвертой строки ADD_DIRECTOR_FIRST ADD_DIRECTOR_THIRD \" +             \" ADD_DIRECTOR_FOUR таким образом будет созданы три места для должности. \" +             \" Но если строка начинается с ADD_DIRECTOR, то название должности должно быть большими \" +             \" буквами и нижними подчеркиваниями, так же в одной строке должна быть только одна должность \" +             \" и больше никаких слов. Те строки где нет добавления должности, используются для описания \" +             \" полномочий добавленных должностей. \" +             \" Чтобы новые должности были добавлены в список, Совет Директоров должен проголосовать методом \" +             \" VOTE_ONE 15 или больше голосов. \" +             \" После как новые должности будут созданы, каждый участник сети сможет подавать себя на данные должности. \" +             \"\" +             \" пример участка кода который создает новые должности. \" +             \" class LawsController: method currentLaw: \" +             \"\" +             \" \\n\" +             \"        //добавляет законы, которые создают новые должности директоров\\n\" +             \"        List<CurrentLawVotesEndBalance> addDirectors = current.stream()\\n\" +             \"                .filter(t->t.getPackageName().startsWith(Seting.ADD_DIRECTOR))\\n\" +             \"                .filter(t->t.getVotesBoardOfDirectors() >= Seting.ORIGINAL_LIMIT_MIN_VOTE_BOARD_OF_DIRECTORS)\\n\" +             \"                .collect(Collectors.toList());\";"," String PROPERTY_OF_THE_CORPORATION = \"  СОБСТВЕННОСТЬ КОРПОРАЦИИ. \" +             \" Вся собственность которая принадлежит Корпорации Международного Торгового Союза, не может быть продана без действующего закона, \" +             \" где будет описан процесс продажи и по какой стоимости будет продана собственность. Счет основателя, и счета других участников не является \" +             \" счетом корпорации, Совет Директоров должен создать отдельный счет который будет  бюджетом и управляться только членами действующих членов \" +             \" Совета Директоров. \";"," String INTERNET_STORE_DIRECTOR = \" Данный директор занимается разработкой, продвижением и руководством интернет магазина, в котором должны \" +             \" продаваться товары за цифровой доллар или цифровые акции. Детальные полномочия должны быть данны или через действующие законы или \" +             \" выданы Генеральным исполнительным директором или Советом Директоров. \" +             \"Название Магазина должен определить либо Совет Директоров или Генеральный Исполнительный Директор. \";","String GENERAL_EXECUTIVE_DIRECTOR = \" Данный Директор координирует действия остальных высших директоров для реализации стратегического плана или \" +             \" поставленных перед ним задач действующими законами. Все полномочия должны быть ему выданы через действующие законы. \";"," String DIRECTOR_OF_THE_DIGITAL_EXCHANGE = \" Данный Директор разработкой, продвижением и руководством интернет биржа. Полномочия должны быть \" +             \" выданы ему или действующими законами, или Советом Директоров или или Генеральным Исполнительным Директором. \";","String DIRECTOR_OF_DIGITAL_BANK = \" Данный Директор руководит интернет банком. Все полномочия должны быть выданы или действующими законами, или Советом директоров \" +             \" или Генеральным Исполнительным Директором. \";","String DIRECTOR_OF_THE_COMMERCIAL_COURT = \" Директор частного коммерческого суда должен обеспечивать руководство частным судом, все полномочия \" +             \" должны быть Выданы или действующими законами или Советом Директоров или Генеральным Исполнительным Директором. \";","String MEDIA_DIRECTOR = \" Данный Директор руководит сми, все полномочия должны быть выданы действующими законами, или Советом Директоров или \" +             \" генеральным исполнительным Директором. \";"," String DIRECTOR_OF_THE_DEVELOPMENT_OF_THE_IMPLEMENTATION_OF_CRYPTOCURRENCY_TECHNOLOGIES_OF_THE_INTERNATIONAL_TRADE_UNION_CORPORATION = \"\" +             \" Данный Директор руководит разработкой и внедрением нового кода в данную криптовалюту, все полномочия должны быть выданы только через \" +             \" действующие законы, но также могут быть выданы или Советом Директоров, если действующие законы дали такие полномочия Совету Директоров. \" +             \" Также ни одно изменение кода не должно противоречить действующему уставу или действующим законам, Также полномочия могут быть выданы \" +             \" Генеральным Исполнительным Директором, если генеральному исполнительному директору данные полномочия выданы действующим законами. \";"," String EXPLANATION_WHY_MONEY_DEMURAGE_IS_USED_HERE = \" ОБЯСНЕНИЕ ПОЧЕМУ ЗДЕСЬ ИСПОЛЬЗУЕТСЯ  ДЕМЕРЕДЖ ДЕНЕГ..\" +             \" Отрицательная ставка сейчас применяется во множестве стран, данная стимулирует держателей денег, когда цена чрезмерно завышена, \" +             \" насыщать рынок деньгами. Количество добываемых денег за каждый блок составляет 200 цифровых долларов и 200 цифровых акций, \" +             \" также 2% от каждой добычи вознаграждение основателю, что составляет 4 цифровых доллара и 4 цифровых Акций при каждой добыче блока. \" +             \" Здесь используется как Теории сильвио Гезеля, а также школы монетаризма (в измененном виде \" +             \" у сильвио Гезеля, отрицательная ставка составляла 1% в месяц, что просто убило бы экономику, \" +             \" при монетаризме рост денежной массы должен был быть пропорционален росту ВВП, но так как \" +             \" в данной системе не получиться посчитать реальный рост ВВП, я установил фиксированный рост, также если денежный рост \" +             \" будет равен ВВП, есть высокая вероятность Гиперинфляции. Деньги должны быть твердые, чтобы \" +             \" бизнес мог прогнозировать свои долгосрочные вложения и от монетаризма, взята только та часть что \" +             \" денежная масса должна расти линейно, но в целом здесь микс из разных экономических школ, включая Австрийскую \" +             \" экономическую школу.). При отрицательной ставке 0.1% каждые пол года для цифровых \" +             \" долларов и 0.2% для цифровых акций мы избегаем последствий тяжелого экономического кризиса для данной валюты. \" +             \" Такой механизм создает коридор цен, где нижняя граница стоимости данных цифровых валют является общее количество выпущенных цифровых \" +             \" долларов и цифровых акций, а верхняя граница является реальная стоимость. Так как только стоимость становиться выше реальной стоимости, \" +             \" держателям выгодней становиться продавать цифровые доллары и цифровые акции, по завышенным ценам, тем самым насыщая рынок деньгами \" +             \" и создавая коррекцию на рынке. \" +             \"\" +             \" Основным источником монетарных кризисов, является между быстрыми изменениями цен на товары и медленным изменением заработных плат. \" +             \" Пример: Представим что стоимость валюты резко подорожало на 30%, держателям выгодней становиться не инвестировать деньги, так как \" +             \" доходы от удерживания валюты, выше чем теперь уже оплачивать более дорогих сотрудников, из за того деньги перестают \" +             \" инвестироваться, люди не дополучают заработные платы, что приводит к тому, что огромное количество товаров не реализуется, \" +             \" что приводит к тому, часть производителей банкротится и увольняют множество рабочих, что еще больше снижает заработную \" +             \" плату у оставшихся, так как становиться профицитный рынок труда. Что  в свою очередь еще больше вызывает страх у держателей \" +             \" денег инвестировать и данный процесс продолжается до того момента, пока стоимость денег не начинает сокращаться в связи с тем \" +             \" что общее количество производственных цепочек сократилось и также сократились товары. \" +             \" Пример: Представим что у нас произошла инфляция и стоимость денег упала на 40% в течение месяца, стоимость товаров резко возрастает, \" +             \" но заработные платы не выросли, таким образом множество товаров не будут куплены, что приводит к закрытию производственных цепочек, \" +             \" что в свою очередь из за избытка рабочих на рынке труда, снижает заработную плату, что также в свою очередь еще больше сокращает \" +             \" количество проданных товаров. Первый случай Дефляционная спираль возникает из за резкого сокращения денег на рынке, второй \" +             \" случай стагфляция чаще возникает когда на рынок поступает резко избыточное количество денег. \" +             \"\" +             \" Чтобы не возникали такие кризисы не возникали, в данной криптовалюте деньги прирастают в одинаковом предсказуемом количестве. \" +             \" 204 (4 - вознаграждение основателю, 200 - вознаграждение добытчику) \" +             \" цифровых долларов и акций за блок, в сутках около 576 блоков. А отрицательная ставка корректирует стоимость монет каждые пол года. \" +             \" Также запрещено использовать частичное банковское резервирование для данных монет, так как их количество растет линейно, и \" +             \" не сможет покрыть долги возникшие из за частичного банковского резервирования, в связи отсутствия с недостатком \" +             \" наличности, так как при частичном банковском резервировании рост долгов будет намного выше, чем данный протокол будет создавать денег. \" +             \" также если увеличить денежную массу изменив настройки, и сделав рост денежной массы значительно выше, может вызвать гиперинфляцию или \" +             \" даже галопирующую инфляцию. Если нужно будет увеличить рост денежной массы это должно происходить только через внесения поправок, \" +             \" сохраняя процент вознаграждения основателя в двух процентах. И добыча за блок не должна увеличиваться больше 5% в течение \" +             \" двадцати лет, каждое следующее увеличение которое может вноситься должно проходить не менее двадцати лет через поправки, \" +             \" и не более 5% за блок от вознаграждения последнего блока. (Пример: если мы изменили \" +             \" через поправки, то добыча не должна быть выше 210 монет, но каждые следующие будет не больше пяти процентов от последнего. \" +             \" Таким образом следующее увеличение внесенное через поправки составит 220.5 монет. Но Эту поправку внесут только через двадцать \" +             \" лет после первой поправки по изменению добычи) \" +             \"\" +             \" При недостатки денежной массы, если не было изменено количество добываемых монет через поправку, можно добавить несколько \" +             \" дополнительных нулей после запятой, таким образом это просто увеличит ценность монет, без увелечения общей выпущенной денежной массы.\" +             \"\" +             \" Отрицательные ставки не должны быть выше 0.5% годовых и ниже 0.2% годовых. Отрицательные ставки можно изменять только через внесения поправок. \" +             \"  \";"," String FREEDOM_OF_SPEECH = \" Ни один орган данной корпорации или субъект не должен запрещать свободное исповедание \" +             \" какой-либо религии; или ограничивать свободу слова, совести или печати; \" +             \" или право людей мирно собираться или объединяться друг с другом, или не объединяться друг с другом, и \" +             \" обращаться к руководству Корпорации Международного Торгового Союза и к данной корпорации с ходатайством об удовлетворении жалоб; \" +             \" или нарушать право на плоды своего труда или \" +             \" право на мирную жизнь по своему выбору. Свободы слова и совести включают свободу вносить вклад в \" +             \" политические кампании или кандидатуры на корпоративные должности и должны толковаться как \" +             \" распространяющиеся в равной степени на любые средства коммуникации. \";","String RIGHTS = \" Все члены сети, должны соблюдать Естественные Права Человека и не нарушать их. \" +             \" Также должно соблюдаться презумпция невиновности и каждый участник сети должен иметь права на честное независимое \" +             \" судебное разбирательство. Каждый участник имеет права на адвоката или быть самому себе адвокатом. \" +             \" Корпорация Международный Торговый Союз не должна регулировать стоимость товаров и услуг участников сети, которые \" +             \" продают через данную платформу. Также Корпорация не должна запрещать отдельные бренды на своей площадке, но может \" +             \" запрещать продавать целые группы товаров, которые попадают по характеристикам описанных действующими законами, если \" +             \" этот запрет не нарушает Естественные Права Человека. В качестве источника прав можно брать в качестве прецедента Страны признанные демократическими \" +             \" странами.  \" +             \"  К числу естественных неотчуждаемых прав человека относят право на жизнь, \" +             \" свободу, безопасность, собственность, физическую и психическую неприкосновенность, достоинство личности, личную и семейную тайну и т. п. \" +             \"\" +             \" Ни один действующий закон не должен интерпретироваться так, чтобы нарушать естественные права человека. \" +             \" Корпоративный верховный суд может использовать прецеденты в качестве судебных решений, если эти решения не противоречат \" +             \" действующему уставу и действующим законам.\" +             \" Корпоративный Верховный Суд может создавать прецеденты аналогичные странам с прецедентным правом, но применять \" +             \" можно если эти прецеденты не нарушают действующий устав или действующие законы Корпорации Международного Торгового Союза. \";","  String POWERS_OF_THE_BOARD_OF_DIRECTORS = \" Powers of the Board of Directors. \" +             \" The Board of Directors may approve invoices submitted for positions on the Directors list. \" +             \" Also Laws package names start with ADD_DIRECTOR are packages that contain \" +             \" list of new directors who should manage new product lines. Data \" +             \" Laws can only be approved by the Board of Directors and from there they will take a list of laws, where \" +             \" every line that starts with ADD_DIRECTOR will be added to the Directors list as a new \" +             \"positions to apply for.\" +             \" The package that starts with BUDGET is the budget and can only be approved by the Board of Directors. \" +             \"There can be only one effective budget.\" +             \" The Board of Directors also approves the strategic plan STRATEGIC_PLAN. Only \" +             \"one strategic plan.\" +             \" The board of directors also participates in the approval of laws (rules on which should operate \" +             \" all members of the corporation), and also participates in the approval of the implementation of amendments to the charter AMENDMENT_TO_THE_CHARTER.\" +             \"\" +             \" The Council has the right to set and collect commission from sales within the platforms owned by the Corporation \" +             \" of the International Trade Union, provided that this commission will not exceed twenty percent (20%). \" +             \"All fees must be allocated to expenses that are established by the budget. \" +             \" Also, a source of income is the sale of their goods and services, for this there are Office Directors who are elected\" +             \" by the board of directors and they must sell the products of the Corporation of the International Trade Union. \" +             \"\" ;"," String HOW_LAWS_ARE_CHOSEN = \"HOW LAWS ARE CHOSEN\" +             \"No law has retroactive effect. No law should violate the current charter or contradict \" +             \" other laws in force. If there is a conflict between several laws from one set of laws, \" +             \" then the current one is the one that is higher in the index. Example: a package for the sale of alcohol \" +             \"the law under index 3 contradicts the law from index 17, in this case the law under index three will be valid, since it is higher in status. \" +             \"if the laws contradict from different packages, then the package that received more votes is valid\" +             \" from the Board of Shareholders, if there is parity, then the one that received more votes from the Board of Directors, if here too \" +             \"there is parity, then this dispute must be decided by the Chief Justice, if he also did not determine which of the two packages\" +             \"where the laws contradict each other, the laws of one of the packages are more valid, then the priority becomes \" +             \"the one that began to operate earlier, the countdown is determined precisely from the last moment of entry into force. \" +             \" All ordinary laws are valid if they are voted in this way ONE_VOTE by the Board of Shareholders, the Board of Directors and possibly \" +             \"The Chief Justice. For a law to be valid, it must receive equal to or more than 100 of the remaining votes of the Board of Shareholders,\" +             \" equal to or greater than 15 remaining votes of the Board of Directors and One vote of the Chief Justice, but if the Chief Justice did not vote or voted against \" +             \" then you can override the veto of the supreme judge by receiving 200 or more of the remainder of the votes of the Board of Shareholders and 30 or more of the remainder of the votes of the Board of Directors. \" +             \" \" +             \"A law is valid as long as it matches the number of votes as described above. Every time someone loses their office\" +             \"also lost are all his votes for all the laws that he voted.\" +             \"\" +             \" Example code in LawsController current law:\" +             \" //laws that don't get enough votes that can only pass if the supreme judge approves\\n\" +             \" List<CurrentLawVotesEndBalance> notEnoughVotes = current.stream()\\n\" +             \" .filter(t -> !directors.contains(t.getPackageName()))\\n\" +             \" .filter(t->!Seting.AMENDMENT_TO_THE_CHARTER.equals(t.getPackageName()))\\n\" +             \" .filter(t->!directors.isCabinets(t.getPackageName()))\\n\" +             \" .filter(t -> !Seting.ORIGINAL_CHARTER_CURRENT_LAW_PACKAGE_NAME.equals(t.getPackageName()))\\n\" +             \" .filter(t -> t.getVotesBoardOfShareholders() >= Seting.ORIGINAL_LIMIT_MIN_VOTE_BOARD_OF_SHAREHOLDERS)\\n\" +             \" .filter(t -> t.getVotesBoardOfDirectors() >= Seting.ORIGINAL_LIMIT_MIN_VOTE_BOARD_OF_DIRECTORS)\\n\" +             \" .filter(t -> t.getVoteHightJudge() >= Seting.ORIGINAL_LIMIT_MIN_VOTE_HIGHT_JUDGE)\\n\" +             \" .sorted(Comparator.comparing(CurrentLawVotesEndBalance::getVotes).reversed()).collect(Collectors.toList());\\n\" +             \"\\n\" +             \"\\n\" +             \" //laws that have received enough votes and do not require the approval of the supreme judge\\n\" +             \" List<CurrentLawVotesEndBalance> powerfulVotes = current.stream()\\n\" +             \" .filter(t -> !directors.contains(t.getPackageName()))\\n\" +             \" .filter(t-> !Seting.AMENDMENT_TO_THE_CHARTER.equals(t.getPackageName()))\\n\" +             \" .filter(t-> !directors.isCabinets(t.getPackageName()))\\n\" +             \" .filter(t -> !Seting.ORIGINAL_CHARTER_CURRENT_LAW_PACKAGE_NAME.equals(t.getPackageName()))\\n\" +             \" .filter(t -> t.getVotesBoardOfShareholders() >= (Seting.ORIGINAL_LIMIT_MIN_VOTE_BOARD_OF_SHAREHOLDERS * Seting.POWERFUL_VOTE))\\n\" +             \" .filter(t -> t.getVotesBoardOfDirectors() >= (Seting.ORIGINAL_LIMIT_MIN_VOTE_BOARD_OF_DIRECTORS * Seting.POWERFUL_VOTE))\\n\" +             \" .sorted(Comparator.comparing(CurrentLawVotesEndBalance::getVotes).reversed()).collect(Collectors.toList()); \";","String HOW_THE_BOARD_OF_DIRECTORS_IS_ELECTED = \"How the Board of Directors is elected.\" +             \"\" +             \" The board of directors consists of 301 BOARD_OF_DIRECTORS accounts. \" +             \" Each member of the network can apply for the position of the board of directors by creating a package of law, where \" +             \" the package name BOARD_OF_DIRECTORS and the sender's account must match the account specified \" +             \" in the first line of the law that is contained in the list of this package. \" +             \" The 301 account with the most remaining votes wins the position. \" +             \" The cost of filing to create a law (position) is worth five digital dollars (5) as a reward to the earner. \" +             \" The voting process is described in VOTE_STOCK \" +             \"\" +             \" Code example: LawController: method currentLaw: \" +             \"code section responsible for the election of the board of directors\" +             \" //minimum number of positive votes for the law to be valid, \\n\" +             \" //positions elected by shares of members of the Board of Directors\\n\" +             \" List<CurrentLawVotesEndBalance> electedByStockBoardOfDirectors = current.stream()\\n\" +             \" .filter(t -> directors.isElectedByStocks(t.getPackageName()))\\n\" +             \" .filter(t -> t.getPackageName().equals(NamePOSITION.BOARD_OF_DIRECTORS.toString()))\\n\" +             \" .filter(t -> t.getVotes() >= Seting.ORIGINAL_LIMIT_MIN_VOTE)\\n\" +             \" .sorted(Comparator.comparing(CurrentLawVotesEndBalance::getVotes).reversed())\\n\" +             \" .limit(directors.getDirector(NamePOSITION.BOARD_OF_DIRECTORS.toString()).getCount())\\n\" +             \" .collect(Collectors.toList()); \";","String POWERS_OF_THE_BOARD_OF_SHAREHOLDERS = \" Powers of the board of shareholders. \" +             \"The Council of Shareholders Participates in the approval of the Laws (rules that all members of this Corporation must comply with). \" +             \" Also, the Board of Shareholders participates in the approval of amendments to the charter of the Corporation of the International Trade Union AMENDMENT_TO_THE_CHARTER. \" +             \" The Board of Shareholders may also participate in voting when electing candidates CORPORATE_COUNCIL_OF_REFEREES and BOARD_OF_DIRECTORS \" +             \" using these rules to vote for VOTE_STOCK candidates. \" +             \"\";","  String HOW_SHAREHOLDERS_BOARD_IS_ELECTED = \" HOW SHAREHOLDERS ARE ELECTED. \" +             \" The Board of Shareholders consists of one thousand five hundred accounts (1500) with the largest number of shares, but only those accounts are taken into account \" +             \" from whose activity more than a year has not passed. formula: the current year is one year, and if the account was active in this range, it \" +             \" is taken into account. All accounts are sorted in descending order of the number of digital shares, and 1500 accounts with the largest number of \" +             \" shares. Recalculation occurs every block. \" +             \"\" +             \" An example of a section of code how the Board of Shareholders is elected: \" +             \" class UtilsGovernment method findBoardOfShareholders: \" +             \" //determining the board of shareholders\\n\" +             \" public static List<Account> findBoardOfShareholders(Map<String, Account> balances, List<Block> blocks, int limit) {\\n\" +             \"List<Block> minersHaveMoreStock = null;\\n\" +             \" if (blocks.size() > limit) {\\n\" +             \" minersHaveMoreStock = blocks.subList(blocks.size() - limit, blocks.size());\\n\" +             \" } else {\\n\" +             \"minersHaveMoreStock = blocks;\\n\" +             \"}\\n\" +             \" List<Account> boardAccounts = minersHaveMoreStock.stream().map(\\n\" +             \" t -> new Account(t.getMinerAddress(), 0, 0))\\n\" +             \" .collect(Collectors.toList());\\n\" +             \"\\n\" +             \" for (Block block : minersHaveMoreStock) {\\n\" +             \" for (DtoTransaction dtoTransaction : block.getDtoTransactions()) {\\n\" +             \" boardAccounts.add(new Account(dtoTransaction.getSender(), 0, 0));\\n\" +             \"}\\n\" +             \"\\n\" +             \"}\\n\" +             \"\\n\" +             \"\\n\" +             \" CompareObject compareObject = new CompareObject();\\n\" +             \"\\n\" +             \" List<Account> boardOfShareholders = balances.entrySet().stream()\\n\" +             \" .filter(t -> boardAccounts.contains(t.getValue()))\\n\" +             \" .map(t -> t.getValue()).collect(Collectors.toList());\\n\" +             \"\\n\" +             \"\\n\" +             \"boardOfShareholders = boardOfShareholders\\n\" +             \".stream()\\n\" +             \" .filter(t -> !t.getAccount().startsWith(Seting.NAME_LAW_ADDRESS_START))\\n\" +             \" .filter(t -> t.getDigitalStockBalance() > 0)\\n\" +             \" .sorted(Comparator.comparing(Account::getDigitalStockBalance).reversed())\\n\" +             \" .collect(Collectors.toList());\\n\" +             \"\\n\" +             \"boardOfShareholders = boardOfShareholders\\n\" +             \".stream()\\n\" +             \" .limit(Setting.BOARD_OF_SHAREHOLDERS)\\n\" +             \" .collect(Collectors.toList());\\n\" +             \"\\n\" +             \" return boardOfShareholders;\\n\" +             \"}\";","String VOTE_STOCK = \"How shares vote. \" +             \" All shares held by the account are equal to the same number of votes. \" +             \" every time someone makes a transaction to an account that is a packet address that starts with \" +             \" LIBER he votes for this package. Only those votes from which more than four years have not passed are taken into account. \" +             \" if the transaction was made VoteEnum.YES then this account receives votes for according to the formula \" +             \" yesV = number of votes equal to the sender's shares.\" +             \" yesN = how many laws this account voted for with VoteEnum.YES\" +             \" resultYES = yesV / math.pow(yesN, 3). Example: A score voted for three scores that start with LIBER,\" +             \"100 shares in the account means 100 votes. 100 / math.pow(3, 3) = 3.7 means each account gets 3.7 votes.\" +             \"\" +             \" if the transaction was made with VoteEnum.NO \" +             \" then the same formula is used, but now all bills for which he voted against are taken into account \" +             \"Example the same account voted for two scores against, it has the same one hundred shares.\" +             \" resultNO = noV / math.pow(noN, 3) = 100/ math.pow(2,3) = 12.5 means every score he voted for, \" +             \"against will get 12.5 votes against.\" +             \" then each score counts all the votes given to it FOR (VoteEnum.YES) and AGAINST (VoteEnum.NO). \" +             \" Then this formula is used remainder = resultYES - resultNO. \" +             \"First, these positions are selected for all accounts that received more than or equal to fourteen thousand\" +             \"four hundred votes of the remainder (14400) remainder >= 14400.\" +             \" Further, all accounts are sorted in descending order by remainder and from there the number of accounts on \" +             \" these positions, as much as it is stipulated in this position. Example: \" +             \" For the Board of Directors, that's the 301 accounts with the most balances. \" +             \" \" +             \"At any time you can change your voice, but only to the opposite, which means if\" +             \" you voted for the candidate YES then you can only change to NO and vice versa. \" +             \"There is no limit to how many times you can change your voice.\" +             \"With every block there is a recalculation of votes, if you lose your shares, your candidates\" +             \" also lose their votes. This measure is specifically implemented so that elected positions \" +             \"were interested in seeing you prosper.\" +             \"Only CORPORATE_COUNCIL_OF_REFEREES and BOARD_OF_DIRECTORS are elected this way\" +             \" Only the last transaction given for each account counts if you haven't updated your vote, \" +             \"then after four years it is annulled.\";"," String CODE_VOTE_STOCK = \" class CurrentLawVotes method: votesLaw \" +             \" public double votesLaw(Map<String, Account> balances,\\n\" +             \" Map<String, Integer> yesAverage, Map<String, Integer> noAverage) {\\n\" +             \"double yes = 0.0;\\n\" +             \"double no = 0.0;\\n\" +             \"\\n\" +             \" //\\n\" +             \" for (String s : YES) {\\n\" +             \"\\n\" +             \"int count = 1;\\n\" +             \"count = yesAverage.get(s) > 0 ? yesAverage.get(s) : 1;\\n\" +             \" yes += balances.get(s).getDigitalStockBalance() / Math.pow(count, Seting.POWERING_FOR_VOTING);\\n\" +             \"\\n\" +             \"}\\n\" +             \" //\\n\" +             \" for (String s : NO) {\\n\" +             \"int count = 1;\\n\" +             \" count = noAverage.get(s) > 0 ? noAverage.get(s) : 1;\\n\" +             \" no += balances.get(s).getDigitalStockBalance() / Math.pow(count, Seting.POWERING_FOR_VOTING);\\n\" +             \"\\n\" +             \"}\\n\" +             \"\\n\" +             \"\\n\" +             \"return yes - no;\\n\" +             \"}\";","  String POWERS_OF_DIRECTORS_IN_THE_OFFICE = \" POWERS OF DIRECTORS IN THE OFFICE \" +             \"Office directors are senior directors who are directors of their divisions.\" +             \" The powers of each director must be described by the laws in force. But each director must manage \" +             \" only their division. Coordination of all directors should be led by the General Executive Director GENERAL_EXECUTIVE_DIRECTOR. \" +             \" \" +             \" Board of Directors, CORPORATE_COUNCIL_OF_REFEREES, HIGH_JUDGE, Board of Shareholders and GENERAL_EXECUTIVE_DIRECTOR can be either \" +             \"individuals and legal entities, but one account will be counted as one vote. \";","String HOW_OFFICE_DIRECTORS_ARE_CHOSEN = \" HOW OFFICE DIRECTORS ARE CHOSEN. \" +             \" All Directors of the office, these are the top directors who manage their divisions, are elected only by the Board of Directors. \" +             \" Each member of the network can apply for the position of supreme director by creating a law with a package name that matches the allowed \" +             \" positions, where the address of the sender of this transaction must match the first line from the list of laws in this package. \" +             \"The cost of the law is five digital dollars as a reward to the earner.\" +             \" the score with the most remaining votes wins the position. \" +             \" The voting mechanism is described by ONE_VOTE. \" +             \"\" +             \" An example of a piece of code how positions are elected class LawsController: method currentLaw: \" +             \"\" +             \" //positions created by the board of directors\\n\" +             \" List<CurrentLawVotesEndBalance> createdByBoardOfDirectors = current.stream()\\n\" +             \" .filter(t->t.getPackageName().startsWith(Seting.ADD_DIRECTOR))\\n\" +             \" .filter(t->t.getVotesBoardOfDirectors() >= Seting.ORIGINAL_LIMIT_MIN_VOTE_BOARD_OF_DIRECTORS)\\n\" +             \" .collect(Collectors.toList());\\n\" +             \" //adding positions created by the board of directors\\n\" +             \" for (CurrentLawVotesEndBalance currentLawVotesEndBalance : createdByBoardOfDirectors) {\\n\" +             \"directors.addAllByBoardOfDirectors(currentLawVotesEndBalance.getLaws());\\n\" +             \"}\\n\" +             \"\\n\" +             \" //positions elected only by the board of directors\\n\" +             \" List<CurrentLawVotesEndBalance> electedByBoardOfDirectors = current.stream()\\n\" +             \" .filter(t -> directors.isElectedByBoardOfDirectors(t.getPackageName()) || directors.isCabinets(t.getPackageName()))\\n\" +             \" .filter(t -> t.getVotesBoardOfDirectors() >= Seting.ORIGINAL_LIMIT_MIN_VOTE_BOARD_OF_DIRECTORS)\\n\" +             \" .sorted(Comparator.comparing(CurrentLawVotesEndBalance::getVotesBoardOfDirectors).reversed())\\n\" +             \" .collect(Collectors.toList());\";","String ONE_VOTE = \"ONE VOTE\" +             \"\" +             \" When these positions are voted, count as one score = one vote \" +             \" (CORPORATE_COUNCIL_OF_REFEREES, BOARD_OF_DIRECTORS, GENERAL_EXECUTIVE_DIRECTOR, HIGH_JUDGE and Board of Shareholders). \" +             \" every score that starts with LIBER counts all votes FOR (VoteEnum.YES) and AGAINST (VoteEnum.NO) for it \" +             \"further subtracted from FOR - AGAINST = if the balances are above the threshold, then it becomes the current law, but if the position is elected\" +             \"then after that it is sorted from largest to smallest and the largest number that is described for this position is selected. \" +             \"Votes are recalculated every block. After voting, the vote can only be changed to the opposite.\" +             \" There are no restrictions on the number of times you can change your vote. Only those votes that are given by accounts are taken into account \" +             \"in their position, for example, if the account has ceased to be in the Board of Directors, his vote as a \" +             \" The Board of Directors does not and will not count in the voting. All votes are valid until the accounts \" +             \" those who voted are in their positions. Only those votes from which no more than \" +             \" four years, but each participant can at any time renew his vote. \";"," String CODE_VOTE_ONE = \" CODE class CurrentLawVotes: method voteGovernment \" +             \"\" +             \"public int voteGovernment(\\n\" +             \" Map<String, Account> balances,\\n\" +             \"List<String>governments\\n\" +             \"\\n\" +             \" ) {\\n\" +             \"int yes = 0;\\n\" +             \"int no = 0;\\n\" +             \"\\n\" +             \" List<String> addressGovernment = governments;\\n\" +             \" for (String s : YES) {\\n\" +             \" if (addressGovernment.contains(s)) {\\n\" +             \" yes += Seting.VOTE_GOVERNMENT;\\n\" +             \"}\\n\" +             \"\\n\" +             \"}\\n\" +             \" for (String s : NO) {\\n\" +             \" if (addressGovernment.contains(s)) {\\n\" +             \"no += Seting.VOTE_GOVERNMENT;\\n\" +             \"}\\n\" +             \"\\n\" +             \"}\\n\" +             \"\\n\" +             \"\\n\" +             \"return yes - no;\\n\" +             \"\\n\" +             \"}\";"," String MECHANISM_FOR_REDUCING_THE_NUMBER_OF_SHARES = \" MECHANISM REDUCING THE NUMBER OF SHARES. \" +             \" Every time one account sends a digital share to another account, but uses VoteEnum.NO, the account \" +             \"the recipient's digital shares are reduced by the amount sent by the share sender.\" +             \" Example account A sent to account B 100 digital shares with VoteEnum.NO, then account A and account B both lose 100 \" +             \" digital shares. This measure is needed so that there is a mechanism to remove the Board of Shareholders from office and also allows you to lower the votes \" +             \" destructive accounts, since the number of votes is equal to the number of shares in the Election of the Board of Directors and \" +             \" when electing CORPORATE_COUNCIL_OF_REFEREES. \" +             \" This mechanism is valid only for digital shares and only if the sender sent with the sign \" +             \"VoteEnum.NO\";"," String WHO_HAS_THE_RIGHT_TO_CREATE_LAWS = \"Create Laws in Cryptocurrency International Trade Union Corporations have the right\" +             \" all network members who have at least five digital dollars. \" +             \" To create a law through the cryptocurrency mechanism of the International Trade Union Corporation \" +             \" It is necessary to create an object of the Laws class inside this cryptocurrency, where packetLawName is the name of the law package. \" +             \" List<String> laws - is a list of laws, String hashLaw - is the address of this package of laws and starts with LIBER. \" +             \" In order for a law to be included in the pool of laws, you need to create a transaction where the recipient is the hashLaw of this law and the reward \" +             \" miner equals five digital dollars (5) of this cryptocurrency. After that, as the law gets into the block, it will be in the pool \" +             \"laws and it will be possible to vote for him.\" +             \" The number of lines in a package of laws can be as many as needed and there are no restrictions. \";"," String POWERS_OF_THE_CORPORATE_COUNCIL_OF_JUDGES = \" POWERS OF THE CORPORATE COUNCIL OF JUDGES. \" +             \"Approves the Chief Justice.\" +             \" Participates in voting on the implementation of amendments. \" +             \" \" +             \"The judicial power of the Corporation of the International Trade Union belongs\" +             \"to one Supreme Court and such inferior courts as the Corporation International\" +             \"The Merchant Union may issue and establish from time to time.\" +             \" Judges of both supreme and inferior courts hold their offices in good conduct and \" +             \"receive remuneration for their services within the stipulated time. \" +             \"Judicial power extends to all cases of law and justice,\" +             \" including those initiated by members to challenge the misappropriation of funds, \" +             \"arising under these Articles, the laws of the International Trade Union Corporation and treaties,\" +             \"prisoners or who will be imprisoned according to their authority.\" +             \"To disputes,\" +             \"in which the International Trade Union will be party to a dispute between two or more members of the network.\" +             \"No trial should be secret, but justice should be administered openly and free of charge, completely and without delay,\" +             \"and every person shall have legal protection against harm done to life, liberty or property.\" +             \" Supreme Court CORPORATE_COUNCIL_OF_REFEREES and Chief Justice HIGH_JUDGE \";"," String HOW_THE_CORPORATE_BOARD_OF_JUDGES_IS_ELECTED = \" HOW THE CORPORATE BOARD OF JUDGES IS ELECTED. \" +             \"CORPORATE_COUNCIL_OF_REFEREES\" +             \" consists of 55 accounts. \" +             \" each member of the network can apply for the CORPORATE_COUNCIL_OF_REFEREES position by creating a law package, where \" +             \" the name of the package CORPORATE_COUNCIL_OF_REFEREES and the sender's account must match the account specified \" +             \" in the first line of the law that is contained in the list of this package \" +             \"The 55th score with the most remaining votes wins the position.\" +             \" The cost of filing to create a law (position) is worth five digital dollars (5) as a reward to the earner. \" +             \" The voting process is described in VOTE_STOCK \" +             \"\" +             \" Code snippet example: class LawsController: method currentLaw: \" +             \" //minimum number of positive votes for the law to be valid,\\n\" +             \" //positions elected by shares CORPORATE_COUNCIL_OF_REFEREES\\n\" +             \" List<CurrentLawVotesEndBalance> electedByStockCorporateCouncilOfReferees = current.stream()\\n\" +             \" .filter(t -> directors.isElectedByStocks(t.getPackageName()))\\n\" +             \" .filter(t -> t.getPackageName().equals(NamePOSITION.CORPORATE_COUNCIL_OF_REFEREES.toString()))\\n\" +             \" .filter(t -> t.getVotes() >= Seting.ORIGINAL_LIMIT_MIN_VOTE)\\n\" +             \" .sorted(Comparator.comparing(CurrentLawVotesEndBalance::getVotes).reversed())\\n\" +             \" .limit(directors.getDirector(NamePOSITION.CORPORATE_COUNCIL_OF_REFEREES.toString()).getCount())\\n\" +             \" .collect(Collectors.toList());\\n\";","String HOW_THE_CHIEF_JUDGE_IS_CHOSEN = \" HOW HIGH_JUDGE IS CHOSEN. \" +             \"The Chief Justice is elected by CORPORATE_COUNCIL_OF_REFEREES.\" +             \" Each member of the network can apply for the position of Chief Justice by creating a law with a package name that matches the allowed \" +             \" position, where the address of the sender of this transaction must match the first line from the list of laws in this package. \" +             \"The cost of the law is five digital dollars as a reward to the earner.\" +             \" the score with the most remaining votes wins the position. \" +             \" The voting mechanism is described by ONE_VOTE. \" +             \"\" +             \" Code example as stated by the Chief Justice. class LawsController: method currentLaw. Code snippet \" +             \" //positions elected by the board of corporate chief judges\\n\" +             \" List<CurrentLawVotesEndBalance> electedByCorporateCouncilOfReferees = current.stream()\\n\" +             \" .filter(t -> directors.isElectedBYCorporateCouncilOfReferees(t.getPackageName()))\\n\" +             \" .filter(t -> t.getVotesCorporateCouncilOfReferees() >= Seting.ORIGINAL_LIMIT_MIN_VOTE_CORPORATE_COUNCIL_OF_REFEREES)\\n\" +             \" .sorted(Comparator.comparing(CurrentLawVotesEndBalance::getVotesCorporateCouncilOfReferees)).collect(Collectors.toList()); \";","String POWERS_OF_THE_CHIEF_JUDGE = \" POWERS OF THE CHIP JUDGE. \" +             \"The Chief Justice participates in the approval of laws, as well as\" +             \" can participate in resolving disputes within network members like CORPORATE_COUNCIL_OF_REFEREES, \" +             \" but his vote is higher than that of CORPORATE_COUNCIL_OF_REFEREES. \";","String HOW_IS_THE_PROCESS_OF_AMENDING_THE_CHARTER = \" HOW DOES THE PROCESS FOR AMENDING THE CHARTER \" +             \" To amend, you need to create a law with the package name AMENDMENT_TO_THE_CHARTER, \" +             \"then this law must be voted on by the method described in VOTE_ONE\" +             \" Board of Shareholders and the balance of votes must be equal to or higher than 300 members, \" +             \" the Board of Directors must also vote and the balance of votes must be 60 or more, \" +             \" should also vote corporate chief judges (CORPORATE_COUNCIL_OF_REFEREES) and \" +             \" The remainder of the votes must be equal to or greater than 5. \" +             \"But the amendments should not concern the way in which the rules of existing laws are established, and also\" +             \" election of the Board of Directors, Board of Shareholders, General Executive Director, \" +             \" Council of Corporate Judges and Chief Justice. Amendments may change the code if the rules are preserved \" +             \"election of current positions (including voting rules), laws and money mining (mining digital dollars and digital stocks),\" +             \"No amendment should give any of the above positions more power.\" +             \"Also, the amendments must not infringe on Natural Human Rights.\" +             \" \" +             \" Code example. class LawsController: method currentLaw: code section that approves current amendments\" +             \" //introduction of amendments to the charter\\n\" +             \" List<CurrentLawVotesEndBalance> chapter_amendment = current.stream()\\n\" +             \" .filter(t -> !directors.contains(t.getPackageName()))\\n\" +             \" .filter(t->Seting.AMENDMENT_TO_THE_CHARTER.equals(t.getPackageName()))\\n\" +             \" .filter(t->!directors.isCabinets(t.getPackageName()))\\n\" +             \" .filter(t -> t.getVotesBoardOfShareholders() >= Seting.ORIGINAL_LIMIT_MINT_VOTE_BOARD_OF_SHAREHOLDERS_AMENDMENT)\\n\" +             \" .filter(t -> t.getVotesBoardOfDirectors() >= Seting.ORIGINAL_LIMIT_MIN_VOTE_BOARD_OF_DIRECTORS_AMENDMENT)\\n\" +             \" .filter(t -> t.getVotesCorporateCouncilOfReferees() >= Seting.ORIGINAL_LIMIT_MIN_VOTE_CORPORATE_COUNCIL_OF_REFEREES_AMENDMENT)\\n\" +             \" .sorted(Comparator.comparing(CurrentLawVotesEndBalance::getVotesBoardOfDirectors).reversed()).collect(Collectors.toList());\\n \";","String HOW_THE_BUDGET_IS_APPROVED = \" HOW IS THE BUDGET APPROVED. \" +             \"There can be only one effective budget. Only the Board of Directors approves the budget.\" +             \" To approve the budget, you need to get the method described in VOTE_ONE 15 or more votes. \" +             \"the process itself goes like this: \" +             \" 1. First, all packages of laws are selected where the name of the package matches BUDGET. \" +             \"2. Next, all the packages that received 15 or more votes are selected. \" +             \" 3. Then all these packages are sorted in descending order, with the most votes. \" +             \"4. Then the very first one with the most votes is selected.\" +             \"\" +             \" Budget approving code example. class LawsController: method: currentLaw. \" +             \" //the budget is approved only by the board of directors.\\n\" +             \" List<CurrentLawVotesEndBalance>budjet = current.stream()\\n\" +             \" .filter(t-> !directors.contains(t.getPackageName()))\\n\" +             \" .filter(t->Seting.BUDGET.equals(t.getPackageName()))\\n\" +             \" .filter(t->!directors.isCabinets(t.getPackageName()))\\n\" +             \" .filter(t-> t.getVotesBoardOfDirectors() >= Seting.ORIGINAL_LIMIT_MIN_VOTE_BOARD_OF_DIRECTORS)\\n\" +             \" .sorted(Comparator.comparing(CurrentLawVotesEndBalance::getVotesBoardOfDirectors).reversed())\\n\" +             \".limit(1)\\n\" +             \" .collect(Collectors.toList());\";","  String HOW_IS_THE_STRATEGIC = \" AS THE STRATEGIC PLAN IS APPROVED. \" +             \" The strategic plan is approved by the Board of Directors, the strategic plan may be valid \" +             \"only in a single copy. For the Strategic Plan to be valid, a balance of votes is needed\" +             \" Board of Directors 15 or more. Voting method VOTE_ONE. \" +             \" \" +             \" The Board of Directors can cancel the Strategic Plan at any time. The Strategic Plan is in effect \" +             \" as long as the number of votes is 15 or more. The Strategic Plan may include a general direction \" +             \"Corporations, and what needs to be implemented.\" +             \"\" +             \"a section of code that shows how the Strategic Plan is being approved.\" +             \" class LawsController: method currentLaw: \" +             \"\\n\" +             \" //the plan is approved only by the chamber Board of Directors\\n\" +             \" List<CurrentLawVotesEndBalance> planFourYears = current.stream()\\n\" +             \" .filter(t->!directors.contains(t.getPackageName()))\\n\" +             \" .filter(t->Seting.STRATEGIC_PLAN.equals(t.getPackageName()))\\n\" +             \" .filter(t->!directors.isCabinets(t.getPackageName()))\\n\" +             \" .filter(t->t.getVotesBoardOfDirectors() >= Seting.ORIGINAL_LIMIT_MIN_VOTE_BOARD_OF_DIRECTORS)\\n\" +             \" .sorted(Comparator.comparing(CurrentLawVotesEndBalance::getVotesBoardOfDirectors).reversed())\\n\" +             \".limit(1)\\n\" +             \" .collect(Collectors.toList());\";","String HOW_NEW_POSITIONS_ARE_ADDED = \" HOW ARE NEW POSITIONS ADDED. \" +             \"In this way, only top management, subordinates of each leader are added\" +             \" are hired without the use of the blockchain, they can be hired by the director himself, or otherwise as \" +             \" described by applicable laws. Top management is added to the list of class Directors. \" +             \"all newly added positions are valid as long as their laws that create these positions\" +             \" work. Only the Board of Directors can add new positions. \" +             \" Every package of laws that starts with ADD_DIRECTOR is defined as adding a position. \" +             \" the list of laws that are inside this package are positions if the name is in \" +             \" line starts with ADD_DIRECTOR. Example: package name ADD_DIRECTOR_PACKAGE\" +             \" the name of the first third and fourth line ADD_DIRECTOR_FIRST ADD_DIRECTOR_THIRD \" +             \" ADD_DIRECTOR_FOUR this will create three positions for the position. \" +             \" But if the line starts with ADD_DIRECTOR, then the job title must be large \" +             \" letters and underscores, also there should be only one position in one line \" +             \" and no more words. Those lines where there is no position added are used to describe \" +             \" permissions of the added positions. \" +             \" In order for new positions to be added to the list, the Board of Directors must vote by the \" +             \"VOTE_ONE 15 or more votes.\" +             \"Once new positions are created, each member of the network will be able to apply for these positions.\" +             \"\" +             \" an example of a piece of code that creates new posts. \" +             \" class LawsController: method currentLaw: \" +             \"\" +             \"\\n\" +             \" //adds laws that create new directorships\\n\" +             \" List<CurrentLawVotesEndBalance> addDirectors = current.stream()\\n\" +             \" .filter(t->t.getPackageName().startsWith(Seting.ADD_DIRECTOR))\\n\" +             \" .filter(t->t.getVotesBoardOfDirectors() >= Seting.ORIGINAL_LIMIT_MIN_VOTE_BOARD_OF_DIRECTORS)\\n\" +             \" .collect(Collectors.toList());\";"," String PROPERTY_OF_THE_CORPORATION = \" PROPERTY OF THE CORPORATION. \" +             \"All property owned by the International Trade Union Corporation cannot be sold without a valid law,\" +             \" where the sale process will be described and at what price the property will be sold. The account of the founder, and the account of other participants is not \" +             \"corporate account, the Board of Directors should create a separate account that will be budgeted and managed only by members of current members\" +             \" Board of directors. \";"," String INTERNET_STORE_DIRECTOR = \" This director is engaged in the development, promotion and management of an online store, which should \" +             \" sell goods for a digital dollar or digital shares. Detailed authority must be given either through applicable laws or \" +             \" issued by the CEO or the Board of Directors. \" +             \"The name of the Store must be determined by either the Board of Directors or the Chief Executive Officer.\";","String GENERAL_EXECUTIVE_DIRECTOR = \" This Director coordinates the actions of other senior directors to implement the strategic plan or \" +             \"the tasks assigned to him by the laws in force. All powers must be issued to him through the laws in force.\";","String DIRECTOR_OF_THE_DIGITAL_EXCHANGE = \"This Director is the development, promotion and management of the Internet exchange. The authority must be \" +             \"issued to him either by applicable law or by the Board of Directors or by the Chief Executive Officer.\";","String DIRECTOR_OF_DIGITAL_BANK = \"This Director is in charge of Internet Banking. All powers must be issued either by applicable law or by the Board of Directors\" +             \"or the Chief Executive Officer.\";"," String DIRECTOR_OF_THE_COMMERCIAL_COURT = \" The director of a private commercial court must provide leadership to a private court, all powers \" +             \"must be Issued either by applicable law or by the Board of Directors or the Chief Executive Officer.\";"," String MEDIA_DIRECTOR = \" This Director directs the media, all powers must be issued by applicable laws, or by the Board of Directors or \" +             \"CEO.\";","String DIRECTOR_OF_THE_DEVELOPMENT_OF_THE_IMPLEMENTATION_OF_CRYPTOCURRENCY_TECHNOLOGIES_OF_THE_INTERNATIONAL_TRADE_UNION_CORPORATION = \"\" +             \" This Director manages the development and implementation of new code in this cryptocurrency, all powers must be issued only through \" +             \" current laws, but may also be issued by either the Board of Directors if the current laws have given such powers to the Board of Directors. \" +             \" Also, no code change should be contrary to the current charter or applicable laws. Also, powers can be issued\" +             \" by the Chief Executive Officer, if such authority is granted to the Chief Executive Officer by applicable law. \";","String EXPLANATION_WHY_MONEY_DEMURAGE_IS_USED_HERE = \" EXPLANATION WHY MONEY DEMURAGE IS USED HERE..\" +             \" Negative rates are now used in many countries, this encourages money holders when the price is excessively high, \" +             \" saturate the market with money. The amount of money mined for each block is 200 digital dollars and 200 digital shares, \" +             \"also 2% of each mining reward to the founder, which is 4 digital dollars and 4 digital Shares for each block mining. \" +             \" Here it is used as the Theories of Silvio Gesell, as well as the school of monetarism (in a modified form \" +             \" with Silvio Gesell, the negative rate was 1% per month, which would just kill the economy, \" +             \"under monetarism, the growth of the money supply should have been proportional to the growth of GDP, but since \" +             \" in this system it is not possible to calculate the real GDP growth, I set a fixed growth, also if the money growth \" +             \" will be equal to GDP, there is a high probability of Hyperinflation. Money must be hard in order to \" +             \" business could predict its long-term investments and from monetarism, only that part was taken that \" +             \"the money supply should grow linearly, but in general there is a mix of different economic schools, including the Austrian one\" +             \" economic school.). With a negative rate of 0.1% every six months for digital \" +             \" dollars and 0.2% for digital stocks, we avoid the consequences of a severe economic crisis for this currency. \" +             \" Such a mechanism creates a price corridor, where the lower limit of the value of these digital currencies is the total number of digital currencies issued \" +             \" dollars and digital stocks, and the upper limit is the real value. As soon as the value becomes higher than the real value, \" +             \" it becomes more profitable for holders to sell digital dollars and digital shares at inflated prices, thereby saturating the market with money \" +             \"and creating a correction in the market.\" +             \"\" +             \"The main source of monetary crises is between rapid changes in commodity prices and slow changes in wages.\" +             \" Example: Imagine that the value of the currency has risen sharply by 30%, it becomes more profitable for holders not to invest money, since \" +             \"revenues from holding currency are higher than what is now paid for more expensive employees, because of this, the money stops\" +             \"to invest, people do not receive wages, which leads to the fact that a huge number of goods are not sold,\" +             \"which leads to the fact that some manufacturers go bankrupt and lay off many workers, which further reduces wages\" +             \"pay the rest, as the labor market becomes surplus. Which in turn causes even more fear among the holders\" +             \"money to invest and this process continues until the moment when the value of money begins to decline due to the fact\" +             \"that the total number of production chains has shrunk and so have the goods.\"+              \" Example: Let's imagine that we had inflation and the value of money fell by 40% within a month, the cost of goods rises sharply, \" +                      \" but wages have not risen, so many goods will not be bought, resulting in the closure of production chains, \" +                      \"which, in turn, due to an excess of workers in the labor market, reduces wages, which also further reduces\" +                      \" the number of goods sold. The first case A deflationary spiral occurs due to a sharp reduction in money in the market, the second \" +                      \"The case of stagflation often occurs when a sharply excess amount of money enters the market. \" +                      \"\" +                      \"So that such crises do not arise, in this cryptocurrency, money grows in the same predictable amount. \" +                      \"204 (4 - reward to the founder, 200 - reward to the earner)\" +                      \" digital dollars and shares per block, there are about 576 blocks per day. And the negative rate adjusts the cost of coins every six months. \" +                      \" It is also forbidden to use fractional reserve banking for these coins, since their number grows linearly, and \" +                      \"will not be able to cover the debts incurred due to fractional reserve banking, due to absence due to a lack of \" +                      \" cash, because with fractional reserve banking, the growth in debt will be much higher than this protocol will create money. \" +                      \" also if you increase the money supply by changing the settings, and making the growth of the money supply much higher, it can cause hyperinflation or \" +                      \"even galloping inflation. If it is necessary to increase the growth of the money supply, this should only happen through amendments, \" +                      \" while keeping the founder's reward percentage at two percent. And the mining per block should not increase more than 5% for \" +                      \"twenty years, each subsequent increase that may be made must pass at least twenty years through amendments,\" +                      \" and no more than 5% per block from the reward of the last block. (Example: if we changed \" +                      \"through the amendments, then the extraction should not be higher than 210 coins, but each subsequent one will be no more than five percent of the last.\" +                      \"Thus, the next increase made through the amendments will be 220.5 coins. But this amendment will be made only after twenty\" +                      \" years after the first correction for production change) \" +                      \"\" +                      \" If the money supply is deficient, if the number of mined coins has not been changed through the amendment, you can add a few \" +                      \"additional zeros after the decimal point, so it will simply increase the value of the coins, without increasing the total money supply.\" +                      \"\" +                      \" Negative rates should not be higher than 0.5% per annum and lower than 0.2% per annum. Negative rates can only be changed through amendments. \" +                      \" \";","String FREEDOM_OF_SPEECH = \"No authority of this corporation or entity shall prohibit free practice\" +             \" any religion; or restrict freedom of speech, conscience, or the press; \" +             \"or the right of people to peacefully assemble or associate with each other, or not associate with each other, and \" +             \" apply to the management of the Corporation of the International Trade Union and to this corporation with a request for satisfaction of complaints; \" +             \" or violate the right to the fruits of one's labor or \" +             \" the right to a peaceful life of one's choice. Freedoms of speech and conscience include the freedom to contribute to \" +             \" political campaigns or nominations for corporate office and shall be interpreted as \" +             \"applying equally to any means of communication. \";","String RIGHTS = \"All members of the network must respect the Natural Human Rights and not violate them.\" +             \" The presumption of innocence must also be respected and each member of the network must have the right to an honest independent \" +             \"litigation. Each participant has the right to a lawyer or to be his own lawyer.\" +             \" International Trade Union Corporation should not regulate the cost of goods and services of network members who \" +             \" sell through this platform. Also, the Corporation should not ban individual brands on its site, but may \" +             \"prohibit the sale of entire groups of goods that fall within the characteristics described by applicable laws, if \" +             \"this ban does not violate Natural Human Rights. As a source of rights, countries recognized as democratic can be taken as a precedent\" +             \"countries.\" +             \"One of the natural inalienable human rights is the right to life,\" +             \"freedom, security, property, physical and mental integrity, personal dignity, personal and family secrets, etc. \" +             \"\" +             \"No law in force should be interpreted in such a way as to violate the natural rights of man.\" +             \" The Corporate Supreme Court may use precedents as judgments, as long as those decisions do not contradict \" +             \"the current charter and current laws.\" +             \" The Corporate Supreme Court can create precedents similar to countries with case law, but apply \" +             \"You can if these precedents do not violate the current charter or current laws of the Corporation of the International Trade Union.\";","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","",""],"hashLaw":"LIBER489cd5a211fc67177e79a10a882120e3b3cb1cc90a053d40cd1ce4bda5f31f9a"}}
{"name":"LIBER18f89b0194e9109e7c0bbf2f2d952359af4c9c52b366b4d87197fe512a3d2114","account":{"account":"LIBER18f89b0194e9109e7c0bbf2f2d952359af4c9c52b366b4d87197fe512a3d2114","digitalDollarBalance":0.0,"digitalStockBalance":0.0},"laws":{"packetLawName":"ORIGINAL_CHARTER_CURRENT_ALL_CODE","laws":["ДАТА УТВЕРЖДЕНИЯ УСТАВА ПЯТОГО АПРЕЛЯ 2023 ГОДА. THE DATE OF APPROVAL OF THE CHARTER IS APRIL 5, 2023. ИСХОДНЫЙ КОД СОЗДАННЫЙ ОСНОВАТЕЛЕМ. SOURCE CODE CREATED BY THE FOUNDER.","package International_Trade_Union.about_us_engDraft; /**устарел(недействителен), является черновиком, но его хеш используется в генезис блоке.  Но с помощью новых законов можно добавить те части которые будут интересны и сделать их действительным законом, если  данные части не противоречат действующему уставу и действующим законам.  */ public interface AboutUsEngDraft {     String aboutUs = \"The purpose of the International Trade Union Corporation is to facilitate trade between people by providing \" +             \"their ecosystem, as well as the provision of their products, which also includes money, legislation, etc. \" +             \"In case of inconsistencies due to the translation of the English charter and Russian, proceed from the Russian charter, since \" +             \"the translation was through Google translator from Russian into English.\";      String aboutUsCity = \"immediate goals: 1. Popularize this system. 2. Create appropriate laws within this system\" +             \"the current needs of this system. 3. Create an appropriate infrastructure for the development of our Corporation.\" +             \"4. Start open negotiations on partnerships with large TNCs. 5. Determine the first city where the headquarters will be\" +             \"this corporation. \";      String finish =              \"International Trade Union Corporation together with all of us to pave for the development of international trade,\" +                     \" developing advanced technologies and providing the best products and services. \" +                     \" Creation of an advanced infrastructure that will create conditions for free international trade.\";      public static String getAboutUs(){         return \"\\naboutUs: \"+aboutUs + \"\\naboutUsCity:\" + aboutUsCity + \"\\nfinish: \" + finish ;     } }","package International_Trade_Union.about_usDraft; /**устарел(недействителен), является черновиком, но его хеш используется в генезис блоке.  Но с помощью новых законов можно добавить те части которые будут интересны и сделать их действительным законом, если  данные части не противоречат действующему уставу и действующим законам.  */ public interface AboutUsDraft {     String aboutUs = \" Целью Корпорации Международного Торгового Союза является облегчене торговли между людьми, предоставление \" +             \"своей экосистемы, а также предоставление своих продукций, в которые также входят деньги, законодательство и т.д. \" +             \"В случае выявления нестыковок из за перевода английского устава и русского, исходите из руского устава, так как  \" +             \"перевод был через гугл переводчик с руского на английский.\";      String aboutUsCity = \" ближайщие цели: 1. Популиризировать данную систему. 2. Создать внутри данной системы законы соответствующие\" +             \"текущим потребностям данной системы. 3. Создать соответствующую инфраструктуру для развития нашей Корпороции.\" +             \"4. Начать открытые переговоры по партнерским отношениям с крупными ТНК. 5. Определить первый город, где будет штаб квартира\" +             \"данной корпорации. \";      String finish =              \"Корпорация Международный Торговый Союз вместе всеми нами проложить для развития международной торговли,\" +                     \" разработки передовых технологии и предоставление лучших товаров и услуг. \" +                     \" Создание передовой инфраструктуры которые создадут условия для свободной международной торговли.\";      public static String getAboutUs(){         return \"\\naboutUs: \"+aboutUs + \"\\naboutUsCity:\" + aboutUsCity + \"\\nfinish: \" + finish ;     } }","package International_Trade_Union.config;   import International_Trade_Union.entity.blockchain.Blockchain; import International_Trade_Union.setings.Seting;  import java.io.IOException; import java.security.InvalidKeyException; import java.security.NoSuchAlgorithmException; import java.security.NoSuchProviderException; import java.security.SignatureException; import java.security.spec.InvalidKeySpecException;  public class BLockchainFactory {      public static Blockchain getBlockchain(BlockchainFactoryEnum factoryEnum) throws NoSuchAlgorithmException, InvalidKeySpecException, IOException, SignatureException, NoSuchProviderException, InvalidKeyException {         switch (factoryEnum){             case TEST:                 return new Blockchain(                         Seting.BLOCK_GENERATION_INTERVAL_TEST,                         Seting.DIFFICULTY_ADJUSTMENT_INTERVAL_TEST,                         Seting.INTERVAL_TARGET_TEST,                         Seting.ADDRESS_FOUNDER_TEST);              case ORIGINAL:                 return new Blockchain(                         Seting.BLOCK_GENERATION_INTERVAL,                         Seting.DIFFICULTY_ADJUSTMENT_INTERVAL,                         Seting.INTERVAL_TARGET,                         Seting.ADDRESS_FOUNDER                 );             default: return null;         }     } }","package International_Trade_Union.config;  public enum BlockchainFactoryEnum {     TEST,     ORIGINAL }","package International_Trade_Union.controllers;  import International_Trade_Union.entity.AddressUrl; import International_Trade_Union.entity.SubBlockchainEntity; import org.json.JSONException;  import org.springframework.http.MediaType; import International_Trade_Union.entity.DtoTransaction.DtoTransaction; import International_Trade_Union.entity.blockchain.Blockchain; import International_Trade_Union.entity.blockchain.block.Block; import International_Trade_Union.governments.UtilsGovernment; import International_Trade_Union.config.BLockchainFactory; import International_Trade_Union.config.BlockchainFactoryEnum; import International_Trade_Union.entity.EntityChain; import International_Trade_Union.model.Account; import International_Trade_Union.model.Mining; import International_Trade_Union.model.User; import International_Trade_Union.network.AllTransactions; import International_Trade_Union.setings.Seting; import International_Trade_Union.utils.*; import International_Trade_Union.vote.*; import org.springframework.http.HttpStatus; import org.springframework.http.ResponseEntity; import org.springframework.util.Assert; import org.springframework.web.bind.annotation.*; import org.springframework.web.context.request.RequestAttributes; import org.springframework.web.context.request.RequestContextHolder; import org.springframework.web.context.request.ServletRequestAttributes;  import javax.servlet.http.HttpServletRequest; import java.io.File; import java.io.IOException;  import java.security.*; import java.security.spec.InvalidKeySpecException;  import java.util.*; import java.util.stream.Collectors;  @RestController public class BasisController {     private static Blockchain blockchain;      private static Set<String> excludedAddresses = new HashSet<>();      public static HttpServletRequest getCurrentRequest() {         RequestAttributes requestAttributes = RequestContextHolder.getRequestAttributes();         Assert.state(requestAttributes != null, \"Could not find current request via RequestContextHolder\");         Assert.isInstanceOf(ServletRequestAttributes.class, requestAttributes);         HttpServletRequest servletRequest = ((ServletRequestAttributes) requestAttributes).getRequest();         Assert.state(servletRequest != null, \"Could not find current HttpServletRequest\");         return servletRequest;     }       public static Set<String> getExcludedAddresses() {         HttpServletRequest request = getCurrentRequest();          String scheme = request.getScheme();         String serverName = request.getServerName();         int serverPort = request.getServerPort();         String contextPath = request.getContextPath();  // includes leading forward slash          String localaddress = scheme + \"://\" + serverName + \":\" + serverPort;          excludedAddresses.add(localaddress);         return excludedAddresses;     }      public static void setExcludedAddresses(Set<String> excludedAddresses) {         BasisController.excludedAddresses = excludedAddresses;     }      private static Set<String> nodes = new HashSet<>(); //    private static Nodes nodes = new Nodes();       public static void setNodes(Set<String> nodes) {         BasisController.nodes = nodes;     }      public static Set<String> getNodes() throws IOException, NoSuchAlgorithmException, InvalidKeySpecException, SignatureException, NoSuchProviderException, InvalidKeyException {          nodes = new HashSet<>();          Set<String> temporary = UtilsAllAddresses.readLineObject(Seting.ORIGINAL_POOL_URL_ADDRESS_FILE);          nodes.addAll(Seting.ORIGINAL_ADDRESSES);         nodes.addAll(temporary);           nodes = nodes.stream()                 .filter(t -> !t.isBlank())                 .filter(t -> t.startsWith(\"\\\"\"))                 .collect(Collectors.toSet());         nodes = nodes.stream().map(t -> t.replaceAll(\"\\\"\", \"\")).collect(Collectors.toSet());          return nodes;     }       public static Blockchain getBlockchain() {         return blockchain;     }      public static synchronized void setBlockchain(Blockchain blockchain) {         BasisController.blockchain = blockchain;     }       static {         try {             blockchain = BLockchainFactory.getBlockchain(BlockchainFactoryEnum.ORIGINAL);         } catch (NoSuchAlgorithmException e) {             throw new RuntimeException(e);         } catch (InvalidKeySpecException e) {             throw new RuntimeException(e);         } catch (IOException e) {             throw new RuntimeException(e);         } catch (SignatureException e) {             throw new RuntimeException(e);         } catch (NoSuchProviderException e) {             throw new RuntimeException(e);         } catch (InvalidKeyException e) {             throw new RuntimeException(e);         }     }       public BasisController() {     }     //TODO если вы прервали mine, то перед следующим вызовом перезапустите сервер и вызовите /addBlock перед mine     //TODO if you interrupted mine, restart the server before next call and call /addBlock before mine     //TODO иначе будет расождение в файле балансов     //TODO otherwise there will be a discrepancy in the balance file     @GetMapping(\"/mine\")     public synchronized ResponseEntity<String> mine() throws NoSuchAlgorithmException, InvalidKeySpecException, IOException, SignatureException, NoSuchProviderException, InvalidKeyException, JSONException, CloneNotSupportedException {          //нахождение адрессов         findAddresses();         sendAddress();          Map<String, Account> balances = SaveBalances.readLineObject(Seting.ORIGINAL_BALANCE_FILE);         blockchain = Mining.getBlockchain(                 Seting.ORIGINAL_BLOCKCHAIN_FILE,                 BlockchainFactoryEnum.ORIGINAL);          if(!blockchain.validatedBlockchain()){             return new ResponseEntity<>(\"blockchain wrong \", HttpStatus.BAD_GATEWAY);         }          //Прежде чем добыть новый блок сначала в сети ищет самый длинный         resolve_conflicts();          long index = blockchain.sizeBlockhain();         if(blockchain.sizeBlockhain() <=1){             //сохранение генезис блока             if (blockchain.sizeBlockhain() == 1) {                 UtilsBlock.saveBLock(blockchain.getBlock(0), Seting.ORIGINAL_BLOCKCHAIN_FILE);             }              balances = Mining.getBalances(Seting.ORIGINAL_BALANCE_FILE, blockchain, balances);             Mining.deleteFiles(Seting.ORIGINAL_BALANCE_FILE);             SaveBalances.saveBalances(balances, Seting.ORIGINAL_BALANCE_FILE);          }         balances = SaveBalances.readLineObject(Seting.ORIGINAL_BALANCE_FILE);          Account miner = balances.get(User.getUserAddress());         if (miner == null) {             miner = new Account(User.getUserAddress(), 0, 0);         }          //транзакции которые мы добавили в блок, и которые стоит удалить из списка когда мы дошли до удаления.         List<DtoTransaction> temporaryDtoList = AllTransactions.getInstance();          //раз в три для очищяет файл sended         AllTransactions.clearAllSendedTransaction(index);         AllTransactions.clearUsedTransaction(AllTransactions.getInsanceSended());         System.out.println(\"BasisController: start mine:\");         Block block = Mining.miningDay(                 miner,                 Seting.ORIGINAL_BLOCKCHAIN_FILE,                 blockchain,                 Seting.BLOCK_GENERATION_INTERVAL,                 Seting.DIFFICULTY_ADJUSTMENT_INTERVAL,                 temporaryDtoList,                 balances,                 index         );         System.out.println(\"BasisController: finish mine:\");         //save sended transaction         AllTransactions.addSendedTransaction(temporaryDtoList);          int diff = Seting.DIFFICULTY_ADJUSTMENT_INTERVAL;         //Тестирование блока         List<Block> testingValidationsBlock = null;          if (blockchain.sizeBlockhain() > diff) { //            testingValidationsBlock = blockchain.getBlockchainList().subList(blockchain.sizeBlockhain() - diff, blockchain.sizeBlockhain());             testingValidationsBlock = blockchain.subBlock(blockchain.sizeBlockhain() - diff, blockchain.sizeBlockhain());         } else { //            testingValidationsBlock = blockchain.getBlockchainList();             testingValidationsBlock = blockchain.clone();         }         if (testingValidationsBlock.size() > 1) {             boolean validationTesting = UtilsBlock.validationOneBlock(                     blockchain.genesisBlock().getFounderAddress(),                     testingValidationsBlock.get(testingValidationsBlock.size() - 1),                     block,                     Seting.BLOCK_GENERATION_INTERVAL,                     diff,                     testingValidationsBlock);              if (validationTesting == false) {                 System.out.println(\"wrong validation block: \" + validationTesting);                 System.out.println(\"index block: \" + block.getIndex());                 return new ResponseEntity<>(\"bad walidation\", HttpStatus.OK);             }             testingValidationsBlock.add(block.clone());         }          //сохранение блока         blockchain.addBlock(block);         UtilsBlock.saveBLock(block, Seting.ORIGINAL_BLOCKCHAIN_FILE);          //перерасчет после добычи         balances = Mining.getBalances(Seting.ORIGINAL_BALANCE_FILE, blockchain, balances);         Mining.deleteFiles(Seting.ORIGINAL_BALANCE_FILE);         SaveBalances.saveBalances(balances, Seting.ORIGINAL_BALANCE_FILE);          //получение и отображение законов, а также сохранение новых законов         //и изменение действующих законов         Map<String, Laws> allLaws = UtilsLaws.getLaws(blockchain.getBlockchainList(), Seting.ORIGINAL_ALL_CORPORATION_LAWS_FILE);          //возвращает все законы с балансом         List<LawEligibleForParliamentaryApproval> allLawsWithBalance = UtilsLaws.getCurrentLaws(allLaws, balances, Seting.ORIGINAL_ALL_CORPORATION_LAWS_WITH_BALANCE_FILE);         //удаление устаревних законов         Mining.deleteFiles(Seting.ORIGINAL_ALL_CORPORATION_LAWS_WITH_BALANCE_FILE);         UtilsLaws.saveCurrentsLaws(allLawsWithBalance, Seting.ORIGINAL_ALL_CORPORATION_LAWS_WITH_BALANCE_FILE);          return new ResponseEntity<>(\"add block: \" + block.getIndex(), HttpStatus.CREATED);      }       @GetMapping(\"/chain\")     @ResponseBody     public  EntityChain full_chain() throws IOException, NoSuchAlgorithmException, InvalidKeySpecException, SignatureException, NoSuchProviderException, InvalidKeyException {         blockchain = Mining.getBlockchain(                 Seting.ORIGINAL_BLOCKCHAIN_FILE,                 BlockchainFactoryEnum.ORIGINAL);         return new EntityChain(blockchain.sizeBlockhain(), blockchain.getBlockchainList());     }      @GetMapping(\"/size\")     @ResponseBody     public  Integer sizeBlockchain() throws IOException, NoSuchAlgorithmException, InvalidKeySpecException, SignatureException, NoSuchProviderException, InvalidKeyException {         blockchain = Mining.getBlockchain(                 Seting.ORIGINAL_BLOCKCHAIN_FILE,                 BlockchainFactoryEnum.ORIGINAL);         return blockchain.sizeBlockhain();     }      @PostMapping(\"/sub-blocks\")     @ResponseBody     public  List<Block> subBlocks(@RequestBody SubBlockchainEntity entity) throws IOException, NoSuchAlgorithmException, InvalidKeySpecException, SignatureException, NoSuchProviderException, InvalidKeyException {         blockchain = Mining.getBlockchain(                 Seting.ORIGINAL_BLOCKCHAIN_FILE,                 BlockchainFactoryEnum.ORIGINAL);         return blockchain.getBlockchainList().subList(entity.getStart(), entity.getFinish());     }      @PostMapping(\"/block\")     @ResponseBody     public Block getBlock(@RequestBody Integer index) throws IOException, NoSuchAlgorithmException, InvalidKeySpecException, SignatureException, NoSuchProviderException, InvalidKeyException {         blockchain = Mining.getBlockchain(                 Seting.ORIGINAL_BLOCKCHAIN_FILE,                 BlockchainFactoryEnum.ORIGINAL);         return blockchain.getBlock(index);     }      //TODO нужно чтобы передавался каждый раз не весь блокчейн а часть, как реализованно в биткоин     //TODO is necessary so that not the entire blockchain is transmitted each time, but a part, as implemented in bitcoin     //TODO need to optimization because now not best     @GetMapping(\"/nodes/resolve\")     public synchronized void resolve_conflicts() throws NoSuchAlgorithmException, InvalidKeySpecException, IOException, SignatureException, NoSuchProviderException, InvalidKeyException, JSONException {         Blockchain temporaryBlockchain = BLockchainFactory.getBlockchain(BlockchainFactoryEnum.ORIGINAL);         Blockchain bigBlockchain = BLockchainFactory.getBlockchain(BlockchainFactoryEnum.ORIGINAL);         blockchain = Mining.getBlockchain(                 Seting.ORIGINAL_BLOCKCHAIN_FILE,                 BlockchainFactoryEnum.ORIGINAL);         int blocks_current_size = blockchain.sizeBlockhain();         long hashCountZeroTemporary = 0;         long hashCountZeroBigBlockchain = 0;         EntityChain entityChain = null;          long hashCountZeroAll = 0;         //count hash start with zero all         for (Block block : blockchain.getBlockchainList()) {             hashCountZeroAll += UtilsUse.hashCount(block.getHashBlock());         }         System.out.println(\"BasisController: resolve: size: \" + getNodes().size());         for (String s : getNodes()) {             System.out.println(\"BasisController: resove: address: \" + s);             String temporaryjson = null;              if (BasisController.getExcludedAddresses().contains(s)) {                 System.out.println(\"its your address or excluded address: \" + s);                 continue;             }             try {                 String address = s + \"/chain\";                 System.out.println(\"BasisController:resolve conflicts: address: \" + s +\"/size\");                 String sizeStr = UtilUrl.readJsonFromUrl(s + \"/size\");                 Integer size = Integer.valueOf(sizeStr);                 if(size > blocks_current_size){                     System.out.println(\"size from address: \" + s + \" upper than: \" + size +\":blocks_current_size \" + blocks_current_size );                     //Test start algorithm                     SubBlockchainEntity subBlockchainEntity = new SubBlockchainEntity(blocks_current_size, size);                     String subBlockchainJson = UtilsJson.objToStringJson(subBlockchainEntity);                      List<Block> emptyList = new ArrayList<>();                      List<Block> subBlocks = UtilsJson.jsonToListBLock(UtilUrl.getObject(subBlockchainJson, s + \"/sub-blocks\"));                     emptyList.addAll(subBlocks);                     emptyList.addAll(blockchain.getBlockchainList());                      emptyList = emptyList.stream().sorted(Comparator.comparing(Block::getIndex)).collect(Collectors.toList());                     temporaryBlockchain.setBlockchainList(emptyList);                     if(!temporaryBlockchain.validatedBlockchain()){                         System.out.println(\"first algorithm not worked\");                         emptyList = new ArrayList<>();                         emptyList.addAll(subBlocks);                         for (int i = blockchain.sizeBlockhain()-1; i > 0 ; i--) {                             Block block = UtilsJson.jsonToBLock(UtilUrl.getObject(UtilsJson.objToStringJson(i), s+\"/block\"));                             if(!blockchain.getBlock(i).getHashBlock().equals(block.getHashBlock())){                                 emptyList.add(block);                             }                             else {                                 emptyList.add(block);                                 emptyList.addAll(blockchain.getBlockchainList().subList(0, i));                                 emptyList = emptyList.stream().sorted(Comparator.comparing(Block::getIndex)).collect(Collectors.toList());                                 temporaryBlockchain.setBlockchainList(emptyList);                                 break;                             }                         }                     }                     if (!temporaryBlockchain.validatedBlockchain()){                         System.out.println(\"second algorith not worked\");                         temporaryjson = UtilUrl.readJsonFromUrl(address);                         entityChain = UtilsJson.jsonToEntityChain(temporaryjson);                         temporaryBlockchain.setBlockchainList(                                 entityChain.getBlocks().stream().sorted(Comparator.comparing(Block::getIndex)).collect(Collectors.toList()));                     }                 }                  else {                     System.out.println(\"BasisController: resove: size less: \" + size + \" address: \" + address);                     continue;                 }             } catch (IOException e) {                 System.out.println(\"BasisController: resolve_conflicts: Error: \" + s);                 continue;             }               if (temporaryBlockchain.validatedBlockchain()) {                 for (Block block : temporaryBlockchain.getBlockchainList()) {                     hashCountZeroTemporary += UtilsUse.hashCount(block.getHashBlock());                 }                  if (blocks_current_size < temporaryBlockchain.sizeBlockhain() && hashCountZeroAll < hashCountZeroTemporary) {                     blocks_current_size = temporaryBlockchain.sizeBlockhain();                     bigBlockchain = temporaryBlockchain;                     hashCountZeroBigBlockchain = hashCountZeroTemporary;                 }                 hashCountZeroTemporary = 0;             }          }           if (bigBlockchain.sizeBlockhain() > blockchain.sizeBlockhain() && hashCountZeroBigBlockchain > hashCountZeroAll) {                  blockchain = bigBlockchain;                 UtilsBlock.deleteFiles();                 addBlock(bigBlockchain.getBlockchainList(), BLockchainFactory.getBlockchain(BlockchainFactoryEnum.ORIGINAL));                 System.out.println(\"BasisController: resolve: bigblockchain size: \" + bigBlockchain.sizeBlockhain());           }     }       /**добавляет блоки в блок чейн пересохраняя файлы, предназначен когда у нас есть готовый      * блокчейн и нужно все файлы(balance, vote, government и т. д.) заного пересохранить.      * adds blocks to the block chain by resaving files, designed when we have it ready      *      * Blockchain and you need to save all files (balance, vote, government, etc.) again.*/     public static void addBlock(List<Block> orignalBlocks, Blockchain blockchain) throws IOException, NoSuchAlgorithmException, SignatureException, InvalidKeySpecException, NoSuchProviderException, InvalidKeyException {          Map<String, Account> balances = new HashMap<>();         Blockchain temporaryForValidation =  BLockchainFactory.getBlockchain(BlockchainFactoryEnum.ORIGINAL);         temporaryForValidation.setBlockchainList(orignalBlocks);              System.out.println(\"addBlock start\");             for (Block block : orignalBlocks) {                 UtilsBlock.saveBLock(block, Seting.ORIGINAL_BLOCKCHAIN_FILE);             }          blockchain = Mining.getBlockchain(                 Seting.ORIGINAL_BLOCKCHAIN_FILE,                 BlockchainFactoryEnum.ORIGINAL);          //перерасчет после добычи         balances = UtilsBalance.calculateBalances(blockchain.getBlockchainList());         Mining.deleteFiles(Seting.ORIGINAL_BALANCE_FILE);         SaveBalances.saveBalances(balances, Seting.ORIGINAL_BALANCE_FILE);           //получение и отображение законов, а также сохранение новых законов         //и изменение действующих законов         Map<String, Laws> allLaws = UtilsLaws.getLaws(blockchain.getBlockchainList(), Seting.ORIGINAL_ALL_CORPORATION_LAWS_FILE);           //возвращает все законы с балансом         List<LawEligibleForParliamentaryApproval> allLawsWithBalance = UtilsLaws.getCurrentLaws(allLaws, balances, Seting.ORIGINAL_ALL_CORPORATION_LAWS_WITH_BALANCE_FILE);         //удаление устаревних законов         Mining.deleteFiles(Seting.ORIGINAL_ALL_CORPORATION_LAWS_WITH_BALANCE_FILE);         UtilsLaws.saveCurrentsLaws(allLawsWithBalance, Seting.ORIGINAL_ALL_CORPORATION_LAWS_WITH_BALANCE_FILE);          System.out.println(\"BasisController: addBlock: finish\");     }      @RequestMapping(method = RequestMethod.POST, value = \"/nodes/register\", consumes = MediaType.APPLICATION_JSON_VALUE)     public synchronized void register_node(@RequestBody AddressUrl urlAddrress) throws IOException, NoSuchAlgorithmException, InvalidKeySpecException, SignatureException, NoSuchProviderException, InvalidKeyException {           for (String s : BasisController.getNodes()) {             String original = s;             String url = s + \"/nodes/register\";              try {                 UtilUrl.sendPost(urlAddrress.getAddress(), url);                 sendAddress();               } catch (Exception e) {                 System.out.println(\"BasisController: register node: wrong node: \" + original);                 BasisController.getNodes().remove(original);                 continue;             }         }          Set<String> nodes = BasisController.getNodes();         nodes = nodes.stream()                 .map(t -> t.replaceAll(\"\\\"\", \"\"))                 .map(t -> t.replaceAll(\"\\\\\\\\\", \"\"))                 .collect(Collectors.toSet());         nodes.add(urlAddrress.getAddress());         BasisController.setNodes(nodes);          Mining.deleteFiles(Seting.ORIGINAL_POOL_URL_ADDRESS_FILE);         nodes.stream().forEach(t -> {             try {                 UtilsAllAddresses.saveAllAddresses(t, Seting.ORIGINAL_POOL_URL_ADDRESS_FILE);             } catch (IOException e) {                 throw new RuntimeException(e);             } catch (NoSuchAlgorithmException e) {                 throw new RuntimeException(e);             } catch (SignatureException e) {                 throw new RuntimeException(e);             } catch (InvalidKeySpecException e) {                 throw new RuntimeException(e);             } catch (NoSuchProviderException e) {                 throw new RuntimeException(e);             } catch (InvalidKeyException e) {                 throw new RuntimeException(e);             }         });      }      //TODO если происходить майнинг, то он возвращает false, пока не прекратиться майнинг.     //TODO if mining occurs, it returns false until mining stops.     /**проверяет целостность цепочки блокчейн true-значит цепочка правильная.      * verifies the integrity of the blockchain chain true-means the chain is correct*/         /**Делает перерасчет исходя и текущего блокчейна, заного перезаписывая файлы баланса и другие файлы.      * Makes a recalculation based on the current blockchain, overwriting balance files and other files.*/     @GetMapping(\"/addBlock\")     public boolean getBLock() throws IOException, NoSuchAlgorithmException, InvalidKeySpecException, SignatureException, NoSuchProviderException, InvalidKeyException {         blockchain = Mining.getBlockchain(                 Seting.ORIGINAL_BLOCKCHAIN_FILE,                 BlockchainFactoryEnum.ORIGINAL);         UtilsBlock.deleteFiles();         addBlock(blockchain.getBlockchainList(), BLockchainFactory.getBlockchain(BlockchainFactoryEnum.ORIGINAL));         return true;     }      @GetMapping(\"/getNodes\")     public Set<String> getAllNodes() throws IOException, NoSuchAlgorithmException, InvalidKeySpecException, SignatureException, NoSuchProviderException, InvalidKeyException {         Set<String> temporary = UtilsAllAddresses.readLineObject(Seting.ORIGINAL_POOL_URL_ADDRESS_FILE);         nodes.addAll(temporary);         nodes.addAll(Seting.ORIGINAL_ADDRESSES);         nodes = nodes.stream().filter(t -> t.startsWith(\"\\\"\"))                 .collect(Collectors.toSet());         return nodes;     }      @GetMapping(\"/findAddresses\")     public void findAddresses() throws IOException, NoSuchAlgorithmException, InvalidKeySpecException, SignatureException, NoSuchProviderException, InvalidKeyException {         for (String s : Seting.ORIGINAL_ADDRESSES) {             Set<String> addressesSet = new HashSet<>();             try {                 String addresses = UtilUrl.readJsonFromUrl(s + \"/getDiscoveryAddresses\");                 addressesSet = UtilsJson.jsonToSetAddresses(addresses);             } catch (IOException e) {                 System.out.println(\"BasisController: findAddress: error\");                 continue;             } catch (JSONException e) {                 throw new RuntimeException(e);             }              for (String s1 : addressesSet) {                  register_node(new AddressUrl(s1));             }          }      }      @GetMapping(\"/moreMining\")     public void moreMining() throws JSONException, IOException {         for (int i = 1; i < 2000; i++) {             System.out.println(\"block generate i: \" + i);             UtilUrl.readJsonFromUrl(\"http://localhost:8082/mine\");           }     }        public static void sendAddress() throws IOException, NoSuchAlgorithmException, InvalidKeySpecException, SignatureException, NoSuchProviderException, InvalidKeyException {         //лист временный для отправки аддресов          for (String s : Seting.ORIGINAL_ADDRESSES) {              String original = s;             String url = s + \"/nodes/register\";              if(BasisController.getExcludedAddresses().contains(url)){                 System.out.println(\"MainController: its your address or excluded address: \" + url);                 continue;             }             try {                 for (String s1 : BasisController.getNodes()) {                       AddressUrl addressUrl = new AddressUrl(s1);                     String json = UtilsJson.objToStringJson(addressUrl);                     UtilUrl.sendPost(json, url);                 }             } catch (Exception e) {                 System.out.println(\"BasisController: sendAddress: wronge node: \" + original);                  continue;             }           }     } }","package International_Trade_Union.controllers;  import International_Trade_Union.config.BlockchainFactoryEnum; import International_Trade_Union.entity.blockchain.Blockchain; import International_Trade_Union.model.Mining; import International_Trade_Union.setings.Seting; import org.springframework.web.bind.annotation.GetMapping; import org.springframework.web.bind.annotation.RestController;  import java.io.IOException; import java.security.InvalidKeyException; import java.security.NoSuchAlgorithmException; import java.security.NoSuchProviderException; import java.security.SignatureException; import java.security.spec.InvalidKeySpecException;  @RestController public class BlockchainCheckController {      //TODO во время майнинга, если майнинг не остановлен, он почему то возвращает false, но после остановки true. Нужно исправить.     //TODO during mining, if mining is not stopped, for some reason it returns false, but after stopping it returns true. Need to fix.     //TODO worked after restart server, get true.     //TODO ошибка возникает если прервать mine,     //TODO error occurs if mine is interrupted,     @GetMapping(\"/checkValidation\")     public boolean checkValidation() throws IOException, NoSuchAlgorithmException, SignatureException, InvalidKeySpecException, NoSuchProviderException, InvalidKeyException {         try{             Blockchain blockchain = Mining.getBlockchain(                     Seting.ORIGINAL_BLOCKCHAIN_FILE,                     BlockchainFactoryEnum.ORIGINAL);             System.out.println(\"BlockchainCheckController: checkValidation: size: \" + blockchain.sizeBlockhain());             return blockchain.validatedBlockchain();}         catch (IOException e){             e.printStackTrace();             return false;         }     } }","package International_Trade_Union.controllers;  import International_Trade_Union.config.BlockchainFactoryEnum; import International_Trade_Union.entity.blockchain.Blockchain; import International_Trade_Union.governments.UtilsGovernment; import International_Trade_Union.model.Mining; import International_Trade_Union.utils.SaveBalances; import org.springframework.stereotype.Controller; import org.springframework.ui.Model; import org.springframework.web.bind.annotation.GetMapping; import International_Trade_Union.model.Account; import International_Trade_Union.setings.Seting;  import java.io.IOException; import java.security.InvalidKeyException; import java.security.NoSuchAlgorithmException; import java.security.NoSuchProviderException; import java.security.SignatureException; import java.security.spec.InvalidKeySpecException; import java.util.ArrayList; import java.util.HashMap; import java.util.List; import java.util.Map; import java.util.stream.Collectors;  @Controller public class BoardOfShareholdersController {     @GetMapping(\"board-of-shareholders\")     public String boardOfShareHolders(Model model) throws NoSuchAlgorithmException, InvalidKeySpecException, IOException, SignatureException, NoSuchProviderException, InvalidKeyException {          Blockchain blockchain = Mining.getBlockchain(                 Seting.ORIGINAL_BLOCKCHAIN_FILE,                 BlockchainFactoryEnum.ORIGINAL);          //Получение баланса         Map<String, Account> balances = new HashMap<>();          balances = SaveBalances.readLineObject(Seting.ORIGINAL_BALANCE_FILE);         List<Account> boardOfShareholders = new ArrayList<>();          boardOfShareholders = UtilsGovernment.findBoardOfShareholders(balances, blockchain.getBlockchainList(), Seting.BOARDS_BLOCK);           model.addAttribute(\"title\", \"board of shareholders. total: \" + boardOfShareholders.size());         model.addAttribute(\"boardOfShareholders\", boardOfShareholders);         return \"board-of-shareholders\";     }   }","package International_Trade_Union.controllers;  import International_Trade_Union.CorporateCharterEngDraft.*; import International_Trade_Union.originalCorporateCharter.OriginalCHARTER; import International_Trade_Union.originalCorporateCharter.OriginalCHARTER_ENG; import International_Trade_Union.originalCorporateCharter.OriginalPreamble; import International_Trade_Union.originalCorporateCharter.OriginalPreambleEng; import International_Trade_Union.setings.Seting; import International_Trade_Union.utils.UtilsSecurity; import International_Trade_Union.utils.base.Base; import International_Trade_Union.utils.base.Base58; import org.bouncycastle.jcajce.provider.asymmetric.ec.BCECPublicKey; import org.springframework.stereotype.Controller; import org.springframework.ui.Model; import org.springframework.web.bind.annotation.GetMapping; import International_Trade_Union.CorporateCharterDraft.*;  import java.io.IOException; import java.security.InvalidKeyException; import java.security.NoSuchAlgorithmException; import java.security.NoSuchProviderException; import java.security.SignatureException; import java.security.spec.InvalidKeySpecException; import java.util.ArrayList; import java.util.List;  @Controller public class ConstitutionController {     @GetMapping(\"corporate-charter\")     public String constutionRus(Model model) throws NoSuchAlgorithmException, InvalidKeySpecException, IOException, SignatureException, NoSuchProviderException, InvalidKeyException {          model.addAttribute(\"title\", \"corporate charter-корпоративный устав\");         List<String> rus = charterRusList();         List<String> eng = charterEngList();               model.addAttribute(\"rus\", rus);         model.addAttribute(\"eng\", eng);         return \"corporate-charter\";     }      public static String charterRus (){         String string = \"\";         for (String s : charterRusList()) {             string = s + \"\\n\";         }         return string;     }      public static String charterEng(){         String string = \"\";         for (String s : charterEngList()) {             string = s + \"\\n\";         }         return string;     }       public static List<String> charterRusList(){         List<String> rus = new ArrayList<>();         List<String> eng = new ArrayList<>();          rus.add(\"OriginalPreamble.ARTICLE_0\\n\"+ OriginalPreamble.ARTICLE_0);         rus.add(\"OriginalCHARTER.POWERS_OF_THE_BOARD_OF_DIRECTORS:\\n\"+ OriginalCHARTER.POWERS_OF_THE_BOARD_OF_DIRECTORS);         rus.add(\"OriginalCHARTER.HOW_LAWS_ARE_CHOSEN:\\n\"+ OriginalCHARTER.HOW_LAWS_ARE_CHOSEN);         rus.add(\"OriginalCHARTER.HOW_THE_BOARD_OF_DIRECTORS_IS_ELECTED:\\n\"+ OriginalCHARTER.HOW_THE_BOARD_OF_DIRECTORS_IS_ELECTED);         rus.add(\"OriginalCHARTER.POWERS_OF_THE_BOARD_OF_SHAREHOLDERS:\\n\"+ OriginalCHARTER.POWERS_OF_THE_BOARD_OF_SHAREHOLDERS);         rus.add(\"OriginalCHARTER.HOW_SHAREHOLDERS_BOARD_IS_ELECTED:\\n\"+ OriginalCHARTER.HOW_SHAREHOLDERS_BOARD_IS_ELECTED);         rus.add(\"OriginalCHARTER.VOTE_STOCK:\\n\"+ OriginalCHARTER.VOTE_STOCK);         rus.add(\"OriginalCHARTER.CODE_VOTE_STOCK:\\n\"+ OriginalCHARTER.CODE_VOTE_STOCK);         rus.add(\"OriginalCHARTER.POWERS_OF_DIRECTORS_IN_THE_OFFICE:\\n\"+ OriginalCHARTER.POWERS_OF_DIRECTORS_IN_THE_OFFICE);         rus.add(\"OriginalCHARTER.HOW_OFFICE_DIRECTORS_ARE_CHOSEN:\\n\"+ OriginalCHARTER.HOW_OFFICE_DIRECTORS_ARE_CHOSEN);         rus.add(\"OriginalCHARTER.ONE_VOTE:\\n\"+ OriginalCHARTER.ONE_VOTE);         rus.add(\"OriginalCHARTER.CODE_VOTE_ONE:\\n\"+ OriginalCHARTER.CODE_VOTE_ONE);         rus.add(\"OriginalCHARTER.MECHANISM_FOR_REDUCING_THE_NUMBER_OF_SHARES:\\n\"+ OriginalCHARTER.MECHANISM_FOR_REDUCING_THE_NUMBER_OF_SHARES);         rus.add(\"OriginalCHARTER.WHO_HAS_THE_RIGHT_TO_CREATE_LAWS:\\n\"+ OriginalCHARTER.WHO_HAS_THE_RIGHT_TO_CREATE_LAWS);         rus.add(\"OriginalCHARTER.POWERS_OF_THE_CORPORATE_COUNCIL_OF_JUDGES:\\n\"+ OriginalCHARTER.POWERS_OF_THE_CORPORATE_COUNCIL_OF_JUDGES);         rus.add(\"OriginalCHARTER.HOW_THE_CORPORATE_BOARD_OF_JUDGES_IS_ELECTED:\\n\"+ OriginalCHARTER.HOW_THE_CORPORATE_BOARD_OF_JUDGES_IS_ELECTED);         rus.add(\"OriginalCHARTER.HOW_THE_CHIEF_JUDGE_IS_CHOSEN:\\n\"+ OriginalCHARTER.HOW_THE_CHIEF_JUDGE_IS_CHOSEN);         rus.add(\"OriginalCHARTER.POWERS_OF_THE_CHIEF_JUDGE:\\n\"+ OriginalCHARTER.POWERS_OF_THE_CHIEF_JUDGE);         rus.add(\"OriginalCHARTER.HOW_IS_THE_PROCESS_OF_AMENDING_THE_CHARTER:\\n\"+ OriginalCHARTER.HOW_IS_THE_PROCESS_OF_AMENDING_THE_CHARTER);         rus.add(\"OriginalCHARTER.HOW_THE_BUDGET_IS_APPROVED:\\n\"+ OriginalCHARTER.HOW_THE_BUDGET_IS_APPROVED);         rus.add(\"OriginalCHARTER.HOW_IS_THE_STRATEGIC:\\n\"+ OriginalCHARTER.HOW_IS_THE_STRATEGIC);         rus.add(\"OriginalCHARTER.HOW_NEW_POSITIONS_ARE_ADDED:\\n\"+ OriginalCHARTER.HOW_NEW_POSITIONS_ARE_ADDED);         rus.add(\"OriginalCHARTER.PROPERTY_OF_THE_CORPORATION:\\n\"+ OriginalCHARTER.PROPERTY_OF_THE_CORPORATION);         rus.add(\"OriginalCHARTER.INTERNET_STORE_DIRECTOR:\\n\"+ OriginalCHARTER.INTERNET_STORE_DIRECTOR);         rus.add(\"OriginalCHARTER.GENERAL_EXECUTIVE_DIRECTOR:\\n\"+ OriginalCHARTER.GENERAL_EXECUTIVE_DIRECTOR);         rus.add(\"OriginalCHARTER.DIRECTOR_OF_THE_DIGITAL_EXCHANGE:\\n\"+ OriginalCHARTER.DIRECTOR_OF_THE_DIGITAL_EXCHANGE);         rus.add(\"OriginalCHARTER.DIRECTOR_OF_DIGITAL_BANK:\\n\"+ OriginalCHARTER.DIRECTOR_OF_DIGITAL_BANK);         rus.add(\"OriginalCHARTER.DIRECTOR_OF_THE_COMMERCIAL_COURT:\\n\"+ OriginalCHARTER.DIRECTOR_OF_THE_COMMERCIAL_COURT);         rus.add(\"OriginalCHARTER.MEDIA_DIRECTOR:\\n\"+ OriginalCHARTER.MEDIA_DIRECTOR);         rus.add(\"OriginalCHARTER.DIRECTOR_OF_THE_DEVELOPMENT_OF_THE_IMPLEMENTATION_OF_CRYPTOCURRENCY_TECHNOLOGIES_OF_THE_INTERNATIONAL_TRADE_UNION_CORPORATION:\\n\"+ OriginalCHARTER.DIRECTOR_OF_THE_DEVELOPMENT_OF_THE_IMPLEMENTATION_OF_CRYPTOCURRENCY_TECHNOLOGIES_OF_THE_INTERNATIONAL_TRADE_UNION_CORPORATION);         rus.add(\"OriginalCHARTER.EXPLANATION_WHY_MONEY_DEMURAGE_IS_USED_HERE:\\n\"+ OriginalCHARTER.EXPLANATION_WHY_MONEY_DEMURAGE_IS_USED_HERE);         rus.add(\"OriginalCHARTER.FREEDOM_OF_SPEECH:\\n\"+ OriginalCHARTER.FREEDOM_OF_SPEECH);         rus.add(\"OriginalCHARTER.RIGHTS:\\n\"+ OriginalCHARTER.RIGHTS);         return rus;     }       public static List<String> charterEngList(){         List<String> eng = new ArrayList<>();              //************************************************************************************         eng.add(\"OriginalPreamble.ARTICLE_0\\n\"+ OriginalPreambleEng.ARTICLE_0);         eng.add(\"OriginalCHARTER_ENG.POWERS_OF_THE_BOARD_OF_DIRECTORS:\\n\"+ OriginalCHARTER_ENG.POWERS_OF_THE_BOARD_OF_DIRECTORS);         eng.add(\"OriginalCHARTER_ENG.HOW_LAWS_ARE_CHOSEN:\\n\"+ OriginalCHARTER_ENG.HOW_LAWS_ARE_CHOSEN);         eng.add(\"OriginalCHARTER_ENG.HOW_THE_BOARD_OF_DIRECTORS_IS_ELECTED:\\n\"+ OriginalCHARTER_ENG.HOW_THE_BOARD_OF_DIRECTORS_IS_ELECTED);         eng.add(\"OriginalCHARTER_ENG.POWERS_OF_THE_BOARD_OF_SHAREHOLDERS:\\n\"+ OriginalCHARTER_ENG.POWERS_OF_THE_BOARD_OF_SHAREHOLDERS);         eng.add(\"OriginalCHARTER_ENG.HOW_SHAREHOLDERS_BOARD_IS_ELECTED:\\n\"+ OriginalCHARTER_ENG.HOW_SHAREHOLDERS_BOARD_IS_ELECTED);         eng.add(\"OriginalCHARTER_ENG.VOTE_STOCK:\\n\"+ OriginalCHARTER_ENG.VOTE_STOCK);         eng.add(\"OriginalCHARTER_ENG.CODE_VOTE_STOCK:\\n\"+ OriginalCHARTER_ENG.CODE_VOTE_STOCK);         eng.add(\"OriginalCHARTER_ENG.POWERS_OF_DIRECTORS_IN_THE_OFFICE:\\n\"+ OriginalCHARTER_ENG.POWERS_OF_DIRECTORS_IN_THE_OFFICE);         eng.add(\"OriginalCHARTER_ENG.HOW_OFFICE_DIRECTORS_ARE_CHOSEN:\\n\"+ OriginalCHARTER_ENG.HOW_OFFICE_DIRECTORS_ARE_CHOSEN);         eng.add(\"OriginalCHARTER_ENG.ONE_VOTE:\\n\"+ OriginalCHARTER_ENG.ONE_VOTE);         eng.add(\"OriginalCHARTER_ENG.CODE_VOTE_ONE:\\n\"+ OriginalCHARTER_ENG.CODE_VOTE_ONE);         eng.add(\"OriginalCHARTER_ENG.MECHANISM_FOR_REDUCING_THE_NUMBER_OF_SHARES:\\n\"+ OriginalCHARTER_ENG.MECHANISM_FOR_REDUCING_THE_NUMBER_OF_SHARES);         eng.add(\"OriginalCHARTER_ENG.WHO_HAS_THE_RIGHT_TO_CREATE_LAWS:\\n\"+ OriginalCHARTER_ENG.WHO_HAS_THE_RIGHT_TO_CREATE_LAWS);         eng.add(\"OriginalCHARTER_ENG.POWERS_OF_THE_CORPORATE_COUNCIL_OF_JUDGES:\\n\"+ OriginalCHARTER_ENG.POWERS_OF_THE_CORPORATE_COUNCIL_OF_JUDGES);         eng.add(\"OriginalCHARTER_ENG.HOW_THE_CORPORATE_BOARD_OF_JUDGES_IS_ELECTED:\\n\"+ OriginalCHARTER_ENG.HOW_THE_CORPORATE_BOARD_OF_JUDGES_IS_ELECTED);         eng.add(\"OriginalCHARTER_ENG.HOW_THE_CHIEF_JUDGE_IS_CHOSEN:\\n\"+ OriginalCHARTER_ENG.HOW_THE_CHIEF_JUDGE_IS_CHOSEN);         eng.add(\"OriginalCHARTER_ENG.POWERS_OF_THE_CHIEF_JUDGE:\\n\"+ OriginalCHARTER_ENG.POWERS_OF_THE_CHIEF_JUDGE);         eng.add(\"OriginalCHARTER_ENG.HOW_IS_THE_PROCESS_OF_AMENDING_THE_CHARTER:\\n\"+ OriginalCHARTER_ENG.HOW_IS_THE_PROCESS_OF_AMENDING_THE_CHARTER);         eng.add(\"OriginalCHARTER_ENG.HOW_THE_BUDGET_IS_APPROVED:\\n\"+ OriginalCHARTER_ENG.HOW_THE_BUDGET_IS_APPROVED);         eng.add(\"OriginalCHARTER_ENG.HOW_IS_THE_STRATEGIC:\\n\"+ OriginalCHARTER_ENG.HOW_IS_THE_STRATEGIC);         eng.add(\"OriginalCHARTER_ENG.HOW_NEW_POSITIONS_ARE_ADDED:\\n\"+ OriginalCHARTER_ENG.HOW_NEW_POSITIONS_ARE_ADDED);         eng.add(\"OriginalCHARTER_ENG.PROPERTY_OF_THE_CORPORATION:\\n\"+ OriginalCHARTER_ENG.PROPERTY_OF_THE_CORPORATION);         eng.add(\"OriginalCHARTER_ENG.INTERNET_STORE_DIRECTOR:\\n\"+ OriginalCHARTER_ENG.INTERNET_STORE_DIRECTOR);         eng.add(\"OriginalCHARTER_ENG.GENERAL_EXECUTIVE_DIRECTOR:\\n\"+ OriginalCHARTER_ENG.GENERAL_EXECUTIVE_DIRECTOR);         eng.add(\"OriginalCHARTER_ENG.DIRECTOR_OF_THE_DIGITAL_EXCHANGE:\\n\"+ OriginalCHARTER_ENG.DIRECTOR_OF_THE_DIGITAL_EXCHANGE);         eng.add(\"OriginalCHARTER_ENG.DIRECTOR_OF_DIGITAL_BANK:\\n\"+ OriginalCHARTER_ENG.DIRECTOR_OF_DIGITAL_BANK);         eng.add(\"OriginalCHARTER_ENG.DIRECTOR_OF_THE_COMMERCIAL_COURT:\\n\"+ OriginalCHARTER_ENG.DIRECTOR_OF_THE_COMMERCIAL_COURT);         eng.add(\"OriginalCHARTER_ENG.MEDIA_DIRECTOR:\\n\"+ OriginalCHARTER_ENG.MEDIA_DIRECTOR);         eng.add(\"OriginalCHARTER_ENG.DIRECTOR_OF_THE_DEVELOPMENT_OF_THE_IMPLEMENTATION_OF_CRYPTOCURRENCY_TECHNOLOGIES_OF_THE_INTERNATIONAL_TRADE_UNION_CORPORATION:\\n\"+ OriginalCHARTER_ENG.DIRECTOR_OF_THE_DEVELOPMENT_OF_THE_IMPLEMENTATION_OF_CRYPTOCURRENCY_TECHNOLOGIES_OF_THE_INTERNATIONAL_TRADE_UNION_CORPORATION);         eng.add(\"OriginalCHARTER_ENG.EXPLANATION_WHY_MONEY_DEMURAGE_IS_USED_HERE:\\n\"+ OriginalCHARTER_ENG.EXPLANATION_WHY_MONEY_DEMURAGE_IS_USED_HERE);         eng.add(\"OriginalCHARTER_ENG.FREEDOM_OF_SPEECH:\\n\"+ OriginalCHARTER_ENG.FREEDOM_OF_SPEECH);         eng.add(\"OriginalCHARTER_ENG.RIGHTS:\\n\"+ OriginalCHARTER_ENG.RIGHTS);         return eng;     } }","package International_Trade_Union.controllers;  import org.springframework.stereotype.Controller; import org.springframework.ui.Model; import org.springframework.web.bind.annotation.GetMapping; import org.springframework.web.bind.annotation.PostMapping; import org.springframework.web.servlet.mvc.support.RedirectAttributes; import International_Trade_Union.model.CreateAccount;  import java.security.InvalidAlgorithmParameterException; import java.security.NoSuchAlgorithmException; import java.security.NoSuchProviderException; import java.security.spec.InvalidKeySpecException; import java.util.Map;  @Controller public class CreateAccountController {       @GetMapping(\"create-account\")     public String createAccount(Model model) throws InvalidAlgorithmParameterException, NoSuchAlgorithmException, InvalidKeySpecException, NoSuchProviderException {         model.addAttribute(\"title\", \"create minerAccount\");         Map<String, String> newAccount = CreateAccount.create();          model.addAttribute(\"login\", newAccount.get(\"pubKey\"));         model.addAttribute(\"password\", newAccount.get(\"privKey\"));         return \"create-account\";     }     @PostMapping(\"create-account\")     public String createNewAccount(RedirectAttributes redirectAttrs) throws InvalidAlgorithmParameterException, NoSuchAlgorithmException, InvalidKeySpecException, NoSuchProviderException {         redirectAttrs.addFlashAttribute(\"title\", \"create minerAccount\");         Map<String, String> newAccount = CreateAccount.create();          redirectAttrs.addFlashAttribute(\"login\", newAccount.get(\"pubKey\"));         redirectAttrs.addFlashAttribute(\"password\", newAccount.get(\"privKey\"));          return \"redirect:/create-account\";     }  //    @PostMapping(\"save-creating-minerAccount\") //    public String saveNewAccount(Model model, @RequestParam String changeAddress){ //        User.setUserAddress(changeAddress); //        return \"redirect:/\"; //    }    }","package International_Trade_Union.controllers;  import International_Trade_Union.config.BlockchainFactoryEnum; import International_Trade_Union.entity.DtoTransaction.DtoTransaction; import International_Trade_Union.entity.blockchain.Blockchain; import International_Trade_Union.governments.Director; import International_Trade_Union.governments.Directors; import International_Trade_Union.governments.NamePOSITION; import International_Trade_Union.model.FIndPositonHelperData; import International_Trade_Union.model.Mining; import International_Trade_Union.network.AllTransactions; import International_Trade_Union.utils.base.Base; import International_Trade_Union.utils.base.Base58; import org.springframework.stereotype.Controller; import org.springframework.ui.Model; import org.springframework.web.bind.annotation.GetMapping; import International_Trade_Union.governments.UtilsGovernment; import International_Trade_Union.model.Account; import International_Trade_Union.setings.Seting; import International_Trade_Union.utils.*; import International_Trade_Union.vote.*; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RequestMethod; import org.springframework.web.bind.annotation.RequestParam; import org.springframework.web.servlet.mvc.support.RedirectAttributes;  import java.io.IOException; import java.security.*; import java.security.spec.InvalidKeySpecException; import java.util.*; import java.util.stream.Collectors;  @Controller public class GovernmentController {      //TODO если происходит майнинг почему то происходят ошибки, и если вызвать данный метод, то может     //TODO прерываться сам процесс майнинга     //TODO if mining occurs for some reason, errors are observed, and this method appears, then it can     //TODO interrupt the mining process itself     @GetMapping(\"/governments\")     public String corporateSeniorpositions(Model model) throws NoSuchAlgorithmException, InvalidKeySpecException, IOException, SignatureException, NoSuchProviderException, InvalidKeyException {         Blockchain blockchain = Mining.getBlockchain(                 Seting.ORIGINAL_BLOCKCHAIN_FILE,                 BlockchainFactoryEnum.ORIGINAL);          //за сколько времени занимает подсчет         Date start = new Date();         //Получение баланса         Map<String, Account> balances = new HashMap<>();          balances = SaveBalances.readLineObject(Seting.ORIGINAL_BALANCE_FILE);          //Нахождение должности         List<LawEligibleForParliamentaryApproval> allGovernment =                 UtilsLaws.readLineCurrentLaws(Seting.ORIGINAL_ALL_CORPORATION_LAWS_WITH_BALANCE_FILE);          //список должностей         Map<Director, List<LawEligibleForParliamentaryApproval>> positionsListMap = new HashMap<>();          Directors directors = new Directors();         //добавление всех должностей         for (Director higherSpecialPositions : directors.getDirectors()) {             positionsListMap.put(higherSpecialPositions, UtilsLaws.getPossions(allGovernment, higherSpecialPositions));         }          //список акционеров         List<Account> BoardOfShareholders = UtilsGovernment.findBoardOfShareholders(balances, blockchain.getBlockchainList(), Seting.BOARDS_BLOCK);          //список законов с голосами         Map<String, List<CurrentLawVotesEndBalance>> curentLawVotesEndBalance = new HashMap<>();          //TODO доработать оптимизацию         //TODO избавиться от find position в данном методе         Map<Director, FIndPositonHelperData> fIndPositonHelperDataMap = new HashMap<>();         for (Director higherSpecialPositions : directors.getDirectors()) {             if(higherSpecialPositions.isElectedByCEO()){                 fIndPositonHelperDataMap.put(higherSpecialPositions,                         new FIndPositonHelperData(higherSpecialPositions, false, false, true, false, false));             }             else if(higherSpecialPositions.isElectedByBoardOfDirectors()){                 fIndPositonHelperDataMap.put(higherSpecialPositions,                         new FIndPositonHelperData(higherSpecialPositions, false, false, false, true, false));             }             else if(higherSpecialPositions.isElectedByCorporateCouncilOfReferees()){                 fIndPositonHelperDataMap.put(higherSpecialPositions,                         new FIndPositonHelperData(higherSpecialPositions, false, false, false, false, true));             }             else {                 fIndPositonHelperDataMap.put(higherSpecialPositions,                         new FIndPositonHelperData(higherSpecialPositions, true, true, false ,false, false));              }          }          List<CurrentLawVotesEndBalance> current = UtilsGovernment.filtersVotes(                 allGovernment,                 balances,                 BoardOfShareholders,                 blockchain.getBlockchainList(),                 Seting.LAW_YEAR_VOTE);            //минимальное значение количество положительных голосов для того чтобы закон действовал,         //позиции избираемые акциями в совет директоров         List<CurrentLawVotesEndBalance> electedByStockBoardOfDirectors = current.stream()                 .filter(t -> directors.isElectedByStocks(t.getPackageName()))                 .filter(t -> t.getPackageName().equals(NamePOSITION.BOARD_OF_DIRECTORS.toString()))                 .filter(t -> t.getVotes() >= Seting.ORIGINAL_LIMIT_MIN_VOTE)                 .sorted(Comparator.comparing(CurrentLawVotesEndBalance::getVotes).reversed())                 .limit(directors.getDirector(NamePOSITION.BOARD_OF_DIRECTORS.toString()).getCount())                 .collect(Collectors.toList());           //минимальное значение количество положительных голосов для того чтобы закон действовал,         //позиции избираемые акциями electedByStockCorporateCouncilOfReferees         List<CurrentLawVotesEndBalance> electedByStockCorporateCouncilOfReferees = current.stream()                 .filter(t -> directors.isElectedByStocks(t.getPackageName()))                 .filter(t -> t.getPackageName().equals(NamePOSITION.CORPORATE_COUNCIL_OF_REFEREES.toString()))                 .filter(t -> t.getVotes() >= Seting.ORIGINAL_LIMIT_MIN_VOTE)                 .sorted(Comparator.comparing(CurrentLawVotesEndBalance::getVotes).reversed())                 .limit(directors.getDirector(NamePOSITION.CORPORATE_COUNCIL_OF_REFEREES.toString()).getCount())                 .collect(Collectors.toList());            //позиции созданные советом директоров         List<CurrentLawVotesEndBalance> createdByBoardOfDirectors = current.stream()                 .filter(t->t.getPackageName().startsWith(Seting.ADD_DIRECTOR))                 .filter(t->t.getVotesBoardOfDirectors() >= Seting.ORIGINAL_LIMIT_MIN_VOTE_BOARD_OF_DIRECTORS)                 .collect(Collectors.toList());         //добавление позиций созданных советом директоров         for (CurrentLawVotesEndBalance currentLawVotesEndBalance : createdByBoardOfDirectors) {             directors.addAllByBoardOfDirectors(currentLawVotesEndBalance.getLaws());         }          //позиции избираемые  только советом директоров в кабинет директоров         List<CurrentLawVotesEndBalance> electedByBoardOfDirectors = current.stream()                 .filter(t -> directors.isElectedByBoardOfDirectors(t.getPackageName()))                 .filter(t -> t.getVotesBoardOfDirectors() >= Seting.ORIGINAL_LIMIT_MIN_VOTE_BOARD_OF_DIRECTORS)                 .sorted(Comparator.comparing(CurrentLawVotesEndBalance::getVotesBoardOfDirectors).reversed())                 .collect(Collectors.toList());          List<CurrentLawVotesEndBalance> addDirectors = current.stream()                         .filter(t->directors.isCabinets(t.getPackageName()))                                 .filter(t->t.getVotesBoardOfDirectors() >= Seting.ORIGINAL_LIMIT_MIN_VOTE_BOARD_OF_DIRECTORS)                                         .collect(Collectors.toList());          System.out.println(\"***************************************\");         System.out.println(\"GovernmentController: corporateSeniorpositions: elected by Board of Directors;\");         electedByBoardOfDirectors.stream().forEach(System.out::println);         System.out.println(\"***************************************\");          //групируем по списку         Map<String, List<CurrentLawVotesEndBalance>> group = electedByBoardOfDirectors.stream()                 .collect(Collectors.groupingBy(CurrentLawVotesEndBalance::getPackageName));          Map<Director, List<CurrentLawVotesEndBalance>> original_group = new HashMap<>();          //оставляем то количество которое описано в данной должности         for (Map.Entry<String, List<CurrentLawVotesEndBalance>> stringListEntry : group.entrySet()) {             List<CurrentLawVotesEndBalance> temporary = stringListEntry.getValue();             temporary = temporary.stream()                     .sorted(Comparator.comparing(CurrentLawVotesEndBalance::getVotesBoardOfDirectors))                     .limit(directors.getDirector(stringListEntry.getKey()).getCount())                     .collect(Collectors.toList());             original_group.put(directors.getDirector(stringListEntry.getKey()), temporary);         }          //позиции избираемые палатой верховных судей         List<CurrentLawVotesEndBalance> electedByChamberOfSupremeJudges = current.stream()                 .filter(t -> directors.isElectedBYCorporateCouncilOfReferees(t.getPackageName()))                 .filter(t -> t.getVotesCorporateCouncilOfReferees() >= Seting.ORIGINAL_LIMIT_MIN_VOTE_CORPORATE_COUNCIL_OF_REFEREES)                 .sorted(Comparator.comparing(CurrentLawVotesEndBalance::getVotesCorporateCouncilOfReferees)).collect(Collectors.toList());            //избираемые премьер министром         List<CurrentLawVotesEndBalance> GENERAL_EXECUTIVE_DIRECTOR = electedByBoardOfDirectors.stream()                 .filter(t -> directors.isElectedCEO(t.getPackageName()))                 .filter(t -> NamePOSITION.GENERAL_EXECUTIVE_DIRECTOR.toString().equals(t.getPackageName()))                 .filter(t -> t.getVoteGeneralExecutiveDirector() >= Seting.ORIGINAL_LIMIT_MIN_VOTE_GENERAL_EXECUTIVE_DIRECTOR)                 .sorted(Comparator.comparing(CurrentLawVotesEndBalance::getVoteGeneralExecutiveDirector))                 .collect(Collectors.toList());          //избираемые верховным судьей         List<CurrentLawVotesEndBalance> electedByHightJudge = electedByChamberOfSupremeJudges.stream()                 .filter(t -> directors.isElectedBYCorporateCouncilOfReferees(t.getPackageName()))                 .filter(t -> t.getVoteHightJudge() >= Seting.ORIGINAL_LIMIT_MIN_VOTE_HIGHT_JUDGE)                 .collect(Collectors.toList());          curentLawVotesEndBalance.put(\"elected by GENERAL_EXECUTIVE_DIRECTOR: \", GENERAL_EXECUTIVE_DIRECTOR);         curentLawVotesEndBalance.put(\"elected by hight judge: \", electedByHightJudge);         curentLawVotesEndBalance.put(NamePOSITION.BOARD_OF_DIRECTORS.toString(), electedByStockBoardOfDirectors);         curentLawVotesEndBalance.put(NamePOSITION.CORPORATE_COUNCIL_OF_REFEREES.toString(), electedByStockCorporateCouncilOfReferees);         curentLawVotesEndBalance.put(NamePOSITION.HIGH_JUDGE.toString(), electedByChamberOfSupremeJudges);          for (Map.Entry<Director, List<CurrentLawVotesEndBalance>> higherSpecialPositionsListMap : original_group.entrySet()) {             curentLawVotesEndBalance.put(higherSpecialPositionsListMap.getKey().toString(), higherSpecialPositionsListMap.getValue());         }           Date finish = new Date();         System.out.println(\"given time: \" + new Date(finish.getTime() - start.getTime()));          model.addAttribute(\"show\", curentLawVotesEndBalance);          model.addAttribute(\"title\", \"current guidance\");          return \"/governments\";     }      @GetMapping(\"/create-position\")     public String createPositionShow(Model model) throws IOException, NoSuchAlgorithmException, InvalidKeySpecException, SignatureException, NoSuchProviderException, InvalidKeyException {         Blockchain blockchain = Mining.getBlockchain(                 Seting.ORIGINAL_BLOCKCHAIN_FILE,                 BlockchainFactoryEnum.ORIGINAL);         Map<String, Account> balances = new HashMap<>();         //считывать баланс         balances = SaveBalances.readLineObject(Seting.ORIGINAL_BALANCE_FILE);          Directors directors = new Directors();          List<LawEligibleForParliamentaryApproval> lawEligibleForParliamentaryApprovals =                 UtilsLaws.readLineCurrentLaws(Seting.ORIGINAL_ALL_CORPORATION_LAWS_WITH_BALANCE_FILE);           List<Account> boardOfShareholders = UtilsGovernment.findBoardOfShareholders(balances, blockchain.getBlockchainList(), Seting.BOARDS_BLOCK);          List<CurrentLawVotesEndBalance> current = UtilsGovernment.filtersVotes(                 lawEligibleForParliamentaryApprovals,                 balances,                 boardOfShareholders,                 blockchain.getBlockchainList(),                 Seting.LAW_YEAR_VOTE);           List<String> positions = directors.getDirectors().stream().map(t->t.getName()).collect(Collectors.toList());         //позиции созданные советом директоров          List<CurrentLawVotesEndBalance> createdByBoardOfDirectors = current.stream()                 .filter(t->t.getPackageName().startsWith(Seting.ADD_DIRECTOR))                 .filter(t->t.getVotesBoardOfDirectors() >= Seting.ORIGINAL_LIMIT_MIN_VOTE_BOARD_OF_DIRECTORS)                 .collect(Collectors.toList());         //добавление позиций созданных советом директоров         for (CurrentLawVotesEndBalance currentLawVotesEndBalance : createdByBoardOfDirectors) {             directors.addAllByBoardOfDirectors(currentLawVotesEndBalance.getLaws());         }           positions.addAll(directors.getNames());         positions = positions.stream().distinct().collect(Collectors.toList());         model.addAttribute(\"positions\", positions);         return \"create-position\";     }      @RequestMapping(value = \"/create-position\", method = RequestMethod.POST, params = \"action=/send\")     public String createLaw(Model model,                             @RequestParam String sender,                             @RequestParam String reward,                             @RequestParam String nameLaw,                             @RequestParam String[] laws,                             @RequestParam String password,                             RedirectAttributes redirectAttrs) throws IOException, NoSuchAlgorithmException, SignatureException, NoSuchProviderException, InvalidKeyException, InvalidKeySpecException {           Laws law = new Laws(nameLaw, Arrays.asList(laws));         Base base = new Base58();          Double rewardD = Double.parseDouble(reward);           DtoTransaction dtoTransaction = new DtoTransaction(                 sender,                 law.getHashLaw(),                 0.0,                 0.0,                 law,                 rewardD,                 VoteEnum.valueOf(\"YES\"));         PrivateKey privateKey = UtilsSecurity.privateBytToPrivateKey(base.decode(password));         byte[] sign = UtilsSecurity.sign(privateKey, dtoTransaction.toSign());          redirectAttrs.addFlashAttribute(\"title\", \"sending result!!!\");         redirectAttrs.addFlashAttribute(\"sender\", sender);          redirectAttrs.addFlashAttribute(\"recipient\", law.getHashLaw());         redirectAttrs.addFlashAttribute(\"dollar\", 0.0);         redirectAttrs.addFlashAttribute(\"stock\", 0.0);         redirectAttrs.addFlashAttribute(\"reward\", rewardD);         redirectAttrs.addFlashAttribute(\"vote\", \"YES\");         dtoTransaction.setSign(sign);          if (dtoTransaction.verify() && UtilsGovernment.checkPostionSenderEqualsLaw(sender, law)) {             redirectAttrs.addFlashAttribute(\"sending\", \"success\");             AllTransactions.addTransaction(dtoTransaction);             String jsonDto = UtilsJson.objToStringJson(dtoTransaction);              for (String s : Seting.ORIGINAL_ADDRESSES) {                 String original = s;                 String url = s + \"/addTransaction\";                 if (BasisController.getExcludedAddresses().contains(url)) {                     System.out.println(\"its your address or excluded address: \" + url);                     continue;                 }                 try {                     UtilUrl.sendPost(jsonDto, url);                  } catch (Exception e) {                     System.out.println(\"exception discovery: \" + original);                  }             }         } else             redirectAttrs.addFlashAttribute(\"sending\", \"wrong transaction\");          return \"redirect:/result-sending\";      } }","package International_Trade_Union.controllers;  import International_Trade_Union.config.BLockchainFactory; import International_Trade_Union.config.BlockchainFactoryEnum; import International_Trade_Union.entity.blockchain.Blockchain; import International_Trade_Union.entity.blockchain.block.Block; import International_Trade_Union.governments.Director; import International_Trade_Union.governments.Directors; import International_Trade_Union.governments.NamePOSITION; import International_Trade_Union.model.FIndPositonHelperData; import International_Trade_Union.model.Mining; import org.springframework.stereotype.Controller; import org.springframework.ui.Model; import org.springframework.web.bind.annotation.*; import org.springframework.web.servlet.mvc.support.RedirectAttributes; import International_Trade_Union.entity.DtoTransaction.DtoTransaction; import International_Trade_Union.governments.UtilsGovernment; import International_Trade_Union.model.Account; import International_Trade_Union.network.AllTransactions; import International_Trade_Union.setings.Seting; import International_Trade_Union.utils.*; import International_Trade_Union.utils.base.Base; import International_Trade_Union.utils.base.Base58; import International_Trade_Union.vote.*;  import java.io.IOException; import java.security.*; import java.security.spec.InvalidKeySpecException; import java.util.*; import java.util.stream.Collectors;   @Controller public class LawsController {      @GetMapping(\"detail-laws\")     public String details(Model model) {         return \"detail-laws\";     }       @GetMapping(\"/detail-laws-current/{addressLaw}\")     public String lawsDetail(@PathVariable(value = \"addressLaw\") String addressLaw, RedirectAttributes redirectAttrs) throws NoSuchAlgorithmException, InvalidKeySpecException, IOException, SignatureException, NoSuchProviderException, InvalidKeyException {         System.out.println(\"LawsController detail-laws-current/{addressLaw}: \" + addressLaw);         redirectAttrs.addAttribute(\"title\", \"detail laws\");         //Seting.ORIGINAL_CURRENT_FEDERAL_LAWS_FILE         List<LawEligibleForParliamentaryApproval> lawEligibleForParliamentaryApprovals =                 UtilsLaws.readLineCurrentLaws(Seting.ORIGINAL_ALL_CORPORATION_LAWS_WITH_BALANCE_FILE);          List<String> currntLaws = new ArrayList<>();         for (LawEligibleForParliamentaryApproval lawEligibleForParliamentaryApproval : lawEligibleForParliamentaryApprovals) {             int i = 0;             if (lawEligibleForParliamentaryApproval.getLaws().getHashLaw().equals(addressLaw)) {                  for (String str : lawEligibleForParliamentaryApproval.getLaws().getLaws()) {                      currntLaws.add(\"\" + i + \": \" + str);                     ++i;                 }              }         }          currntLaws.forEach(System.out::println);         redirectAttrs.addFlashAttribute(\"laws\", currntLaws);         return \"redirect:/detail-laws\";     }      @GetMapping(\"/detail-laws-all/{addressLaw}\")     public String lawsDetailAll(@PathVariable(value = \"addressLaw\") String addressLaw, RedirectAttributes redirectAttrs) throws NoSuchAlgorithmException, InvalidKeySpecException, IOException, SignatureException, NoSuchProviderException, InvalidKeyException {         System.out.println(\"LawsController /detail-laws-all/{addressLaw}: \" + addressLaw);         redirectAttrs.addAttribute(\"title\", \"detail laws\");         //ORIGINAL_ALL_CORPORATION_LAWS_FILE         List<Laws> laws = UtilsLaws.readLineLaws(Seting.ORIGINAL_ALL_CORPORATION_LAWS_FILE);         List<String> allLaws = new ArrayList<>();         for (Laws laws1 : laws) {             int i = 0;             if (laws1.getHashLaw().equals(addressLaw)) {                  for (String s : laws1.getLaws()) {                     allLaws.add(\"\" + i + \": \" + s);                     ++i;                 }              }         }          redirectAttrs.addFlashAttribute(\"laws\", allLaws);         return \"redirect:/detail-laws\";     }       @GetMapping(\"/current-laws\")     public String currentLaw(Model model) throws IOException, NoSuchAlgorithmException, InvalidKeySpecException, SignatureException, NoSuchProviderException, InvalidKeyException, CloneNotSupportedException {         Directors directors = new Directors();         Blockchain blockchain = Mining.getBlockchain(                 Seting.ORIGINAL_BLOCKCHAIN_FILE,                 BlockchainFactoryEnum.ORIGINAL);          Map<String, Account> balances = new HashMap<>();         //считывать баланс         balances = SaveBalances.readLineObject(Seting.ORIGINAL_BALANCE_FILE);          List<LawEligibleForParliamentaryApproval> lawEligibleForParliamentaryApprovals =                 UtilsLaws.readLineCurrentLaws(Seting.ORIGINAL_ALL_CORPORATION_LAWS_WITH_BALANCE_FILE);           List<Account> boardOfShareholders = UtilsGovernment.findBoardOfShareholders(balances, blockchain.getBlockchainList(), Seting.BOARDS_BLOCK);           //TODO доработать оптимизацию         //TODO избавиться от find position в данном методе         Map<Director, FIndPositonHelperData> fIndPositonHelperDataMap = new HashMap<>();         for (Director higherSpecialPositions : directors.getDirectors()) {             if (higherSpecialPositions.isElectedByCEO()) {                 fIndPositonHelperDataMap.put(higherSpecialPositions,                         new FIndPositonHelperData(higherSpecialPositions, false, false, true, false, false));             } else if (higherSpecialPositions.isElectedByBoardOfDirectors()) {                 fIndPositonHelperDataMap.put(higherSpecialPositions,                         new FIndPositonHelperData(higherSpecialPositions, false, false, false, true, false));             } else if (higherSpecialPositions.isElectedByCorporateCouncilOfReferees()) {                 fIndPositonHelperDataMap.put(higherSpecialPositions,                         new FIndPositonHelperData(higherSpecialPositions, false, false, false, false, true));             } else {                 fIndPositonHelperDataMap.put(higherSpecialPositions,                         new FIndPositonHelperData(higherSpecialPositions, true, true, false, false, false));              }          }         List<CurrentLawVotesEndBalance> current = UtilsGovernment.filtersVotes(                 lawEligibleForParliamentaryApprovals,                 balances,                 boardOfShareholders,                 blockchain.getBlockchainList(),                 Seting.LAW_YEAR_VOTE);             //минимальное значение количество положительных голосов для того чтобы закон действовал,         //позиции избираемые акциями совета директоров         List<CurrentLawVotesEndBalance> electedByStockBoardOfDirectors = current.stream()                 .filter(t -> directors.isElectedByStocks(t.getPackageName()))                 .filter(t -> t.getPackageName().equals(NamePOSITION.BOARD_OF_DIRECTORS.toString()))                 .filter(t -> t.getVotes() >= Seting.ORIGINAL_LIMIT_MIN_VOTE)                 .sorted(Comparator.comparing(CurrentLawVotesEndBalance::getVotes).reversed())                 .limit(directors.getDirector(NamePOSITION.BOARD_OF_DIRECTORS.toString()).getCount())                 .collect(Collectors.toList());           //минимальное значение количество положительных голосов для того чтобы закон действовал,         //позиции избираемые акциями CORPORATE_COUNCIL_OF_REFEREES         List<CurrentLawVotesEndBalance> electedByStockCorporateCouncilOfReferees = current.stream()                 .filter(t -> directors.isElectedByStocks(t.getPackageName()))                 .filter(t -> t.getPackageName().equals(NamePOSITION.CORPORATE_COUNCIL_OF_REFEREES.toString()))                 .filter(t -> t.getVotes() >= Seting.ORIGINAL_LIMIT_MIN_VOTE)                 .sorted(Comparator.comparing(CurrentLawVotesEndBalance::getVotes).reversed())                 .limit(directors.getDirector(NamePOSITION.CORPORATE_COUNCIL_OF_REFEREES.toString()).getCount())                 .collect(Collectors.toList());            //позиции созданные советом директоров         List<CurrentLawVotesEndBalance> createdByBoardOfDirectors = current.stream()                 .filter(t->t.getPackageName().startsWith(Seting.ADD_DIRECTOR))                 .filter(t->t.getVotesBoardOfDirectors() >= Seting.ORIGINAL_LIMIT_MIN_VOTE_BOARD_OF_DIRECTORS)                 .collect(Collectors.toList());         //добавление позиций созданных советом директоров         for (CurrentLawVotesEndBalance currentLawVotesEndBalance : createdByBoardOfDirectors) {             directors.addAllByBoardOfDirectors(currentLawVotesEndBalance.getLaws());         }          //позиции избираемые только советом директоров         List<CurrentLawVotesEndBalance> electedByBoardOfDirectors = current.stream()                 .filter(t -> directors.isElectedByBoardOfDirectors(t.getPackageName()) || directors.isCabinets(t.getPackageName()))                 .filter(t -> t.getVotesBoardOfDirectors() >= Seting.ORIGINAL_LIMIT_MIN_VOTE_BOARD_OF_DIRECTORS)                 .sorted(Comparator.comparing(CurrentLawVotesEndBalance::getVotesBoardOfDirectors).reversed())                 .collect(Collectors.toList());           //групируем по списку         Map<String, List<CurrentLawVotesEndBalance>> group = electedByBoardOfDirectors.stream()                 .collect(Collectors.groupingBy(CurrentLawVotesEndBalance::getPackageName));          Map<Director, List<CurrentLawVotesEndBalance>> original_group = new HashMap<>();          //оставляем то количество которое описано в данной должности         for (Map.Entry<String, List<CurrentLawVotesEndBalance>> stringListEntry : group.entrySet()) {             List<CurrentLawVotesEndBalance> temporary = stringListEntry.getValue();             temporary = temporary.stream()                     .sorted(Comparator.comparing(CurrentLawVotesEndBalance::getVotesBoardOfDirectors))                     .limit(directors.getDirector(stringListEntry.getKey()).getCount())                     .collect(Collectors.toList());             original_group.put(directors.getDirector(stringListEntry.getKey()), temporary);         }            //позиции избираемые советом корпоративных верховных судей         List<CurrentLawVotesEndBalance> electedByCorporateCouncilOfReferees = current.stream()                 .filter(t -> directors.isElectedBYCorporateCouncilOfReferees(t.getPackageName()))                 .filter(t -> t.getVotesCorporateCouncilOfReferees() >= Seting.ORIGINAL_LIMIT_MIN_VOTE_CORPORATE_COUNCIL_OF_REFEREES)                 .sorted(Comparator.comparing(CurrentLawVotesEndBalance::getVotesCorporateCouncilOfReferees)).collect(Collectors.toList());           //избираемые GENERAL_EXECUTIVE_DIRECTOR         List<CurrentLawVotesEndBalance> electedByGeneralExecutiveDirector = electedByBoardOfDirectors.stream()                 .filter(t -> directors.isElectedCEO(t.getPackageName()))                 .filter(t -> NamePOSITION.GENERAL_EXECUTIVE_DIRECTOR.toString().equals(t.getPackageName()))                 .filter(t -> t.getVoteGeneralExecutiveDirector() >= Seting.ORIGINAL_LIMIT_MIN_VOTE_GENERAL_EXECUTIVE_DIRECTOR)                 .sorted(Comparator.comparing(CurrentLawVotesEndBalance::getVoteGeneralExecutiveDirector))                 .collect(Collectors.toList());          //голос верховного судьи         List<CurrentLawVotesEndBalance> electedByHightJudge = electedByCorporateCouncilOfReferees.stream()                 .filter(t -> directors.isElectedBYCorporateCouncilOfReferees(t.getPackageName()))                 .filter(t -> t.getVoteHightJudge() >= Seting.ORIGINAL_LIMIT_MIN_VOTE_HIGHT_JUDGE)                 .collect(Collectors.toList());           //законы которые получили не достаточно голосов которые могут пройти только если верховный судья одобрет         List<CurrentLawVotesEndBalance> notEnoughVotes = current.stream()                 .filter(t -> !directors.contains(t.getPackageName()))                 .filter(t->!Seting.AMENDMENT_TO_THE_CHARTER.equals(t.getPackageName()))                 .filter(t->!directors.isCabinets(t.getPackageName()))                 .filter(t -> !Seting.ORIGINAL_CHARTER_CURRENT_LAW_PACKAGE_NAME.equals(t.getPackageName()))                 .filter(t->!Seting.ORIGINAL_CHARTER_CURRENT_ALL_CODE.equals(t.getPackageName()))                 .filter(t -> t.getVotesBoardOfShareholders() >= Seting.ORIGINAL_LIMIT_MIN_VOTE_BOARD_OF_SHAREHOLDERS)                 .filter(t -> t.getVotesBoardOfDirectors() >= Seting.ORIGINAL_LIMIT_MIN_VOTE_BOARD_OF_DIRECTORS)                 .filter(t -> t.getVoteHightJudge() >= Seting.ORIGINAL_LIMIT_MIN_VOTE_HIGHT_JUDGE)                 .sorted(Comparator.comparing(CurrentLawVotesEndBalance::getVotes).reversed()).collect(Collectors.toList());           //законы которые получили достаточно голосов и не требуют одобрения верховного судьи         List<CurrentLawVotesEndBalance> powerfulVotes = current.stream()                 .filter(t -> !directors.contains(t.getPackageName()))                 .filter(t-> !Seting.AMENDMENT_TO_THE_CHARTER.equals(t.getPackageName()))                 .filter(t-> !directors.isCabinets(t.getPackageName()))                 .filter(t -> !Seting.ORIGINAL_CHARTER_CURRENT_LAW_PACKAGE_NAME.equals(t.getPackageName()))                 .filter(t->!Seting.ORIGINAL_CHARTER_CURRENT_ALL_CODE.equals(t.getPackageName()))                 .filter(t -> t.getVotesBoardOfShareholders() >= (Seting.ORIGINAL_LIMIT_MIN_VOTE_BOARD_OF_SHAREHOLDERS * Seting.POWERFUL_VOTE))                 .filter(t -> t.getVotesBoardOfDirectors() >= (Seting.ORIGINAL_LIMIT_MIN_VOTE_BOARD_OF_DIRECTORS * Seting.POWERFUL_VOTE))                 .sorted(Comparator.comparing(CurrentLawVotesEndBalance::getVotes).reversed()).collect(Collectors.toList());          //удаление совпадающих голосов         notEnoughVotes.addAll(powerfulVotes);         notEnoughVotes = notEnoughVotes.stream().distinct().collect(Collectors.toList());          //внедрение поправок в устав         List<CurrentLawVotesEndBalance> chapter_amendment = current.stream()                 .filter(t -> !directors.contains(t.getPackageName()))                 .filter(t-> Seting.AMENDMENT_TO_THE_CHARTER.equals(t.getPackageName()))                 .filter(t->!directors.isCabinets(t.getPackageName()))                 .filter(t -> t.getVotesBoardOfShareholders() >= Seting.ORIGINAL_LIMIT_MINT_VOTE_BOARD_OF_SHAREHOLDERS_AMENDMENT)                 .filter(t -> t.getVotesBoardOfDirectors() >= Seting.ORIGINAL_LIMIT_MIN_VOTE_BOARD_OF_DIRECTORS_AMENDMENT)                 .filter(t -> t.getVotesCorporateCouncilOfReferees() >= Seting.ORIGINAL_LIMIT_MIN_VOTE_CORPORATE_COUNCIL_OF_REFEREES_AMENDMENT)                 .sorted(Comparator.comparing(CurrentLawVotesEndBalance::getVotesBoardOfDirectors).reversed()).collect(Collectors.toList());          //бюджет утверждается только советом директоров.         List<CurrentLawVotesEndBalance> budjet = current.stream()                 .filter(t-> !directors.contains(t.getPackageName()))                 .filter(t->Seting.BUDGET.equals(t.getPackageName()))                 .filter(t->!directors.isCabinets(t.getPackageName()))                 .filter(t-> t.getVotesBoardOfDirectors() >= Seting.ORIGINAL_LIMIT_MIN_VOTE_BOARD_OF_DIRECTORS)                 .sorted(Comparator.comparing(CurrentLawVotesEndBalance::getVotesBoardOfDirectors).reversed())                 .limit(1)                 .collect(Collectors.toList());           //добавляет законы, которые создают новые должности директоров         List<CurrentLawVotesEndBalance> addDirectors = current.stream()                 .filter(t->t.getPackageName().startsWith(Seting.ADD_DIRECTOR))                 .filter(t->t.getVotesBoardOfDirectors() >= Seting.ORIGINAL_LIMIT_MIN_VOTE_BOARD_OF_DIRECTORS)                 .collect(Collectors.toList());          //план утверждается только палатой Советом Директоров         List<CurrentLawVotesEndBalance> planFourYears = current.stream()                 .filter(t->!directors.contains(t.getPackageName()))                 .filter(t->Seting.STRATEGIC_PLAN.equals(t.getPackageName()))                 .filter(t->!directors.isCabinets(t.getPackageName()))                 .filter(t->t.getVotesBoardOfDirectors() >= Seting.ORIGINAL_LIMIT_MIN_VOTE_BOARD_OF_DIRECTORS)                 .sorted(Comparator.comparing(CurrentLawVotesEndBalance::getVotesBoardOfDirectors).reversed())                 .limit(1)                 .collect(Collectors.toList());           //устав всегда действующий он подписан основателем         List<CurrentLawVotesEndBalance> CHARTER_ORIGINAL = current.stream()                 .filter(t -> !directors.contains(t.getPackageName()) && Seting.ORIGINAL_CHARTER_CURRENT_LAW_PACKAGE_NAME.equals(t.getPackageName()))                 .filter(t->!directors.isCabinets(t.getPackageName()))                 .filter(t->t.getFounderVote()>=1)                 .sorted(Comparator.comparing(CurrentLawVotesEndBalance::getVotes).reversed())                 .limit(1)                 .collect(Collectors.toList());          //ИСХОДНЫЙ КОД СОЗДАННЫЙ ОСНОВАТЕЛЕМ         List<CurrentLawVotesEndBalance> CHARTER_ORIGINAL_CODE = current.stream()                 .filter(t -> !directors.contains(t.getPackageName()) && Seting.ORIGINAL_CHARTER_CURRENT_ALL_CODE.equals(t.getPackageName()))                 .filter(t->!directors.isCabinets(t.getPackageName()))                 .filter(t->t.getFounderVote()>=1)                 .sorted(Comparator.comparing(CurrentLawVotesEndBalance::getVotes).reversed())                 .limit(1)                 .collect(Collectors.toList());           if(blockchain.sizeBlockhain() > 14743){             List<Block> blocksCharter = blockchain.subBlock(14700, 14741);             //учитывает отрезок блоков для выяснения подлиности устава             List<CurrentLawVotesEndBalance> charterBlocks = UtilsGovernment.filtersVotes(                     lawEligibleForParliamentaryApprovals,                     balances,                     boardOfShareholders,                     blocksCharter,                     Seting.LAW_YEAR_VOTE             );             List<CurrentLawVotesEndBalance> charterCheckBlock = charterBlocks.stream()                     .filter(t -> !directors.contains(t.getPackageName()) && Seting.ORIGINAL_CHARTER_CURRENT_LAW_PACKAGE_NAME.equals(t.getPackageName()))                     .filter(t->!directors.isCabinets(t.getPackageName()))                     .filter(t->t.getFounderVote()>=1)                     .sorted(Comparator.comparing(CurrentLawVotesEndBalance::getVotes).reversed())                     .limit(1)                     .collect(Collectors.toList());              CHARTER_ORIGINAL.addAll(charterCheckBlock);               List<CurrentLawVotesEndBalance> charterOriginalCode = charterBlocks.stream()                     .filter(t -> !directors.contains(t.getPackageName()) && Seting.ORIGINAL_CHARTER_CURRENT_ALL_CODE.equals(t.getPackageName()))                     .filter(t->!directors.isCabinets(t.getPackageName()))                     .filter(t->t.getFounderVote()>=1)                     .sorted(Comparator.comparing(CurrentLawVotesEndBalance::getVotes).reversed())                     .limit(1)                     .collect(Collectors.toList());              CHARTER_ORIGINAL_CODE.addAll(charterOriginalCode);         }                    for (Map.Entry<Director, List<CurrentLawVotesEndBalance>> higherSpecialPositionsListMap : original_group.entrySet()) {             current.addAll(higherSpecialPositionsListMap.getValue());         }           current = new ArrayList<>();         current.addAll(addDirectors);         current.addAll(budjet);         current.addAll(planFourYears);         current.addAll(electedByStockBoardOfDirectors);         current.addAll(electedByStockCorporateCouncilOfReferees);         current.addAll(electedByBoardOfDirectors);         current.addAll(electedByCorporateCouncilOfReferees);         current.addAll(electedByGeneralExecutiveDirector);         current.addAll(electedByHightJudge);         current.addAll(notEnoughVotes);         current.addAll(CHARTER_ORIGINAL);         current.addAll(CHARTER_ORIGINAL_CODE);         current.addAll(chapter_amendment);         current = current.stream()                 .filter(UtilsUse.distinctByKey(CurrentLawVotesEndBalance::getAddressLaw))                 .collect(Collectors.toList());         System.out.println(\"notEnoughVotes: \" + notEnoughVotes);          model.addAttribute(\"title\", \"How the current laws are approved are described in the statute.\" +                 \" \");         model.addAttribute(\"currentLaw\", current);         return \"current-laws\";     }      @GetMapping(\"/all-laws\")     public String allLaws(Model model) throws IOException, NoSuchAlgorithmException, InvalidKeySpecException, SignatureException, NoSuchProviderException, InvalidKeyException {         Blockchain blockchain = Mining.getBlockchain(                 Seting.ORIGINAL_BLOCKCHAIN_FILE,                 BlockchainFactoryEnum.ORIGINAL);          Map<String, Account> balances = new HashMap<>();         balances = SaveBalances.readLineObject(Seting.ORIGINAL_BALANCE_FILE);           List<Account> boardOfShareholders = UtilsGovernment.findBoardOfShareholders(balances, blockchain.getBlockchainList(), Seting.BOARDS_BLOCK);           List<LawEligibleForParliamentaryApproval> lawEligibleForParliamentaryApprovals =                 UtilsLaws.readLineCurrentLaws(Seting.ORIGINAL_ALL_CORPORATION_LAWS_WITH_BALANCE_FILE);         //данные для отображения           Directors directors = new Directors();         //TODO доработать оптимизацию         //TODO избавиться от find position в данном методе         //TODO доработать оптимизацию         //TODO избавиться от find position в данном методе         Map<Director, FIndPositonHelperData> fIndPositonHelperDataMap = new HashMap<>();         for (Director higherSpecialPositions : directors.getDirectors()) {             if (higherSpecialPositions.isElectedByCEO()) {                 fIndPositonHelperDataMap.put(higherSpecialPositions,                         new FIndPositonHelperData(higherSpecialPositions, false, false, true, false, false));             } else if (higherSpecialPositions.isElectedByBoardOfDirectors()) {                 fIndPositonHelperDataMap.put(higherSpecialPositions,                         new FIndPositonHelperData(higherSpecialPositions, false, false, false, true, false));             } else if (higherSpecialPositions.isElectedByCorporateCouncilOfReferees()) {                 fIndPositonHelperDataMap.put(higherSpecialPositions,                         new FIndPositonHelperData(higherSpecialPositions, false, false, false, false, true));             } else if (higherSpecialPositions.isElectedByStocks()) {                 fIndPositonHelperDataMap.put(higherSpecialPositions,                         new FIndPositonHelperData(higherSpecialPositions, true, true, false, false, false));              }          }           List<CurrentLawVotesEndBalance> current = UtilsGovernment.filtersVotes(                 lawEligibleForParliamentaryApprovals,                 balances,                 boardOfShareholders,                 blockchain.getBlockchainList(),                 Seting.LAW_YEAR_VOTE);           current = current.stream().distinct().collect(Collectors.toList());          current = current.stream().sorted(Comparator.comparing(CurrentLawVotesEndBalance::getVotes).reversed()).collect(Collectors.toList());         model.addAttribute(\"allLaws\", current);         return \"all-laws\";     }       @GetMapping(\"/create-law\")     public String createLawsShow(Model model) {         return \"create-law\";     }       @RequestMapping(value = \"/create-law\", method = RequestMethod.POST, params = \"action=/send\")     public String createLaw(Model model,                             @RequestParam String sender,                             @RequestParam String reward,                             @RequestParam String nameLaw,                             @RequestParam String[] laws,                             @RequestParam String password,                             RedirectAttributes redirectAttrs) throws IOException, NoSuchAlgorithmException, SignatureException, NoSuchProviderException, InvalidKeyException, InvalidKeySpecException {           Laws law = new Laws(nameLaw, Arrays.asList(laws));         Base base = new Base58();          Double rewardD = Double.parseDouble(reward);           DtoTransaction dtoTransaction = new DtoTransaction(                 sender,                 law.getHashLaw(),                 0.0,                 0.0,                 law,                 rewardD,                 VoteEnum.valueOf(\"YES\"));         PrivateKey privateKey = UtilsSecurity.privateBytToPrivateKey(base.decode(password));         byte[] sign = UtilsSecurity.sign(privateKey, dtoTransaction.toSign());          redirectAttrs.addFlashAttribute(\"title\", \"sending result!!!\");         redirectAttrs.addFlashAttribute(\"sender\", sender);          redirectAttrs.addFlashAttribute(\"recipient\", law.getHashLaw());         redirectAttrs.addFlashAttribute(\"dollar\", 0.0);         redirectAttrs.addFlashAttribute(\"stock\", 0.0);         redirectAttrs.addFlashAttribute(\"reward\", rewardD);         redirectAttrs.addFlashAttribute(\"vote\", \"YES\");         dtoTransaction.setSign(sign);          Directors directors = new Directors();         if (dtoTransaction.verify()) {              //если в названия закона совпадает с корпоративными должностями, то закон является действительным только когда             //отправитель совпадает с законом             List<Director> enumPosition = directors.getDirectors();             List<String> corporateSeniorPositions = enumPosition.stream()                     .map(t->t.getName())                     .collect(Collectors.toList());              if (corporateSeniorPositions.contains(law.getPacketLawName()) && !UtilsGovernment.checkPostionSenderEqualsLaw(sender, law)) {                 redirectAttrs.addFlashAttribute(\"sending\", \"wrong transaction: Position to be equals whith send\");                 return \"redirect:/result-sending\";             }              redirectAttrs.addFlashAttribute(\"sending\", \"success\");             AllTransactions.addTransaction(dtoTransaction);             String jsonDto = UtilsJson.objToStringJson(dtoTransaction);              for (String s : Seting.ORIGINAL_ADDRESSES) {                 String original = s;                 String url = s + \"/addTransaction\";                 if (BasisController.getExcludedAddresses().contains(url)) {                     System.out.println(\"its your address or excluded address: \" + url);                     continue;                 }                 try {                     UtilUrl.sendPost(jsonDto, url);                  } catch (Exception e) {                     System.out.println(\"exception discovery: \" + original);                  }             }         } else             redirectAttrs.addFlashAttribute(\"sending\", \"wrong transaction\");          return \"redirect:/result-sending\";      }  }","package International_Trade_Union.controllers;  import International_Trade_Union.about_us_engDraft.AboutUsEngDraft; import International_Trade_Union.governments.Director; import International_Trade_Union.governments.Directors; import International_Trade_Union.governments.UtilsGovernment; import International_Trade_Union.originalCorporateCharter.OriginalPreamble; import International_Trade_Union.originalCorporateCharter.OriginalPreambleEng; import org.springframework.http.HttpStatus; import org.springframework.http.ResponseEntity; import org.springframework.stereotype.Controller; import org.springframework.ui.Model; import org.springframework.web.bind.annotation.GetMapping; import org.springframework.web.bind.annotation.PostMapping; import org.springframework.web.bind.annotation.RequestParam; import org.springframework.web.servlet.mvc.support.RedirectAttributes; import International_Trade_Union.entity.DtoTransaction.DtoTransaction; import International_Trade_Union.model.Account; import International_Trade_Union.model.User; import International_Trade_Union.network.AllTransactions; import International_Trade_Union.setings.Seting; import International_Trade_Union.utils.*; import International_Trade_Union.utils.base.Base; import International_Trade_Union.utils.base.Base58; import International_Trade_Union.vote.Laws; import International_Trade_Union.vote.VoteEnum;   import java.io.IOException; import java.security.*; import java.security.spec.InvalidKeySpecException; import java.util.*; import java.util.stream.Collectors;  @Controller public class MainController {     @GetMapping(\"/\")     public String home(Model model) throws IOException, NoSuchAlgorithmException, InvalidKeySpecException, SignatureException, NoSuchProviderException, InvalidKeyException {         model.addAttribute(\"title\", \"Corporation International Trade Union.\");         Map<String, Account> balances = new HashMap<>(); //        Blockchain blockchain = BLockchainFactory.getBlockchain(BlockchainFactoryEnum.ORIGINAL);          //догрузить блокчейн //        List<Block> blocks = UtilsBlock.readLineObject(Seting.ORIGINAL_BLOCKCHAIN_FILE); //        balances = UtilsBalance.calculateBalances(blocks);         balances = SaveBalances.readLineObject(Seting.ORIGINAL_BALANCE_FILE);           Account account = UtilsBalance.getBalance(User.getUserAddress(), balances);         model.addAttribute(\"account\", account);          return \"home\";     }      @PostMapping(\"/setMinner\")     public ResponseEntity<String> setMinnerAddress(@RequestParam(value = \"setMinner\") String setMinner, RedirectAttributes redirectAttrs){         System.out.println(\"MainController:  \" + setMinner);         UtilsFileSaveRead.save(setMinner, Seting.ORIGINAL_ACCOUNT, false);         return new ResponseEntity<>(\"change address: \" + setMinner, HttpStatus.OK);     }        @GetMapping(\"about\")     public String aboutUs(Model model){         model.addAttribute(\"title\", \"ABOUT US\");         model.addAttribute(\"eng\", OriginalPreambleEng.ARTICLE_0);         model.addAttribute(\"rus\", OriginalPreamble.ARTICLE_0);         return \"about\";     }     @GetMapping(\"result-sending\")     public String resultSending(Model model){          return \"result-sending\";     }      @PostMapping(\"/\")     public String new_transaction(             @RequestParam  String sender,             @RequestParam  String recipient,                                    Double dollar,                                    Double stock,                                    Double reward,                                   @RequestParam  String vote,                                   @RequestParam  String password,                                   RedirectAttributes redirectAttrs) throws IOException, NoSuchAlgorithmException, SignatureException, InvalidKeySpecException, NoSuchProviderException, InvalidKeyException {         Base base = new Base58();         vote = vote.toUpperCase(Locale.ROOT);         Laws laws =  new Laws();         laws.setLaws(new ArrayList<>());         laws.setHashLaw(\"\");         laws.setPacketLawName(\"\");         DtoTransaction dtoTransaction = new DtoTransaction(                 sender,                 recipient,                 dollar,                 stock,                 laws,                 reward,                 VoteEnum.valueOf(vote));         PrivateKey privateKey = UtilsSecurity.privateBytToPrivateKey(base.decode(password));         byte[] sign = UtilsSecurity.sign(privateKey, dtoTransaction.toSign());         System.out.println(\"Main Controller: new transaction: vote: \" + vote);         redirectAttrs.addFlashAttribute(\"title\", \"sending result!!!\");         redirectAttrs.addFlashAttribute(\"sender\", sender);         redirectAttrs.addFlashAttribute(\"recipient\", recipient);         redirectAttrs.addFlashAttribute(\"dollar\", dollar);         redirectAttrs.addFlashAttribute(\"stock\", stock);         redirectAttrs.addFlashAttribute(\"reward\", reward);         redirectAttrs.addFlashAttribute(\"vote\", vote);         dtoTransaction.setSign(sign);         Directors directors = new Directors();         if(dtoTransaction.verify()){              //если в названия закона совпадает с корпоративными должностями, то закон является действительным только когда             //отправитель совпадает с законом             List<Director> enumPosition = directors.getDirectors();             List<String> corporateSeniorPositions = directors.getDirectors().stream()                     .map(t->t.getName()).collect(Collectors.toList());             System.out.println(\"LawsController: create_law: \" + laws.getPacketLawName() + \"contains: \" + corporateSeniorPositions.contains(laws.getPacketLawName()));             if(corporateSeniorPositions.contains(laws.getPacketLawName()) && !UtilsGovernment.checkPostionSenderEqualsLaw(sender, laws)){                 redirectAttrs.addFlashAttribute(\"sending\", \"wrong transaction: Position to be equals whith send\");                 return \"redirect:/result-sending\";             }             redirectAttrs.addFlashAttribute(\"sending\", \"success\");             System.out.println(\"dto MainController: \" + dtoTransaction);              AllTransactions.addTransaction(dtoTransaction);             String jsonDto = UtilsJson.objToStringJson(dtoTransaction);             for (String s : Seting.ORIGINAL_ADDRESSES) {                  String original = s;                 String url = s +\"/addTransaction\";                 if(BasisController.getExcludedAddresses().contains(url)){                     System.out.println(\"MainController: its your address or excluded address: \" + url);                     continue;                 }                 try {                     UtilUrl.sendPost(jsonDto, url);                  }catch (Exception e){                     System.out.println(\"exception discover: \" + original);                  }             }            }          else             redirectAttrs.addFlashAttribute(\"sending\", \"wrong transaction\");         return \"redirect:/result-sending\";     }   }","package International_Trade_Union.controllers;  import International_Trade_Union.entity.DtoTransaction.DtoTransaction; import International_Trade_Union.network.AllTransactions; import org.springframework.http.MediaType; import org.springframework.web.bind.annotation.RequestBody; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RequestMethod; import org.springframework.web.bind.annotation.RestController;  import java.io.IOException; import java.security.InvalidKeyException; import java.security.NoSuchAlgorithmException; import java.security.NoSuchProviderException; import java.security.SignatureException; import java.security.spec.InvalidKeySpecException;  @RestController public class TransactionController {     @RequestMapping(method = RequestMethod.POST, value = \"/addTransaction\", consumes = MediaType.APPLICATION_JSON_VALUE)     public  void add(@RequestBody DtoTransaction data) throws IOException, NoSuchAlgorithmException, SignatureException, InvalidKeySpecException, NoSuchProviderException, InvalidKeyException {         System.out.println(\"add transaction: \" + data);         AllTransactions.getInstance();         AllTransactions.addTransaction(data);         System.out.println(\"TransactionController: add: \" + AllTransactions.getInstance().size());     }  }","package International_Trade_Union.entity.blockchain.block;  import International_Trade_Union.entity.DtoTransaction.DtoTransaction; import International_Trade_Union.exception.NotValidTransactionException; import International_Trade_Union.utils.UtilsJson; import International_Trade_Union.utils.UtilsUse; import com.fasterxml.jackson.annotation.JsonAutoDetect;  import lombok.Data;  import java.io.IOException; import java.security.InvalidKeyException; import java.security.NoSuchAlgorithmException; import java.security.NoSuchProviderException; import java.security.SignatureException; import java.security.spec.InvalidKeySpecException; import java.sql.Timestamp; import java.util.List; import java.util.Objects;  @JsonAutoDetect @Data public final class Block implements Cloneable {     private List<DtoTransaction> dtoTransactions;     private String previousHash;     private String minerAddress;     private String founderAddress;     private long randomNumberProof;     private double minerRewards;     private int hashCompexity;     private Timestamp timestamp;     private long index;     private String hashBlock;      public Block(List<DtoTransaction> dtoTransactions,  String previousHex, String minerAddress, String founderAddress, int hashCompexity, long index) throws IOException, NoSuchAlgorithmException, SignatureException, NoSuchProviderException, InvalidKeyException, InvalidKeySpecException {         this.dtoTransactions = dtoTransactions;         this.previousHash = previousHex;         this.minerAddress = minerAddress;         this.minerRewards = miningRewardsCount();         this.hashCompexity = hashCompexity;         this.founderAddress = founderAddress;         this.timestamp = new Timestamp(System.currentTimeMillis());         this.index = index;         this.hashBlock = findHash(hashCompexity);      }      public Block(List<DtoTransaction> dtoTransactions, String previousHash, String minerAddress, String founderAddress, long randomNumberProof, double minerRewards, int hashCompexity, Timestamp timestamp, long index, String hashBlock) {         this.dtoTransactions = dtoTransactions;         this.previousHash = previousHash;         this.minerAddress = minerAddress;         this.founderAddress = founderAddress;         this.randomNumberProof = randomNumberProof;         this.minerRewards = minerRewards;         this.hashCompexity = hashCompexity;         this.timestamp = timestamp;         this.index = index;         this.hashBlock = hashBlock;     }      @JsonAutoDetect     @Data     private class BlockForHash{         private List<DtoTransaction> transactions;         private String previousHash;         private String minerAddress;         private String founderAddress;         private long randomNumberProof;         private double minerRewards;         private int hashCompexity;         private Timestamp timestamp;         private long index;           public BlockForHash() {         }           public BlockForHash(List<DtoTransaction> transactions,                             String previousHash,                             String minerAddress,                             String founderAddress,                             long randomNumberProof,                             double minerRewards,                             int hashCompexity,                             Timestamp timestamp,                             long index) {             this.transactions = transactions;             this.previousHash = previousHash;             this.minerAddress = minerAddress;             this.founderAddress = founderAddress;             this.randomNumberProof = randomNumberProof;             this.minerRewards = minerRewards;             this.hashCompexity = hashCompexity;             this.timestamp = timestamp;             this.index = index;          }         private String hashesAllTrans() throws IOException {             String hash = \"\";             for (DtoTransaction dtoTransaction : dtoTransactions) {                 hash += dtoTransaction.hashForBlock();             }              return hash;          }          public String hashForTransaction() throws IOException {             return UtilsUse.sha256hash(jsonString());         }          public String jsonString() throws IOException {             return UtilsJson.objToStringJson(this);         }     }      public Block() {     }      public String hashForBlockchain()             throws             IOException{         return this.hashBlock;     }       public boolean verifyesTransSign() throws IOException, NoSuchAlgorithmException, SignatureException, NoSuchProviderException, InvalidKeyException, InvalidKeySpecException {         for (DtoTransaction dtoTransaction : dtoTransactions) {             if(!dtoTransaction.verify())                 return false;         }         return true;     }      private double miningRewardsCount(){         double rewards = 0.0;         for (DtoTransaction dtoTransaction : dtoTransactions) {              rewards += dtoTransaction.getBonusForMiner();         }          return rewards;     }      public String jsonString() throws IOException {         return UtilsJson.objToStringJson(this);     }     //TODO     public String findHash(int hashCoplexity) throws IOException, NoSuchAlgorithmException, SignatureException, NoSuchProviderException, InvalidKeyException, InvalidKeySpecException {         if (!verifyesTransSign()){             throw new NotValidTransactionException();         }          this.randomNumberProof = 0;         String hash = \"\";         while (true){             this.randomNumberProof++;             BlockForHash block = new BlockForHash(this.dtoTransactions,                     this.previousHash, this.minerAddress, this.founderAddress,                     this.randomNumberProof, this.minerRewards, this.hashCompexity, this.timestamp, this.index);             hash = block.hashForTransaction();             if(UtilsUse.hashComplexity(hash.substring(0, hashCoplexity), hashCoplexity))             {                 break;             }          }         return hash;     }      @Override     public boolean equals(Object o) {           if (this == o) return true;         if (!(o instanceof Block)) return false;         Block block = (Block) o;         return getRandomNumberProof() == block.getRandomNumberProof() && Double.compare(block.getMinerRewards(), getMinerRewards()) == 0 && getHashCompexity() == block.getHashCompexity() && getIndex() == block.getIndex() && Objects.equals(getDtoTransactions(), block.getDtoTransactions()) && Objects.equals(getPreviousHash(), block.getPreviousHash()) && Objects.equals(getMinerAddress(), block.getMinerAddress()) && Objects.equals(getFounderAddress(), block.getFounderAddress()) && Objects.equals(getTimestamp(), block.getTimestamp()) && Objects.equals(getHashBlock(), block.getHashBlock());     }      @Override     public int hashCode() {         return Objects.hash(getDtoTransactions(), getPreviousHash(), getMinerAddress(), getFounderAddress(), getRandomNumberProof(), getMinerRewards(), getHashCompexity(), getTimestamp(), getIndex(), getHashBlock());     }      @Override     public Block clone() throws CloneNotSupportedException {         return new Block(this.dtoTransactions, this.previousHash, this.minerAddress, this.founderAddress,                 this.randomNumberProof, this.minerRewards, this.hashCompexity, this.timestamp, this.index,                 this.hashBlock);     } }","package International_Trade_Union.entity.blockchain;  import International_Trade_Union.entity.DtoTransaction.DtoTransaction; import International_Trade_Union.entity.blockchain.block.Block; import International_Trade_Union.setings.Seting; import International_Trade_Union.utils.UtilsBlock; import International_Trade_Union.utils.UtilsJson; import International_Trade_Union.utils.UtilsSecurity; import International_Trade_Union.utils.UtilsUse; import International_Trade_Union.utils.base.Base; import International_Trade_Union.utils.base.Base58; import International_Trade_Union.vote.Laws; import International_Trade_Union.vote.VoteEnum; import com.fasterxml.jackson.annotation.JsonAutoDetect;  import lombok.Data;  import java.io.IOException; import java.security.*; import java.security.spec.InvalidKeySpecException; import java.util.ArrayList; import java.util.List; import java.util.Objects;   @JsonAutoDetect @Data public class Blockchain implements Cloneable{     private List<Block> blockchainList;     //как часто должно создаваться блок в миллисекундах 1000 миллисекунд = 1 секунд     private long BLOCK_GENERATION_INTERVAL;     //каждые сколько блоков должен происходить перерасчет сложности     private int DIFFICULTY_ADJUSTMENT_INTERVAL;     //блок действителен, если значение блока меньше данного занчения в миллисекунда     private long INTERVAL_TARGET;     private String ADDRESS_FOUNDER;     public int sizeBlockhain(){          return blockchainList.size();     }      public void setBlockchainList(List<Block> blockchainList) throws IOException, NoSuchAlgorithmException, InvalidKeySpecException, SignatureException, NoSuchProviderException, InvalidKeyException {         this.blockchainList = blockchainList;      }      public Blockchain(long BLOCK_GENERATION_INTERVAL, int DIFFICULTY_ADJUSTMENT_INTERVAL, long INTERVAL_TARGET, String ADDRESS_FOUNDER) throws NoSuchAlgorithmException, InvalidKeySpecException, NoSuchProviderException, IOException, SignatureException, InvalidKeyException {         this(new ArrayList<>(), BLOCK_GENERATION_INTERVAL, DIFFICULTY_ADJUSTMENT_INTERVAL, INTERVAL_TARGET, ADDRESS_FOUNDER);      }     public Blockchain(List<Block> blockchainList, long BLOCK_GENERATION_INTERVAL, int DIFFICULTY_ADJUSTMENT_INTERVAL, long INTERVAL_TARGET,String ADDRESS_FOUNDER) throws IOException, NoSuchAlgorithmException, InvalidKeySpecException, SignatureException, NoSuchProviderException, InvalidKeyException {         this.blockchainList = blockchainList;         this.BLOCK_GENERATION_INTERVAL = BLOCK_GENERATION_INTERVAL;         this.DIFFICULTY_ADJUSTMENT_INTERVAL = DIFFICULTY_ADJUSTMENT_INTERVAL;         this.INTERVAL_TARGET = INTERVAL_TARGET;         this.ADDRESS_FOUNDER = ADDRESS_FOUNDER;         Block block = genesisBlock();         addBlock(block);     }      public void addBlock(Block newBlock) throws IOException, NoSuchAlgorithmException, SignatureException, InvalidKeySpecException, NoSuchProviderException, InvalidKeyException { //        if(blockchainList.size() > 2){ //            boolean time = UtilsBlock.isValidTimestamp(blockchainList.get(blockchainList.size()-1), newBlock, INTERVAL_TARGET); //            if(!time){ //                System.out.println(\"time out block add \" + time); //               return; //            } //        }         blockchainList.add(newBlock);       }      public Block genesisBlock() throws IOException, NoSuchAlgorithmException, InvalidKeySpecException, NoSuchProviderException, SignatureException, InvalidKeyException {         Base base = new Base58();         //dto sign         //pub byte keys         //transactions         List<DtoTransaction> transactions = new ArrayList<>();          DtoTransaction gold = new DtoTransaction(Seting.BASIS_ADDRESS, ADDRESS_FOUNDER,                 Seting.FOUNDERS_REMUNERATION_DIGITAL_DOLLAR, Seting.FOUNDERS_REMNUNERATION_DIGITAL_STOCK, new Laws(), 0.0, VoteEnum.YES);         PrivateKey privateKey = UtilsSecurity.privateBytToPrivateKey(base.decode(Seting.BASIS_PASSWORD));         byte[] signGold = UtilsSecurity.sign(privateKey, gold.toSign());         gold.setSign(signGold);         transactions.add(gold);          String genesisHash = genesisPrevHash();         Block block = new Block(transactions,  genesisHash, ADDRESS_FOUNDER, ADDRESS_FOUNDER,  Seting.HASH_COMPLEXITY_GENESIS, blockchainList.size());         return block;     }        public String genesisPrevHash() throws IOException {         return UtilsUse.hashComplexityStr(Seting.CORPORATE_CHARTER_DRAFT, Seting.HASH_COMPLEXITY_GENESIS);     }      public String getHashBlock(int index) throws IOException {         return blockchainList.get(index).hashForBlockchain();     }     public Block getBlock(int index){         return blockchainList.get(index);     }        public boolean validatedBlockchain() throws IOException, NoSuchAlgorithmException, SignatureException, InvalidKeySpecException, NoSuchProviderException, InvalidKeyException {        return UtilsBlock.validation(blockchainList, BLOCK_GENERATION_INTERVAL, DIFFICULTY_ADJUSTMENT_INTERVAL);     }      public String jsonString() throws IOException {         return UtilsJson.objToStringJson(blockchainList);     }     @Override     public boolean equals(Object o) {         if (this == o) return true;         if (!(o instanceof Blockchain)) return false;         Blockchain that = (Blockchain) o;         return getBlockchainList().equals(that.getBlockchainList());     }      @Override     public int hashCode() {         return Objects.hash(getBlockchainList());     }      public  List<Block> subBlock(int startIndex, int finishIndex) throws CloneNotSupportedException {         List<Block> temporary = this.getBlockchainList().subList(startIndex, finishIndex);         List<Block> result = new ArrayList<>();         for (Block block : temporary) {             result.add(block.clone());         }         return result;     }       @Override     public List<Block> clone() throws CloneNotSupportedException {         List<Block> result = new ArrayList<>();         for (Block block : blockchainList) {             result.add(block.clone());         }         return result;      } }","package International_Trade_Union.entity.DtoTransaction;  import org.bouncycastle.jcajce.provider.asymmetric.ec.BCECPublicKey; import International_Trade_Union.setings.Seting; import International_Trade_Union.utils.UtilsJson; import International_Trade_Union.utils.UtilsSecurity; import International_Trade_Union.utils.UtilsUse; import International_Trade_Union.utils.base.Base; import International_Trade_Union.utils.base.Base58; import International_Trade_Union.vote.Laws; import International_Trade_Union.vote.VoteEnum; import com.fasterxml.jackson.annotation.JsonAutoDetect;  import lombok.Data;   import java.io.IOException; import java.security.*; import java.security.spec.InvalidKeySpecException; import java.util.Arrays; import java.util.Objects;   @JsonAutoDetect @Data public class DtoTransaction {     private String sender;     private String customer;     private double digitalDollar;     private double digitalStockBalance;     private Laws laws;     private double bonusForMiner;     private VoteEnum voteEnum;     private byte[] sign;        public DtoTransaction(String sender, String customer, double digitalDollar, double digitalStockBalance, Laws laws, double bonusForMiner, VoteEnum voteEnum) {         this.sender = sender;         this.customer = customer;         this.digitalDollar = digitalDollar;         this.digitalStockBalance = digitalStockBalance;         this.laws = laws;         this.bonusForMiner = bonusForMiner;         this.voteEnum = voteEnum;     }      public DtoTransaction() {     }      //TODO возможно стоит перевести проверку подписи в отдельный utils, под вопросом!!     public boolean verify() throws IOException, NoSuchAlgorithmException, SignatureException, NoSuchProviderException, InvalidKeyException, InvalidKeySpecException {         Base base = new Base58();         byte[] pub = base.decode(sender);         BCECPublicKey publicKey = (BCECPublicKey) UtilsSecurity.decodeKey(pub); //        PublicKey publicKey = UtilsSecurity.publicByteToPublicKey(pub);         String sha = sender + customer + digitalDollar + digitalStockBalance + laws + bonusForMiner;         sha = UtilsUse.sha256hash(sha);         if(sender.isBlank() || customer.isBlank() || digitalDollar < 0 || digitalStockBalance < 0 || bonusForMiner < 0 || laws == null){             System.out.println(\"wrong dto transaction sender or customer blank? or dollar, reputation or reward less then 0\");             return false;         }         if(Seting.BASIS_ADDRESS.equals(publicKey))             return true;         return UtilsSecurity.verify(sha, sign, publicKey);     }      public String toSign(){         String sha = sender + customer + digitalDollar + digitalStockBalance + laws + bonusForMiner;         return UtilsUse.sha256hash(sha);     }      public String hashForBlock() throws IOException {         return UtilsUse.sha256hash(jsonString());     }      public String jsonString() throws IOException {         return UtilsJson.objToStringJson(this);     }      @Override     public boolean equals(Object o) {         if (this == o) return true;         if (!(o instanceof DtoTransaction)) return false;         DtoTransaction that = (DtoTransaction) o;         return Double.compare(that.getDigitalDollar(), getDigitalDollar()) == 0 && Double.compare(that.getDigitalStockBalance(), getDigitalStockBalance()) == 0 && Double.compare(that.getBonusForMiner(), getBonusForMiner()) == 0 && getSender().equals(that.getSender()) && getCustomer().equals(that.getCustomer()) && getLaws().equals(that.getLaws()) && getVoteEnum() == that.getVoteEnum() && Arrays.equals(getSign(), that.getSign());     }      @Override     public int hashCode() {         int result = Objects.hash(getSender(), getCustomer(), getDigitalDollar(), getDigitalStockBalance(), getLaws(), getBonusForMiner(), getVoteEnum());         result = 31 * result + Arrays.hashCode(getSign());         return result;     } }","package International_Trade_Union.entity;  import lombok.Data;  @Data public class AddressUrl {     private String address;      public AddressUrl() {     }      public AddressUrl(String address) {         this.address = address;     } }","package International_Trade_Union.entity;   import lombok.Data; import International_Trade_Union.entity.blockchain.block.Block;  import java.util.List;  @Data public class EntityChain {      private int size;     private List<Block> blocks;      public EntityChain() {     }      public EntityChain(int sizeBlockhain, List<Block> blockchainList) {         this.size = sizeBlockhain;         this.blocks = blockchainList;     } }","package International_Trade_Union.entity;   import lombok.Data; import International_Trade_Union.entity.blockchain.Blockchain; import International_Trade_Union.entity.blockchain.block.Block; import International_Trade_Union.model.Account;  import java.util.List; import java.util.Map;  @Data public class ResultMiningData {     private Map<String, Account> balance;     private Blockchain blockchain;     private Block miningBlock;     private List<Block> lastBlock;     private Account governments;  }","package International_Trade_Union.entity;  import lombok.Data;  @Data public class SubBlockchainEntity {     private int start;     private int finish;      public SubBlockchainEntity(int start, int finish) {         this.start = start;         this.finish = finish;     }      public SubBlockchainEntity() {     } }","package International_Trade_Union.exception;  import java.io.IOException;  public class NotValidTransactionException extends IOException { }","package International_Trade_Union.governments;   import International_Trade_Union.model.Account;  public class CompareObject {      public int compare(Account o1, Account o2) {         double x1 = o1.getDigitalStockBalance();         double x2 = o2.getDigitalStockBalance();         int power = Double.compare(x1, x2);         if (power != 0)             return power;         double gold1 = o1.getDigitalDollarBalance();         double gold2 = o2.getDigitalDollarBalance();         int gold = Double.compare(gold1, gold2);         if(gold != 0)             return gold;         double first = x1 + gold1;         double second = x2 + gold2;         return Double.compare(first, second);     }      @Override     public boolean equals(Object obj) {         return false;     } }","package International_Trade_Union.governments;  import lombok.AllArgsConstructor; import lombok.Data; import lombok.NoArgsConstructor;  import java.util.Arrays; import java.util.List; import java.util.Locale; import java.util.Objects; import java.util.stream.Collectors;  @Data @NoArgsConstructor @AllArgsConstructor public class Director {     //количество юридических или физических лиц в данной должности     //количество юридических или физических лиц в данной должности     private String name;     private  int count;      private boolean electedByCEO;     private boolean electedByBoardOfDirectors;       private boolean electedByCorporateCouncilOfReferees;     private boolean electedByStocks;     private boolean officeOfDirectors;       @Override     public boolean equals(Object o) {         if (this == o) return true;         if (!(o instanceof Director)) return false;         Director director = (Director) o;         return getName().equals(director.getName());     }      @Override     public int hashCode() {         return Objects.hash(getName());     }      public boolean isAppointedByTheGovernment(){         if(electedByCEO || electedByBoardOfDirectors || electedByCorporateCouncilOfReferees)             return true;         else return false;     }     public int getCount() {         return count;     }     }","package International_Trade_Union.governments;  import International_Trade_Union.setings.Seting; import International_Trade_Union.utils.UtilsUse; import lombok.Data;  import java.util.ArrayList; import java.util.List; import java.util.Locale; import java.util.stream.Collectors;  @Data  public class Directors {     public Directors() {          directors = new ArrayList<>();         Director CORPORATE_COUNCIL_OF_REFEREES = new Director(\"CORPORATE_COUNCIL_OF_REFEREES\", 55, false, false, false, true, false);         Director BOARD_OF_DIRECTORS = new Director(\"BOARD_OF_DIRECTORS\", 301, false, false, false, true, false);          Director GENERAL_EXECUTIVE_DIRECTOR = new Director(\"GENERAL_EXECUTIVE_DIRECTOR\", 1, false, true, false, false, true);         Director HIGH_JUDGE = new Director(\"HIGH_JUDGE\",1, false, false, true, false, false);          Director INTERNET_STORE_DIRECTOR = new Director(\"INTERNET_STORE_DIRECTOR\",1, false, true, false, false, true);         Director DIRECTOR_OF_THE_DIGITAL_EXCHANGE = new Director(\"DIRECTOR_OF_THE_DIGITAL_EXCHANGE\",1, false, true, false, false, true);         Director DIRECTOR_OF_DIGITAL_BANK = new Director(\"DIRECTOR_OF_DIGITAL_BANK\",1, false, true, false, false, true);         Director DIRECTOR_OF_THE_COMMERCIAL_COURT = new Director(\"DIRECTOR_OF_THE_COMMERCIAL_COURT\",1, false, true, false, false, true);         Director MEDIA_DIRECTOR = new Director(\"MEDIA_DIRECTOR\",1, false, true, false, false, true);         Director DIRECTOR_OF_THE_DEVELOPMENT_OF_THE_IMPLEMENTATION_OF_CRYPTOCURRENCY_TECHNOLOGIES_OF_THE_INTERNATIONAL_TRADE_UNION_CORPORATION = new Director(\"DIRECTOR_OF_THE_DEVELOPMENT_OF_THE_IMPLEMENTATION_OF_CRYPTOCURRENCY_TECHNOLOGIES_OF_THE_INTERNATIONAL_TRADE_UNION_CORPORATION\",1, false, true, false, false, true);          directors.add(CORPORATE_COUNCIL_OF_REFEREES);         directors.add(BOARD_OF_DIRECTORS);          directors.add(GENERAL_EXECUTIVE_DIRECTOR);         directors.add(HIGH_JUDGE);          directors.add(INTERNET_STORE_DIRECTOR);         directors.add(DIRECTOR_OF_THE_DIGITAL_EXCHANGE);         directors.add(DIRECTOR_OF_DIGITAL_BANK);         directors.add(DIRECTOR_OF_THE_COMMERCIAL_COURT);         directors.add(MEDIA_DIRECTOR);         directors.add(DIRECTOR_OF_THE_DEVELOPMENT_OF_THE_IMPLEMENTATION_OF_CRYPTOCURRENCY_TECHNOLOGIES_OF_THE_INTERNATIONAL_TRADE_UNION_CORPORATION);     }       public Director getDirector(String str){        List<Director> director = directors                .stream()                .filter(t->t.getName().equals(str))                .collect(Collectors.toList());        return director.get(0);      }     private List<Director> directors;      public boolean contains(String str) {         str = str.toUpperCase();         directors = directors.stream().filter(UtilsUse.distinctByKey(Director::getName)).collect(Collectors.toList());         List<String> strings = directors.stream().map(t->t.getName()).collect(Collectors.toList());        return strings.contains(str);     }      public boolean isCabinets(String str) {         List<String> list = directors.stream()                 .filter(t->t.isOfficeOfDirectors())                 .filter(UtilsUse.distinctByKey(Director::getName))                 .map(t->t.getName())                 .collect(Collectors.toList());         return list.contains(str.toUpperCase(Locale.ROOT));     }       //должности которые добавляются только советом директоров     public void addByBoardOfDirectors(String str) {         if (str.startsWith(Seting.ADD_DIRECTOR)) {             Director director = new Director(str, 1, false, true, false, false, true);             directors.add(director);             directors = directors.stream().filter(UtilsUse.distinctByKey(Director::getName)).collect(Collectors.toList());         }      }      public void addAllByBoardOfDirectors(List<String> strings) {         strings = strings.stream()                 .filter(t -> t.startsWith(Seting.ADD_DIRECTOR))                 .distinct()                 .collect(Collectors.toList());         for (String s : strings) {             Director director = new Director(s, 1, false, true, false, false, true);             directors.add(director);         }         directors = directors.stream().filter(UtilsUse.distinctByKey(Director::getName)).collect(Collectors.toList());      }       public List<String> getNames() {         return directors.stream().map(t -> t.getName()).collect(Collectors.toList());     }       public  boolean isElectedByStocks(String str){         List<String> list = directors.stream()                 .filter(t->t.isElectedByStocks())                 .map(t->t.getName())                 .collect(Collectors.toList());          return list.contains(str.toUpperCase(Locale.ROOT));     }     public boolean isElectedCEO(String str){         List<String> list = directors.stream()                 .filter(t->t.isElectedByCEO())                 .map(t->t.getName())                 .collect(Collectors.toList());          return list.contains(str.toUpperCase(Locale.ROOT));     }      public  boolean isElectedByBoardOfDirectors(String  str){         List<String> list = directors.stream()                 .filter(t->t.isElectedByBoardOfDirectors())                 .map(t->t.getName())                 .collect(Collectors.toList());          return list.contains(str.toUpperCase(Locale.ROOT));     }      public boolean isElectedBYCorporateCouncilOfReferees(String  str){         List<String> list = directors.stream()                 .filter(t->t.isElectedByCorporateCouncilOfReferees())                 .map(t->t.getName())                 .collect(Collectors.toList());          return list.contains(str.toUpperCase(Locale.ROOT));     }      public boolean isofficeOfDirectors(String str){         List<String> list = directors.stream()                 .filter(t->t.isOfficeOfDirectors())                 .map(t->t.getName())                 .collect(Collectors.toList());          return list.contains(str.toUpperCase(Locale.ROOT));     } }","package International_Trade_Union.governments;  public enum NamePOSITION {     BOARD_OF_DIRECTORS,     CORPORATE_COUNCIL_OF_REFEREES,     GENERAL_EXECUTIVE_DIRECTOR,     HIGH_JUDGE }","package International_Trade_Union.governments;   import International_Trade_Union.entity.DtoTransaction.DtoTransaction; import International_Trade_Union.entity.blockchain.block.Block; import International_Trade_Union.model.Account; import International_Trade_Union.setings.Seting; import International_Trade_Union.vote.*;  import java.io.IOException; import java.security.InvalidKeyException; import java.security.NoSuchAlgorithmException; import java.security.NoSuchProviderException; import java.security.SignatureException; import java.security.spec.InvalidKeySpecException; import java.util.*; import java.util.stream.Collectors;  public class UtilsGovernment {      //для корпоративных позиций, адресс отправителя должен совпадать с первой строкой закона     public static boolean checkPostionSenderEqualsLaw(String addressSender, Laws laws) {         Directors directors = new Directors();         List<Director> enumPosition = directors.getDirectors();         List<String> corporateSeniorPositions = enumPosition.stream().map(t->t.getName()).collect(Collectors.toList());         if (corporateSeniorPositions.contains(laws.getPacketLawName())) {             if (laws.getLaws().get(0) != null && addressSender.equals(laws.getLaws().get(0))) {                 System.out.println(\"UtilsBogernment: checkPostionSenderEqualsLaw: \" + laws.getLaws().get(0) + \" true:\");                 return true;             } else {                 System.out.println(\"UtilsBogernment: checkPostionSenderEqualsLaw: \" + laws.getLaws().get(0) + \" false:\");                 return false;             }         }         System.out.println(\"UtilsBogernment: checkPostionSenderEqualsLaw: \" + laws.getLaws().get(0) + \" not position:\");         return true;     }       //определение совета акционеров     public static List<Account> findBoardOfShareholders(Map<String, Account> balances, List<Block> blocks, int limit) {         List<Block> minersHaveMoreStock = null;         if (blocks.size() > limit) {             minersHaveMoreStock = blocks.subList(blocks.size() - limit, blocks.size());         } else {             minersHaveMoreStock = blocks;         }         List<Account> boardAccounts = minersHaveMoreStock.stream().map(                         t -> new Account(t.getMinerAddress(), 0, 0))                 .collect(Collectors.toList());          for (Block block : minersHaveMoreStock) {             for (DtoTransaction dtoTransaction : block.getDtoTransactions()) {                 boardAccounts.add(new Account(dtoTransaction.getSender(), 0, 0));             }          }           CompareObject compareObject = new CompareObject();          List<Account> boardOfShareholders = balances.entrySet().stream()                 .filter(t -> boardAccounts.contains(t.getValue()))                 .map(t -> t.getValue()).collect(Collectors.toList());           boardOfShareholders = boardOfShareholders                 .stream()                 .filter(t -> !t.getAccount().startsWith(Seting.NAME_LAW_ADDRESS_START))                 .filter(t -> t.getDigitalStockBalance() > 0)                 .sorted(Comparator.comparing(Account::getDigitalStockBalance).reversed())                 .collect(Collectors.toList());          boardOfShareholders = boardOfShareholders                 .stream()                 .limit(Seting.BOARD_OF_SHAREHOLDERS)                 .collect(Collectors.toList());          return boardOfShareholders;     }       public static List<CurrentLawVotesEndBalance> filtersVotes(             List<LawEligibleForParliamentaryApproval> approvalList,             Map<String, Account> balances,             List<Account> BoardOfShareholders,             List<Block> blocks,             int limitBlocks     ) throws IOException, NoSuchAlgorithmException, SignatureException, InvalidKeySpecException, NoSuchProviderException, InvalidKeyException {         //действующие законы чьи голоса больше ORIGINAL_LIMIT_MIN_VOTE         List<CurrentLawVotesEndBalance> current = new ArrayList<>();         Map<String, CurrentLawVotes> votesMap = null;         List<Account> accounts = balances.entrySet().stream().map(t -> t.getValue()).collect(Collectors.toList());         if (blocks.size() > limitBlocks) {             votesMap = UtilsCurrentLaw.calculateVotes(accounts, blocks.subList(blocks.size() - limitBlocks, blocks.size()));         } else {             votesMap = UtilsCurrentLaw.calculateVotes(accounts, blocks);         }          //подсчитать средннее количество раз сколько он проголосовал за         Map<String, Integer> yesAverage = UtilsCurrentLaw.calculateAverageVotesYes(votesMap);         //подсчитать среднее количество раз сколько он проголосовал против         Map<String, Integer> noAverage = UtilsCurrentLaw.calculateAverageVotesNo(votesMap);           //подсчитываем голоса для для обычных законов и законов позиций         for (LawEligibleForParliamentaryApproval lawEligibleForParliamentaryApproval : approvalList) {             if (votesMap.containsKey(lawEligibleForParliamentaryApproval.getLaws().getHashLaw())) {                 String address = lawEligibleForParliamentaryApproval.getLaws().getHashLaw();                 String packageName = lawEligibleForParliamentaryApproval.getLaws().getPacketLawName();                 List<String> laws = lawEligibleForParliamentaryApproval.getLaws().getLaws();                 double vote = 0;                 int supremeVotes = 0;                 int boafdOfShareholderVotes = 0;                 int houseOfRepresentativiesVotes = 0;                 int primeMinisterVotes = 0;                 int hightJudgesVotes = 0;                 int founderVote = 0;                  //для законов подсчитываем специальные голоса                 vote = votesMap.get(lawEligibleForParliamentaryApproval.getLaws().getHashLaw()).votesLaw(balances, yesAverage, noAverage);                 List<String> boardOfShareholdersAddress = BoardOfShareholders.stream().map(t -> t.getAccount()).collect(Collectors.toList());                 boafdOfShareholderVotes = votesMap.get(lawEligibleForParliamentaryApproval.getLaws().getHashLaw()).voteGovernment(balances, boardOfShareholdersAddress);                  List<String> founder = List.of(Seting.ADDRESS_FOUNDER);                 founderVote = votesMap.get(lawEligibleForParliamentaryApproval.getLaws().getHashLaw()).voteGovernment(balances, founder);                 CurrentLawVotesEndBalance currentLawVotesEndBalance = new CurrentLawVotesEndBalance(                         address,                         packageName,                         vote,                         supremeVotes,                         houseOfRepresentativiesVotes,                         boafdOfShareholderVotes,                         primeMinisterVotes,                         hightJudgesVotes,                         founderVote,                         laws);                 current.add(currentLawVotesEndBalance);              }         }          List<String> houseOfRepresentativies = new ArrayList<>();         List<String> chamberOfSumpremeJudges = new ArrayList<>();          for (CurrentLawVotesEndBalance currentLawVotesEndBalance: current) {             if(currentLawVotesEndBalance.getPackageName().equals(NamePOSITION.BOARD_OF_DIRECTORS.toString())){                 if(currentLawVotesEndBalance.getVotes() >= Seting.ORIGINAL_LIMIT_MIN_VOTE){                      houseOfRepresentativies.add(currentLawVotesEndBalance.getLaws().get(0));                 }              }             if(currentLawVotesEndBalance.getPackageName().equals(NamePOSITION.CORPORATE_COUNCIL_OF_REFEREES.toString())){                 if(currentLawVotesEndBalance.getVotes() >= Seting.ORIGINAL_LIMIT_MIN_VOTE){                     chamberOfSumpremeJudges.add(currentLawVotesEndBalance.getLaws().get(0));                 }              }         }            for (CurrentLawVotesEndBalance currentLawVotesEndBalance : current) {             if(votesMap.containsKey(currentLawVotesEndBalance.getAddressLaw())){                   double vote = votesMap.get(currentLawVotesEndBalance.getAddressLaw()).votesLaw(balances, yesAverage, noAverage);                 int supremeVotes  = votesMap.get(currentLawVotesEndBalance.getAddressLaw()).voteGovernment(balances, chamberOfSumpremeJudges);                 int houseOfRepresentativiesVotes = votesMap.get(currentLawVotesEndBalance.getAddressLaw()).voteGovernment(balances, houseOfRepresentativies);                  currentLawVotesEndBalance.setVotes(vote);                 currentLawVotesEndBalance.setVotesBoardOfDirectors(houseOfRepresentativiesVotes);                 currentLawVotesEndBalance.setVotesCorporateCouncilOfReferees(supremeVotes);             }          }          List<String> primeMinister = new ArrayList<>();         List<String> hightJudge = new ArrayList<>();         for (CurrentLawVotesEndBalance currentLawVotesEndBalance : current) {             if(currentLawVotesEndBalance.getPackageName().equals(NamePOSITION.GENERAL_EXECUTIVE_DIRECTOR.toString())){                 if(currentLawVotesEndBalance.getVotesBoardOfDirectors() >= Seting.ORIGINAL_LIMIT_MIN_VOTE_BOARD_OF_DIRECTORS){                     primeMinister.add(currentLawVotesEndBalance.getLaws().get(0));                 }             }              if(currentLawVotesEndBalance.getPackageName().equals(NamePOSITION.HIGH_JUDGE.toString())){                 if(currentLawVotesEndBalance.getVotesCorporateCouncilOfReferees() >= Seting.ORIGINAL_LIMIT_MIN_VOTE_CORPORATE_COUNCIL_OF_REFEREES){                     hightJudge.add(currentLawVotesEndBalance.getLaws().get(0));                 }             }         }         for (CurrentLawVotesEndBalance currentLawVotesEndBalance : current) {             if(votesMap.containsKey(currentLawVotesEndBalance.getAddressLaw())){                 int primeMinisterVotes = votesMap.get(currentLawVotesEndBalance.getAddressLaw()).voteGovernment(balances, primeMinister);                 int hightJudgeVotes = votesMap.get(currentLawVotesEndBalance.getAddressLaw()).voteGovernment(balances, hightJudge);                  currentLawVotesEndBalance.setVoteGeneralExecutiveDirector(primeMinisterVotes);                 currentLawVotesEndBalance.setVoteHightJudge(hightJudgeVotes);             }          }           return current;      }          //без учета палаты представителей     public static List<CurrentLawVotesEndBalance> filters(List<LawEligibleForParliamentaryApproval> approvalList, Map<String, Account> balances,                                                           List<Account> BoardOfShareholders, List<Block> blocks, int limitBlocks) throws IOException, NoSuchAlgorithmException, InvalidKeySpecException, SignatureException, NoSuchProviderException, InvalidKeyException {         //действующие законы чьи голоса больше ORIGINAL_LIMIT_MIN_VOTE         List<CurrentLawVotesEndBalance> current = new ArrayList<>();         Map<String, CurrentLawVotes> votesMap = null;         List<Account> accounts = balances.entrySet().stream().map(t -> t.getValue()).collect(Collectors.toList());         if (blocks.size() > limitBlocks) {             votesMap = UtilsCurrentLaw.calculateVotes(accounts, blocks.subList(blocks.size() - limitBlocks, blocks.size()));         } else {             votesMap = UtilsCurrentLaw.calculateVotes(accounts, blocks);         }          //подсчитать средннее количество раз сколько он проголосовал за         Map<String, Integer> yesAverage = UtilsCurrentLaw.calculateAverageVotesYes(votesMap);         //подсчитать среднее количество раз сколько он проголосовал против         Map<String, Integer> noAverage = UtilsCurrentLaw.calculateAverageVotesNo(votesMap);          for (LawEligibleForParliamentaryApproval lawEligibleForParliamentaryApproval : approvalList) {             if (votesMap.containsKey(lawEligibleForParliamentaryApproval.getLaws().getHashLaw())) {                 String address = lawEligibleForParliamentaryApproval.getLaws().getHashLaw();                 String packageName = lawEligibleForParliamentaryApproval.getLaws().getPacketLawName();                 List<String> laws = lawEligibleForParliamentaryApproval.getLaws().getLaws();                 double vote = votesMap.get(lawEligibleForParliamentaryApproval.getLaws().getHashLaw()).votes(balances, yesAverage, noAverage);                  CurrentLawVotesEndBalance currentLawVotesEndBalance = new CurrentLawVotesEndBalance(address, packageName, vote, 0, 0, 0, 0, 0, 0,  laws);                 current.add(currentLawVotesEndBalance);              }         }         return current;     }   }","package International_Trade_Union.model;   import lombok.Data; import International_Trade_Union.entity.DtoTransaction.DtoTransaction; import International_Trade_Union.utils.UtilsSecurity; import International_Trade_Union.utils.base.Base; import International_Trade_Union.utils.base.Base58; import International_Trade_Union.vote.Laws; import International_Trade_Union.vote.VoteEnum;  import java.io.IOException; import java.security.*; import java.security.spec.InvalidKeySpecException; import java.util.Objects;   @Data public class Account {     private String account;     private double digitalDollarBalance;     private double digitalStockBalance;       public Account(String account, double digitalDollarBalance) {         this(account, digitalDollarBalance, 0.0);      }      public Account(String account, double digitalDollarBalance, double digitalStockBalance) {         this.account = account;         this.digitalDollarBalance = digitalDollarBalance;         this.digitalStockBalance = digitalStockBalance;     }      public Account() {     }      @Override     public boolean equals(Object o) {         if (this == o) return true;         if (!(o instanceof Account)) return false;         Account account1 = (Account) o;         return getAccount().equals(account1.getAccount());     }      @Override     public int hashCode() {         return Objects.hash(getAccount());     }      private DtoTransaction sendMoney(String recipient, String privatekey, double digitalDollar, double digitalStock, Laws laws, double minerRewards, VoteEnum voteEnum) throws NoSuchAlgorithmException, InvalidKeySpecException, NoSuchProviderException, SignatureException, IOException, InvalidKeyException {          DtoTransaction transaction = null;         if (account.equals(recipient)){             System.out.println(\"sender %s, recipient %s cannot be equals! Error!\".format(account,recipient));             return transaction;         }              if(digitalDollarBalance < digitalDollar + minerRewards  ){                 System.out.println(\"sender don't have digitalDollar\");                 return transaction;             }             if(digitalStockBalance < digitalStock){                 System.out.println(\"sender don't have digitalReputation\");                 return transaction;             }             else{                 Base base = new Base58();                 PrivateKey privateKey = UtilsSecurity.privateBytToPrivateKey(base.decode(privatekey));                  transaction = new DtoTransaction(this.getAccount(), recipient, digitalDollar, digitalStock, laws, minerRewards, voteEnum);                 byte[] signGold = UtilsSecurity.sign(privateKey, transaction.toSign());                 transaction.setSign(signGold);             }         return transaction;     }  //      recipient - получатель //      gold сумма отправки, last Block - это послдний блок.     public DtoTransaction send(String recipient, String privateKey, double digitalDollar, double digitalReputation, Laws laws,  double minerRewards, VoteEnum voteEnum) throws NoSuchAlgorithmException, InvalidKeySpecException, SignatureException, IOException, NoSuchProviderException, InvalidKeyException {          return sendMoney(recipient,privateKey, digitalDollar, digitalReputation, laws, minerRewards, voteEnum);     }      }","package International_Trade_Union.model;  import International_Trade_Union.utils.UtilsSecurity; import International_Trade_Union.utils.base.Base; import International_Trade_Union.utils.base.Base58;  import java.security.InvalidAlgorithmParameterException; import java.security.NoSuchAlgorithmException; import java.security.NoSuchProviderException; import java.security.spec.InvalidKeySpecException; import java.util.HashMap; import java.util.Map;  public class CreateAccount {     public static Map<String, String> create() throws InvalidAlgorithmParameterException, NoSuchAlgorithmException, InvalidKeySpecException, NoSuchProviderException {         Map<String, String> create = new HashMap<>();         Base base = new Base58();         Keys keyPair = UtilsSecurity.generateKeyPair();         String pubkey = keyPair.getPubkey();         String privKey = keyPair.getPrivkey();         System.out.println(\"pubkey: \" + pubkey);         System.out.println(\"privKey: \" + privKey);         create.put(\"pubKey\", pubkey);         create.put(\"privKey\", privKey);         return create;     } }","package International_Trade_Union.model;  import International_Trade_Union.governments.Director; import lombok.AllArgsConstructor; import lombok.Data; import lombok.NoArgsConstructor;  @Data @AllArgsConstructor @NoArgsConstructor public class FIndPositonHelperData {     Director addressPosition;     boolean withLimited;     boolean electedWithStock;     boolean electedWithPrimeMinister;     boolean electedWithHousOfRepresentativies;     boolean electedWithChamberOfHightJudjes;  }","package International_Trade_Union.model;  import lombok.Data;  @Data public class Keys {     private String pubkey;     private String privkey;      public Keys(String pubkey, String privkey) {         this.pubkey = pubkey;         this.privkey = privkey;     } }","package International_Trade_Union.model;    import International_Trade_Union.config.BLockchainFactory; import International_Trade_Union.config.BlockchainFactoryEnum; import International_Trade_Union.entity.DtoTransaction.DtoTransaction; import International_Trade_Union.entity.blockchain.Blockchain; import International_Trade_Union.entity.blockchain.block.Block; import International_Trade_Union.governments.Director; import International_Trade_Union.governments.Directors; import International_Trade_Union.governments.UtilsGovernment; import International_Trade_Union.setings.Seting; import International_Trade_Union.utils.base.Base; import International_Trade_Union.utils.base.Base58; import International_Trade_Union.vote.Laws; import International_Trade_Union.vote.VoteEnum; import International_Trade_Union.utils.*;  import java.io.File; import java.io.IOException; import java.security.*; import java.security.spec.InvalidKeySpecException; import java.util.*; import java.util.stream.Collectors;  public class Mining {      public static Blockchain getBlockchain(String filename, BlockchainFactoryEnum factoryEnum) throws IOException, NoSuchAlgorithmException, InvalidKeySpecException, SignatureException, NoSuchProviderException, InvalidKeyException {          List<Block> blocks = UtilsBlock.readLineObject(filename);         Blockchain blockchain = null;         blockchain = BLockchainFactory.getBlockchain(factoryEnum);          if (blocks.size() != 0) {            blockchain.setBlockchainList(blocks);         }         return blockchain;     }      public static Map<String, Account> getBalances(String filename, Blockchain blockchain, Map<String, Account> balances) throws IOException, NoSuchAlgorithmException, SignatureException, InvalidKeySpecException, NoSuchProviderException, InvalidKeyException {         //start test           //папка чтобы проверить есть ли         File folder = new File(filename);         List<String> files = new ArrayList<>();         for (File file : folder.listFiles()) {             if(!file.isDirectory()){                 files.add(file.getAbsolutePath());             }         }          if (files.size() > 0 ){             File file = new File(files.get(files.size()-1));             if(file.exists() && file.length() > 0){                 balances = SaveBalances.readLineObject(filename);             }          }          if (balances == null) {             balances = new HashMap<>();         }          Block block;         if(blockchain != null && blockchain.sizeBlockhain() > 0){             block = blockchain.getBlock(blockchain.sizeBlockhain() - 1);             balances = UtilsBalance.calculateBalance(balances, block);           }           return balances;     }      public static void deleteFiles(String fileDelit) {         UtilsFileSaveRead.deleteAllFiles(fileDelit);     }       public static Block miningDay(             Account minner,             String filename,             Blockchain blockchain,             long blockGenerationInterval,             int DIFFICULTY_ADJUSTMENT_INTERVAL,             List<DtoTransaction> transactionList,             Map<String, Account> balances,             long index     ) throws IOException, NoSuchAlgorithmException, SignatureException, InvalidKeySpecException, NoSuchProviderException, InvalidKeyException {         Directors directors = new Directors();         //получение транзакций с сети         List<DtoTransaction> listTransactions = transactionList;          //определение валидных транзакций         List<DtoTransaction> forAdd = new ArrayList<>();          cicle:         for (DtoTransaction transaction : listTransactions) {             if (transaction.verify()) {                  Account account = balances.get(transaction.getSender());                 if (account == null) {                     System.out.println(\"minerAccount null\");                     continue cicle;                 }                 if(transaction.getCustomer().startsWith(Seting.NAME_LAW_ADDRESS_START) && !balances.containsKey(transaction.getCustomer())){                     //если в названия закона совпадает с корпоративными должностями, то закон является действительным только когда                     //отправитель совпадает с законом                     List<Director> enumPosition = directors.getDirectors();                     List<String> corporateSeniorPositions = directors.getDirectors().stream()                             .map(t->t.getName()).collect(Collectors.toList());                     System.out.println(\"LawsController: create_law: \" + transaction.getLaws().getPacketLawName()                             + \"contains: \" + corporateSeniorPositions.contains(transaction.getLaws().getPacketLawName()));                     if(corporateSeniorPositions.contains(transaction.getLaws().getPacketLawName())                             && !UtilsGovernment.checkPostionSenderEqualsLaw(transaction.getSender(), transaction.getLaws())){                         System.out.println(\"if your create special corporate position, you need \" +                                 \"sender to be equals with first law: now its wrong\");                         continue cicle;                     }                 }                 if(transaction.getLaws() == null){                     System.out.println(\"law cannot to be null: \");                     continue cicle;                 }                  if (account != null) {                     if(transaction.getSender().equals(Seting.BASIS_ADDRESS)){                         System.out.println(\"only this miner can input basis adress in this block\");                         continue cicle;                     }                     if(transaction.getCustomer().equals(Seting.BASIS_ADDRESS)){                         System.out.println(\"basis address canot to be customer(recipient)\");                         continue cicle;                     }                      if( account.getDigitalDollarBalance() < transaction.getDigitalDollar() + transaction.getBonusForMiner()){                         System.out.println(\"sender don't have digital dollar: \" + account.getAccount() + \" balance: \" + account.getDigitalDollarBalance() );                         System.out.println(\"digital dollar for send: \" + (transaction.getDigitalDollar() + transaction.getBonusForMiner()));                         continue cicle;                     }                     if (account.getDigitalStockBalance() < transaction.getDigitalStockBalance()){                         System.out.println(\"sender don't have digital reputation: \" + account.getAccount() + \" balance: \" + account.getDigitalStockBalance());                         System.out.println(\"digital reputation for send: \" + (transaction.getDigitalDollar() + transaction.getBonusForMiner()));                         continue cicle;                     }                     if(transaction.getSender().equals(transaction.getCustomer()) ){                         System.out.println(\"sender end recipient equals \" + transaction.getSender() + \" : recipient: \" + transaction.getCustomer());                         continue cicle;                     }                     forAdd.add(transaction);                 }              }         }           //доход майнера         double minerRewards = Seting.DIGITAL_DOLLAR_REWARDS_BEFORE;         double digitalReputationForMiner = Seting.DIGITAL_STOCK_REWARDS_BEFORE;          //доход основателя         double founderReward = Seting.DIGITAL_DOLLAR_FOUNDER_REWARDS_BEFORE;         double founderDigigtalReputationReward = Seting.DIGITAL_REPUTATION_FOUNDER_REWARDS_BEFORE;          Base base = new Base58();          //суммирует все вознаграждения майнеров         PrivateKey privateKey = UtilsSecurity.privateBytToPrivateKey(base.decode(Seting.BASIS_PASSWORD));         double sumRewards = forAdd.stream().collect(Collectors.summingDouble(DtoTransaction::getBonusForMiner));          //вознаграждения майнера         DtoTransaction minerRew = new DtoTransaction(Seting.BASIS_ADDRESS, minner.getAccount(),                 minerRewards, digitalReputationForMiner, new Laws(), sumRewards, VoteEnum.YES );          byte[] signGold = UtilsSecurity.sign(privateKey, minerRew.toSign());         minerRew.setSign(signGold);          //вознаграждение основателя         DtoTransaction founderRew = new DtoTransaction(Seting.BASIS_ADDRESS, blockchain.getADDRESS_FOUNDER(),                 founderReward, founderDigigtalReputationReward, new Laws(), 0.0, VoteEnum.YES);         byte[] signFounder = UtilsSecurity.sign(privateKey, founderRew.toSign());          founderRew.setSign(signFounder);           forAdd.add(minerRew);         forAdd.add(founderRew);           //определение сложности и создание блока          int difficulty = UtilsBlock.difficulty(blockchain.getBlockchainList(), blockGenerationInterval, DIFFICULTY_ADJUSTMENT_INTERVAL);          System.out.println(\"Mining: miningBlock: difficulty: \" + difficulty + \" index: \" + index);           //blockchain.getHashBlock(blockchain.sizeBlockhain() - 1)         Block block = new Block(                 forAdd,                 blockchain.getHashBlock(blockchain.sizeBlockhain() - 1),                 minner.getAccount(),                 blockchain.getADDRESS_FOUNDER(),                 difficulty,                 index);          return block;     } }","package International_Trade_Union.model;  import International_Trade_Union.setings.Seting; import International_Trade_Union.utils.UtilsFileSaveRead;  import java.io.FileNotFoundException;   public class User {     private static String addressMiner=\"\";      public static void setUserAddress(String addressMiner) { //        System.out.println(\"change minerAccount: \" + addressMiner); //        UtilsFileSaveRead.save(addressMiner, Seting.ORIGINAL_ACCOUNT, false);         User.addressMiner = addressMiner;     }      public static String getUserAddress() throws FileNotFoundException {         addressMiner = UtilsFileSaveRead.read(Seting.ORIGINAL_ACCOUNT);         System.out.println(\"user: \" + addressMiner);         if(addressMiner.isEmpty() || addressMiner == null)             addressMiner = \"empty \";         return addressMiner;     } }","package International_Trade_Union.network;  import International_Trade_Union.entity.DtoTransaction.DtoTransaction; import International_Trade_Union.model.Mining; import International_Trade_Union.setings.Seting; import International_Trade_Union.utils.*; import org.json.JSONException;  import java.io.File; import java.io.IOException; import java.security.InvalidKeyException; import java.security.NoSuchAlgorithmException; import java.security.NoSuchProviderException; import java.security.SignatureException; import java.security.spec.InvalidKeySpecException; import java.util.ArrayList; import java.util.List; import java.util.stream.Collectors;  public class AllTransactions {     private static List<DtoTransaction> instance = new ArrayList<>();     //все транзакции которые уже добавлены в блок, нужно чтобы повторно     //не добавлялись в блок если они скачены с дисковери.     private static List<DtoTransaction> sendedTransaction = new ArrayList<>();      public static List<DtoTransaction> readFrom() throws IOException, NoSuchAlgorithmException, InvalidKeySpecException, SignatureException, NoSuchProviderException, InvalidKeyException {         return UtilsTransaction.readLineObject(Seting.ORGINAL_ALL_TRANSACTION_FILE);     }      public static synchronized List<DtoTransaction> getInstance() throws IOException, NoSuchAlgorithmException, InvalidKeySpecException, SignatureException, NoSuchProviderException, InvalidKeyException {         if (instance == null) {             instance = new ArrayList<>();         }         instance = new ArrayList<>();          //считываем с пула транзакции из дисковери.         for (String s : Seting.ORIGINAL_ADDRESSES) {             try {                 String json = UtilUrl.readJsonFromUrl(s + \"/getTransactions\");                 List<DtoTransaction> list = UtilsJson.jsonToDtoTransactionList(json);                  instance.addAll(list);               } catch (IOException | JSONException e) {                  System.out.println(\"AllTransaction: getInstance: Error\");                 continue;             }           }          instance.addAll(UtilsTransaction.readLineObject(Seting.ORGINAL_ALL_TRANSACTION_FILE));         instance = instance.stream().distinct().collect(Collectors.toList());          sendedTransaction = getInsanceSended();          instance.removeAll(sendedTransaction);         return instance;     }      public static synchronized void clearAllTransaction() {         instance = new ArrayList<>();         Mining.deleteFiles(Seting.ORGINAL_ALL_TRANSACTION_FILE);     }      public static synchronized void clearAllSendedTransaction(long index) {         if(index % (Seting.COUNT_BLOCK_IN_DAY * Seting.DAY_DELETED_SENDED_FILE) == 0){             sendedTransaction = new ArrayList<>();             Mining.deleteFiles(Seting.ORIGINAL_ALL_SENDED_TRANSACTION_FILE);             System.out.println(\"clear delete sended transaction\");         }      }      public static synchronized void clearUsedTransaction(List<DtoTransaction> transactions) throws IOException, NoSuchAlgorithmException, SignatureException, InvalidKeySpecException, NoSuchProviderException, InvalidKeyException {         instance = getInstance();         List<DtoTransaction> temporaryDto = new ArrayList<>();          instance = temporaryDto;         instance.removeAll(transactions);         Mining.deleteFiles(Seting.ORGINAL_ALL_TRANSACTION_FILE);         for (DtoTransaction dtoTransaction : instance) {              UtilsTransaction.saveAllTransaction(dtoTransaction, Seting.ORGINAL_ALL_TRANSACTION_FILE);         }       }      public static synchronized void addTransaction(DtoTransaction transaction) throws IOException, NoSuchAlgorithmException, SignatureException, InvalidKeySpecException, NoSuchProviderException, InvalidKeyException {          instance = getInstance();         instance.add(transaction);         Mining.deleteFiles(Seting.ORGINAL_ALL_TRANSACTION_FILE);         instance = instance.stream().filter(UtilsUse.distinctByKey(DtoTransaction::toSign)).collect(Collectors.toList());         for (DtoTransaction dtoTransaction : instance) {             UtilsTransaction.saveAllTransaction(dtoTransaction, Seting.ORGINAL_ALL_TRANSACTION_FILE);         }       }      public static synchronized void addSendedTransaction(List<DtoTransaction> transactions) throws IOException, NoSuchAlgorithmException, InvalidKeySpecException, SignatureException, NoSuchProviderException, InvalidKeyException {         sendedTransaction = getInsanceSended();         sendedTransaction.addAll(transactions);          Mining.deleteFiles(Seting.ORIGINAL_ALL_SENDED_TRANSACTION_FILE);         for (DtoTransaction dtoTransaction : sendedTransaction) {             UtilsTransaction.saveAllTransaction(dtoTransaction, Seting.ORIGINAL_ALL_SENDED_TRANSACTION_FILE);         }          System.out.println(\"AllTransaction: addSendedTransaction: \" + sendedTransaction.size());      }      public static List<DtoTransaction> getInsanceSended() throws IOException, NoSuchAlgorithmException, InvalidKeySpecException, SignatureException, NoSuchProviderException, InvalidKeyException {         if (sendedTransaction == null) {             sendedTransaction = new ArrayList<>();         }         sendedTransaction = UtilsTransaction.readLineObject(Seting.ORIGINAL_ALL_SENDED_TRANSACTION_FILE);         sendedTransaction = sendedTransaction.stream().distinct().collect(Collectors.toList());         return sendedTransaction;     }  }","package International_Trade_Union.network;    import International_Trade_Union.entity.DtoTransaction.DtoTransaction;  import java.util.ArrayList; import java.util.List;  public class Transactions {     public  List<DtoTransaction> getTransactions() {         List<DtoTransaction> transactions = new ArrayList<>();         return transactions;     } }","package International_Trade_Union.node;  import java.util.HashSet; import java.util.Set;  public class Nodes {      public int size(){         return urlAddress.size();     }      public Nodes() {         this.urlAddress = new HashSet<>();     }      public Nodes(Set<String> urlAddress) {         this.urlAddress = urlAddress;     }      private  Set<String> urlAddress = new HashSet<>();      public  void setUrlAddress(Set<String> urlAddress) {         this.urlAddress = urlAddress;     }     public void addAddress(String addressUrl){         urlAddress.add(addressUrl);     }      public  Set<String> getUrlAddresses() {         return urlAddress;     }      public void clear(){         urlAddress = new HashSet<>();     } }","package International_Trade_Union.CorporateCharterDraft;  /**устарел(недействителен), является черновиком, но его хеш используется в генезис блоке.  Но с помощью новых законов можно добавить те части которые будут интересны и сделать их действительным законом, если  данные части не противоречат действующему уставу и действующим законам.  */ public interface ArticleFiveCharterSupremacyDraft {     String CHAPTER_1 = \"Все долги и обязательства, заключенные до принятия настоящего Устава, будут иметь такую\" +             \"же силу в отношении тех членов которые присоединились к \" +             \" Международному Торговому Союзу в соответствии с настоящим Уставом, как и прежде.\" +             \"Настоящий Устав и действующие законы Корпорации Международного Торгового Союза, которые должны быть приняты во исполнение ее;\" +             \" и все договоры, заключенные или которые будут заключены под властью Корпорации Международного Торгового Союза,\" +             \" являются высшим законом Корпорации Международного Торгового Союза;\" +             \" и судьи на територии принадлежащей членам Корпорации Международного Торгового Союза должны быть связаны этим, несмотря \" +             \"ни на что в\" +             \" правилах или законах любого члена об обратном.\\n\" +             \"\\n\" +             \" но никакие религиозные испытания никогда не должны требоваться в качестве квалификации для какой-либо должности \" +             \"или Корпоративного фонда в Корпорацию Международного Торгового Союза.\";      String CONSTITUTIONAL_SUPERMACY = \"Ратификация Данного Устава происходит сразу как избраны триста и более членов Совета Акционеров,\"; }","package International_Trade_Union.CorporateCharterDraft; /**устарел(недействителен), является черновиком, но его хеш используется в генезис блоке.  Но с помощью новых законов можно добавить те части которые будут интересны и сделать их действительным законом, если  данные части не противоречат действующему уставу и действующим законам.  */ public interface ArticleFourAmendmentProcessDraft {      String CHAPTER_1 = \"Любые поправки можно вводить только после пяти лет с момента основания данной криптовалюты (начало 20.Января.2023).\" +             \"Всякий раз, две третьи Совета Ационеров проголосовало, но при условии что будет создан действующий закон за пол года\" +             \" до введения поправок и там будет описано как будет происходить внесения поправок и какие поправки предлагается вносить,\" +             \" но если закон не был действительным на момент\" +             \"начала даты голосования поправок, то поправки не имеют силы. \" +             \" сочтут это необходимым, они могут предложить поправки к настоящему Уставу, которые в любом случае будут иметь силу\" +             \" во всех смыслах и целях, как часть настоящему Уставу, когда Верховный судья Корпорации Международного Торгового Союза\" +             \" удостоверяет, что она ратифицирована действующим Советом Акционеров.\" +             \" при условии, что ни один член действующего Совета Акционеров без его согласия не может быть лишен равного \" +             \" избирательного права (один счет члена Совета Акционеров, один голос.) Также поправки не должны ограничивать права (Статья 7)граждан или\" +             \"всех членов Корпорации Международного Торгового Союза. Голосование должно быть реализовано через данную платформу,\" +             \" время на голосование должно быть отведено шесть месяцев. (Сначала нужно реализовать механизм голосования внутри данной сети, я не смог реализовать,\" +             \"чтобы все акционеры имели право голоса. Так что реализуйте данную часть сами. )\" +             \"\" +             \"Разрешается вводить любые улучшения в код данной системы, если это утверждено действующим законом, без поправок в устав\" +             \" при условии если эти изменения не нарушают\" +             \"Устав данной корпорации и не изменяют сам устав, а также соблюдают устав и действующие законы. А также действующие \" +             \"правила для разработки законов и создания должностных лиц, включая отрицательную ставку и другие \" +             \"правила описанные в данном уставе.\"; }","package International_Trade_Union.CorporateCharterDraft; /**устарел(недействителен), является черновиком, но его хеш используется в генезис блоке.  Но с помощью новых законов можно добавить те части которые будут интересны и сделать их действительным законом, если  данные части не противоречат действующему уставу и действующим законам.  */ public interface ArticleOneLegistratureDraft {  //совета ди     String SECTION_1 = \"Все предоставленные здесь законодательные полномочия принадлежат Корпорации \" +             \" Международного Торгового Союза, который Состоит из Совета Акционеров и HigherSpecialPositions и всех остальных членов\" +             \" которые имеют право голосовать в соответсвтвии с данным Уставом.\" +             \" Все законы создаются через механизм криптовалюты Корпорации Международного Торгового Союза, в соответсвии описаными здесь \" +             \" правилами.\" +             \" Все полномочия предоставленные данным Уставом, а также действующими законами которые не протироворечат данному уставу \" +             \" являются легитимными. \" +             \"Единственым преимуществом совета директоров, перед остальными участниками данной системы и ее\" +             \"граждан, является только тот факт, что они обладают на 10% больше голосов. А также право вводит поправки \" +             \"как описано в данном уставе\";      String CHAPTER_2 = \" Совет Акционеров состоит из одной тысячи счетов(1000),\" +             \" счетов с наибольшим количеством цифровых акций digitalStockBalance.\" +             \"Но отбирается этот список из всех счетов которые хотя бы один раз были активными тоесть  отправителями или майнерами в течение\" +             \"одного года (текущий год - один год, и если активность была внутри данного диапазона.), но\" +             \"если прошло больше года с последней активности, то данный счет не учитывается при отборе\" +             \"совета Акционеров. Это нужно чтобы если вдруг был утерян счет, то это не влияло на систему, так как будут учитываться \" +             \"только активные участники и только активные участники могут быть Акционерами. \" +         \" Перерасчет членов Совета акционеров происходит каждый блок и определяется каждый блок.\" +         \"  при голосовании через механизм даной криптовалюты их голоса(цифровые акции) умножается на множитель 1.10 \" +             \" что дает им на десять процентов больше \" +             \" голоса при созаднии закона в рамках данной \" +             \" криптовалюты (при голосовании через механизм данной криптовалюты)\" +         \" Абсолютно любое лицо (Юридическое, Физическое, Цифровое Лицо-Исккуственный Интелект и т.д.) \" +             \" может быть членом Совета Акционеров (не зависимо от граждансва, национальности, пола и т.д. или любых \" +         \"других признаков) или даже любое государство может выступать в качестве члена Совета Акционеров.\" +             \"\" +             \"Алгоритм Избрания Совета ационеров:\" +             \" //определение совета акционеров\\n\" +             \"    public static List<Account> findBoardOfShareholders(Map<String, Account> balances, List<Block> blocks, int limit) {\\n\" +             \"        List<Block> minersHaveMoreStock = null;\\n\" +             \"        if(blocks.size() > limit){\\n\" +             \"            minersHaveMoreStock = blocks.subList(blocks.size() - limit, blocks.size());\\n\" +             \"        }\\n\" +             \"        else {\\n\" +             \"            minersHaveMoreStock = blocks;\\n\" +             \"        }\\n\" +             \"        List<Account> boardAccounts = minersHaveMoreStock.stream().map(\\n\" +             \"                t->new Account(t.getMinerAddress(), 0, 0))\\n\" +             \"                .collect(Collectors.toList());\\n\" +             \"\\n\" +             \"        for (Block block : minersHaveMoreStock) {\\n\" +             \"            for (DtoTransaction dtoTransaction : block.getDtoTransactions()) {\\n\" +             \"                boardAccounts.add(new Account(dtoTransaction.getSender(), 0, 0));\\n\" +             \"            }\\n\" +             \"        }\\n\" +              \"        CompareObject compareObject = new CompareObject();\\n\" +             \"        List<Account> boardOfShareholders = balances.entrySet().stream()\\n\" +             \"                .filter(t->boardAccounts.contains(t.getValue()))\\n\" +             \"                .map(t -> t.getValue()).collect(Collectors.toList());\\n\" +             \"                boardOfShareholders = boardOfShareholders\\n\" +             \"                .stream()\\n\" +             \"                .filter(t -> !t.getAccount().startsWith(Seting.NAME_LAW_ADDRESS_START))\\n\" +             \"                .filter(t -> t.getDigitalStockBalance() > 0)\\n\" +             \"                .sorted((f1, f2) -> {return compareObject.compare(f1, f2);})\\n\" +             \"                .limit(Seting.BOARD_OF_SHAREHOLDERS)\\n\" +             \"                .collect(Collectors.toList());\\n\" +             \"        return boardOfShareholders;\\n\" +             \"    }\" +             \"\" +             \"в BoardOfShareholdersController происходит сортировка по убыванию\" +             \"  //сортировка по убыванию\\n\" +             \"        boardOfShareholders = boardOfShareholders.stream().sorted((f1, f2)\\n\" +             \"                -> Double.compare(f2.getDigitalStockBalance(), f1.getDigitalStockBalance())).collect(Collectors.toList());\\n\";      String CHAPTER_3 = \"Создавать законы через механизм данной криптовалюты имеет право любой счет в криптовалюте Корпорации Международный Торговый Союз.\" +             \" Стоимость создания закона \" +             \" сто сорок четыре цифровых доллара(144) в качестве вознаграждения майнеру( стоимость может быть уменьшена через действующий закон).\" +             \" Закон созданный через механизм данной криптовалюты \" +             \" является дейтсвующим пока за \" +             \" него проголосовало  \" +             \" пять миллионов сто восемдесят четыре тысячи голосов и более. Механизм голосования такой: Голоса проголосовавшие ЗА минус голоса проголосовавшие\" +             \" ПРОТИВ и \" +             \" остаток должен быть больше 5184000. Даная мера предназначена чтобы не\" +             \"терялись голоса против (Пример: если брать класический механизм голосования акциями,\" +             \"то если у одного участника есть 51%, то не будет учитываться оставшиеся 49% голосов.\" +             \"так как не зависимо как проголосуют оставшиеся, это не сыграет роли. Но в данной\" +             \"системе отнимая от ЗА - ПРОТИВ > ПОРОГА, мы получаем ситуацию когда каждый голос \" +             \"важен.). Для обычных счетов количество голосов равно количеству цифровых акций на данный момент, \" +             \" для членов Совета Акционеров \" +             \" Количество голосов равно количеству цифровых акций на данный момент, умноженной на множитель одна целая и десять сотых\" +             \" процента (1.10).\" +             \" Что дает членам Совета Акционеров 10% больше голосов чем у них есть цифровых акций. \" +             \" Каждый блок идет перерасчет всех голосов проголосовавших за и против. Пока количество голосов больше 5184000 закон является \" +             \" действительным. \";      String CHAPTER_4 = \" Право создавать законы через механизм данной криптовалюты, \" +             \"  а также право голосовать за законы через механизм данной криптовалюты имеют все юридические и физические лица обладающие \" +             \" счетом в данной криптовалюте и удовлетворяющие условиям создания и голосования в \" +             \" данной криптовалюте Корпорации Международного Торгового Союза.\" +             \"Учитываются только те голоса, от которых не прошло больше трех лет для законов и не больше трех лет для HigherSpecialPositions,\" +             \" но можно переголосовать заного чтобы \" +             \"обновит голос. Данная мера нужна для безопастности системы, если вдруг счет был утерян то, этот голос не будет действовать вечно,\" +             \"а только определенный периуд времени.\" +             \"также это позволяет переизберать важные должностные лица и бороться с лобированием вредных законов, так как плохие законы\" +             \"не переизберуться. \";      String CHAPTER_5 = \"HigherSpecialPositions данные специальные должности являются высшемыми должностями. Все должности \" +             \" описанные в данном\" +             \" Уставе яляются действительными. (CORPORATE_SUPREME_COURT(18), DEPARTMENT_OF_CORPORATE_JOURNALISTS(15),\" +             \" BOARD_OF_DIRECTORS(16), MARKETING_DEPARTMENT(5), DEPARTMENT_OF_STRATEGIC_DEVELOPMENT_AND_PLANNING(5), PR_DEPARTMENT(5),\" +             \" DEPARTMENT_OF_FINANCE(5),DEPARTMENT_OF_HUMAN_RESOURCES(5)).\" +             \" Чтобы создать новые специальные высшие должности нужно \" +             \" создать закон с новым названием должности, определить сколько мест руководства будет создано для данной должности.\" +             \" А также определить ее полномочия. Данная должность и все ее полномочия будут действительными.\" +              \"пока действует закон который создал данную должность. \" +             \"В  случае если закон о должности стал не действительным \" +             \", то данная должность теряет все свои полномочия. Если снова этот закон не будет возобновлен или создан аналогичный действующий закон\" +             \" для отменненой должности. Должности Которые описаны в уставе являются всегда действующими, но их полномочия могут\" +             \"менятся в зависимости от действующих законов, которые описывают данные должности\" +             \"Как принят закон который создает новую должность и не отменен в течение четырех недель с момента принятия, \" +             \"Все майнеры должны добавить даную должность в HigherSpecialPositions.\" +             \" \";      String CHAPTER_6 =             \" Чтобы занять Специальную должность HigherSpecialPositions нужно создать закон с названием пакета который \" +                     \" совпадает с названием действующей должности. В качестве первой строки закона должен быть вписан адресс отправителя(создателя) \" +                     \"данного закона. Адресс создателя должен совпадать с адрессом который вписан в данном законе.\" +                     \" Вторая строка может быть заполнена контактными данными или полезной информацией о том кто подает на \" +                     \" данную должность. Счет в вступает в должность как только данный пакет закона будет одобрен с теми \" +                     \"же условиями как для всех законов в данной криптовалюте и он будет находиться в должности, пока \" +                     \"его пакет по подаче на данную должность будет действующим.\";        String CHAPTER_7 = \" В случае нескольких действующих законов которые противоречать друг другу \" +             \", Верховный судьи (назначенные через криптовалюту CORPORATE_SUPREME_COURT)\" +             \" должен одавать приоритет тем законам, \" +             \" которые на момент судебного процесса имеет наибольшее количество голосов, превосходящее в 5% \" +             \" от противоречающих голосов, но если \" +              \" нет такого превосходства то данный вопрос должен быть решен либо с помощью прецендента, которы й\" +             \" будет действовать пока не пройзодет изменение в количестве голосов или пока верховные судьи которые создали прецендент \" +             \" находятся на своих должностях.\" +              \" Прецендент создается голосованием верховных судей которые большинством голосов определяют что в случае \" +             \" пока несколько противоречащих законов действуют и нет превосходства в голосах в 5%, то суд принимает что тот \" +              \" или иной закон будет более высшим, над другим пока будет сохраняться паритет в голосах за закон и пока судьи \" +             \" которые проголосовали за данный закон как действующий и более высший, из противоречащих но принятых через механизм \" +             \" данной криптовалюты. В случае если если состав судей изменился, те которые голосовали за закон, то если сохраняется \" +             \" паритет противоречащих законов, нужно заного принять с помощью прецендента который из них более высший над другими \" +             \" противоречащими.\" ;      String CHAPTER_8 = \" Для создания закона через механизм криптовалюты Корпорации Международого торгового Союза \" +             \" Нужно внутри данной криптовалюты Создать объект класса Laws где packetLawName- является названием пакета законов.\" +             \" List<String> laws - является списком законов, String hashLaw - является адрессом данного пакета законов и начинается с LIBER.\" +             \" Чтобы Закон попал в пул законов нужно создать транзакцию где получателем является hashLaw данного закона и вознаграждение \" +             \" майнера равно сто сорок четыре цифровых долара данной криптовалюты. После этого как закон попадет в блок, он окажется в пуле \" +             \" законов и за него можно будет голосовать.\";      String CHAPTER_9 = \"при отправке \\\"digitalStockBalance\\\" на любой баланс, с VoteEnum.NO\" +             \" сокращяет баланс получателя на то количество которое отправил отправитель,\" +             \" Данная опереция нужна чтобы иметь возможность снизить голоса деструктивных членов Корпорации Международного Торгового Союза\" +             \" а также чтобы убрать конкретный счет c Совета Акционеров.,\" +             \" или сократить политическую власть конкретного счета,\\n\" +             \"\\n\" +             \"при отправке \\\"digitalStockBalance\\\" на любой баланс, с VoteEnum.YES\\n\" +             \"увеличивает баланс получателя на то количество которое отправил отправитель,\" +             \" Данная опереция нужна \" +             \"  чтобы добавить конкретный счет в Совет Акционеров, или увеличить \" +             \"политическую власть конкретного счета.\";      String CHAPTER_10 = \"все лица могут занимать специальные высшие должности.\" +             \" HigherSpecialPositions.\" +             \" Примерный код работы описан в GovernmentController.\" +             \" Каждая Специальная должность имеет ограничение в количестве.\" +             \" Один счет может занять одно место в пуле одной должноти, но \" +             \" один счет может занимать несколько должностей если они разные и имеют разные полномочия.\" +             \" (Пример: CORPORATE_SUPREME_COURT(18),BOARD_OF_DIRECTORS(16) один и тот же счет может занимать по одной\" +             \" должности в каждой такой группе, но счет не может занять к примеру более двух мест в должности BOARD_OF_DIRECTORS\" +             \" или иной специальной должности).\" +             \"Требование к должности такие как к действующим законом, но есть отличие, примерный алгоритм описан здесь:\" +             \"1.создается список всех балансов.\" +             \"2. создать список всех законов.\" +             \"3. создать списки с названием HigherSpecialPositions.\" +             \"ДАННЫЙ КОД МОЖНО УЛУЧШАТЬ ЕСЛИ СОХРАНЯТЬ ДЕЙСТВУЮЩИЕ ПРИНЦИПЫ, НО УЛУЧШЕНИЕ ДОЛЖНО БЫТЬ \" +             \"СНАЧАЛА СОЗДАННО ВВИДЕ ДЕЙСТВУЮЩЕГО ЗАКОНА, ГДЕ УКАЗЫВАЕТСЯ КАКОЙ КОД И КАК БУДЕТ ДЕЙСТВОВАТЬ ДАННЫЙ КОД \" +             \" //отбирает позицию вакансий\\n\" +             \"  //отбирает позицию вакансий\\n\" +             \"  class UtilsLaws  public static List<LawEligibleForParliamentaryApproval> getPossions(List<LawEligibleForParliamentaryApproval> lawEligibleForParliamentaryApprovals, HigherSpecialPositions corporateSeniorPositions){\\n\" +             \"\\n\" +             \"        List<LawEligibleForParliamentaryApproval> temporary = new ArrayList<>();\\n\" +             \"        temporary = lawEligibleForParliamentaryApprovals.stream()\\n\" +             \"                .filter(t->Objects.nonNull(t))\\n\" +             \"                .filter(t->Objects.nonNull(t.getLaws()))\\n\" +             \"                .filter(t->Objects.nonNull(t.getLaws().getLaws()))\\n\" +             \"                .filter(t->Objects.nonNull(t.getLaws().getPacketLawName()))\\n\" +             \"                .filter(t->Objects.nonNull(t.getName()))\\n\" +             \"                .filter(t->Objects.nonNull(t.getLaws().getHashLaw()))\\n\" +             \"                .sorted((f1, f2) -> Double.compare(f2.getAccount().getDigitalStockBalance(), f1.getAccount().getDigitalStockBalance()))\\n\" +             \"                .filter(t-> t.getLaws().getPacketLawName().equals(corporateSeniorPositions.name()))\\n\" +             \"                .limit(corporateSeniorPositions.getCount())\\n\" +             \"                .collect(Collectors.toList());\\n\" +             \"        return temporary;\\n\" +             \"\\n\" +             \"    }\" +             \",\" +             \"4. Получить список акционеров.\" +             \"5. Удостовериться пакет-закон который действует как должность является действуюм, таким же способом как и обычные законы.\" +             \"6. Дальше отсортировать каждый действующий должность закон по убыванию, и из них отобрать с наибольшим количеством\" +             \"голосов равное количествую на данную должность.\" +             \" //отобрать голоса выше лимита\\n\" +             \"            curentLawVotesEndBalance.put(corp.getKey(), curentLawVotesEndBalance.get(corp.getKey())\\n\" +             \"                    .stream().filter(t-> t.getVotes() >= Seting.ORIGINAL_LIMIT_MIN_VOTE)\\n\" +             \"                    .collect(Collectors.toList()));\\n\" +             \"\\n\" +             \" //отобрать то количество которое соответсвтвует данной должности\\n\" +             \"            List<CurrentLawVotesEndBalance> temporary = curentLawVotesEndBalance.get(corp.getKey()).stream().filter(\\n\" +             \"                            t->!t.getPackageName().equals(corp.getKey()))\\n\" +             \"                    .sorted(Comparator.comparing(CurrentLawVotesEndBalance::getVotes).reversed())\\n\" +             \"                    .limit(corp.getKey().getCount()).collect(Collectors.toList());\\n\" +             \"\\n\" +             \"           curentLawVotesEndBalance.put(corp.getKey(), temporary);\" +             \"\" +             \"Любое лицо может голосовать за участников претендующих на  должности, но подать за должность может каждый счет только за себя\" +             \"при подаче себя на данную должность счет создает закон и первая строка закона совпадает с счетом отправителя.\" +             \"как только закон попадает в список, каждый может голосовать за данный закон, который утверждает счет указанный \" +             \"там на данную должность. Действующие должности отбираются таким образом:\" +             \"GovernmentController corporateSeniorpositions\" +             \" Blockchain blockchain = Mining.getBlockchain(\\n\" +             \"                Seting.ORIGINAL_BLOCKCHAIN_FILE,\\n\" +             \"                BlockchainFactoryEnum.ORIGINAL);\\n\" +             \"\\n\" +             \"        //Получение баланса\\n\" +             \"        Map<String, Account> balances = new HashMap<>();\\n\" +             \"\\n\" +             \"        balances = SaveBalances.readLineObject(Seting.ORIGINAL_BALANCE_FILE);\\n\" +             \"\\n\" +             \"        //Нахождение должности\\n\" +             \"        List<LawEligibleForParliamentaryApproval> allGovernment =\\n\" +             \"                UtilsLaws.readLineCurrentLaws(Seting.ORIGINAL_ALL_CORPORATION_LAWS_WITH_BALANCE_FILE);\\n\" +             \"\\n\" +             \"        //список должностей\\n\" +             \"        Map<HigherSpecialPositions, List<LawEligibleForParliamentaryApproval>> positionsListMap = new HashMap<>();\\n\" +             \"        //добавление всех должностей\\n\" +             \"        for (HigherSpecialPositions corporateSeniorPositions : HigherSpecialPositions.values()) {\\n\" +             \"            positionsListMap.put(corporateSeniorPositions, UtilsLaws.getPossions(allGovernment, corporateSeniorPositions));\\n\" +             \"        }\\n\" +             \"\\n\" +             \"\\n\" +             \"        //список акционеров\\n\" +             \"        List<Account> BoardOfShareholders  = UtilsGovernment.findBoardOfShareholders(balances, blockchain.getBlockchainList(), Seting.BOARDS_BLOCK);\\n\" +             \"\\n\" +             \"        //константа список акционеров\\n\" +             \"        List<Account> finalBoardOfShareholders = BoardOfShareholders;\\n\" +             \"\\n\" +             \"        //список законов с голосами\\n\" +             \"        Map<HigherSpecialPositions, List<CurrentLawVotesEndBalance>> curentLawVotesEndBalance = new HashMap<>();\\n\" +             \"\\n\" +             \"        for (Map.Entry<HigherSpecialPositions, List<LawEligibleForParliamentaryApproval>> corp :positionsListMap.entrySet()) {\\n\" +             \"            //убрать повторяющиеся должности из списка.\\n\" +             \"                    .distinct().collect(Collectors.toList()));\\n\" +             \"\\n\" +             \"            //получить баланс и голоса для действующих законов\\n\" +             \"            curentLawVotesEndBalance.put(corp.getKey(),UtilsGovernment.filters(corp.getValue(), balances, BoardOfShareholders,\\n\" +             \"                    blockchain.getBlockchainList(), Seting.POSITION_YEAR_VOTE));\\n\" +             \"\\n\" +             \"            //отобрать голоса выше лимита\\n\" +             \"            curentLawVotesEndBalance.put(corp.getKey(), curentLawVotesEndBalance.get(corp.getKey())\\n\" +             \"                    .stream().filter(t-> t.getVotes() >= Seting.ORIGINAL_LIMIT_MIN_VOTE)\\n\" +             \"                    .collect(Collectors.toList()));\\n\" +             \"\\n\" +             \"            //отобрать то количество которое соответсвтвует данной должности\\n\" +             \"            List<CurrentLawVotesEndBalance> temporary = curentLawVotesEndBalance.get(corp.getKey()).stream().filter(\\n\" +             \"                            t->!t.getPackageName().equals(corp.getKey()))\\n\" +             \"                    .sorted(Comparator.comparing(CurrentLawVotesEndBalance::getVotes).reversed())\\n\" +             \"                    .limit(corp.getKey().getCount()).collect(Collectors.toList());\\n\" +             \"\\n\" +             \"           curentLawVotesEndBalance.put(corp.getKey(), temporary);\\n\" +             \"        }\\n\" +             \"\\n\" +             \"\\n\" +             \"\\n\" +             \"        model.addAttribute(\\\"show\\\", curentLawVotesEndBalance);\\n\" +             \"\\n\" +             \"        model.addAttribute(\\\"title\\\", \\\"current guidance\\\");\\n\" +             \"\\n\" +             \"        return \\\"/governments\\\";\";      String CHAPTER_11 = \"Для голосования за любой закон созданный через механизм данной криптовалюты,\" +             \" достаточно в качестве получателя поставить адресс закона и в качестве голоса \" +             \"отправить VoteEnum YES или NO как только ваш голос попадет голос отправителя будет равен количеству digitalStockBalance на данный \" +             \"момент, если отправитель член Совета Акционеров то голос будет равен количетву цифровой репутации на данный момент умноженный на \" +             \" 1.10, что даст на 10% больше голоса. Голоса за закон перерасчитываются каждый блок \" +             \"Алгоритм подсчета голосования:\" +             \"\" +             \"class LawController: \" +             \" public String currentLaw(Model model) throws IOException, NoSuchAlgorithmException, InvalidKeySpecException, SignatureException, NoSuchProviderException, InvalidKeyException {\\n\" +             \"\\n\" +             \"        Blockchain  blockchain = Mining.getBlockchain(\\n\" +             \"                Seting.ORIGINAL_BLOCKCHAIN_FILE,\\n\" +             \"                BlockchainFactoryEnum.ORIGINAL);\\n\" +             \"\\n\" +             \"        Map<String, Account> balances = new HashMap<>();\\n\" +             \"        //считывать баланс\\n\" +             \"        balances = SaveBalances.readLineObject(Seting.ORIGINAL_BALANCE_FILE);\\n\" +             \"\\n\" +             \"        List<LawEligibleForParliamentaryApproval> lawEligibleForParliamentaryApprovals =\\n\" +             \"                UtilsLaws.readLineCurrentLaws(Seting.ORIGINAL_ALL_CORPORATION_LAWS_WITH_BALANCE_FILE);\\n\" +             \"\\n\" +             \"\\n\" +             \"        List<Account> boardOfShareholders = UtilsGovernment.findBoardOfShareholders(balances, blockchain.getBlockchainList(), Seting.BOARDS_BLOCK);\\n\" +             \"\\n\" +             \"\\n\" +             \"\\n\" +             \"        //данные для отображения\\n\" +             \"        List<CurrentLawVotesEndBalance> current = UtilsGovernment.filters(lawEligibleForParliamentaryApprovals, balances, boardOfShareholders,\\n\" +             \"                blockchain.getBlockchainList(), Seting.LAW_YEAR_VOTE);\\n\" +             \"//        Seting.ORIGINAL_LIMIT_MIN_VOTE\\n\" +             \"        //минимальное значение количество положительных голосов для того чтобы закон действовал,\\n\" +             \"//        int ORIGINAL_LIMIT_MIN_VOTE = (int) (200 * Seting.COUNT_BLOCK_IN_DAY * 45); count_block_in_day = 144\\n\" +             \"        current = current.stream().filter(t-> t.getVotes() >= Seting.ORIGINAL_LIMIT_MIN_VOTE)\\n\" +             \"                .sorted(Comparator.comparing(CurrentLawVotesEndBalance::getVotes).reversed()).collect(Collectors.toList());\\n\" +             \"\\n\" +             \"        model.addAttribute(\\\"title\\\", \\\"current law: current laws are laws that have more than this: \\\" + Seting.ORIGINAL_LIMIT_MIN_VOTE + \\\" the number of votes.\\\");\\n\" +             \"        model.addAttribute(\\\"currentLaw\\\", current);\\n\" +             \"        return \\\"current-laws\\\";\\n\" +             \"    }\" +             \"\\n\" +             \"\\n\" +             \"        //данные для отображения. Здесь определяются действующие законы\\n\" +             \"        List<CurrentLawVotesEndBalance> current = UtilsGovernment.filters(lawEligibleForParliamentaryApprovals, balances, boardOfShareholders);\\n\" +             \"//        Seting.ORIGINAL_LIMIT_MIN_VOTE\\n\" +             \"        //минимальное значение количество положительных голосов для того чтобы закон действовал,\\n\" +             \"//        int ORIGINAL_LIMIT_MIN_VOTE = (int) (200 * Seting.COUNT_BLOCK_IN_DAY * 45); count_block_in_day = 144\\n\" +             \"        current = current.stream().filter(t-> t.getVotes() >= Seting.ORIGINAL_LIMIT_MIN_VOTE)\\n\" +             \"                .sorted(Comparator.comparing(CurrentLawVotesEndBalance::getVotes).reversed()).collect(Collectors.toList());\\n\" +             \"\\n\" +             \"        model.addAttribute(\\\"title\\\", \\\"current law: current laws are laws that have more than this: \\\" + Seting.ORIGINAL_LIMIT_MIN_VOTE + \\\" the number of votes.\\\");\\n\" +             \"        model.addAttribute(\\\"currentLaw\\\", current);\\n\" +             \"        return \\\"current-laws\\\";\\n\" +             \"    }\" +             \"\" +             \"Class UtilsGovernment:\" +             \"  public static List<CurrentLawVotesEndBalance> filters(List<LawEligibleForParliamentaryApproval> approvalList, Map<String, Account> balances, List<Account> BoardOfShareholders, List<Block> blocks, int limitBlocks) throws IOException, NoSuchAlgorithmException, InvalidKeySpecException, SignatureException, NoSuchProviderException, InvalidKeyException {\\n\" +             \"        //действующие законы чьи голоса больше ORIGINAL_LIMIT_MIN_VOTE\\n\" +             \"        List<CurrentLawVotesEndBalance> current = new ArrayList<>();\\n\" +             \"        Map<String, CurrentLawVotes> votesMap = null;\\n\" +             \"        List<Account> accounts = balances.entrySet().stream().map(t->t.getValue()).collect(Collectors.toList());\\n\" +             \"        if(blocks.size() > limitBlocks){\\n\" +             \"            votesMap = UtilsCurrentLaw.calculateVotes(accounts,blocks.subList(blocks.size() - limitBlocks, blocks.size()));\\n\" +             \"        }else {\\n\" +             \"            votesMap = UtilsCurrentLaw.calculateVotes(accounts, blocks);\\n\" +             \"        }\\n\" +             \"\\n\" +             \"        for (LawEligibleForParliamentaryApproval lawEligibleForParliamentaryApproval : approvalList) {\\n\" +             \"            if(votesMap.containsKey(lawEligibleForParliamentaryApproval.getLaws().getHashLaw())){\\n\" +             \"                String address = lawEligibleForParliamentaryApproval.getLaws().getHashLaw();\\n\" +             \"                String packageName = lawEligibleForParliamentaryApproval.getLaws().getPacketLawName();\\n\" +             \"                double vote = votesMap.get(lawEligibleForParliamentaryApproval.getLaws().getHashLaw()).votes(balances, BoardOfShareholders);\\n\" +             \"\\n\" +             \"                CurrentLawVotesEndBalance currentLawVotesEndBalance = new CurrentLawVotesEndBalance(address, packageName, vote);\\n\" +             \"                current.add(currentLawVotesEndBalance);\\n\" +             \"\\n\" +             \"            }\\n\" +             \"        }\\n\" +             \"        return current;\\n\" +             \"    }\" +             \"\" +             \"class CurrentLawVotes: механизм голосования\" +             \"public double votes(Map<String, Account> balances, List<Account> pubChumbers){\\n\" +             \"        double yes = 0.0;\\n\" +             \"        double no = 0.0;\\n\" +             \"        List<String> addressGovernment = pubChumbers.stream().map(t->t.getAccount()).collect(Collectors.toList());\\n\" +             \"        for (String s : YES) {\\n\" +             \"            if(addressGovernment.contains(s)){\\n\" +             \"                yes += balances.get(s).getDigitalStockBalance() * Seting.POWER_SHAREHOLDER;\\n\" +             \"            }else {\\n\" +             \"                yes += balances.get(s).getDigitalStockBalance();\\n\" +             \"            }\\n\" +             \"\\n\" +             \"        }\\n\" +             \"        for (String s : NO) {\\n\" +             \"            if(addressGovernment.contains(s)){\\n\" +             \"                no += balances.get(s).getDigitalStockBalance() * Seting.POWER_SHAREHOLDER;\\n\" +             \"            }else {\\n\" +             \"                no += balances.get(s).getDigitalStockBalance();\\n\" +             \"            }\\n\" +             \"\\n\" +             \"        }\\n\" +             \"\\n\" +             \"\\n\" +             \"        return yes - no;\\n\" +             \"    }\";      String CHAPTER_12 = \"Любое физическое или юридическое лицо может заниматься майнингом, и все добытые с помощью майнинга \" +             \"цифровые доллары и цифровые акции принадлежит добытчику, как и вознаграждение основателя принадлежит основателю.\" +             \"За один Блок Майнер получает 200 цифровых доллара и 200 цифровых репутации, вознаграждение основателя равно 2% с округлением\" +             \"до целого числа.\";      String CHAPTER_13 = \"Любые должности которые могут понадабиться Международному Торговому союзу включая отделы и другие структуры \" +             \"должны быть утверждены законами Международного Торгового Союза, а также и их полномочия. \" +             \"Любые полномочия переданые Совету Акционеров, Специальным Должностям или должностям созданными иными способами,\" +             \"действуют пока действует законы созданные через данную криптовалюту которые определяют данные полномочия\";      String CHAPTER_14 = \" (Относиться только к специальным должностям и Совету акционеров)\" +             \"Любое вознаграждение Специальных Должностей и Совета Ационеров должно определяться действующими законами.\" +             \"И определяться как они должны получать, но в силу того что данная валюта имеет ограниченное количество, то с бюджета \" +             \"данной Корпорации вознаграждение должно быть не фиксированным а процентным. (Пример: Вместо зарплаты 30 монет, \" +             \"определить какой процент занимает данная сумма из бюджета и выдавать именно процент с учетом инфляции и дефляции, на момент\" +             \"выдачи. \" +             \"пример номер два: Зарплата судьи на момент принятия на работу была 20 монет, но на тот момент это было 0.003% от дохода\" +             \"данной корпорации, тогда ежемесячно он будет получать не 20 монет а 0.003% но этот процент .)\" +             \"Данная защита сделана вот по какой причине, к примеру биткоин на заре своего становления был всего лишь несколько центов.\" +             \"но помере развития, стоимость росла, если не вести такую меру, то зарплата одного сотрудника может вырости в несколько \" +             \"сот раз, что приведет к банкротству данной Корпорации.\" +             \"\";     String CHAPTER_15 = \"Любая наличность или иные деньги которая выпускает Корпорация Международный Торговый Союз,\" +             \"должны быть сто процентно обеспечены цифровым долларом или цифровой акцией данной криптовалюты, по фиксированному курсу.\" +             \"Но курс должен коректироваться раз в десят лет с учетом инфлционых и дефляционых процесов, а также рыночной конюктуры.\" +             \"Кто имеет права выпускать деньги обеспеченные данной криптовалютой и коректировать\" +             \"курс должны быть определены с помощью действующих законов\" +             \"и созданны специальные должности.\";        //********************************************************************************************************************************************      String CHAPTER_16 = \" Корпорация Международный Торговый Союз имеет право устанавливать и собирать комисию, пошлины (при \" +             \"условии не выше 20%);\" +             \" Также источником дохода данной корпорации\" +             \" может быть продажа своих товаров или услуг, а также иные источники дохода(к примеру продажа подписок, членских взносов и т.д.)\" +            \" целью таких мер является выдача дивидентов, акционерам и инвесторам, финансирование расходов данной Корпорации,\" +             \"  В первую очередь \" +             \" в инвестирование развития своей продукции и экосистемы, развитие инфраструктуры \" +             \" данной Корпорции, содержание персонала, выплата долгов, возможно также содержание социальных и обществено значимых проектов,\" +             \" таких как доступная медицина, образование(на благо всего общего общества) и т.д. на територии Корпорации Международного Торгового Союза.\" +             \" Содействовать и развивать всеобщему благосостоянию на всей територии Корпорации Международного Торгового Союза - \" +             \" проблемы которые не могут быть решенены на региональном или местном уровне, а также проблем которые не решаемы \" +             \" частными мелкими инвестициями. Используя эффект масштаба, можно удешевить стоимость разработки и внедрения передовых технологий\" +             \" а также социально значимых продукции и услуг на територии Корпорации Международного Торгового Союза, но любые меры\" +             \"которая Корпорация Международного Торгового Союза решит реализовать, включая выше перечисленные, должны быть утверждены действующим\" +             \"законом, или переданы действующими законами полномочием Совету Директоров или другим специальным высшим должностям\" +             \"HigherSpecialPositions. \"+             \", все расходы данной Корпорации должны быть определены либо советом директоров или действующими законами или специальными\" +             \" действующими должностями\" +             \"которым через действующие законы переданы данные полномочия.\" +             \" \" +             \" которым выданы данные полномочия действующими законами\" +             \" Все цели Корпорации Международного Торгового Союза должны быть определены или через\" +             \"  действующие законы или советом директоров или специальными должностными лицами, которым через действующие законы им\" +             \"переданы данные полномочия. развитие инфраструры для\" +             \" ведения торговли и предоставления услуг членам Корпорации Международного торгового Союза,\" +             \" а также возможно развитие общественных и социальных благ на територии, если это необходимо и определено как цели, как\" +             \"описано выше или любые иные цели которые определены как описано выше в\" +             \"Корпорации Междунардного Торгового Союза.\" +             \" (Пример общественных и социальных благ, производство и продажа жизнено необходимых лекарств по низской цене, или создание парков, общественного транспорта,\" +             \"обслуживание канализаций и т.д.\" +             \"\\n\" +             \"Занять деньги в кредит Корпорации Международного Торгового Союза;\\n\" +             \"\\n\" +             \"Регулировать торговлю с иностранными государствами и похожими корпорациями, и при условии, что это положение не \" +             \"разрешает регулировать или запрещать какую-либо \" +             \"некоммерческую деятельность или любую коммерческую деятельность, \" +             \"которая ограничивается одной части територии Корпорации Международного \" +             \"Торгового Союза, независимо от его последствия за пределами данной територии; но Корпорация Международного Торгового Союза\" +             \" имеет право регулировать вредные выбросы между териториями входящими под контроль Корпорации\" +             \"Международного Торгового Союза, независимо от их источника;\\n\" +             \"\\n\" +             \"Установить единые правила натурализации и единые законы о банкротстве на всей территории Корпорации Международного \" +             \"Торгового Союза, при условии, что это не будет истолковано как санкционирование законодательства,\" +             \" запрещающего въезд на територию Корпорации Международного Торгового Союза любого лица,\" +             \" въезжающего по мирным, непреступным причинам, и кто не страдает заразной болезнью;\\n\" +             \"\\n\" +             \"Выпускать деньги и другую валюту сто процентно обеспеченную криптовалютой Корпорации Международного Торгового Союза,\" +             \" регулировать их стоимость и иностранную монету, при условии, что это не будет \" +             \"истолковано как разрешение превращения какой-либо валюты в законное платежное средство; и установить эталон мер и весов;\\n\" +             \"\\n\" +             \"Предусмотреть наказание за подделку ценных бумаг и текущей монеты или валюты Корпорации Международного Торгового Союза;\\n\" +             \"\\n\" +             \"Учреждать почтовые отделения и почтовые дороги при условии,\" +             \" что это не будет истолковано как допускающее установление какой-либо почтовой монополии;\\n\" +             \"\\n\" +             \"Содействовать прогрессу науки и полезных искусств, предоставляя авторам и изобретателям на срок не более \" +             \"28 лет исключительное право на их соответствующие произведения и открытия;\\n\" +             \"\\n\" +              \"Все действующие законы Действуют на територии принадлежащей Корпорации Международного Торгового Союза и на всех членов не зависимо от територий.\" +              \"Корпорация Международного Торгового Союза не должен возлагать на членов Корпорации Международного Торгового Союза\" +             \" или его политическое подразделение какие-либо обязательства \" +             \"или обязанности по осуществлению расходов, если такие расходы не будут \" +             \"полностью возмещены Корпорацией Международного Торгового Союза; Конгресс также не должен ставить\" +             \" какие-либо условия в отношении расходования или получения ассигнованных средств,\" +             \" требуя от членов Корпорации Международного Торгового Союза\" +             \" или его политического подразделения принятия закона или постановления,\" +             \" ограничивающего свободы его граждан или иным образом воздействующего на какие-либо полномочия(Так как членами могут\" +             \"быть также юридические лица, это позволяет защитать граждан иных компаний, корпорации, государств от таких действий.),\" +             \" не входящие в компетенцию Корпорации Международного Торгового Союза. Если член откажется от ассигнованных средств \" +             \"с условиями их расходования, сумма ассигнований, \" +             \"пропорционально распределенная населением этого члена(Если это какая то компания, корпорация, или государство и т.д.),\" +             \" выплачивается члену в виде единовременной субсидии,\" +             \" которая расходуется на общие цели ассигнований.\";        String CHAPTER_17 = \" Привилегия судебного приказа о хабеас корпус не может быть приостановлена,\" +             \" за исключением случаев, когда в случаях  этого может потребовать общественная безопасность.\" +             \" Ни один законопроект об аресте или закон постфактум, будь то гражданский или уголовный, не может быть принят.\" +             \" Корпорация Международного Торгового Союза не должен издавать законов, устанавливающих или взимающих налоги с доходов,\" +             \" подарков или имущества, \" +             \" прямых или подушных налогов или налогов на совокупное потребление или расходы; \" +             \" но Корпорация Международного Торгового Союза имеет право взимать единую комисию на продажу товаров или \" +             \" услуг если данная комисия \" +             \" не выше дватцати процентов(20%).  \" +             \" Любое введение или увеличение комисии, пошлины, сбора или акциза требует чтобы был создан закон который будет\" +             \" действовать и в котором будет описано данное изменение.\" +              \" Никакое регулирование торговли или доходов не должно отдавать предпочтение\" +             \" одним членам Корпорации Международного Торгового Союза, между другими.:\" +             \" и суда или другие виды транспорта, направляющиеся в или из одного штата(Члены) или земель племен,\" +             \" не обязаны заходить в порты. , ясно, или платить пошлины в другом.\" +              \" Никакие деньги не могут быть взяты из казны, но вследствие ассигнований,\" +             \" сделанных по закону, все такие ассигнования истекают через два года;\" +             \" и регулярный отчет и отчет о поступлениях и расходах всех Корпорации Международного Торгового Союза денег \" +             \" должны время от времени публиковаться, и быть доступна Совету Акционеров.(Данная мера нужна чтобы привлечь больше людей в данную корпорацию,\" +             \" и сделать прозрачным действия руководства.)\" +               \"Корпорация Международного Торгового Союза также не может издавать никаких законов, которые не применяются\" +             \" к нему самому или к его собственным членам.\";      String CHAPTER_18 = \" Все счета подвержены отрицательной ставке. Отрицательная ставка для цифрового доллара составляет 0.10%\" +             \" каждые пол года, а отрицательная ставка для цифровых акций составляет 0.2% каждые пол года. \" +             \" Данная часть кода указана в class UtilsBalance calculateBalance:\" +             \"   if (i != 0 && i / Seting.COUNT_BLOCK_IN_DAY % (Seting.YEAR / Seting.HALF_YEAR) == 0.0) {\\n\" +             \"\\n\" +             \"            for (Map.Entry<String, Account> changeBalance : balances.entrySet()) {\\n\" +             \"                Account change = changeBalance.getValue();\\n\" +             \"                change.setDigitalStockBalance(change.getDigitalStockBalance() - UtilsUse.countPercents(change.getDigitalStockBalance(), digitalReputationPercent));\\n\" +             \"                change.setDigitalDollarBalance(change.getDigitalDollarBalance() - UtilsUse.countPercents(change.getDigitalDollarBalance(), percent));\\n\" +             \"            }\\n\" +             \"        }\" +             \"\" +             \" Данная мера принята для избежания кризисов аналогичной Великой Депрессии, а также чтобы не эффективные и устаревшие\" +             \" законы легко удалялись из системы и чтобы мотивировать акционеров получить поддержку общества, отрицательная ставка не дает \" +             \"слишком высоко переоценивать стоимость как валюты,\" +             \" так стоимость акций, что не создает ситуций как в иных криптовалютах, где есть очень высокая валотильность.\" +             \" Данная мера не должна изменяться никакими поправками. (Обяснение: Когда цифровой доллар подвергается отрицательной ставке в размере 0.10% каждые пол года,\" +             \"это создает канал цены, где нижняя грацица монеты определяется себе себестоимостью и общим количеством в обороте, а верхняя граница\" +             \"определяется реальной стоимостью, как только цена становиться выше реальной рыночной цены, участникам выгодней становиться быстро продать данную\" +             \"валюту, и тем самым насытить рынок деньгами, это создает частые корекции рынка, что не дает созданию условий для больших обвалов.\" +             \"Но эффект будет заметен чем больше активных участников в сети, и чем дольше существует система.)\";      String CHAPTER_19 = \"Любой закон может быть как отменен, так и возобновлен. Если закон удовлетворяет условию действующего\" +             \"закона, он считается действующим, даже если не давно он был отменен, также если закон не удовлетворяет условия,\" +             \"он считается отмененым законом.\";      String CHAPTER_20 = \"Настройки\" +             \"// значение используется для вычисления процентов\\n\" +             \"    int HUNDRED_PERCENT = 100;\\n\" +             \"    // значение используется как константа года,\\n\" +             \"    // в данной системе отсутствует вискосный год\\n\" +             \"    int YEAR = 360;\\n\" +             \"\\n\" +             \"    //удаление отправленных транзакций\\n\" +             \"    String DELETED_SENDED_TRANSACTION_TIME = \\\"PT96H\\\";\\n\" +             \"\\n\" +             \"\\n\" +             \"    //за какой периуд последних блоков учитыать для отбора акционеров.\\n\" +             \"    //Актционрами могут быть только с наибольшим количеством баланса\\n\" +             \"    //отправители и майнеры.\\n\" +             \"    int BOARDS_BLOCK = (int) (Seting.COUNT_BLOCK_IN_DAY * YEAR);\\n\" +             \"\\n\" +             \"    //Множитель голоса для правительства для обчного счета одна акция один голос, для членов парламента одна репутация * 1.10\\n\" +             \"    double POWER_SHAREHOLDER = 1.10;\\n\" +             \"\\n\" +             \"    //минимальное значение количество положительных голосов для того чтобы закон действовал,\\n\" +             \"    int ORIGINAL_LIMIT_MIN_VOTE = (int) (200 * Seting.COUNT_BLOCK_IN_DAY * 45);\\n\" +             \"\\n\" +             \"    //    процент который получает основатель от добычи\\n\" +             \"    Double FOUNDERS_REWARD = 2.0;\\n\" +             \"    \\n\" +             \"    //address for send rewards\\n\" +             \"    String BASIS_ADDRESS = \\\"faErFrDnBhfSfNnj1hYjxydKNH28cRw1PBwDQEXH3QsJ\\\";\\n\" +             \"    String BASIS_PASSWORD = \\\"3hupFSQNWwiJuQNc68HiWzPgyNpQA2yy9iiwhytMS7rZyfPddNRwtvExeevhayzN6xL2YmTXN6NCA8jBhV9ge1w8KciHedGUMgZyq2T7rDdvekVNwEgf5pQrELv8VAEvQ4Kb5uviXJFuMyuD1kRAGExrZym5nppyibEVnTC9Uiw8YzUh2JmVT9iUajnVV3wJ5foMs\\\";\\n\" +             \"\\n\" +             \"    //сложность корекция каждые n блоков\\n\" +             \"    int DIFFICULTY_ADJUSTMENT_INTERVAL = (int) (Seting.COUNT_BLOCK_IN_DAY / 2);\\n\" +             \"    int DIFFICULTY_ADJUSTMENT_INTERVAL_TEST = 10;\\n\" +             \"\\n\" +             \"    long BLOCK_GENERATION_INTERVAL = Seting.BLOCK_TIME * 1000;// after Seting.BLOCK_TIME\\n\" +             \"    long BLOCK_GENERATION_INTERVAL_TEST = 0 * 1000;\\n\" +             \"\\n\" +             \"    long INTERVAL_TARGET = 600000;\\n\" +             \"    long INTERVAL_TARGET_TEST = 25000;\\n\" +             \"\\n\" +             \"    // плата за обслуживание каждые 6 месяцев 0.4 /HALF_YEAR = 0.1, 0.4/HALF_YEAR = 0.2\\n\" +             \"    Double ANNUAL_MAINTENANCE_FREE_DIGITAL_DOLLAR_YEAR = 0.2;\\n\" +             \"    //отрицательная ставка для цифровой акции\\n\" +             \"    double ANNUAL_MAINTENANCE_FREE_DIGITAL_STOCK_YEAR = 0.4;\\n\" +             \"    //каждые сколько месяцев снимать\\n\" +             \"    int HALF_YEAR = 2;\\n\" +             \"\\n\" +             \"    //стоимость создания закона\\n\" +             \"    double COST_LAW = 144;\\n\" +             \"    //с чего начинается адресс пакета закона\\n\" +             \"    //сокращенно корпорация\\n\" +             \"    String NAME_LAW_ADDRESS_START = \\\"LIBER\\\";\\n\" +             \"\\n\" +             \"    int HASH_COMPLEXITY_GENESIS = 1;\\n\" +             \"\\n\" +             \"    //совет акционеров\\n\" +             \"   int BOARD_OF_SHAREHOLDERS = 1000;\\n\" +             \"\\n\" +             \"\\n\" +             \"    //    адресс основателя: здесь будет мой адресс. Сейчас заглушка\\n\" +             \"    String ADDRESS_FOUNDER_TEST = \\\"stExZb8ifLfnFoq4JJuTifpAcscegATH8znhwW26zyTa\\\";\\n\" +             \"    String ADDRESS_FOUNDER = \\\"stExZb8ifLfnFoq4JJuTifpAcscegATH8znhwW26zyTa\\\";\\n\" +             \"\\n\" +             \"    String CORPORATE_CHARTER = International_Trade_Union.CorporateCharter.CorporateCharter.getAllConstitution() + \\\"\\\\n\\\" + CorporateCharter.getAllConstitution() + AboutUsDraft.getAboutUs()\\n\" +             \"            + AboutUsEngDraft.getAboutUs();\\n\" +             \"\\n\" +             \"    //начальная сумма основателя\\n\" +             \"    Double FOUNDERS_REMUNERATION_DIGITAL_DOLLAR = 30000000.0;\\n\" +             \"    double FOUNDERS_REMNUNERATION_DIGITAL_STOCK = 30000000.0;\\n\" +             \"    \\n\" +             \"\\n\" +             \"    // сколько секунд в сутках\\n\" +             \"    int DAY_SECOND = 86400;\\n\" +             \"\\n\" +             \"    //    за сколько секунд добывается каждый блок\\n\" +             \"    int BLOCK_TIME = 150;\\n\" +             \"\\n\" +             \"\\n\" +             \"    //сколько блоков добывается в сутки\\n\" +             \"    double COUNT_BLOCK_IN_DAY = (DAY_SECOND / BLOCK_TIME);\\n\" +             \"\\n\" +             \"    //подсчет голосов для должности в годах\\n\" +             \"    int POSITION_YEAR_VOTE = (int) Seting.COUNT_BLOCK_IN_DAY * YEAR * 3;\\n\" +             \"    //подсчет голосов для законов в годах\\n\" +             \"    int LAW_YEAR_VOTE = (int) Seting.COUNT_BLOCK_IN_DAY * YEAR * 3;\\n\" +             \"double DIGITAL_DOLLAR_REWARDS_BEFORE = 200.0;\\n\" +             \"    double DIGITAL_STOCK_REWARDS_BEFORE = 200.0;\\n\" +             \"    double DIGITAL_DOLLAR_FOUNDER_REWARDS_BEFORE = Math.round(UtilsUse.countPercents(Seting.DIGITAL_DOLLAR_REWARDS_BEFORE, Seting.FOUNDERS_REWARD));\\n\" +             \"    double DIGITAL_REPUTATION_FOUNDER_REWARDS_BEFORE = Math.round(UtilsUse.countPercents(Seting.DIGITAL_STOCK_REWARDS_BEFORE, Seting.FOUNDERS_REWARD));\";        }","package International_Trade_Union.CorporateCharterDraft;  /**устарел(недействителен), является черновиком, но его хеш используется в генезис блоке.  Но с помощью новых законов можно добавить те части которые будут интересны и сделать их действительным законом, если  данные части не противоречат действующему уставу и действующим законам.  */ public interface ArticleSixBillOfRightsDraft {     String SECTION_1 = \"Ни один орган данной корпорации или субъект не должен запрещать свободное исповедание \" +             \"какой-либо религии; или ограничивать свободу слова, совести или печати;\" +             \" или право людей мирно собираться или объединяться друг с другом, или не объединяться друг с другом, и \" +             \"обращаться к руководству Корпорации Международного Торгового Союза и к данной корпорации с ходатайством об удовлетворении жалоб;\" +             \" или нарушать право на плоды своего труда или \" +             \"право на мирную жизнь по своему выбору. Свободы слова и совести включают свободу вносить вклад в \" +             \"политические кампании или кандидатуры на корпоративные должности и должны толковаться как\" +             \" распространяющиеся в равной степени на любые средства коммуникации.\";      String CHAPTER_2 = \"Ни одно лицо в мирное время не может быть расквартирован в каком-либо доме без согласия владельца,\" +             \" а также во время форсмажорных обстоятельств, кроме как в порядке, установленном законом. \" +             \"Это положение применяется в равной степени на всей територии Корпорации Международного Торгового Союза.\";       String CHAPTER_3 = \"Право людей на защиту своих лиц, перемещений, личных данных, домов, документов,\" +             \" данных и вещей от необоснованных обысков и конфискаций не должно нарушаться, \" +             \"и никакие ордера не должны выдаваться, кроме как при наличии достаточных оснований, \" +             \"подкрепленных присягой. или утверждение, в частности описание места, лиц или вещей,\" +             \" подлежащих обыску или конфискации. Это положение применяется в равной степени на всей \" +             \"територии Корпорации международного Торгового Союза.\";      String CHAPTER_4 = \"Ни одно лицо не может быть привлечено к ответственности за какое-либо\" +             \" уголовное преступление, кроме как по представлению или обвинению Большого жюри, \" +             \"за исключением случаев\" +             \" или общественной опасности; ни одно лицо не может подвергаться опасности для жизни или\" +             \" здоровья дважды за одно и то же преступление; ни \" +             \"в каком уголовном деле он не может быть принужден свидетельствовать против самого себя,\" +             \" а также не может быть лишен жизни, свободы или имущества без надлежащей правовой процедуры;\" +             \" частная собственность не может быть изъята для общественного пользования без справедливой компенсации,\" +             \" выплаченной в течение разумного периода времени. Это положение применяется в равной степени как на всей\" +             \"територии Корпорции Международного Торгового Союза.\" ;      String CHAPTER_5 = \"Во всех уголовных делах обвиняемый имеет право на быстрое и открытое судебное разбирательство\" +             \" беспристрастным судом присяжных того штата и округа, где было совершено преступление,\" +             \" район которого должен быть предварительно установлен законом, \" +             \"и быть информированным о характер и причина обвинения; встретиться со свидетелями против него;\" +             \" иметь обязательный процесс для получения свидетелей в свою пользу и иметь помощь адвоката для своей защиты.\" +             \" данная корпроация должно нести бремя демонстрации ясными и убедительными доказательствами того, \" +             \"что любой отказ от таких прав должен быть осознанным, разумным и добровольным.\";      String CHAPTER_6 = \"В исках по общему праву право на рассмотрение дела присяжными должно быть \" +             \"таким же, как и в штате, где заседают присяжные, \" +             \"и ни один факт, рассматриваемый присяжными, \" +             \"не может быть повторно рассмотрен в каком-либо суде Корпорации Международного Торгового Союза иначе,\" +             \" чем в соответствии с правилами общего права. \" +             \"В состязательных разбирательствах, когда на карту поставлены основные человеческие потребности, \" +             \"такие как те, которые касаются крова, средств к существованию, безопасности, депортации,\" +             \" здоровья или опеки над детьми, должен быть предоставлен компетентный адвокат,\" +             \" и разумные расходы на такого адвоката оплачиваются Корпорорацие Международного Торгового Союза правительством, \" +             \"правительствами штатов и территорий. государственные расходы малоимущим.\";      String CHAPTER_7 = \"Не могут применяться жестокие, необычные или чрезмерные наказания или штрафы, а также не может\" +             \" требоваться чрезмерный залог. Наказание смертной казнью, пожизненным заключением или эквивалентным сроком\" +             \" лишения свободы запрещается. Это положение применяется в равной степени на всей територии Корпорации Международного\" +             \" Торгового Союза.\";      String CHAPTER_8 = \"Ни рабство, ни подневольный труд не должны существовать в Корпорации Международного\" +             \" Торгового Союза или в любом другом месте, находящемся под их юрисдикцией.\" +             \"Корпорация Международного Торгового Союза\" +             \" имеет право обеспечить соблюдение этой статьи посредством соответствующего законодательства.\\n\" +             \"\\n\" +             \" \";      String CHAPTER_9 = \"Все лица, родившиеся или натурализованные на територии штатов входящих в Международный Торговый Союз а также их родители\" +             \"и дети и братья и сестры являются гражданами и членами Корпорации Международного Торгового Союза\" +             \" и штата, в котором они проживают.  Корпорация Международного Торгового Союза, \" +             \"ни  не должны принимать или применять какой-либо закон, который \" +             \"ущемляет естественные или гражданские права граждан корпорации Международного Торгового Союза; или лишить любого человека\" +             \" свободы или собственности без надлежащей правовой процедуры; или отказывать любому лицу в пределах своей \" +             \"юрисдикции в равной защите закона.\\n\" +             \"\\n\" +             \"Использование слов «он» и «его» в настоящей кодексе распространяется на всех лиц.\";      String CHAPTER_10 = \"Надлежащая правовая процедура должна толковаться как предоставление возможности представить\" +             \" доказательства или иным образом показать, что закон, постановление или приказ является нарушением таких прав любого \" +             \"гражданина или законного резидента Корпорации  Международного Торгового Союза, и сторона, защищающая оспариваемый закон,\" +             \" постановления или распоряжения несут бремя установления их основы в законе и в соответствии с настоящим Уставом. \" +             \"Ни одно лицо не может быть подвергнуто уголовному наказанию без судебного разбирательства,\" +             \" направленного на установление того, виновно ли это лицо в нарушении законно принятого статута,\" +             \" принятие которого находится в пределах надлежащих полномочий Международного Торгового Союза\" +             \" или законодательного собрания штата.\" +             \" Все лица предположительно свободны пользоваться своей жизнью, \" +             \"свободой или имуществом и распоряжаться ими по своему усмотрению, и всякий раз,\" +             \" когда Корпорация международный Торговый Союз нарушает это право,\" +             \" и любое лицо требует возмещения ущерба,\";      String CHAPTER_11 = \"Право голоса граждан Корпорации Межудународного Торгового Союза в возрасте восемнадцати лет и старше не может быть\" +             \" ограничено или ограничено Международным Торговым Союзом на всей територии ,\" +             \" за исключением случаев наказания за преступление, \" +             \"сторона которого должна иметь был должным образом осужден. Междунродный Торговый Союз или любое \" +             \" Любой гражданин, временно проживающий в нежилом районе, являющемся резиденцией правительства \" +             \"Международного Торгового Союза, считается гражданином штата, откуда он прибыл.\";       String CHAPTER_12 = \"Право людей покупать и продавать законные товары и услуги на взаимоприемлемых условиях\" +             \" не должно нарушаться Межданародным Торговым Союзом или правительством любого штата или племени.\" +             \"Только частное лицо в праве устанавливать цены на свои товары и услуги выставленые на продажу\" +             \", ни Корпорация Международного Торгового Союза, ни правительство штатов не имеет права ни какими законами, указами,\" +             \"резолюциями или любыми другими способами регулировать цены на товары или услуги частных лиц.\" +              \" Только лицо которое нанимает работника может устанавливать заработную плату, если\" +             \"нанимаемый согласился добровольно работать по контракту за данную заработную плату, то это законно. \" +             \"Ни Корпорация Международного Торгового Союза ни Правительство штата никами законами, резолюциями, указами или другими способами\" +             \"не имеет регулировать заработную плату если был добровольный контракт между работадателем\" +             \"или рабодадателями и нанимаемым, или нанимаемыми\";      String CHAPTER_13 = \"Корпорация Международный Торговый Союз имеет право устанавливать законные основания для возбуждения\" +             \" иска в связи с нарушением настоящей статьи.\";      String CHAPTER_14 = \"Все люди в равной степени свободны и независимы и обладают определенными\" +             \" естественными, неотъемлемыми и неотъемлемыми правами, которые они сохраняют при формировании любого правительства,\" +             \" среди которых пользование, защита и сохранение своей жизни и свободы, приобретение, владение и \" +             \"защита недвижимого и личного имущества. ,\" +             \" заключая обязывающие контракты по своему выбору и стремясь к своему счастью и безопасности.\" +             \" Перечисление в Данном Уставе корпорации определенных прав не должно толковаться как отрицание или умаление других прав, \" +             \"сохраняемых за народом, или придание этим перечисленным \" +             \"правам приоритета или более принудительного исполнения по сравнению с неперечисленными правами.\";      String CHAPTER_15 = \"Полномочия, прямо не делегированные  Международным Торговым\" +             \" Союзом Конституцией и не запрещенные ею штатам, сохраняются соответственно за штатами или за народом. \" +             \"И мы это имеем в виду.\";      String CHAPTER_16 = \"Любое лицо которое находиться на территории подконтрольной  Международному Торговому Союзу,\" +             \" имеет право легально работать и заниматься комерческой дейтейльностью, если\" +             \" данные действия нарушают действующие законы, с момента нахождения на территории подконтрольной Международного Торгового Союза.\";      String CHAPTER_17 = \"Запрет на применение всеми банками частичного банковского резервирования\" +             \"Все банки обязаны использовать обязательного полного банковского резервирования\";      String CHAPTER_18 = \"Любые законы Коропрации Международного Торгового Союза или законы штата не могут вводить квоты. Запрещено\" +             \"применение механизма квотирования Корпорацией Международного Торгового Союза или правительством штата.\" +             \"также запрещено тарифные квоты.\";      String CHAPTER_19 = \"любое снижение правил для бизнеса должно касаться всех участников для бизнеса, не выделяя отдельные \" +            \"компании, корпорации и т.д. Ни Корпорация Международного Торгового Союза, ни правительство Штата не может давать любые исключительные \" +            \"привелегии или создавать фаворитов.\";       String CHAPTER_20 = \"Любое лицо которое легально прожило на территории подконтрольной Международного торгового Союза три и более лет,\" +                     \" признается гражданином, Корпорации Международного Торгового Союза. \" +             \"Также жителем Международного Торгового Союза признается лица входящие в \" +                     \"руководство данной корпорации.\" +             \" Любое лицо хотя бы один раз создавшее через механизм данной криптовалюты закон, и заплатившее\" +             \"вознаграждение майнеру за созданный закон \" +             \"(на данный момент цена 144 цифровых доллара) также является гражданином Корпорации Международного\" +             \"Торгового Союза.\" +                     \". Также любое лицо которое получило гражданство, \" +                     \"также сразу имеют право получить  его близкие родственики,\" +                     \"в которые входят родители, дети, братья и сестры, а также дедушки и бабушки. Гражданам разрешается обладать\" +             \" гражданством нескольких стран или обладать гражданством нескольких похожих на данную корпорацию.\";      String CHAPTER_21 = \"Ни Международный Торговый Союз, ни правительство штата или иные государственные учреждения\" +             \" не могут регулирвать процентные ставки частных банков. Каждый частный банк сам в праве где хранить свои денежные \" +             \"средства и устанавливать процентные ставки\" +             \"и золото и любые свои ресурсы. Корпорация Международный Торговый Союз не имеет права требовать от банков хранить их средства \" +             \"в хранилищях принадлежащих данной корпорации, но они могут это сделать добровольно\";      String CHAPTER_22 = \"Везде где говориться федеральное правительство, имеется виду Корпорация Международный Торговый Союз и его ветви власти\";      String CHAPTER_23 = \"Все граждане, члены и акционеры Корпорации Международного Торгового Союза\" +             \" должны иметь право свободно передвигаться между штатами,\" +             \"все граждане членов союза должны иметь право свободно перевозить любые сумы денег между штатами.\" +             \"Все граждане должны иметь право свободно устраиваться на работу и заниматься комерческой дейтейльностью внутри штатов членов союза и иметь\" +             \"право свободно предоставлять свои товары и услуги.\";      String CHAPTER_24 = \"Кто может быть членом корпорации должно быть определено действующими законами. Корпорация Международного \" +             \"Торгового Союза может предоставлять специальные услуги своим членам, а также своим акционерам. Членами являются\" +             \"также все члены Совета Акционеров и Занимающие Специальные должности. При условии что специальные услуги не нарушают\" +             \"Устав и действующие законы\";  }","package International_Trade_Union.CorporateCharterDraft;  /**устарел(недействителен), является черновиком, но его хеш используется в генезис блоке.  Но с помощью новых законов можно добавить те части которые будут интересны и сделать их действительным законом, если  данные части не противоречат действующему уставу и действующим законам.  */ public interface ArticleThreeJudiciaryDraft {      //Статья 3 Судебная власть.     String Article_3_Judiciary = \"Судебная власть Корпорации Международного Торгового Союза принадлежит\" +             \" одному Верховному суду и таким нижестоящим судам, которые Корпорация Международный \" +             \"Торговый Союз может время от времени издавать и учреждать.\" +             \" Судьи как верховных, так и нижестоящих судов занимают свои должности при хорошем поведении и \" +             \"в установленные сроки получают за свои услуги вознаграждение.\";      String CHAPTER_2 = \"Судебная власть распространяется на все дела по закону и справедливости, \" +             \"в том числе инициированные членами для оспаривания незаконного расходования средств,\" +             \" возникающего в соответствии с настоящем Уставом, законами Корпорации Международного Торгового Союза и договорами,\" +             \" заключенными или которые будут заключены в соответствии с их авторитет; ко всем делам, касающимся послов, \" +             \"других государственных министров и консулов; ко всем делам адмиралтейства и морской юрисдикции; к спорам, \" +             \"в которых Международный Торговый Союз будут стороной; к разногласиям между двумя или более государствами; \" +             \"между государством и людьми; между племенным правительством и гражданами этого племени;\" +             \" между гражданами разных государств, между гражданами одного государства, претендующими на земли,\" +             \"\" +             \" предоставленные разными государствами, а также между государством или его гражданами и иностранными государствами,\" +             \"\" +             \" гражданами или подданными. А также между всеми членами Корпорации Международного Торгового Союза\\n\" +             \"\\n\" +             \"Во всех делах, касающихся послов, других государственных министров и консулов, а также в спорах, \" +             \"затрагивающих два или более штатов, Верховный суд принимает первоначальную юрисдикцию. Во всех других случаях,\" +             \" упомянутых выше, Верховный суд обладает апелляционной юрисдикцией, как в отношении закона, так и в отношении фактов,\" +             \" с такими исключениями и в соответствии с такими правилами, которые будут приняты Конгрессом.\\n\" +             \"\\n\" +             \"Суд над всеми преступлениями осуществляется судом присяжных;\" +             \" и такое судебное разбирательство должно проводиться в штате, где были совершены указанные преступления;\" +             \" но когда дело не совершено в каком-либо штате, судебное разбирательство должно проводиться в таком месте или местах,\" +             \" которые Корпорация Международного Торгового Союза может установить по закону.\\n\" +             \"\\n\" +             \"Ни один суд не должен быть тайным, но правосудие должно вершиться открыто и бесплатно, полностью и безотлагательно,\" +             \" и каждый человек должен иметь правовую правовую защиту от вреда, причиненного жизни, свободе или имуществу.\" +             \"Верховный Суд CORPORATE_SUPREME_COURT\";      }","package International_Trade_Union.CorporateCharterDraft;  /**устарел(недействителен), является черновиком, но его хеш используется в генезис блоке.  Но с помощью новых законов можно добавить те части которые будут интересны и сделать их действительным законом, если  данные части не противоречат действующему уставу и действующим законам.  */public interface ArticleTwoSpecialPositionDraft {  String SECTION_1 = \" любое лицо может занимать специальные высшие должности\" +          \". Все Специальные должности и членство в Совете Акционеров\" +          \" могут занимать как физические, так и юридические лица.\";       String CHAPTER_2 = \" Совет директоров BOARD_OF_DIRECTORS Корпорации Международного\" +             \" Торгового Союза осуществляет общее руководство деятельностью, детали данной дейтельности должны быть\" +             \" описаны принятыми и действующими законами. Обязаности и полномочия совета директоров, как и других HigherSpecialPositions\" +             \" и других руководящих органов должны быть описаны действующими законами,\" +              \" Избраный совет директоров как описано в даном уставе, должен рукодоводить данной системой,\" +             \"для общего блага всех участников данной системы и ее граждан. Совет директоров это колективный\" +             \"орган исполнительной власти в данной системе.\" +              \"Любое решение совет директоров должен принимать большинством голосов среди действующих членов совета директоров совета директоров.\" +             \"Ни одно решение совета директоров не должно нарушать устав или действующие законы Корпорации Международного Торгового Союза,\" +             \"Ни один орган или специальные должности не имеет права нарушать устав или действующие законы.\";      String CHAPTER_3 = \"\" +             \"Все должности  HigherSpecialPositions внутри каждой группы равнозначны и должны колективные решения принимать \" +             \"большинством голосов.\" +             \"DEPARTMENT_OF_CORPORATE_JOURNALISTS отдел корпоративных журналистов занимается независимым \" +             \" информированием членов Корпорации Международного Торгового Союза о происходящих событиях.\";      String CHAPTER_4 = \" Большинство специальных должностей HigherSpecialPositions которые описаны здесь , и их \" +             \"полномочия и обязаности,\" +             \" и их иерахия должны определяться действующими законами (между разными должностями), с учетом целей и\" +             \" приоритетов текущей реальности и\" +             \" потребностей Корпорации Международного Торгового Союза. Каждая такая должность является руководством, но иерархия\" +             \"данного руководства должна определяться действующими законами(имеется ввиду иерархия между должностями).\" +             \"Но внутри одной группы должностей, все должности равны. (Пример члены совета директоров равны.)\";     }","package International_Trade_Union.CorporateCharterDraft; /**устарел(недействителен), является черновиком, но его хеш используется в генезис блоке.  Но с помощью новых законов можно добавить те части которые будут интересны и сделать их действительным законом, если  данные части не противоречат действующему уставу и действующим законам.  */ public class CorporateCharter {      public  static  String getAllConstitution(){         String corporateCharter = PreambleDraft.ARTICLE_0 + \"\\n\";         //Статья I: Законодательная власть         String articleOneLegistrature = ArticleOneLegistratureDraft.SECTION_1;         articleOneLegistrature += \"\\n\" + ArticleOneLegistratureDraft.CHAPTER_2;         articleOneLegistrature += \"\\n\" + ArticleOneLegistratureDraft.CHAPTER_3;         articleOneLegistrature += \"\\n\" + ArticleOneLegistratureDraft.CHAPTER_4;         articleOneLegistrature += \"\\n\" + ArticleOneLegistratureDraft.CHAPTER_5;         articleOneLegistrature += \"\\n\" + ArticleOneLegistratureDraft.CHAPTER_6;         articleOneLegistrature += \"\\n\" + ArticleOneLegistratureDraft.CHAPTER_7;         articleOneLegistrature += \"\\n\" + ArticleOneLegistratureDraft.CHAPTER_8;         articleOneLegistrature += \"\\n\" + ArticleOneLegistratureDraft.CHAPTER_9;         articleOneLegistrature += \"\\n\" + ArticleOneLegistratureDraft.CHAPTER_10;         articleOneLegistrature += \"\\n\" + ArticleOneLegistratureDraft.CHAPTER_11;         articleOneLegistrature += \"\\n\" + ArticleOneLegistratureDraft.CHAPTER_12;         articleOneLegistrature += \"\\n\" + ArticleOneLegistratureDraft.CHAPTER_13;         articleOneLegistrature += \"\\n\" + ArticleOneLegistratureDraft.CHAPTER_14;         articleOneLegistrature += \"\\n\" + ArticleOneLegistratureDraft.CHAPTER_15;         articleOneLegistrature += \"\\n\" + ArticleOneLegistratureDraft.CHAPTER_16;         articleOneLegistrature += \"\\n\" + ArticleOneLegistratureDraft.CHAPTER_17;         articleOneLegistrature += \"\\n\" + ArticleOneLegistratureDraft.CHAPTER_18;         articleOneLegistrature += \"\\n\" + ArticleOneLegistratureDraft.CHAPTER_19;         articleOneLegistrature += \"\\n\" + ArticleOneLegistratureDraft.CHAPTER_20;         corporateCharter += \"\\n\" + articleOneLegistrature;          //Часть II: Исполнительная власть         String spectialPosition = ArticleTwoSpecialPositionDraft.SECTION_1;         spectialPosition += \"\\n\" + ArticleTwoSpecialPositionDraft.CHAPTER_2;         spectialPosition += \"\\n\" + ArticleTwoSpecialPositionDraft.CHAPTER_3;         spectialPosition += \"\\n\" + ArticleTwoSpecialPositionDraft.CHAPTER_4;         corporateCharter += \"\\n\" + spectialPosition;          //Статья III: Судебная власть         String articleThreeJudiciary = ArticleThreeJudiciaryDraft.Article_3_Judiciary;         articleThreeJudiciary += \"\\n\" + ArticleThreeJudiciaryDraft.CHAPTER_2;         corporateCharter += \"\\n\" + articleThreeJudiciary;           //Статья 4: Процесс внесения поправок         String articleFiveAmendmentProcess = ArticleFourAmendmentProcessDraft.CHAPTER_1;         corporateCharter += \"\\n\" + articleFiveAmendmentProcess;           //Статья 5: Конституционное верховенство         String articleSixConstitutionalSupremacy = ArticleFiveCharterSupremacyDraft.CHAPTER_1;         articleSixConstitutionalSupremacy += \"\\n\" + ArticleFiveCharterSupremacyDraft.CONSTITUTIONAL_SUPERMACY;         corporateCharter += \"\\n\" + articleSixConstitutionalSupremacy;          //Статья 6: Билль о правах         String articleSevenBillOfRights = ArticleSixBillOfRightsDraft.SECTION_1;         articleSevenBillOfRights += \"\\n\" + ArticleSixBillOfRightsDraft.CHAPTER_2;         articleSevenBillOfRights += \"\\n\" + ArticleSixBillOfRightsDraft.CHAPTER_3;         articleSevenBillOfRights += \"\\n\" + ArticleSixBillOfRightsDraft.CHAPTER_4;         articleSevenBillOfRights += \"\\n\" + ArticleSixBillOfRightsDraft.CHAPTER_5;         articleSevenBillOfRights += \"\\n\" + ArticleSixBillOfRightsDraft.CHAPTER_6;         articleSevenBillOfRights += \"\\n\" + ArticleSixBillOfRightsDraft.CHAPTER_7;         articleSevenBillOfRights += \"\\n\" + ArticleSixBillOfRightsDraft.CHAPTER_8;         articleSevenBillOfRights += \"\\n\" + ArticleSixBillOfRightsDraft.CHAPTER_9;         articleSevenBillOfRights += \"\\n\" + ArticleSixBillOfRightsDraft.CHAPTER_10;         articleSevenBillOfRights += \"\\n\" + ArticleSixBillOfRightsDraft.CHAPTER_11;         articleSevenBillOfRights += \"\\n\" + ArticleSixBillOfRightsDraft.CHAPTER_12;         articleSevenBillOfRights += \"\\n\" + ArticleSixBillOfRightsDraft.CHAPTER_13;         articleSevenBillOfRights += \"\\n\" + ArticleSixBillOfRightsDraft.CHAPTER_14;         articleSevenBillOfRights += \"\\n\" + ArticleSixBillOfRightsDraft.CHAPTER_15;         articleSevenBillOfRights += \"\\n\" + ArticleSixBillOfRightsDraft.CHAPTER_16;         articleSevenBillOfRights += \"\\n\" + ArticleSixBillOfRightsDraft.CHAPTER_17;         articleSevenBillOfRights += \"\\n\" + ArticleSixBillOfRightsDraft.CHAPTER_18;         articleSevenBillOfRights += \"\\n\" + ArticleSixBillOfRightsDraft.CHAPTER_19;         articleSevenBillOfRights += \"\\n\" + ArticleSixBillOfRightsDraft.CHAPTER_20;         articleSevenBillOfRights += \"\\n\" + ArticleSixBillOfRightsDraft.CHAPTER_21;         articleSevenBillOfRights += \"\\n\" + ArticleSixBillOfRightsDraft.CHAPTER_22;         articleSevenBillOfRights += \"\\n\" + ArticleSixBillOfRightsDraft.CHAPTER_23;         articleSevenBillOfRights += \"\\n\" + ArticleSixBillOfRightsDraft.CHAPTER_24;         corporateCharter += \"\\n\" + articleSevenBillOfRights;           return corporateCharter;     } }","package International_Trade_Union.CorporateCharterDraft; /**устарел(недействителен), является черновиком, но его хеш используется в генезис блоке.  Но с помощью новых законов можно добавить те части которые будут интересны и сделать их действительным законом, если  данные части не противоречат действующему уставу и действующим законам.  */ public interface PreambleDraft {     String ARTICLE_0 = \" Корпорпация Международнодного Торгового Союза, создана с целью развития международной торговли.\" +             \" Корпорация Международного Торгового Союза ставит своей целью предоставление экосистемы, а также своей продукции \" +             \" и услуг, которые облегчают торговлю и при этом не нарушая естественных прав человека. \" +             \"Корпорация Международного Торгового Союза это форма демократии, где голоса приравниваются количеству акций,\" +             \"такая форма позволяет учитывать вклад каждого в развитие данного сообщества, таким образом создавая условие\" +             \"где все участники заинтиресованы в развитии данного сообщества. Как так каждый участник становиться заинтересованым\" +             \"лицом, и каждый хочет что бы благосостояние данного общества процветало.\";   }","package International_Trade_Union.CorporateCharterEngDraft; /**устарел(недействителен), является черновиком, но его хеш используется в генезис блоке.  Но с помощью новых законов можно добавить те части которые будут интересны и сделать их действительным законом, если  данные части не противоречат действующему уставу и действующим законам.  */ public interface ArticleFiveCharterSupremacyEngDraft {     String CHAPTER_1 = \"All debts and obligations entered into prior to the adoption of these Articles shall have this\" +             \"the same force against those members who have joined\" +             \"to the International Trade Union in accordance with these Articles, as before.\" +             \"The present Articles and laws in force of the Corporation of the International Trade Union, which shall be enacted in pursuance of it;\" +             \"and all contracts entered into or to be entered into under the authority of the Corporation of the International Trade Union,\" +             \"are the supreme law of the Corporation of the International Trade Union;\" +             \" and the judges in the territory belonging to the members of the Corporation of the International Trade Union must be bound by this, despite the \" +             \"nothing in\" +             \" rules or laws of any member to the contrary.\\n\" +             \"\\n\" +             \"but no religious test should ever be required as a qualification for any position\" +             \"or the Corporate Fund to the Corporation of the International Trade Union.\";      String CONSTITUTIONAL_SUPERMACY = \"The ratification of these Articles of Association occurs as soon as three hundred or more members of the Board of Shareholders are elected,\"; }","package International_Trade_Union.CorporateCharterEngDraft; /**устарел(недействителен), является черновиком, но его хеш используется в генезис блоке.  Но с помощью новых законов можно добавить те части которые будут интересны и сделать их действительным законом, если  данные части не противоречат действующему уставу и действующим законам.  */ public interface ArticleFourAmendmentProcessEngDraft {     String CHAPTER_1 = \"Any amendments can only be made after five years since the founding of this cryptocurrency (beginning on January 20, 2023).\" +             \"Every time, two-thirds of the Board of Shareholders voted, but on the condition that the current law is created in half a year\" +             \"before the introduction of amendments and there it will be described how amendments will be made and what amendments are proposed to be made,\" +             \"but if the law was not valid at the moment\" +             \"beginning of the voting date of the amendments, then the amendments are not valid. \" +             \"deem it necessary, they may propose amendments to these Bylaws, which shall in any event be in force\" +             \"for all intents and purposes, as part of these Bylaws, when the Chief Justice of the International Trade Union Corporation\" +             \"certifies that it has been ratified by the current Board of Shareholders.\" +             \"provided that no member of the current Board of Shareholders, without his consent, can be deprived of an equal \" +             \"suffrage (one account of a member of the Board of Shareholders, one vote.) Also, the amendments should not restrict the rights (Article 7) of citizens or\" +             \"all members of the International Trade Union Corporation. Voting must be done through this platform,\" +             \"the voting time should be six months. (First, you need to implement a voting mechanism within this network, I could not implement it,\" +             \"so that all shareholders have the right to vote. So implement this part yourself.)\" +             \"\" +             \"It is allowed to introduce any improvements to the code of this system, if it is approved by the current law, without amendments to the charter\" +             \"provided that these changes do not violate\" +             \"The charter of this corporation and do not change the charter itself, and also comply with the charter and applicable laws. As well as the current \" +             \"rules for making laws and creating officials, including negative rates and others\" +             \"the rules described in this statute.\"; }","package International_Trade_Union.CorporateCharterEngDraft; /**устарел(недействителен), является черновиком, но его хеш используется в генезис блоке.  Но с помощью новых законов можно добавить те части которые будут интересны и сделать их действительным законом, если  данные части не противоречат действующему уставу и действующим законам.  */ public interface ArticleOneLegistratureEngDraft {     String SECTION_1 = \"All legislative authority granted here is vested in the Corporation \" +             \"International Trade Union, which consists of the Board of Shareholders and HigherSpecialPositions and all other members\" +             \"who are entitled to vote in accordance with these Statutes.\" +             \" All laws are created through the International Trade Union Corporation's cryptocurrency mechanism as described here \" +             \"rules.\" +             \"All the powers granted by this Charter, as well as existing laws that do not contradict this charter\" +             \"are legitimate.\" +             \"The only advantage of the board of directors over the rest of the participants in this system and its\" +             \"citizens, is only the fact that they have 10% more votes. And also the right to introduce amendments\" +             \"as described in this statute\";      String CHAPTER_2 = \"The Board of Shareholders consists of one thousand accounts(1000),\" +             \"accounts with the most digital stocks digitalStockBalance.\" +             \"But this list is selected from all accounts that were active at least once, i.e. senders or miners during\" +             \"of one year (the current year is one year, and if the activity was within this range.), but\" +             \"if more than a year has passed since the last activity, then this account is not taken into account in the selection\" +             \"of the Shareholders' Council. This is necessary so that if an account is suddenly lost, then this does not affect the system, since \" +             \"only active members and only active members can be Shareholders.\" +             \"Recalculation of members of the Board of Shareholders occurs every block and is determined by each block.\" +             \" when voting through the mechanism of this cryptocurrency, their votes (digital shares) are multiplied by a multiplier of 1.10 \" +             \"which gives them ten percent more\" +             \"votes in the creation of the law within the framework of this\" +             \"cryptocurrencies (when voting through the mechanism of this cryptocurrency)\" +             \"Absolutely any person (Legal, Physical, Digital Person-Artificial Intelligence, etc.)\" +             \" may be a member of the Board of Shareholders (regardless of citizenship, nationality, gender, etc. or any \" +             \"other signs) or even any state can act as a member of the Board of Shareholders.\" +             \"\" +             \"Algorithm for Election of the Board of Shareholders:\" +             \" //determining the board of shareholders\\n\" +             \" public static List<Account> findBoardOfShareholders(Map<String, Account> balances, List<Block> blocks, int limit) {\\n\" +             \"List<Block> minersHaveMoreStock = null;\\n\" +             \" if(blocks.size() > limit){\\n\" +             \" minersHaveMoreStock = blocks.subList(blocks.size() - limit, blocks.size());\\n\" +             \"}\\n\" +             \"else {\\n\" +             \"minersHaveMoreStock = blocks;\\n\" +             \"}\\n\" +             \" List<Account> boardAccounts = minersHaveMoreStock.stream().map(\\n\" +             \" t->new Account(t.getMinerAddress(), 0, 0))\\n\" +             \" .collect(Collectors.toList());\\n\" +             \"\\n\" +             \" for (Block block : minersHaveMoreStock) {\\n\" +             \" for (DtoTransaction dtoTransaction : block.getDtoTransactions()) {\\n\" +             \" boardAccounts.add(new Account(dtoTransaction.getSender(), 0, 0));\\n\" +             \"}\\n\" +             \"}\\n\" +              \" CompareObject compareObject = new CompareObject();\\n\" +             \" List<Account> boardOfShareholders = balances.entrySet().stream()\\n\" +             \" .filter(t->boardAccounts.contains(t.getValue()))\\n\" +             \" .map(t -> t.getValue()).collect(Collectors.toList());\\n\" +             \"boardOfShareholders = boardOfShareholders\\n\" +             \".stream()\\n\" +             \" .filter(t -> !t.getAccount().startsWith(Seting.NAME_LAW_ADDRESS_START))\\n\" +             \" .filter(t -> t.getDigitalStockBalance() > 0)\\n\" +             \" .sorted((f1, f2) -> {return compareObject.compare(f1, f2);})\\n\" +             \" .limit(Setting.BOARD_OF_SHAREHOLDERS)\\n\" +             \" .collect(Collectors.toList());\\n\" +             \" return boardOfShareholders;\\n\" +             \"}\" +             \"\" +             \"boardOfShareholdersController is sorted in descending order\" +             \" //sort in descending order\\n\" +             \" boardOfShareholders = boardOfShareholders.stream().sorted((f1, f2)\\n\" +             \" -> Double.compare(f2.getDigitalStockBalance(), f1.getDigitalStockBalance())).collect(Collectors.toList());\\n\";      String CHAPTER_3 = \"Any International Trade Union Corporation cryptocurrency account can create laws through the mechanism of this cryptocurrency.\" +             \"The Cost of Making Law\" +             \"one hundred and forty-four digital dollars (144) as a reward to the miner (the cost may be reduced through current law).\" +             \"The law created through the mechanism of this cryptocurrency\" +             \" is valid as long as \" +             \"he was voted\" +             \"five million one hundred and eighty-four thousand votes or more. The voting mechanism is as follows: Votes that voted FOR minus votes that voted\" +             \"AGAINST and\" +             \"the remainder must be greater than 5184000. This measure is intended not to\" +             \"votes against were lost (Example: if we take the classic mechanism of voting by shares,\" +             \"then if one participant has 51%, then the remaining 49% of the votes will not be taken into account.\" +             \"since no matter how the rest vote, it will not play a role. But in this one\" +             \" system subtracting from FOR - AGAINST > THRESHOLD, we get a situation where each vote \" +             \"important.). For normal accounts, the number of votes is equal to the number of digital shares at the moment, \" +             \"for members of the Board of Shareholders\" +             \" The number of votes is equal to the number of digital shares at the moment, multiplied by a multiplier of one and ten hundredths\" +             \" percent (1.10).\" +             \" Which gives members of the Board of Shareholders 10% more votes than they own digital shares. \" +             \"Each block is recalculating all the votes of those who voted for and against. As long as the number of votes is more than 5,184,000, the law is\" +             \" valid. \";      String CHAPTER_4 = \" The right to create laws through the mechanism of this cryptocurrency, \" +             \"as well as the right to vote for laws through the mechanism of this cryptocurrency have all legal entities and individuals who have \" +             \" an account in this cryptocurrency and satisfying the conditions for creating and voting in \" +             \"to this cryptocurrency of the International Trade Union Corporation.\" +             \"Only those votes that are less than three years old for laws and no more than three years old for HigherSpecialPositions count,\" +             \" but you can vote again to \" +             \"will update the voice. This measure is necessary for the security of the system, if suddenly the account was lost, then this voice will not work forever,\" +             \"But only a certain period of time.\" +             \"it also allows you to re-elect important officials and fight against lobbying for bad laws because bad laws\" +             \"do not get re-elected.\";      String CHAPTER_5 = \"HigherSpecialPositions These special positions are senior positions. All positions are \" +             \"described in this\" +             \" Bylaws are valid. (CORPORATE_SUPREME_COURT(18), DEPARTMENT_OF_CORPORATE_JOURNALISTS(15),\" +             \" BOARD_OF_DIRECTORS(16), MARKETING_DEPARTMENT(5), DEPARTMENT_OF_STRATEGIC_DEVELOPMENT_AND_PLANNING(5), PR_DEPARTMENT(5),\" +             \" DEPARTMENT_OF_FINANCE(5),DEPARTMENT_OF_HUMAN_RESOURCES(5)).\" +             \"To create new special top positions you need\" +             \"Create a law with a new job title, determine how many leadership positions will be created for that job.\" +             \"And also to determine its powers. This position and all its powers will be valid.\" +             \"as long as the law that created this position is in effect. \" +             \"In the event that the law on the office has become invalid\" +             \", then this position loses all its powers. If again this law is not renewed or a similar law is created\" +             \"for a canceled position. The positions that are described in the charter are always valid, but their powers may\" +             \"change depending on the laws in force that describe these positions\" +             \"How is a law passed that creates a new position and is not repealed within four weeks of its adoption, \" +             \"All miners must add this position to HigherSpecialPositions.\" +             \" \";      String CHAPTER_6 =             \" To take the Special position HigherSpecialPositions you need to create a law with the name of the package which \" +                     \" coincides with the name of the current position. The address of the sender (creator) must be entered as the first line of the law \" +                     \"of this law. The address of the creator must match the address that is written in this law.\" +                     \" The second line can be filled with contact details or useful information about who is applying for \" +                     \" this position. The account will take office as soon as this package of law is approved with those \" +                     \"the same conditions as for all laws in this cryptocurrency and he will be in office until\" +                     \"his application package for this position will be valid.\";        String CHAPTER_7 = \"In the case of several existing laws that contradict each other\" +             \", Chief Justice (appointed through the CORPORATE_SUPREME_COURT cryptocurrency)\" +             \"should give priority to those laws,\" +             \" who at the time of the trial has the largest number of votes, exceeding 5% \" +             \" from dissenting votes, but if \" +             \"there is no such superiority, then this issue must be resolved either with the help of a precedent that\" +             \"will remain in effect until there is a change in the number of votes or until the supreme judges who set the precedent\" +             \"are in their positions.\" +              \" The precedent is created by the vote of the supreme judges who, by a majority vote, determine what in the case \" +             \"as long as several conflicting laws are in effect and there is no 5% majority, then the court accepts that one\" +             \"or another law will be higher, over another, as long as parity in votes for the law is maintained and as long as the judges\" +             \"who voted for this law as the current and higher, of the contradictory but adopted through the mechanism\" +             \" of this cryptocurrency. If the composition of the judges has changed, those who voted for the law, then if the \" +             \"the parity of conflicting laws must be accepted again with the help of a precedent which of them is higher than the others\" +             \"contradictory.\" ;      String CHAPTER_8 = \"To create law through the International Trade Union Corporation's cryptocurrency mechanism\" +             \" Inside this cryptocurrency, Create an object of the Laws class, where packetLawName- is the name of the law package.\" +             \" List<String> laws - is a list of laws, String hashLaw - is the address of this package of laws and starts with LIBER.\" +             \" In order for a law to be included in the pool of laws, you need to create a transaction where the recipient is the hashLaw of this law and the reward \" +             \" miner is equal to one hundred and forty-four digital dollars of this cryptocurrency. After that, as the law gets into the block, it will be in the pool \" +             \"laws and it will be possible to vote for him.\";      String CHAPTER_9 = \"when sending \\\"digitalStockBalance\\\" to any balance, with VoteEnum.NO\" +             \"reduces the recipient's balance by the amount sent by the sender,\" +             \"This operation is needed to be able to lower the voices of the destructive members of the Corporation of the International Trade Union\" +             \"and also to remove a specific bill from the Board of Shareholders.,\" +             \"or reduce the political power of a particular account,\\n\" +             \"\\n\" +             \"when sending \\\"digitalStockBalance\\\" to any balance, with VoteEnum.YES\\n\" +             \"increases the recipient's balance by the amount sent by the sender,\" +             \"This operation is needed\" +             \" to add a specific account to the Board of Shareholders, or increase \" +             \"the political power of a particular account.\";      String CHAPTER_10 = \"All individuals may hold special senior positions.\" +             \"HigherSpecialPositions.\" +             \"Exemplary job code is described in GovernmentController.\" +             \"Each Special Position has a limited number.\" +             \" One account can take one place in the pool of one position, but \" +             \"One account can hold several positions if they are different and have different powers.\" +             \" (Example: CORPORATE_SUPREME_COURT(18),BOARD_OF_DIRECTORS(16) the same account can borrow one\" +             \" positions in each such group, but the account cannot occupy for example more than two positions in the position BOARD_OF_DIRECTORS\" +             \"or other special position).\" +             \"The requirements for the position are the same as for the current law, but there is a difference, an approximate algorithm is described here:\" +             \"1.creates a list of all balances.\" +             \"2. create a list of all laws.\" +             \"3. create lists named HigherSpecialPositions.\" +             \"THIS CODE CAN BE IMPROVED IF THE OPERATING PRINCIPLES ARE KEEPED, BUT THE IMPROVEMENT MUST BE\" +             \"FIRST CREATED IN THE VIEW OF THE CURRENT LAW, WHERE IT IS INDICATED WHAT CODE AND HOW THIS CODE WILL ACT\" +             \" //selects the position of vacancies\\n\" +             \" //selects the position of vacancies\\n\" +             \" class UtilsLaws public static List<LawEligibleForParliamentaryApproval> getPossions(List<LawEligibleForParliamentaryApproval> lawEligibleForParliamentaryApprovals, HigherSpecialPositions corporateSeniorPositions){\\n\" +             \"\\n\" +             \" List<LawEligibleForParliamentaryApproval> temporary = new ArrayList<>();\\n\" +             \"temporary = lawEligibleForParliamentaryApprovals.stream()\\n\" +             \" .filter(t->Objects.nonNull(t))\\n\" +             \" .filter(t->Objects.nonNull(t.getLaws()))\\n\" +             \" .filter(t->Objects.nonNull(t.getLaws().getLaws()))\\n\" +             \" .filter(t->Objects.nonNull(t.getLaws().getPacketLawName()))\\n\" +             \" .filter(t->Objects.nonNull(t.getName()))\\n\" +             \" .filter(t->Objects.nonNull(t.getLaws().getHashLaw()))\\n\" +             \" .sorted((f1, f2) -> Double.compare(f2.getAccount().getDigitalStockBalance(), f1.getAccount().getDigitalStockBalance()))\\n\" +             \" .filter(t-> t.getLaws().getPacketLawName().equals(corporateSeniorPositions.name()))\\n\" +             \" .limit(corporateSeniorPositions.getCount())\\n\" +             \" .collect(Collectors.toList());\\n\" +             \"return temporary;\\n\" +             \"\\n\" +             \"}\" +             \",\" +             \"4. Get a list of shareholders.\" +             \"5. Make sure the package—the law that acts as an office is valid, in the same way as ordinary laws.\" +             \"6. Next, sort each current position of the law in descending order, and select from them with the largest number\" +             \"Votes equal to the number for this position.\" +             \" //select votes above the limit\\n\" +             \"curentLawVotesEndBalance.put(corp.getKey(), curentLawVotesEndBalance.get(corp.getKey())\\n\" +             \" .stream().filter(t-> t.getVotes() >= Seting.ORIGINAL_LIMIT_MIN_VOTE)\\n\" +             \" .collect(Collectors.toList()));\\n\" +             \"\\n\" +             \" //select the number that corresponds to this position\\n\" +             \" List<CurrentLawVotesEndBalance> temporary = curentLawVotesEndBalance.get(corp.getKey()).stream().filter(\\n\" +             \"t->!t.getPackageName().equals(corp.getKey()))\\n\" +             \" .sorted(Comparator.comparing(CurrentLawVotesEndBalance::getVotes).reversed())\\n\" +             \" .limit(corp.getKey().getCount()).collect(Collectors.toList());\\n\" +             \"\\n\" +             \"currentLawVotesEndBalance.put(corp.getKey(), temporary);\" +             \"\" +             \"Any person can vote for participants applying for positions, but each person can apply for a position only for himself\" +             \"when applying for this position, the bill creates a law and the first line of the law is the same as the sender's bill.\" +             \"once a bill is on the list, everyone can vote for that bill, which approves the score specified\" +             \"there for this position. Current positions are selected in this way:\" +             \"GovernmentController corporateSeniorpositions\" +             \" Blockchain blockchain = Mining.getBlockchain(\\n\" +             \" Seting.ORIGINAL_BLOCKCHAIN_FILE,\\n\" +             \"BlockchainFactoryEnum.ORIGINAL);\\n\" +             \"\\n\" +             \" //Getting balance\\n\" +             \" Map<String, Account> balances = new HashMap<>();\\n\" +             \"\\n\" +             \"balances = SaveBalances.readLineObject(Seting.ORIGINAL_BALANCE_FILE);\\n\" +             \"\\n\" +             \" //Finding a position\\n\" +             \" List<LawEligibleForParliamentaryApproval> allGovernment =\\n\" +             \"UtilsLaws.readLineCurrentLaws(Seting.ORIGINAL_ALL_CORPORATION_LAWS_WITH_BALANCE_FILE);\\n\" +             \"\\n\" +             \" //list of positions\\n\" +             \" Map<HigherSpecialPositions, List<LawEligibleForParliamentaryApproval>> positionsListMap = new HashMap<>();\\n\" +             \" //adding all posts\\n\" +             \" for (HigherSpecialPositions corporateSeniorPositions : HigherSpecialPositions.values()) {\\n\" +             \"positionsListMap.put(corporateSeniorPositions, UtilsLaws.getPossions(allGovernment, corporateSeniorPositions));\\n\" +             \"}\\n\" +             \"\\n\" +             \"\\n\" +             \" //list of shareholders\\n\" +             \" List<Account> BoardOfShareholders = UtilsGovernment.findBoardOfShareholders(balances, blockchain.getBlockchainList(), Seting.BOARDS_BLOCK);\\n\" +             \"\\n\" +             \" //constant list of shareholders\\n\" +             \" List<Account> finalBoardOfShareholders = BoardOfShareholders;\\n\" +             \"\\n\" +             \" //list of laws with votes\\n\" +             \" Map<HigherSpecialPositions, List<CurrentLawVotesEndBalance>> curentLawVotesEndBalance = new HashMap<>();\\n\" +             \"\\n\" +             \" for (Map.Entry<HigherSpecialPositions, List<LawEligibleForParliamentaryApproval>> corp :positionsListMap.entrySet()) {\\n\" +             \" //remove duplicate posts from the list.\\n\" +             \" .distinct().collect(Collectors.toList()));\\n\" +             \"\\n\" +             \" //get balance and votes for existing laws\\n\" +             \" curentLawVotesEndBalance.put(corp.getKey(),UtilsGovernment.filters(corp.getValue(), balances, BoardOfShareholders,\\n\" +             \" blockchain.getBlockchainList(), Seting.POSITION_YEAR_VOTE));\\n\" +             \"\\n\" +             \" //select votes above the limit\\n\" +             \"curentLawVotesEndBalance.put(corp.getKey(), curentLawVotesEndBalance.get(corp.getKey())\\n\" +             \" .stream().filter(t-> t.getVotes() >= Seting.ORIGINAL_LIMIT_MIN_VOTE)\\n\" +             \" .collect(Collectors.toList()));\\n\" +             \"\\n\" +             \" //select the number that corresponds to this position\\n\" +             \" List<CurrentLawVotesEndBalance> temporary = curentLawVotesEndBalance.get(corp.getKey()).stream().filter(\\n\" +             \"t->!t.getPackageName().equals(corp.getKey()))\\n\" +             \" .sorted(Comparator.comparing(CurrentLawVotesEndBalance::getVotes).reversed())\\n\" +             \" .limit(corp.getKey().getCount()).collect(Collectors.toList());\\n\" +             \"\\n\" +             \"curentLawVotesEndBalance.put(corp.getKey(), temporary);\\n\" +             \"}\\n\" +             \"\\n\" +             \"\\n\" +             \"\\n\" +             \"model.addAttribute(\\\"show\\\", curentLawVotesEndBalance);\\n\" +             \"\\n\" +             \" model.addAttribute(\\\"title\\\", \\\"current guidance\\\");\\n\" +             \"\\n\" +             \"return \\\"/governments\\\";\";      String CHAPTER_11 = \"To vote for any law created through the mechanism of this cryptocurrency,\" +             \"it is enough to put the address of the law as a recipient and as a vote\" +             \"send VoteEnum YES or NO as soon as your vote hits the sender's vote will be equal to the number of digitalStockBalance on this \" +             \"moment, if the sender is a member of the Board of Shareholders, then the vote will be equal to the number of digital reputation at the moment multiplied by \" +             \" 1.10, which will give 10% more votes. Votes for the law are recalculated every block \" +             \"Algorithm for counting votes:\" +             \"\" +             \"classLawController: \" +             \" public String currentLaw(Model model) throws IOException, NoSuchAlgorithmException, InvalidKeySpecException, SignatureException, NoSuchProviderException, InvalidKeyException {\\n\" +             \"\\n\" +             \" Blockchain blockchain = Mining.getBlockchain(\\n\" +             \" Seting.ORIGINAL_BLOCKCHAIN_FILE,\\n\" +             \"BlockchainFactoryEnum.ORIGINAL);\\n\" +             \"\\n\" +             \" Map<String, Account> balances = new HashMap<>();\\n\" +             \" //read balance\\n\" +             \"balances = SaveBalances.readLineObject(Seting.ORIGINAL_BALANCE_FILE);\\n\" +             \"\\n\" +             \" List<LawEligibleForParliamentaryApproval> lawEligibleForParliamentaryApprovals =\\n\" +             \"UtilsLaws.readLineCurrentLaws(Seting.ORIGINAL_ALL_CORPORATION_LAWS_WITH_BALANCE_FILE);\\n\" +             \"\\n\" +             \"\\n\" +             \" List<Account> boardOfShareholders = UtilsGovernment.findBoardOfShareholders(balances, blockchain.getBlockchainList(), Seting.BOARDS_BLOCK);\\n\" +             \"\\n\" +             \"\\n\" +             \"\\n\" +             \" //data to display\\n\" +             \" List<CurrentLawVotesEndBalance> current = UtilsGovernment.filters(lawEligibleForParliamentaryApprovals, balances, boardOfShareholders,\\n\" +             \" blockchain.getBlockchainList(), Seting.LAW_YEAR_VOTE);\\n\" +             \"// Seting.ORIGINAL_LIMIT_MIN_VOTE\\n\" +             \" //minimum number of positive votes for the law to be valid,\\n\" +             \"// int ORIGINAL_LIMIT_MIN_VOTE = (int) (200 * Seting.COUNT_BLOCK_IN_DAY * 45); count_block_in_day = 144\\n\" +             \" current = current.stream().filter(t-> t.getVotes() >= Seting.ORIGINAL_LIMIT_MIN_VOTE)\\n\" +             \" .sorted(Comparator.comparing(CurrentLawVotesEndBalance::getVotes).reversed()).collect(Collectors.toList());\\n\" +             \"\\n\" +             \" model.addAttribute(\\\"title\\\", \\\"current law: current laws are laws that have more than this: \\\" + Seting.ORIGINAL_LIMIT_MIN_VOTE + \\\" the number of votes.\\\");\\n\" +             \"model.addAttribute(\\\"currentLaw\\\", current);\\n\" +             \" return \\\"current-laws\\\";\\n\" +             \"}\" +             \"\\n\" +             \"\\n\" +             \" //data to display. Actual laws are defined here\\n\" +             \" List<CurrentLawVotesEndBalance> current = UtilsGovernment.filters(lawEligibleForParliamentaryApprovals, balances, boardOfShareholders);\\n\" +             \"// Seting.ORIGINAL_LIMIT_MIN_VOTE\\n\" +             \" //minimum number of positive votes for the law to be valid,\\n\" +             \"// int ORIGINAL_LIMIT_MIN_VOTE = (int) (200 * Seting.COUNT_BLOCK_IN_DAY * 45); count_block_in_day = 144\\n\" +             \" current = current.stream().filter(t-> t.getVotes() >= Seting.ORIGINAL_LIMIT_MIN_VOTE)\\n\" +             \" .sorted(Comparator.comparing(CurrentLawVotesEndBalance::getVotes).reversed()).collect(Collectors.toList());\\n\" +             \"\\n\" +             \" model.addAttribute(\\\"title\\\", \\\"current law: current laws are laws that have more than this: \\\" + Seting.ORIGINAL_LIMIT_MIN_VOTE + \\\" the number of votes.\\\");\\n\" +             \"model.addAttribute(\\\"currentLaw\\\", current);\\n\" +             \" return \\\"current-laws\\\";\\n\" +             \"}\" +             \"\" +             \"ClassUtilsGovernment:\" +             \" public static List<CurrentLawVotesEndBalance> filters(List<LawEligibleForParliamentaryApproval> approvalList, Map<String, Account> balances, List<Account> BoardOfShareholders, List<Block> blocks, int limitBlocks) throws IOException, NoSuchAlgorithmException, InvalidKeySpecException, SignatureException, NoSuchProviderException, InvalidKeyException {\\n\" +             \" //current laws whose votes are greater than ORIGINAL_LIMIT_MIN_VOTE\\n\" +             \" List<CurrentLawVotesEndBalance> current = new ArrayList<>();\\n\" +             \" Map<String, CurrentLawVotes> votesMap = null;\\n\" +             \" List<Account> accounts = balances.entrySet().stream().map(t->t.getValue()).collect(Collectors.toList());\\n\" +             \" if(blocks.size() > limitBlocks){\\n\" +             \"votesMap = UtilsCurrentLaw.calculateVotes(accounts,blocks.subList(blocks.size() - limitBlocks, blocks.size()));\\n\" +             \" }else {\\n\" +             \"votesMap = UtilsCurrentLaw.calculateVotes(accounts, blocks);\\n\" +             \"}\\n\" +             \"\\n\" +             \" for (LawEligibleForParliamentaryApproval lawEligibleForParliamentaryApproval : approvalList) {\\n\" +             \" if(votesMap.containsKey(lawEligibleForParliamentaryApproval.getLaws().getHashLaw())){\\n\" +             \" String address = lawEligibleForParliamentaryApproval.getLaws().getHashLaw();\\n\" +             \" String packageName = lawEligibleForParliamentaryApproval.getLaws().getPacketLawName();\\n\" +             \" double vote = votesMap.get(lawEligibleForParliamentaryApproval.getLaws().getHashLaw()).votes(balances, BoardOfShareholders);\\n\" +             \"\\n\" +             \" CurrentLawVotesEndBalance currentLawVotesEndBalance = new CurrentLawVotesEndBalance(address, packageName, vote);\\n\" +             \"current.add(currentLawVotesEndBalance);\\n\" +             \"\\n\" +             \"}\\n\" +             \"}\\n\" +             \"return current;\\n\" +             \"}\" +             \"\" +             \"class CurrentLawVotes: voting mechanism\" +             \"public double votes(Map<String, Account> balances, List<Account> pubChumbers){\\n\" +             \"double yes = 0.0;\\n\" +             \"double no = 0.0;\\n\" +             \" List<String> addressGovernment = pubChumbers.stream().map(t->t.getAccount()).collect(Collectors.toList());\\n\" +             \" for (String s : YES) {\\n\" +             \" if(addressGovernment.contains(s)){\\n\" +             \" yes += balances.get(s).getDigitalStockBalance() * Seting.POWER_SHAREHOLDER;\\n\" +             \" }else {\\n\" +             \" yes += balances.get(s).getDigitalStockBalance();\\n\" +             \"}\\n\" +             \"\\n\" +             \"}\\n\" +             \" for (String s : NO) {\\n\" +             \" if(addressGovernment.contains(s)){\\n\" +             \" no += balances.get(s).getDigitalStockBalance() * Seting.POWER_SHAREHOLDER;\\n\" +             \" }else {\\n\" +             \" no += balances.get(s).getDigitalStockBalance();\\n\" +             \"}\\n\" +             \"\\n\" +             \"}\\n\" +             \"\\n\" +             \"\\n\" +             \"return yes - no;\\n\" +             \"}\";       String CHAPTER_12 = \"Any person or entity can mine, and all mined by mining \" +             \"Digital dollars and digital stocks belong to the miner, just as the founder's reward belongs to the founder.\" +             \"For one Block Miner receives 200 digital dollars and 200 digital reputation, the founder's reward is 2% rounded\" +             \"up to an integer.\";      String CHAPTER_13 = \"Any positions that the International Trade Union may need, including departments and other structures\" +             \"must be approved by the laws of the International Trade Union, as well as their powers.\" +             \"Any powers delegated to the Board of Shareholders, Special Positions or positions otherwise created,\" +             \"are in effect while the laws created through this cryptocurrency that determine these powers\";      String CHAPTER_14 = \" (Applies to Special Positions and Board of Shareholders only)\" +             \"Any remuneration of the Special Positions and the Board of Shareholders shall be determined by the laws in force.\" +             \"And be determined how they should receive, but due to the fact that this currency has a limited amount, then from the budget \" +             \"for this Corporation, the remuneration should not be fixed, but percentage. (Example: Instead of a salary of 30 coins, \" +             \"determine what percentage this amount takes from the budget and issue exactly the percentage, taking into account inflation and deflation, at the moment\" +             \"issuing.\" +             \"example number two: The salary of a judge at the time of hiring was 20 coins, but at that time it was 0.003% of income\" +             \"for this corporation, then monthly it will receive not 20 coins, but 0.003%, but this percentage.)\" +             \"This protection is made for this reason, for example, bitcoin at the dawn of its formation was only a few cents.\" +             \"but as development progressed, the cost grew, if such a measure is not carried out, then the salary of one employee can grow by several\" +             \"hundreds of times, which will lead to the bankruptcy of this Corporation.\" +             \"\";     String CHAPTER_15 = \"Any cash or other money issued by the International Trade Union Corporation,\" +             \"must be 100% backed by a digital dollar or a digital share of that cryptocurrency, at a fixed rate.\" +             \"But the rate should be corrected every ten years, taking into account inflationary and deflationary processes, as well as market conditions.\" +             \"Who has the right to issue money backed by this cryptocurrency and correct\" +             \"the course must be determined by the laws in force\" +             \"and created special positions.\";      String CHAPTER_16 = \"The International Trade Union Corporation has the right to set and collect commissions, duties (when \" +             \"condition not higher than 20%);\" +             \"Also a source of income for this corporation\" +             \"can be the sale of their goods or services, as well as other sources of income (for example, the sale of subscriptions, membership fees, etc.)\" +             \"the purpose of such measures is the issuance of dividends to shareholders and investors, financing the expenses of this Corporation,\" +             \"First of all\" +             \"in investing in the development of its products and ecosystems, infrastructure development\" +             \"of this Corporation, the maintenance of personnel, the payment of debts, it is also possible the maintenance of social and socially significant projects,\" +             \"such as affordable medicine, education (for the benefit of the entire common society), etc. on the territory of the Corporation of the International Trade Union.\" +             \" To promote and develop the general welfare throughout the territory of the Corporation of the International Trade Union - \" +             \"problems that cannot be solved at the regional or local level, as well as problems that cannot be solved\" +             \"Private small investments. Using economies of scale, you can reduce the cost of developing and implementing advanced technologies\" +             \"as well as socially significant products and services on the territory of the Corporation of the International Trade Union, but any measures\" +             \"which the International Trade Union Corporation decides to implement, including those listed above, must be approved by the current\" +             \"by law, or delegated by law in force to the Board of Directors or other special higher offices\" +             \"HigherSpecialPositions. \"+             \", all expenses of this Corporation shall be determined either by the board of directors or by applicable laws or special\" +             \"current positions\" +             \"to whom, through the laws in force, these powers have been transferred.\" +             \" \" +             \"to whom these powers have been issued by the laws in force\" +             \"All purposes of the International Trade Union Corporation must be determined by or through\" +             \"the laws in force or by the board of directors or special officers whom, through the laws in force, them\" +             \"These powers have been transferred. Infrastructure development for\" +             \"conducting trade and providing services to members of the Corporation of the International Trade Union,\" +             \"and it is also possible to develop public and social benefits in the territory, if necessary and defined as goals, as\" +             \"described above or any other purpose defined as described above in\" +             \"Corporations of the International Trade Union.\" +             \"(An example of public and social goods, the production and sale of life-saving medicines at a low price, or the creation of parks, public transport,\" +             \"maintenance of sewers, etc.\" +             \"\\n\" +             \"Borrow money from the International Trade Union Corporation;\\n\" +             \"\\n\" +             \"To regulate trade with foreign countries and similar corporations, and provided that this provision is not \" +             \"permits to regulate or prohibit any \" +             \"non-commercial activity or any commercial activity, \" +             \"which is limited to one part of the territory of the International Corporation\" +             \"Trade Union, regardless of its effect outside the territory; but the Corporation of the International Trade Union\" +             \"has the right to regulate harmful emissions between the territories controlled by the Corporation\" +             \"International Trade Union, whatever their source;\\n\" +             \"\\n\" +             \"Establish uniform rules for naturalization and uniform bankruptcy laws throughout the territory of the International Corporation\" +             \"The Trade Union, provided this is not construed as sanctioning legislation,\" +             \"forbidding entry to the territory of the Corporation of the International Trade Union of any person,\" +             \" who enters for peaceful, impregnable reasons, and who does not suffer from a contagious disease;\\n\" +             \"\\n\" +             \"Issue money and other currencies one hundred percent backed by the International Trade Union Corporation's cryptocurrency,\" +             \"regulate their value and foreign coinage, provided it doesn't\" +             \"construed as permitting the conversion of any currency into legal tender; and establishing a standard of weights and measures;\\n\" +             \"\\n\" +             \"To provide for punishment for counterfeiting securities and the current coin or currency of the Corporation of the International Trade Union;\\n\" +             \"\\n\" +             \"Establish post offices and post roads on condition\" +             \"that it won't beinterpreted as allowing for the establishment of some sort of postal monopoly;\\n\" +             \"\\n\" +             \"To promote the progress of science and the useful arts by granting to authors and inventors for a period not exceeding\" +             \"28 years exclusive right to their respective works and discoveries;\\n\" +             \"\\n\" +              \"All applicable laws apply in the territory owned by the International Trade Union Corporation and to all members regardless of territory.\" +              \"The International Trade Union Corporation shall not impose on the members of the International Trade Union Corporation\" +             \"or its political subdivision any obligations\" +             \"or the obligation to make expenses, if such expenses will not be\" +             \"completely reimbursed by the International Trade Union Corporation; Congress also must not bet\" +             \"any conditions regarding the spending or receipt of the allocated funds,\" +             \"requiring members of the International Trade Union Corporation\" +             \"or its political subdivision passing a law or regulation,\" +             \"restricting the freedoms of its citizens or otherwise affecting any powers (Since members can\" +             \"to be also legal entities, this allows you to protect citizens of other companies, corporations, states from such actions.),\" +             \" not within the competence of the Corporation of the International Trade Union. If a member refuses the allocated funds \" +             \"with the conditions for their spending, the amount of appropriations, \" +             \"proportionately distributed by the population of this member (If it is some kind of company, corporation, or state, etc.),\" +             \"paid to the member as a lump-sum grant,\" +             \"which is spent on the general purposes of appropriations.\";      String CHAPTER_17 = \"The habeas corpus privilege cannot be suspended,\" +             \"Except in cases where public safety may require it.\" +             \"No arrest bill or ex post facto law, whether civil or criminal, can be passed.\" +             \"The International Trade Union Corporation shall not make laws imposing or levying taxes on income,\" +             \"gifts or property,\" +             \" direct or poll taxes or taxes on aggregate consumption or expenditure; \" +             \" but the International Trade Union Corporation has the right to charge a flat commission on the sale of goods or \" +             \" services if this commission \" +             \" no more than twenty percent (20%). \" +             \"Any introduction or increase in a commission, duty, levy or excise requires that a law be made which will\" +             \" act and which will describe this change.\" +              \"No regulation of trade or income should be given preference\" +             \"to one member of the Corporation of the International Trade Union, among others.:\" +             \"and ships or other modes of transport bound for or from one State(Members) or tribal lands,\" +             \"not required to call at ports. , clear, or pay duties in another.\" +              \"No money can be taken from the treasury, but due to appropriations,\" +             \"made by law, all such appropriations shall expire in two years;\" +             \"and a regular report and report on the receipts and expenditures of all the Corporation of the International Trade Union of money\" +             \"should be published from time to time, and be available to the Board of Shareholders. (This measure is needed to attract more people to this corporation,\" +             \"and make the management's actions transparent.)\" +               \"The International Trade Union Corporation also cannot make any laws that do not apply\" +             \"to himself or to his own members.\";      String CHAPTER_18 = \"All accounts are subject to a negative rate. The negative rate for the digital dollar is 0.10%\" +             \" every half year, and the negative rate for digital stocks is 0.2% every half year. \" +             \" This part of the code is specified in class UtilsBalance calculateBalance:\" +             \" if (i != 0 && i / Seting.COUNT_BLOCK_IN_DAY % (Seting.YEAR / Seting.HALF_YEAR) == 0.0) {\\n\" +             \"\\n\" +             \" for (Map.Entry<String, Account> changeBalance : balances.entrySet()) {\\n\" +             \" Account change = changeBalance.getValue();\\n\" +             \" change.setDigitalStockBalance(change.getDigitalStockBalance() - UtilsUse.countPercents(change.getDigitalStockBalance(), digitalReputationPercent));\\n\" +             \" change.setDigitalDollarBalance(change.getDigitalDollarBalance() - UtilsUse.countPercents(change.getDigitalDollarBalance(), percent));\\n\" +             \"}\\n\" +             \"}\" +             \"\" +             \"This measure was taken to avoid crises similar to the Great Depression, as well as to be ineffective and outdated\" +             \" laws were easily removed from the system, and in order to motivate shareholders to get the support of society, a negative rate does not \" +             \"it's too much to overvalue as a currency,\" +             \"So the value of the shares, which does not create situations like in other cryptocurrencies, where there is a very high volatility.\" +             \" This measure should not be changed by any amendments. (Explanation: When the digital dollar is subject to a negative rate of 0.10% every six months,\" +             \"this creates a price channel, where the lower limit of the coin is determined by its cost and the total amount in circulation, and the upper limit\" +             \"is determined by the real value, as soon as the price becomes higher than the real market price, it becomes more profitable for participants to quickly sell this one\" +             \"currency, and thereby saturate the market with money, this creates frequent market corrections, which does not create conditions for large collapses.\" +             \"But the effect will be noticeable the more active participants in the network, and the longer the system exists.)\";      String CHAPTER_19 = \"Any law can be either canceled or renewed. If the law satisfies the condition of being in force\" +             \"of the law, it is considered valid even if it was repealed not long ago, also if the law does not satisfy the conditions,\" +             \"it is considered repealed by law.\";      String CHAPTER_20 = \"Settings\" +             \"// value is used to calculate percentages\\n\" +             \"int HUNDRED_PERCENT = 100;\\n\" +             \" // value is used as year constant,\\n\" +             \" // there is no leap year in this system\\n\" +             \"int YEAR = 360;\\n\" +             \"\\n\" +             \" //delete sent transactions\\n\" +             \" String DELETED_SENDED_TRANSACTION_TIME = \\\"PT96H\\\";\\n\" +             \"\\n\" +             \"\\n\" +             \" //for what period of the last blocks should be taken into account for the selection of shareholders.\\n\" +             \" //Shareholders can only be those with the largest amount of balance\\n\" +             \" //senders and miners.\\n\" +             \" int BOARDS_BLOCK = (int) (Seting.COUNT_BLOCK_IN_DAY * YEAR);\\n\" +             \"\\n\" +             \" //Government vote multiplier for general account one share one vote, for members of parliament one reputation * 1.10\\n\" +             \"double POWER_SHAREHOLDER = 1.10;\\n\" +             \"\\n\" +             \" //minimum number of positive votes for the law to be valid,\\n\" +             \" int ORIGINAL_LIMIT_MIN_VOTE = (int) (200 * Seting.COUNT_BLOCK_IN_DAY * 45);\\n\" +             \"\\n\" +             \" // percentage that the founder receives from the production\\n\" +             \"Double FOUNDERS_REWARD = 2.0;\\n\" +             \"\\n\" +             \" //address for send rewards\\n\" +             \" String BASIS_ADDRESS = \\\"faErFrDnBhfSfNnj1hYjxydKNH28cRw1PBwDQEXH3QsJ\\\";\\n\" +              \"\\n\" +             \" //difficulty correction every n blocks\\n\" +             \" int DIFFICULTY_ADJUSTMENT_INTERVAL = (int) (Seting.COUNT_BLOCK_IN_DAY / 2);\\n\" +             \"int DIFFICULTY_ADJUSTMENT_INTERVAL_TEST = 10;\\n\" +             \"\\n\" +             \" long BLOCK_GENERATION_INTERVAL = Seting.BLOCK_TIME * 1000;// after Seting.BLOCK_TIME\\n\" +             \"long BLOCK_GENERATION_INTERVAL_TEST = 0 * 1000;\\n\" +             \"\\n\" +             \"long INTERVAL_TARGET = 600000;\\n\" +             \"long INTERVAL_TARGET_TEST = 25000;\\n\" +             \"\\n\" +             \" // maintenance fee every 6 months 0.4 /HALF_YEAR = 0.1, 0.4/HALF_YEAR = 0.2\\n\" +             \"Double ANNUAL_MAINTENANCE_FREE_DIGITAL_DOLLAR_YEAR = 0.2;\\n\" +             \" //negative rate for a digital stock\\n\" +             \"double ANNUAL_MAINTENANCE_FREE_DIGITAL_STOCK_YEAR = 0.4;\\n\" +             \" //every how many months to shoot\\n\" +             \"int HALF_YEAR = 2;\\n\" +             \"\\n\" +             \" //the cost of creating a law\\n\" +             \"double COST_LAW = 144;\\n\" +             \" //where does the law packet address begin\\n\" +             \" //corporation for short\\n\" +             \" String NAME_LAW_ADDRESS_START = \\\"LIBER\\\";\\n\" +             \"\\n\" +             \"int HASH_COMPLEXITY_GENESIS = 1;\\n\" +             \"\\n\" +             \" //shareholders' council\\n\" +             \"int BOARD_OF_SHAREHOLDERS = 1000;\\n\" +             \"\\n\" +             \"\\n\" +             \" // address of the founder: here will be my address. Now a stub\\n\" +             \" String ADDRESS_FOUNDER_TEST = \\\"stExZb8ifLfnFoq4JJuTifpAcscegATH8znhwW26zyTa\\\";\\n\" +             \" String ADDRESS_FOUNDER = \\\"stExZb8ifLfnFoq4JJuTifpAcscegATH8znhwW26zyTa\\\";\\n\" +             \"\\n\" +             \" String CORPORATE_CHARTER = International_Trade_Union.CorporateCharter.CorporateCharter.getAllConstitution() + \\\"\\\\n\\\" + CorporateCharter.getAllConstitution() + AboutUsDraft.getAboutUs()\\n\" +             \" + AboutUsEngDraft.getAboutUs();\\n\" +             \"\\n\" +             \" //founder's initial amount\\n\" +             \"Double FOUNDERS_REMUNERATION_DIGITAL_DOLLAR = 30000000.0;\\n\" +             \"double FOUNDERS_REMNUNERATION_DIGITAL_STOCK = 30000000.0;\\n\" +             \"\\n\" +             \"\\n\" +             \" // how many seconds are there in a day\\n\" +             \"int DAY_SECOND = 86400;\\n\" +             \"\\n\" +             \" // how many seconds each block is mined\\n\" +             \"int BLOCK_TIME = 150;\\n\" +             \"\\n\" +             \"\\n\" +             \" //how many blocks are mined per day\\n\" +             \"double COUNT_BLOCK_IN_DAY = (DAY_SECOND / BLOCK_TIME);\\n\" +             \"\\n\" +             \" //count of votes for the position in years\\n\" +             \" int POSITION_YEAR_VOTE = (int) Seting.COUNT_BLOCK_IN_DAY * YEAR * 3;\\n\" +             \" //count of votes for laws in years\\n\" +             \" int LAW_YEAR_VOTE = (int) Seting.COUNT_BLOCK_IN_DAY * YEAR * 3;\\n\" +             \"double DIGITAL_DOLLAR_REWARDS_BEFORE = 200.0;\\n\" +             \"double DIGITAL_STOCK_REWARDS_BEFORE = 200.0;\\n\" +             \" double DIGITAL_DOLLAR_FOUNDER_REWARDS_BEFORE = Math.round(UtilsUse.countPercents(Seting.DIGITAL_DOLLAR_REWARDS_BEFORE, Seting.FOUNDERS_REWARD));\\n\" +             \" double DIGITAL_REPUTATION_FOUNDER_REWARDS_BEFORE = Math.round(UtilsUse.countPercents(Seting.DIGITAL_STOCK_REWARDS_BEFORE, Seting.FOUNDERS_REWARD));\"; }","package International_Trade_Union.CorporateCharterEngDraft; /**устарел(недействителен), является черновиком, но его хеш используется в генезис блоке.  Но с помощью новых законов можно добавить те части которые будут интересны и сделать их действительным законом, если  данные части не противоречат действующему уставу и действующим законам.  */ public interface ArticleSixBillOfRightsEngDraft {     String SECTION_1 = \"No body of this corporation or entity shall prohibit free practice\" +             \"any religion; or restrict freedom of speech, conscience, or the press;\" +             \"or the right of people to peacefully assemble or associate with each other, or not associate with each other, and \" +             \"apply to the management of the Corporation of the International Trade Union and to this corporation with a petition for satisfaction of complaints;\" +             \" or violate the right to the fruits of one's labor or \" +             \"the right to a peaceful life of one's choice. Freedoms of speech and conscience include the freedom to contribute to \" +             \"political campaigns or nominations for corporate office and shall be construed as\" +             \"applying equally to any means of communication.\";      String CHAPTER_2 = \"No person in peacetime may be quartered in any house without the consent of the owner,\" +             \"as well as during force majeure, except in the manner prescribed by law. \" +             \"This provision applies equally throughout the territory of the International Trade Union Corporation.\";       String CHAPTER_3 = \"People's right to protect their faces, movements, personal data, homes, documents,\" +             \" data and things from unreasonable searches and confiscations should not be violated, \" +             \"and no warrants shall be issued except on good cause,\" +             \"supported by an oath. or statement, in particular a description of a place, persons or things,\" +             \" subject to search or confiscation. This provision applies equally throughout the \" +             \"territories of the International Trade Union Corporation.\";      String CHAPTER_4 = \"No person can be held liable for any\" +             \"a felony, except as directed or charged by a Grand Jury,\" +             \"except\" +             \"or public danger; no person may be endangered to life or\" +             \"health twice for the same crime; neither \" +             \"in what criminal case can he not be forced to testify against himself,\" +             \"and also cannot be deprived of life, liberty or property without due process of law;\" +             \"Private property cannot be taken for public use without fair compensation,\" +             \"paid within a reasonable period of time. This provision applies equally to all\" +             \"territories of the Corporation of the International Trade Union.\" ;      String CHAPTER_5 = \"In all criminal cases, the defendant has the right to a speedy and open trial\" +             \"by an impartial jury of the state and county where the crime was committed,\" +             \" the area of which must be previously established by law, \" +             \"and be informed of the nature and cause of the accusation; meet the witnesses against him;\" +             \"have a mandatory process for obtaining witnesses in your favor and have the assistance of a lawyer for your defense.\" +             \"this corporation must bear the burden of demonstrating clear and conclusive evidence that\" +             \"that any waiver of such rights must be knowing, reasonable and voluntary.\";      String CHAPTER_6 = \"In common law cases, the right to a jury trial must be \" +             \"the same as in the state where the jury sits,\" +             \"and not a single fact before the jury,\" +             \"cannot be retried in any court of the International Trade Union Corporation otherwise,\" +             \"than under common law rules.\" +             \"In adversarial proceedings when basic human needs are at stake,\" +             \"such as those relating to shelter, livelihood, security, deportation,\" +             \"health or child custody must be provided by a competent attorney,\" +             \"and the reasonable expenses of such attorney shall be paid by the International Trade Union Corporation by the government,\" +             \"State and Territory Governments. Government Spending to the Poor.\";      String CHAPTER_7 = \"Severe, unusual, or excessive punishments or fines may not be applied, and may not\" +             \"excessive bail required. Punishment of death, life imprisonment, or equivalent\" +             \"Deprivation of liberty is prohibited. This provision applies equally throughout the territory of the Corporation International\" +             \"Trade Union.\";      String CHAPTER_8 = \"Neither slavery nor forced labor shall exist in the Corporation International\" +             \"The Merchant Alliance or any other place under their jurisdiction.\" +             \"International Trade Union Corporation\" +             \" has the right to enforce this article through appropriate legislation.\\n\" +             \"\\n\" +             \" \";      String CHAPTER_9 = \"All persons born or naturalized within the states of the International Trade Union and their parents\" +             \"and the children and siblings are citizens and members of the Corporation of the International Trade Union\" +             \" and the state in which they live. International Trade Union Corporation, \" +             \"neither shall pass or enforce any law which \" +             \"infringes on the natural or civil rights of citizens of an International Trade Union corporation; or deprives any person\" +             \"freedom or property without due process of law; or to deny any person within its\" +             \"jurisdictions in equal protection of the law.\\n\" +             \"\\n\" +             \"The use of the words 'he' and 'him' in this code applies to all persons.\";      String CHAPTER_10 = \"Due process should be interpreted as providing an opportunity to submit\" +             \"evidence or otherwise show that a law, regulation or order is in violation of such rights of any\" +             \"a citizen or legal resident of an International Trade Union Corporation, and the party defending the contested law,\" +             \"Decrees or orders bear the burden of establishing their basis in law and in accordance with this Charter. \" +             \"No person can be subjected to criminal punishment without trial,\" +             \"aimed at establishing whether that person is guilty of violating a lawfully enacted statute,\" +             \"the adoption of which is within the proper authority of the International Trade Union\" +             \"or the state legislature.\" +             \"All persons are supposedly free to enjoy their lives,\" +             \"freedom or property and dispose of them at your discretion, and whenever,\" +             \"when the International Trade Union Corporation violates this right,\" +             \"and any person claims damages,\";      String CHAPTER_11 = \"Voting rights of International Trade Union Corporation citizens aged eighteen or over cannot be\" +             \"limited or limited by the International Trade Union throughout the territory,\" +             \" except in cases of punishment for a crime, \" +             \"whose party should have been duly convicted. International Trade Union or any \" +             \"Any citizen temporarily residing in a non-residential area that is the seat of government\" +             \"International Trade Union, is considered a citizen of the state from which he came.\";       String CHAPTER_12 = \"People's right to buy and sell lawful goods and services on mutually acceptable terms\" +             \"Must not be infringed by the International Trade Union or any state or tribe government.\" +             \"Only a private person has the right to set prices for their goods and services for sale\" +             \"Neither the International Trade Union Corporation nor the State Governments are entitled by any laws, ordinances,\" +             \"by resolutions or by any other means to regulate the prices of goods or services of private persons.\" +             \"Only the person who employs the worker can set wages if\" +             \"the hired person agreed to voluntarily work under a contract for a given salary, then this is legal.\" +             \"Neither the International Trade Union Corporation nor the State Government by laws, resolutions, ordinances or otherwise\" +             \"does not have to regulate wages if there was a voluntary contract between the employer\" +             \"or employers and hired, or hired\";      String CHAPTER_13 = \"The International Trade Union Corporation has the authority to establish legal grounds for initiation\" +             \"A claim for a breach of this article.\";      String CHAPTER_14 = \"All people are equally free and independent and have certain things\" +             \"natural, inalienable and inalienable rights, to which they retain in the formation of any government,\" +             \"among which are the use, protection and preservation of one's life and freedom, the acquisition, possession and\" +             \"Protection of real and personal property. ,\" +             \"by entering into binding contracts of one's choice and seeking one's own happiness and security.\" +             \"The enumeration in these Corporation Articles of certain rights shall not be construed as a denial or derogation of other rights,\" +             \"reserved for the people, or given to these enumerated \" +             \"Rights of priority or more enforcement over non-listed rights.\";      String CHAPTER_15 = \"Authorities not expressly delegated by International Trade\" +             \"Under the Constitution and not prohibited by it to the states, are reserved respectively to the states or to the people.\" +             \"And we mean it.\";      String CHAPTER_16 = \"Any person located in territory controlled by the International Trade Union,\" +             \"has the right to legally work and engage in commercial activities if\" +             \"these actions violate applicable laws from the moment they are in the territory controlled by the International Trade Union.\";      String CHAPTER_17 = \"Prohibit all banks from using fractional reserve banking\" +             \"All banks are required to use mandatory full reserve banking\";      String CHAPTER_18 = \"Any laws of the International Trade Union Corporation or state laws may not impose quotas. Forbidden\" +             \"the application of the quota mechanism by the International Trade Union Corporation or the state government.\" +             \"tariff quotas are also prohibited.\";      String CHAPTER_19 = \"Any reduction in business rules must apply to all business members, without isolating individual \" +             \"companies, corporations, etc. Neither the International Trade Union Corporation nor the State government can grant any exclusive \" +             \"privileges or create favorites.\";       String CHAPTER_20 = \"Any person who has legally resided in territory controlled by the International Trade Union for three years or more,\" +             \"recognized as a citizen, International Trade Union Corporation.\" +             \"Also, a resident of the International Trade Union is recognized as a person included in\" +             \"the management of this corporation.\" +             \"Any person who at least once created a law through the mechanism of this cryptocurrency and paid\" +             \"reward to the miner for the created law\" +             \"(at the moment the price is 144 digital dollars) is also a citizen of the Corporation International\" +             \"Trade Union.\" +             \". Also, any person who has acquired citizenship, \" +             \"also immediately have the right to receive his close relatives,\" +             \"which includes parents, children, siblings, and grandparents. Citizens are allowed to have\" +             \" Citizenship of several countries or possess the citizenship of several similar corporations.\";      String CHAPTER_21 = \"Neither the International Trade Union, nor any state government or other public agency\" +             \"they cannot regulate the interest rates of private banks. Each private bank has the right to keep its money\" +             \"funds and set interest rates\" +             \"and gold and any of its resources. The International Trade Union Corporation has no right to require banks to hold their funds\" +             \"in vaults owned by this corporation, but they can do it voluntarily\";      String CHAPTER_22 = \"Wherever we say federal government, we mean International Trade Union Corporation and its branches of government\";      String CHAPTER_23 = \"All citizens, members and shareholders of the International Trade Union Corporation\" +             \"should have the right to move freely between the states,\" +             \"All citizens of the members of the union shall have the right to freely transport any amount of money between the states.\" +             \"All citizens should have the right to freely take up employment and engage in commercial activities within the states of the members of the union and have\" +             \"the right to freely provide their goods and services.\";      String CHAPTER_24 = \"Who can be a member of a corporation is to be determined by applicable laws. Corporation International \" +             \"The Trade Union can provide special services to its members as well as its shareholders. Members are\" +             \"also all members of the Board of Shareholders and Holders of Special Positions. Provided that special services do not violate\" +             \"Charter and current laws\"; }","package International_Trade_Union.CorporateCharterEngDraft; /**устарел(недействителен), является черновиком, но его хеш используется в генезис блоке.  Но с помощью новых законов можно добавить те части которые будут интересны и сделать их действительным законом, если  данные части не противоречат действующему уставу и действующим законам.  */ public interface ArticleThreeJudiciaryEngDraft {     //Article 3 Judicial power.     String Article_3_Judiciary = \"The judicial power of the International Trade Union Corporation belongs to\" +             \"to one Supreme Court and such inferior courts as the Corporation International\" +             \"The Merchant Union may publish and establish from time to time.\" +             \" Judges of both supreme and inferior courts hold their offices in good conduct and \" +             \"they receive remuneration for their services within the established time limits.\";      String CHAPTER_2 = \"Judicial power extends to all matters of law and justice, \" +             \"including those initiated by members to challenge the misappropriation of funds,\" +             \"arising under these Articles, the laws of the International Trade Union Corporation and treaties,\" +             \"prisoners or who will be imprisoned according to their authority; to all matters concerning ambassadors,\" +             \"other ministers of state and consuls; to all matters of the admiralty and maritime jurisdiction; to disputes,\" +             \"in which the International Trade Union will be a party; to disagreements between two or more states; \" +             \"between the state and the people; between the tribal government and the citizens of that tribe;\" +             \"between citizens of different states, between citizens of the same state claiming land,\" +             \"\" +             \"provided by different states, as well as between a state or its citizens and foreign states,\" +             \"\" +             \"citizens or subjects. And between all members of the International Trade Union Corporation\\n\" +             \"\\n\" +             \"In all matters concerning ambassadors, other ministers of state and consuls, as well as in disputes,\" +             \"affecting two or more states, the Supreme Court assumes original jurisdiction. In all other cases,\"+              \"mentioned above, the Supreme Court has appellate jurisdiction, both on law and on facts,\" +                      \" with such exceptions and in accordance with such rules as the Congress may adopt.\\n\" +                      \"\\n\" +                      \"The trial of all crimes is by jury;\" +                      \"and such proceedings shall be held in the state where said crimes were committed;\" +                      \"but when the case is not done in any state, the trial shall be held in such place or places,\" +                      \" which the International Trade Union Corporation may establish by law.\\n\" +                      \"\\n\" +                      \"No trial should be secret, but justice should be administered openly and free of charge, completely and without delay,\" +                      \"and every person shall have legal remedy against injury to life, liberty, or property.\" +                      \"Supreme Court CORPORATE_SUPREME_COURT\"; }","package International_Trade_Union.CorporateCharterEngDraft; /**устарел(недействителен), является черновиком, но его хеш используется в генезис блоке.  Но с помощью новых законов можно добавить те части которые будут интересны и сделать их действительным законом, если  данные части не противоречат действующему уставу и действующим законам.  */ public interface ArticleTwoSpecialPositionEngDraft {     String SECTION_1 = \" любое лицо может занимать специальные высшие должности\" +             \". Все Специальные должности и членство в Совете Акционеров\" +             \" могут занимать как физические, так и юридические лица.\";       String CHAPTER_2 = \" Совет директоров BOARD_OF_DIRECTORS Корпорации Международного\" +             \" Торгового Союза осуществляет общее руководство деятельностью, детали данной дейтельности должны быть\" +             \" описаны принятыми и действующими законами. Обязаности и полномочия совета директоров, как и других HigherSpecialPositions\" +             \" и других руководящих органов должны быть описаны действующими законами,\" +              \" Избраный совет директоров как описано в даном уставе, должен рукодоводить данной системой,\" +             \"для общего блага всех участников данной системы и ее граждан. Совет директоров это колективный\" +             \"орган исполнительной власти в данной системе.\" +              \"Любое решение совет директоров должен принимать большинством голосов среди действующих членов совета директоров совета директоров.\" +             \"Ни одно решение совета директоров не должно нарушать устав или действующие законы Корпорации Международного Торгового Союза,\" +             \"Ни один орган или специальные должности не имеет права нарушать устав или действующие законы.\";      String CHAPTER_3 = \"\" +             \"Все должности  HigherSpecialPositions внутри каждой группы равнозначны и должны колективные решения принимать \" +             \"большинством голосов.\" +             \"DEPARTMENT_OF_CORPORATE_JOURNALISTS отдел корпоративных журналистов занимается независимым \" +             \" информированием членов Корпорации Международного Торгового Союза о происходящих событиях.\";      String CHAPTER_4 = \" Большинство специальных должностей HigherSpecialPositions которые описаны здесь , и их \" +             \"полномочия и обязаности,\" +             \" и их иерахия должны определяться действующими законами (между разными должностями), с учетом целей и\" +             \" приоритетов текущей реальности и\" +             \" потребностей Корпорации Международного Торгового Союза. Каждая такая должность является руководством, но иерархия\" +             \"данного руководства должна определяться действующими законами(имеется ввиду иерархия между должностями).\" +             \"Но внутри одной группы должностей, все должности равны. (Пример члены совета директоров равны.)\";  }","package International_Trade_Union.CorporateCharterEngDraft; /**устарел(недействителен), является черновиком, но его хеш используется в генезис блоке.  Но с помощью новых законов можно добавить те части которые будут интересны и сделать их действительным законом, если  данные части не противоречат действующему уставу и действующим законам.  */ public class CorporateCharter {     public  static  String getAllConstitution(){         String сorporateCharter = PreambleEngDraft.ARTICLE_0 + \"\\n\";         //Статья I: Законодательная власть         String articleOneLegistrature = ArticleOneLegistratureEngDraft.SECTION_1;         articleOneLegistrature += \"\\n\" + ArticleOneLegistratureEngDraft.CHAPTER_2;         articleOneLegistrature += \"\\n\" + ArticleOneLegistratureEngDraft.CHAPTER_3;         articleOneLegistrature += \"\\n\" + ArticleOneLegistratureEngDraft.CHAPTER_4;         articleOneLegistrature += \"\\n\" + ArticleOneLegistratureEngDraft.CHAPTER_5;         articleOneLegistrature += \"\\n\" + ArticleOneLegistratureEngDraft.CHAPTER_6;         articleOneLegistrature += \"\\n\" + ArticleOneLegistratureEngDraft.CHAPTER_7;         articleOneLegistrature += \"\\n\" + ArticleOneLegistratureEngDraft.CHAPTER_8;         articleOneLegistrature += \"\\n\" + ArticleOneLegistratureEngDraft.CHAPTER_9;         articleOneLegistrature += \"\\n\" + ArticleOneLegistratureEngDraft.CHAPTER_10;         articleOneLegistrature += \"\\n\" + ArticleOneLegistratureEngDraft.CHAPTER_11;         articleOneLegistrature += \"\\n\" + ArticleOneLegistratureEngDraft.CHAPTER_12;         articleOneLegistrature += \"\\n\" + ArticleOneLegistratureEngDraft.CHAPTER_13;         articleOneLegistrature += \"\\n\" + ArticleOneLegistratureEngDraft.CHAPTER_14;         articleOneLegistrature += \"\\n\" + ArticleOneLegistratureEngDraft.CHAPTER_15;         articleOneLegistrature += \"\\n\" + ArticleOneLegistratureEngDraft.CHAPTER_16;         articleOneLegistrature += \"\\n\" + ArticleOneLegistratureEngDraft.CHAPTER_17;         articleOneLegistrature += \"\\n\" + ArticleOneLegistratureEngDraft.CHAPTER_18;         articleOneLegistrature += \"\\n\" + ArticleOneLegistratureEngDraft.CHAPTER_19;         articleOneLegistrature += \"\\n\" + ArticleOneLegistratureEngDraft.CHAPTER_20;         сorporateCharter += \"\\n\" + articleOneLegistrature;          //Часть II: Исполнительная власть         String articleTwoExecutiveBranch = ArticleTwoSpecialPositionEngDraft.SECTION_1;         articleTwoExecutiveBranch += \"\\n\" + ArticleTwoSpecialPositionEngDraft.CHAPTER_2;         articleTwoExecutiveBranch += \"\\n\" + ArticleTwoSpecialPositionEngDraft.CHAPTER_3;         articleTwoExecutiveBranch += \"\\n\" + ArticleTwoSpecialPositionEngDraft.CHAPTER_4;         сorporateCharter += \"\\n\" + articleTwoExecutiveBranch;          //Статья III: Судебная власть         String articleThreeJudiciary = ArticleThreeJudiciaryEngDraft.Article_3_Judiciary;         articleThreeJudiciary += \"\\n\" + ArticleThreeJudiciaryEngDraft.CHAPTER_2;          сorporateCharter += \"\\n\" + articleThreeJudiciary;           //Статья V: Процесс внесения поправок         String articleFiveAmendmentProcess = ArticleFourAmendmentProcessEngDraft.CHAPTER_1;         сorporateCharter += \"\\n\" + articleFiveAmendmentProcess;           //Статья VI: Конституционное верховенство         String articleSixConstitutionalSupremacy = ArticleFiveCharterSupremacyEngDraft.CHAPTER_1;         articleSixConstitutionalSupremacy += \"\\n\" + ArticleFiveCharterSupremacyEngDraft.CONSTITUTIONAL_SUPERMACY;         сorporateCharter += \"\\n\" + articleSixConstitutionalSupremacy;          //Статья VII: Билль о правах         String articleSevenBillOfRights = ArticleSixBillOfRightsEngDraft.SECTION_1;         articleSevenBillOfRights += \"\\n\" + ArticleSixBillOfRightsEngDraft.CHAPTER_2;         articleSevenBillOfRights += \"\\n\" + ArticleSixBillOfRightsEngDraft.CHAPTER_3;         articleSevenBillOfRights += \"\\n\" + ArticleSixBillOfRightsEngDraft.CHAPTER_4;         articleSevenBillOfRights += \"\\n\" + ArticleSixBillOfRightsEngDraft.CHAPTER_5;         articleSevenBillOfRights += \"\\n\" + ArticleSixBillOfRightsEngDraft.CHAPTER_6;         articleSevenBillOfRights += \"\\n\" + ArticleSixBillOfRightsEngDraft.CHAPTER_7;         articleSevenBillOfRights += \"\\n\" + ArticleSixBillOfRightsEngDraft.CHAPTER_8;         articleSevenBillOfRights += \"\\n\" + ArticleSixBillOfRightsEngDraft.CHAPTER_9;         articleSevenBillOfRights += \"\\n\" + ArticleSixBillOfRightsEngDraft.CHAPTER_10;         articleSevenBillOfRights += \"\\n\" + ArticleSixBillOfRightsEngDraft.CHAPTER_11;         articleSevenBillOfRights += \"\\n\" + ArticleSixBillOfRightsEngDraft.CHAPTER_12;         articleSevenBillOfRights += \"\\n\" + ArticleSixBillOfRightsEngDraft.CHAPTER_13;         articleSevenBillOfRights += \"\\n\" + ArticleSixBillOfRightsEngDraft.CHAPTER_14;         articleSevenBillOfRights += \"\\n\" + ArticleSixBillOfRightsEngDraft.CHAPTER_15;         articleSevenBillOfRights += \"\\n\" + ArticleSixBillOfRightsEngDraft.CHAPTER_16;         articleSevenBillOfRights += \"\\n\" + ArticleSixBillOfRightsEngDraft.CHAPTER_17;         articleSevenBillOfRights += \"\\n\" + ArticleSixBillOfRightsEngDraft.CHAPTER_18;         articleSevenBillOfRights += \"\\n\" + ArticleSixBillOfRightsEngDraft.CHAPTER_19;         articleSevenBillOfRights += \"\\n\" + ArticleSixBillOfRightsEngDraft.CHAPTER_20;         articleSevenBillOfRights += \"\\n\" + ArticleSixBillOfRightsEngDraft.CHAPTER_21;         articleSevenBillOfRights += \"\\n\" + ArticleSixBillOfRightsEngDraft.CHAPTER_22;         articleSevenBillOfRights += \"\\n\" + ArticleSixBillOfRightsEngDraft.CHAPTER_23;         articleSevenBillOfRights += \"\\n\" + ArticleSixBillOfRightsEngDraft.CHAPTER_24;          сorporateCharter += \"\\n\" + articleSevenBillOfRights;          return сorporateCharter;     } }","package International_Trade_Union.CorporateCharterEngDraft; /**устарел(недействителен), является черновиком, но его хеш используется в генезис блоке.  Но с помощью новых законов можно добавить те части которые будут интересны и сделать их действительным законом, если  данные части не противоречат действующему уставу и действующим законам.  */ public interface PreambleEngDraft {     String ARTICLE_0 = \"The International Trade Union Corporation, established for the purpose of promoting international trade.\" +             \" International Trade Union Corporation aims to provide the ecosystem as well as its products \" +             \"and services that facilitate trade without violating natural human rights. \" +             \"The International Trade Union Corporation is a form of democracy where votes are equal to shares,\" +             \"this form allows you to take into account the contribution of everyone to the development of this community, thus creating a condition\" +             \"where all participants are interested in the development of this community. How does each participant become interested\" +             \"face, and everyone wants the well-being of this society to flourish.\"; }","package International_Trade_Union.originalCorporateCharter;  public interface OriginalCHARTER {     String POWERS_OF_THE_BOARD_OF_DIRECTORS = \" Полномочия Совета Директоров. \" +             \" Совет Директоров может утверждать счета которые подали на должности из списка Directors. \" +             \" Также Законы название пакетов начинаются с ADD_DIRECTOR являются пакетами которые содержать \" +             \" список новых директоров которые должны управлять новыми линейками продукции. Данные \" +             \" Законы может утверждать только Совет директоров и оттуда будет взять список законов, где \" +             \" каждая строка которая начинается  ADD_DIRECTOR будет добавлена в список Directors в качестве новой \" +             \" должности на которую можно подать. \" +             \" пакет который начинается  BUDGET является бюджетом и может его утвердить только Совет директоров. \" +             \" Действующий бюджет может быть только один. \" +             \" Совет директоров также утверждает стратегический план STRATEGIC_PLAN. Стратегический \" +             \" план может быть только один действующим. \" +             \" Совет директоров также участвует в утверждении законов (правил по которым должны действовать \" +             \" все участники корпорации), а также участвует в утверждении внедрения поправок в устав AMENDMENT_TO_THE_CHARTER.\" +             \"\" +             \" Совет имеет право устанавливать и собирать комиссию от продаж внутри платформ принадлежащих Корпорации \" +             \" Международного Торгового Союза, при условии что данная комиссия не будет выше двадцати процентов (20%). \" +             \" Все сборы должны и направлены на расходы которые установлены бюджетом. \" +             \" Также источником дохода является продажа своих товаров и услуг, для этого есть Директора офисов которые избираются \" +             \" советом директоров и они должны реализовать продукцию Корпорации Международного Торгового Союза. \" +             \"\" ;      //правила для законов     //TODO     String HOW_LAWS_ARE_CHOSEN =  \" КАК ИЗБИРАЮТСЯ ЗАКОНЫ. \" +             \" Ни один закон не имеет обратной силы. Ни один закон не должен нарушать действующий устав или противоречит \" +             \" другим действующим законам. Если есть противотечение между несколькими законами из одного пакета законов, \" +             \" то действующим является тот который списке находится выше по индексу. Пример: пакет об продаже алкоголя \" +             \" закон под индексом 3 противоречит закону из индекса 17, в даном случае закон под индексом три будет действующим. \" +             \" если законы противоречат из разных пакетов, то действующим является тот пакет, который получил больше голосов \" +             \" от Совета акционеров, если есть паритет, то тот который получил больше голосов Совета Директоров, если и здесь \" +             \" есть паритет то данный спор должен решить Верховный Судья, если он также не определил который из двух пакетов \" +             \" где законы противоречат друг другу является законы одно из пакетов более действующими, то в приоритете становиться \" +             \" тот который начал действовать раньше, отсчет определяется именно с последнего момента вступления в силу. \" +             \" Все обычные законы являются действующими если за них проголосовали таким способом ONE_VOTE Совет Акционеров, Совет Директоров и возможно \" +             \" Верховный Судья. Чтобы закон был действующим он должен получить равно или больше 100 остатка голосов Совета Акционеров, \" +             \" 15 остатка голосов Совета Директоров и Один голос Верховного Судьи, но если Верховный Судья не проголосовал или проголосовал против \" +             \" то можно обойти вето верховного судьи получив 200 остаток голосов Совета Акционеров и 30 остаток голосов Совета Директоров. \" +             \" \" +             \" Закон является действующим пока он соответствует количеству голосов как описано выше. Каждый раз как кто то теряет свою должность \" +             \" также теряется все его голоса за все законы которые он проголосовал.\" +             \"\" +             \" Пример кода в LawsController current law:\" +             \" //законы которые получили не достаточно голосов которые могут пройти только если верховный судья одобрит\\n\" +             \"        List<CurrentLawVotesEndBalance> notEnoughVotes = current.stream()\\n\" +             \"                .filter(t -> !directors.contains(t.getPackageName()))\\n\" +             \"                .filter(t->!Seting.AMENDMENT_TO_THE_CHARTER.equals(t.getPackageName()))\\n\" +             \"                .filter(t->!directors.isCabinets(t.getPackageName()))\\n\" +             \"                .filter(t -> !Seting.ORIGINAL_CHARTER_CURRENT_LAW_PACKAGE_NAME.equals(t.getPackageName()))\\n\" +             \"                .filter(t -> t.getVotesBoardOfShareholders() >= Seting.ORIGINAL_LIMIT_MIN_VOTE_BOARD_OF_SHAREHOLDERS)\\n\" +             \"                .filter(t -> t.getVotesBoardOfDirectors() >= Seting.ORIGINAL_LIMIT_MIN_VOTE_BOARD_OF_DIRECTORS)\\n\" +             \"                .filter(t -> t.getVoteHightJudge() >= Seting.ORIGINAL_LIMIT_MIN_VOTE_HIGHT_JUDGE)\\n\" +             \"                .sorted(Comparator.comparing(CurrentLawVotesEndBalance::getVotes).reversed()).collect(Collectors.toList());\\n\" +             \"\\n\" +             \"\\n\" +             \"        //законы которые получили достаточно голосов и не требуют одобрения верховного судьи\\n\" +             \"        List<CurrentLawVotesEndBalance> powerfulVotes = current.stream()\\n\" +             \"                .filter(t -> !directors.contains(t.getPackageName()))\\n\" +             \"                .filter(t-> !Seting.AMENDMENT_TO_THE_CHARTER.equals(t.getPackageName()))\\n\" +             \"                .filter(t-> !directors.isCabinets(t.getPackageName()))\\n\" +             \"                .filter(t -> !Seting.ORIGINAL_CHARTER_CURRENT_LAW_PACKAGE_NAME.equals(t.getPackageName()))\\n\" +             \"                .filter(t -> t.getVotesBoardOfShareholders() >= (Seting.ORIGINAL_LIMIT_MIN_VOTE_BOARD_OF_SHAREHOLDERS * Seting.POWERFUL_VOTE))\\n\" +             \"                .filter(t -> t.getVotesBoardOfDirectors() >= (Seting.ORIGINAL_LIMIT_MIN_VOTE_BOARD_OF_DIRECTORS * Seting.POWERFUL_VOTE))\\n\" +             \"                .sorted(Comparator.comparing(CurrentLawVotesEndBalance::getVotes).reversed()).collect(Collectors.toList()); \";      String HOW_THE_BOARD_OF_DIRECTORS_IS_ELECTED = \" Как избирается Совет директоров.\" +             \"\" +             \" Совет директоров состоит из 301 счетов BOARD_OF_DIRECTORS. \" +             \" каждый участник сети может подать на должность совета директоров, создав пакет закона, где \" +             \" название пакета BOARD_OF_DIRECTORS и счет отправителя должен совпадать счетом который указан \" +             \" в первой строке закона который содержится в списке данного пакета \" +             \" 301 счет с наибольшим количеством остатка из голосов получает должность.\" +             \" стоимость подачи на создание закона(должность) стоит пять цифровых долларов (5) в качестве вознаграждения добытчику \" +             \" Процесс голосования описан в VOTE_STOCK\" +             \"\" +             \" Пример кода: LawController: method currentLaw: \" +             \" участок кода отвечающий за избрание совета директоров \" +             \"  //минимальное значение количество положительных голосов для того чтобы закон действовал,\\n\" +             \"        //позиции избираемые акциями совета директоров\\n\" +             \"        List<CurrentLawVotesEndBalance> electedByStockBoardOfDirectors = current.stream()\\n\" +             \"                .filter(t -> directors.isElectedByStocks(t.getPackageName()))\\n\" +             \"                .filter(t -> t.getPackageName().equals(NamePOSITION.BOARD_OF_DIRECTORS.toString()))\\n\" +             \"                .filter(t -> t.getVotes() >= Seting.ORIGINAL_LIMIT_MIN_VOTE)\\n\" +             \"                .sorted(Comparator.comparing(CurrentLawVotesEndBalance::getVotes).reversed())\\n\" +             \"                .limit(directors.getDirector(NamePOSITION.BOARD_OF_DIRECTORS.toString()).getCount())\\n\" +             \"                .collect(Collectors.toList()); \";      String POWERS_OF_THE_BOARD_OF_SHAREHOLDERS = \" Полномочия совета акционеров  \" +             \" Совет Акционеров Участвует в утверждении Законов (правил которые должны соблюдать все участники данной корпорации) \" +             \" Также Совет Акционеров участвует в утверждении поправок в устав Корпорации Международного Торгового Союза AMENDMENT_TO_THE_CHARTER \" +             \" Совет Акционеров также может участвовать в голосовании при избрании кандидатов  CORPORATE_COUNCIL_OF_REFEREES и BOARD_OF_DIRECTORS \" +             \" используя эти правила для голосования за кандидатов VOTE_STOCK. \" +             \"\";      String HOW_SHAREHOLDERS_BOARD_IS_ELECTED = \" КАК ИЗБИРАЕТСЯ СОВЕТ АКЦИОНЕРОВ \" +             \" Совет Акционеров состоит из тысячи пятьсот счетов (1500) с наибольшим количеством акций, но учитываются только те счета \" +             \" от чьей активности не прошло больше года. формула: текущий год - один год, и если счет был активен в этом диапазоне он \" +             \" учитывается. Все счета сортируются по убыванию количества цифровых акций, и отбираются 1500 счетов с наибольшим количеством  \" +             \" акций. Перерасчет происходит Каждый блок. \" +             \"\" +             \"  Пример участка кода как избирается Совет Акционеров: \" +             \" class UtilsGovernment method findBoardOfShareholders: \" +             \"  //определение совета акционеров\\n\" +             \"    public static List<Account> findBoardOfShareholders(Map<String, Account> balances, List<Block> blocks, int limit) {\\n\" +             \"        List<Block> minersHaveMoreStock = null;\\n\" +             \"        if (blocks.size() > limit) {\\n\" +             \"            minersHaveMoreStock = blocks.subList(blocks.size() - limit, blocks.size());\\n\" +             \"        } else {\\n\" +             \"            minersHaveMoreStock = blocks;\\n\" +             \"        }\\n\" +             \"        List<Account> boardAccounts = minersHaveMoreStock.stream().map(\\n\" +             \"                        t -> new Account(t.getMinerAddress(), 0, 0))\\n\" +             \"                .collect(Collectors.toList());\\n\" +             \"\\n\" +             \"        for (Block block : minersHaveMoreStock) {\\n\" +             \"            for (DtoTransaction dtoTransaction : block.getDtoTransactions()) {\\n\" +             \"                boardAccounts.add(new Account(dtoTransaction.getSender(), 0, 0));\\n\" +             \"            }\\n\" +             \"\\n\" +             \"        }\\n\" +             \"\\n\" +             \"\\n\" +             \"        CompareObject compareObject = new CompareObject();\\n\" +             \"\\n\" +             \"        List<Account> boardOfShareholders = balances.entrySet().stream()\\n\" +             \"                .filter(t -> boardAccounts.contains(t.getValue()))\\n\" +             \"                .map(t -> t.getValue()).collect(Collectors.toList());\\n\" +             \"\\n\" +             \"\\n\" +             \"        boardOfShareholders = boardOfShareholders\\n\" +             \"                .stream()\\n\" +             \"                .filter(t -> !t.getAccount().startsWith(Seting.NAME_LAW_ADDRESS_START))\\n\" +             \"                .filter(t -> t.getDigitalStockBalance() > 0)\\n\" +             \"                .sorted(Comparator.comparing(Account::getDigitalStockBalance).reversed())\\n\" +             \"                .collect(Collectors.toList());\\n\" +             \"\\n\" +             \"        boardOfShareholders = boardOfShareholders\\n\" +             \"                .stream()\\n\" +             \"                .limit(Seting.BOARD_OF_SHAREHOLDERS)\\n\" +             \"                .collect(Collectors.toList());\\n\" +             \"\\n\" +             \"        return boardOfShareholders;\\n\" +             \"    } \";      String VOTE_STOCK = \" Как с помощью акций происходит голосование. \" +             \" все акции которым счет владеет приравниваются такому же количеству голосов. \" +             \" каждый раз когда кто то делает транзакцию на счет который является адресом данного пакета который начинается \" +             \" LIBER он голосует за данный пакет. Учитываются только те голоса, с которых не прошло больше четырех лет. \" +             \" если транзакция была совершена VoteEnum.YES то данный счет получает голоса за по формуле \" +             \" yesV = количество голосов равные количеству акций отправителя.\" +             \" yesN = за сколько законов данный счет проголосовал с VoteEnum.YES\" +             \" resultYES = yesV / math.pow(yesN, 3). Пример: счет проголосовал за три счета которые начинаются с LIBER,\" +             \" на счету сто акций, значит сто голосов. 100 / math.pow(3, 3) = 3.7 значит каждый счет получит по 3.7 голоса. \" +             \"\" +             \" если транзакция была совершена с VoteEnum.NO \" +             \" то используется такая же формула, но учитываются теперь все счета за которые он проголосовал против \" +             \" пример тот же счет проголосовал за два счет против, у него те же сто акций. \" +             \" resultNO = noV / math.pow(noN, 3) = 100/ math.pow(2,3) = 12.5 значит каждый счет за который он проголосовал, \" +             \" против получит 12.5 голосов против. \" +             \" дальше каждый счет подсчитывает все отданные ему голоса ЗА (VoteEnum.YES)  и ПРОТИВ (VoteEnum.NO). \" +             \" потом используется данная формула remainder = resultYES - resultNO. \" +             \" сначала данные должности отбираются все счета которые получили больше или равно четырнадцать тысяч \" +             \" четыреста голосов остатка (14400) remainder >= 14400.\" +             \" Дальше все счета сортируются по убыванию remainder и оттуда отбираются то количество счетов на \" +             \" данные должности, сколько это оговорено в данной должности. Пример: \" +             \" Для Совета Директоров это 301 счет с наибольшим количеством остатка. \" +             \" \" +             \" В любой момент можно изменить свой голос, но только на противоположный, что значит если \" +             \" вы проголосовали за кандидата YES то вы можете изменить только на NO и обратно. \" +             \" количество раз сколько вы можете изменить свой голос не ограничено. \" +             \" С каждым блоком происходит перерасчет голосов, если вы теряете свои акции, ваши кандидаты \" +             \" также теряют свои голоса. Данная мера специально так реализовано чтобы избираемые должности\" +             \" были заинтересованы в том чтобы вы процветали. \" +             \" Таким способом избираются Только CORPORATE_COUNCIL_OF_REFEREES и BOARD_OF_DIRECTORS\" +             \" Учитывается только последняя транзакция отданная за каждый счет, если вы не обновляли свой голос, \" +             \" то по прошествии четырех лет он аннулируется. \";      String CODE_VOTE_STOCK = \" class CurrentLawVotes method: votesLaw \" +             \" public double votesLaw(Map<String, Account> balances,\\n\" +             \"                           Map<String, Integer> yesAverage, Map<String, Integer> noAverage) {\\n\" +             \"        double yes = 0.0;\\n\" +             \"        double no = 0.0;\\n\" +             \"\\n\" +             \"        //\\n\" +             \"        for (String s : YES) {\\n\" +             \"\\n\" +             \"            int count = 1;\\n\" +             \"            count = yesAverage.get(s) > 0 ? yesAverage.get(s) : 1;\\n\" +             \"            yes += balances.get(s).getDigitalStockBalance() / Math.pow(count, Seting.POWERING_FOR_VOTING);\\n\" +             \"\\n\" +             \"        }\\n\" +             \"        //\\n\" +             \"        for (String s : NO) {\\n\" +             \"            int count = 1;\\n\" +             \"            count = noAverage.get(s) > 0 ? noAverage.get(s) : 1;\\n\" +             \"            no += balances.get(s).getDigitalStockBalance() / Math.pow(count, Seting.POWERING_FOR_VOTING);\\n\" +             \"\\n\" +             \"        }\\n\" +             \"\\n\" +             \"\\n\" +             \"        return yes - no;\\n\" +             \"    } \";      String POWERS_OF_DIRECTORS_IN_THE_OFFICE = \" ПОЛНОМОЧИЯ ДИРЕКТОРОВ В ОФИС \" +             \" директорами офиса называются высшие  директора которые являются директорами своих дивизионов. \" +             \" Полномочия каждого директора должны быть описаны действующими законами. Но каждый директор должен управлять \" +             \" только своим дивизионом. Координацией всех директоров должен Генеральный Исполнительный Директор GENERAL_EXECUTIVE_DIRECTOR. \" +             \" \" +             \" Совет Директоров, CORPORATE_COUNCIL_OF_REFEREES, HIGH_JUDGE, Совет Акционеров и  GENERAL_EXECUTIVE_DIRECTOR могут быть как \" +             \" физическими лицами, так и юридическими лицами, но один счет будет учитываться как один голос. \";      String HOW_OFFICE_DIRECTORS_ARE_CHOSEN = \" КАК ИЗБИРАЮТСЯ ОФИСНЫЕ ДИРЕКТОРА \" +             \" Все Директора офиса, это высшие директора которые управляют своими дивизионами, избираются только Советом Директоров. \" +             \" Каждый участник сети может подать на должность высшего директора, создав закон, с названием пакета который совпадает с допустимыми \" +             \" должностями, где адрес отправителя данной транзакции должен совпадать с первой строкой из списка законов данного пакета. \" +             \" стоимость закона пять цифровых долларов в качестве вознаграждения добытчику.  \" +             \" счет с наибольшим количеством голосов остатка получает данную должность. \" +             \" Механизм голосования описан ONE_VOTE. \" +             \"\" +             \" Пример участка кода как избирается должности class LawsController: method currentLaw: \" +             \"\" +             \" //позиции созданные советом директоров\\n\" +             \"        List<CurrentLawVotesEndBalance> createdByBoardOfDirectors = current.stream()\\n\" +             \"                .filter(t->t.getPackageName().startsWith(Seting.ADD_DIRECTOR))\\n\" +             \"                .filter(t->t.getVotesBoardOfDirectors() >= Seting.ORIGINAL_LIMIT_MIN_VOTE_BOARD_OF_DIRECTORS)\\n\" +             \"                .collect(Collectors.toList());\\n\" +             \"        //добавление позиций созданных советом директоров\\n\" +             \"        for (CurrentLawVotesEndBalance currentLawVotesEndBalance : createdByBoardOfDirectors) {\\n\" +             \"            directors.addAllByBoardOfDirectors(currentLawVotesEndBalance.getLaws());\\n\" +             \"        }\\n\" +             \"\\n\" +             \"        //позиции избираемые только советом директоров\\n\" +             \"        List<CurrentLawVotesEndBalance> electedByBoardOfDirectors = current.stream()\\n\" +             \"                .filter(t -> directors.isElectedByBoardOfDirectors(t.getPackageName()) || directors.isCabinets(t.getPackageName()))\\n\" +             \"                .filter(t -> t.getVotesBoardOfDirectors() >= Seting.ORIGINAL_LIMIT_MIN_VOTE_BOARD_OF_DIRECTORS)\\n\" +             \"                .sorted(Comparator.comparing(CurrentLawVotesEndBalance::getVotesBoardOfDirectors).reversed())\\n\" +             \"                .collect(Collectors.toList());\";      String ONE_VOTE = \" ОДИН ГОЛОС \" +             \"\" +             \" когда голосуют данные должности, учитывается как один счет = один голос. \" +             \" CORPORATE_COUNCIL_OF_REFEREES, BOARD_OF_DIRECTORS, GENERAL_EXECUTIVE_DIRECTOR, HIGH_JUDGE и Совет Акционеров. \" +             \" каждый счет который начинается с LIBER учитывает все голоса ЗА (VoteEnum.YES) и ПРОТИВ (VoteEnum.NO) за него \" +             \" дальше отнимается отнимается от ЗА - ПРОТИВ = если остатков выше порога, то он становиться действующим. \" +             \" Перерасчет голосов происходит каждый блок. После голосования голос можно поменять только на противоположный. \" +             \" Ограничений на количество сколько раз можно поменять свой голос нет. Учитываются только те голоса которые даны счетами \" +             \" находящимися в своей должности, к примеру если счет перестал быть в Совете Директор, его голос как в качестве \" +             \" Совета Директоров не учитывается, и не будет учитываться в голосовании. Все голоса действуют, пока счета \" +             \" проголосовавшие находятся в своих должностях. Учитываются также только те голоса, от которых прошло не более \" +             \" четырех лет, но каждый участник, может в любой момент времени обновить свой голос.  \";      String CODE_VOTE_ONE = \" КОД class CurrentLawVotes: method voteGovernment \" +             \"\" +             \" public int voteGovernment(\\n\" +             \"            Map<String, Account> balances,\\n\" +             \"            List<String> governments\\n\" +             \"\\n\" +             \"    ) {\\n\" +             \"        int yes = 0;\\n\" +             \"        int no = 0;\\n\" +             \"\\n\" +             \"        List<String> addressGovernment = governments;\\n\" +             \"        for (String s : YES) {\\n\" +             \"            if (addressGovernment.contains(s)) {\\n\" +             \"                yes += Seting.VOTE_GOVERNMENT;\\n\" +             \"            }\\n\" +             \"\\n\" +             \"        }\\n\" +             \"        for (String s : NO) {\\n\" +             \"            if (addressGovernment.contains(s)) {\\n\" +             \"                no += Seting.VOTE_GOVERNMENT;\\n\" +             \"            }\\n\" +             \"\\n\" +             \"        }\\n\" +             \"\\n\" +             \"\\n\" +             \"        return yes - no;\\n\" +             \"\\n\" +             \"    } \";      String MECHANISM_FOR_REDUCING_THE_NUMBER_OF_SHARES = \" МЕХАНИЗМ СНИЖЕНИЯ КОЛИЧЕСТВА АКЦИЙ \" +             \" Каждый раз когда один счет отправляет на другой счет цифровую акцию, но использует VoteEnum.NO, счет \" +             \" цифровых акций получателя снижается на то количество которое отправил отправитель акций. \" +             \" Пример счет А отправил на счет Б 100 цифровых акций VoteEnum.NO, тогда счет А и счет Б оба теряют 100 \" +             \" цифровых акций. Данная мера нужна чтобы был механизм какой нибудь счет снять с Совета акционеров. \" +             \" Данный механизм действует только на цифровые акции и только в том случае, что отправитель отправил с знаком \" +             \" VoteEnum.NO \";      String WHO_HAS_THE_RIGHT_TO_CREATE_LAWS = \" Создавать законы в криптовалюте Корпорации Международный Торговый Союз имеют права \" +             \" все участники сети, которые имеют минимум пять цифровых доллара. \" +             \"Для создания закона через механизм криптовалюты Корпорации Международного торгового Союза \" +             \" Нужно внутри данной криптовалюты Создать объект класса Laws где packetLawName- является названием пакета законов.\" +             \" List<String> laws - является списком законов, String hashLaw - является адресом данного пакета законов и начинается с LIBER.\" +             \" Чтобы Закон попал в пул законов нужно создать транзакцию где получателем является hashLaw данного закона и вознаграждение \" +             \" майнера равно пять цифровых доллара (5)  данной криптовалюты. После этого как закон попадет в блок, он окажется в пуле \" +             \" законов и за него можно будет голосовать. \" +             \" Количество строк в пакете законов может быть столько, сколько понадобиться и нет никаких ограничений. \";      String POWERS_OF_THE_CORPORATE_COUNCIL_OF_JUDGES = \" ПОЛНОМОЧИЯ КОРПОРАТИВНОГО СОВЕТА СУДЕЙ \" +             \" Утверждает Верховного судью. \" +             \" Участвует в голосовании внедрения поправок. \" +             \" \" +             \" Судебная власть Корпорации Международного Торгового Союза принадлежит \" +             \" одному Верховному суду и таким нижестоящим судам, которые Корпорация Международный \" +             \" Торговый Союз может время от времени издавать и учреждать. \" +             \" Судьи как верховных, так и нижестоящих судов занимают свои должности при хорошем поведении и\" +             \" в установленные сроки получают за свои услуги вознаграждение.\" +             \" Судебная власть распространяется на все дела по закону и справедливости,\" +             \" в том числе инициированные членами для оспаривания незаконного расходования средств,\" +             \" возникающего в соответствии с настоящем Уставом, законами Корпорации Международного Торгового Союза и договорами, \" +             \" заключенными или которые будут заключены в соответствии с их авторитетом.\" +             \" к спорам, \" +             \" в которых Международный Торговый Союз будут стороной; к разногласиям между двумя или более участников сети. \" +             \" Ни один суд не должен быть тайным, но правосудие должно вершиться открыто и бесплатно, полностью и безотлагательно,\" +             \" и каждый человек должен иметь правовую правовую защиту от вреда, причиненного жизни, свободе или имуществу.\" +             \" Верховный Суд CORPORATE_COUNCIL_OF_REFEREES и верховный судья HIGH_JUDGE \";      String HOW_THE_CORPORATE_BOARD_OF_JUDGES_IS_ELECTED = \" КАК ИЗБИРАЮТСЯ КОРПОРАТИВНЫЙ СОВЕТ СУДЕЙ \" +             \" CORPORATE_COUNCIL_OF_REFEREES \" +             \"  состоит из 55 счетов. \" +             \" каждый участник сети может подать на должность CORPORATE_COUNCIL_OF_REFEREES , создав пакет закона, где \" +             \" название пакета CORPORATE_COUNCIL_OF_REFEREES и счет отправителя должен совпадать счетом который указан \" +             \" в первой строке закона который содержится в списке данного пакета \" +             \" 55 счет с наибольшим количеством остатка из голосов получает должность.\" +             \" стоимость подачи на создание закона(должность) стоит пять цифровых долларов (5) в качестве вознаграждения добытчику \" +             \" Процесс голосования описан в VOTE_STOCK \" +             \"\" +             \" Пример участка кода: class LawsController: method currentLaw: \" +             \"  //минимальное значение количество положительных голосов для того чтобы закон действовал,\\n\" +             \"        //позиции избираемые акциями CORPORATE_COUNCIL_OF_REFEREES\\n\" +             \"        List<CurrentLawVotesEndBalance> electedByStockCorporateCouncilOfReferees = current.stream()\\n\" +             \"                .filter(t -> directors.isElectedByStocks(t.getPackageName()))\\n\" +             \"                .filter(t -> t.getPackageName().equals(NamePOSITION.CORPORATE_COUNCIL_OF_REFEREES.toString()))\\n\" +             \"                .filter(t -> t.getVotes() >= Seting.ORIGINAL_LIMIT_MIN_VOTE)\\n\" +             \"                .sorted(Comparator.comparing(CurrentLawVotesEndBalance::getVotes).reversed())\\n\" +             \"                .limit(directors.getDirector(NamePOSITION.CORPORATE_COUNCIL_OF_REFEREES.toString()).getCount())\\n\" +             \"                .collect(Collectors.toList());\\n\";      String HOW_THE_CHIEF_JUDGE_IS_CHOSEN = \" КАК ИЗБИРАЕТСЯ ВЕРХОВНЫЙ СУДЬЯ HIGH_JUDGE \" +             \" Верховный Судья избирается CORPORATE_COUNCIL_OF_REFEREES. \" +             \" Каждый участник сети может подать на должность Верховного Судьи, создав закон, с названием пакета который совпадает с допустимым \" +             \" должностью, где адрес отправителя данной транзакции должен совпадать с первой строкой из списка законов данного пакета. \" +             \" стоимость закона пять цифровых долларов в качестве вознаграждения добытчику.  \" +             \" счет с наибольшим количеством голосов остатка получает данную должность. \" +             \" Механизм голосования описан ONE_VOTE. \" +             \"\" +             \" Пример кода как утверждается верховный судья. class LawsController: method currentLaw. Участок кода \" +             \"   //позиции избираемые советом корпоративных верховных судей\\n\" +             \"        List<CurrentLawVotesEndBalance> electedByCorporateCouncilOfReferees = current.stream()\\n\" +             \"                .filter(t -> directors.isElectedBYCorporateCouncilOfReferees(t.getPackageName()))\\n\" +             \"                .filter(t -> t.getVotesCorporateCouncilOfReferees() >= Seting.ORIGINAL_LIMIT_MIN_VOTE_CORPORATE_COUNCIL_OF_REFEREES)\\n\" +             \"                .sorted(Comparator.comparing(CurrentLawVotesEndBalance::getVotesCorporateCouncilOfReferees)).collect(Collectors.toList()); \";      String POWERS_OF_THE_CHIEF_JUDGE = \" ПОЛНОМОЧИЯ ВЕРХОВНОГО СУДЬИ. \" +             \" Верховный судья участвует в утверждении законов и в утверждении поправок в устав, а также \" +             \" может участвовать в решении споров внутри членов сети как и CORPORATE_COUNCIL_OF_REFEREES \" +             \" но его голос выше чем голос CORPORATE_COUNCIL_OF_REFEREES. \";      String HOW_IS_THE_PROCESS_OF_AMENDING_THE_CHARTER = \" КАК ПРОИСХОДИТ ПРОЦЕСС ВНЕСЕНИЯ ПОПРАВОК В УСТАВ. \" +             \" для внесения поправок нужно создать закон с названием пакета AMENDMENT_TO_THE_CHARTER. \" +             \" Дальше за этот закон должны проголосовать методом описанным в VOTE_ONE \" +             \" Совет Акционеров и остаток голосов должен быть равен или выше 300 участников, \" +             \" также должны проголосовать Совет Директоров и остаток голосов должен быть 60 или больше, \" +             \" также должны проголосовать корпоративные верховные судьи (CORPORATE_COUNCIL_OF_REFEREES) и \" +             \" остаток голосов должен быть равен или больше 5. \" +             \" Но поправки не должны касаться способа установления правил действующих законов, а также \" +             \" избрания Совета Директоров, Совета Акционеров, Генерального Исполнительного Директора, \" +             \" Совета Корпоративных Судей и Верховного Судьи. Поправки могут изменять код, если сохраняются правила \" +             \" избрания действующих должностей (включая правил голосования), законов и добычи денег (добыча цифровых долларов и цифровых акции),\" +             \" Ни одна поправка не должна наделять из выше перечисленных должностей большей властью. \" +             \" Также поправки не должны ущемлять Естественные Права Человека. \" +             \" \" +             \" Пример кода. class LawsController: method currentLaw: участок кода утверждающий действующие поправки\" +             \"  //внедрение поправок в устав\\n\" +             \"        List<CurrentLawVotesEndBalance> chapter_amendment = current.stream()\\n\" +             \"                .filter(t -> !directors.contains(t.getPackageName()))\\n\" +             \"                .filter(t-> Seting.AMENDMENT_TO_THE_CHARTER.equals(t.getPackageName()))\\n\" +             \"                .filter(t->!directors.isCabinets(t.getPackageName()))\\n\" +             \"                .filter(t -> t.getVotesBoardOfShareholders() >= Seting.ORIGINAL_LIMIT_MINT_VOTE_BOARD_OF_SHAREHOLDERS_AMENDMENT)\\n\" +             \"                .filter(t -> t.getVotesBoardOfDirectors() >= Seting.ORIGINAL_LIMIT_MIN_VOTE_BOARD_OF_DIRECTORS_AMENDMENT)\\n\" +             \"                .filter(t -> t.getVotesCorporateCouncilOfReferees() >= Seting.ORIGINAL_LIMIT_MIN_VOTE_CORPORATE_COUNCIL_OF_REFEREES_AMENDMENT)\\n\" +             \"                .sorted(Comparator.comparing(CurrentLawVotesEndBalance::getVotesBoardOfDirectors).reversed()).collect(Collectors.toList());\\n \";      String HOW_THE_BUDGET_IS_APPROVED = \" КАК УТВЕРЖДАЕТСЯ БЮДЖЕТ. \" +             \" Действующий бюджет может быть только один. Бюджет утверждает только Совет Директоров. \" +             \" Для утверждения бюджета нужно получить методом описанным в VOTE_ONE 15 и больше голосов. \" +             \" сам процесс происходит так: \" +             \" 1. Сначала отбираются все пакеты законов где название пакета совпадает с BUDGET. \" +             \" 2. Дальше отбираются все пакеты которые остаток голосов получили 15 или больше. \" +             \" 3. Дальше все эти пакеты сортируются по убыванию, с наибольшим количеством голосов. \" +             \" 4. Дальше отбирается самый первый с наибольшим количеством голосов. \" +             \"\" +             \" Пример кода утверждающий бюджет. class LawsController: method: currentLaw. \" +             \"   //бюджет утверждается только советом директоров.\\n\" +             \"        List<CurrentLawVotesEndBalance> budjet = current.stream()\\n\" +             \"                .filter(t-> !directors.contains(t.getPackageName()))\\n\" +             \"                .filter(t->Seting.BUDGET.equals(t.getPackageName()))\\n\" +             \"                .filter(t->!directors.isCabinets(t.getPackageName()))\\n\" +             \"                .filter(t-> t.getVotesBoardOfDirectors() >= Seting.ORIGINAL_LIMIT_MIN_VOTE_BOARD_OF_DIRECTORS)\\n\" +             \"                .sorted(Comparator.comparing(CurrentLawVotesEndBalance::getVotesBoardOfDirectors).reversed())\\n\" +             \"                .limit(1)\\n\" +             \"                .collect(Collectors.toList());\";        String HOW_IS_THE_STRATEGIC = \" КАК УТВЕРЖДАЕТСЯ СТРАТЕГИЧЕСКИЙ ПЛАН. \" +             \" Стратегический план утверждает Совет Директоров, стратегический план может быть действующим \" +             \" только в единственном экземпляре. Чтобы Стратегический План был действующим, нужно остаток голосов \" +             \" Совета Директоров 15 или больше. Способ голосования VOTE_ONE. В любой момент можно отменить \" +             \" Совет Директоров в любой момент может отменить Стратегический План. Стратегический План действует \" +             \" пока количество голосов 15 или больше. Стратегический План может включать в себя общее направление \" +             \" Корпорации, а также что нужно реализовать. \" +             \"\" +             \" участок кода который показывает как утверждается Стратегический План. \" +             \" class LawsController: method currentLaw: \" +             \" \\n\" +             \"        //план утверждается только палатой Советом Директоров\\n\" +             \"        List<CurrentLawVotesEndBalance> planFourYears = current.stream()\\n\" +             \"                .filter(t->!directors.contains(t.getPackageName()))\\n\" +             \"                .filter(t->Seting.STRATEGIC_PLAN.equals(t.getPackageName()))\\n\" +             \"                .filter(t->!directors.isCabinets(t.getPackageName()))\\n\" +             \"                .filter(t->t.getVotesBoardOfDirectors() >= Seting.ORIGINAL_LIMIT_MIN_VOTE_BOARD_OF_DIRECTORS)\\n\" +             \"                .sorted(Comparator.comparing(CurrentLawVotesEndBalance::getVotesBoardOfDirectors).reversed())\\n\" +             \"                .limit(1)\\n\" +             \"                .collect(Collectors.toList());\";        String HOW_NEW_POSITIONS_ARE_ADDED = \" КАК ДОБАВЛЯЮТСЯ НОВЫЕ ДОЛЖНОСТИ. \" +             \" таким способом добавляются только высшее руководство, подчиненные каждого руководителя\" +             \" нанимают без использования блокчейна, их может нанять сам директор, или иным способом как \" +             \" описано действующими законами. Высшее руководство добавляется в список class Directors.\" +             \" все новые добавленные должности действуют пока их законы которые создают данные должности \" +             \" действуют. Добавлять новые должности может только Совет директоров. \" +             \" Каждый пакет законов который начинается с ADD_DIRECTOR определяется как добавление должности. \" +             \" список законов который находиться внутри данного пакета являются должностями если название в \" +             \" строке начинается с ADD_DIRECTOR. Пример: название пакета ADD_DIRECTOR_PACKAGE\" +             \" название первой третьей и четвертой строки ADD_DIRECTOR_FIRST ADD_DIRECTOR_THIRD \" +             \" ADD_DIRECTOR_FOUR таким образом будет созданы три места для должности. \" +             \" Но если строка начинается с ADD_DIRECTOR то название должности должно быть большими \" +             \" буквами и нижними подчеркиваниями, так же в одной строке должна быть только одна должность \" +             \" и больше никаких слов. Те строки где нет добавления должности, используются для описания \" +             \" полномочий добавленных должностей. \" +             \" Чтобы новые должности были добавлены в список, Совет Директоров должен проголосовать методом \" +             \" VOTE_ONE 15 или больше голосов. \" +             \" После как новые должности будут созданы, каждый участник сети сможет подавать себя на данные должности. \" +             \"\" +             \" пример участка кода который создает новые должности. \" +             \" class LawsController: method currentLaw: \" +             \"\" +             \" \\n\" +             \"        //добавляет законы, которые создают новые должности директоров\\n\" +             \"        List<CurrentLawVotesEndBalance> addDirectors = current.stream()\\n\" +             \"                .filter(t->t.getPackageName().startsWith(Seting.ADD_DIRECTOR))\\n\" +             \"                .filter(t->t.getVotesBoardOfDirectors() >= Seting.ORIGINAL_LIMIT_MIN_VOTE_BOARD_OF_DIRECTORS)\\n\" +             \"                .collect(Collectors.toList());\";        String PROPERTY_OF_THE_CORPORATION = \"  СОБСТВЕННОСТЬ КОРПОРАЦИИ. \" +             \" Вся собственность которая принадлежит Корпорации Международного Торгового Союза, не может быть продана без действующего закона, \" +             \" где будет описан процесс продажи и по какой стоимости будет продана собственность. Счет основателя, и счета других участников не является \" +             \" счетом корпорации, Совет Директоров должен создать отдельный счет который будет как бюджет управляться долько членами действующих \" +             \" Совета Директоров. \";      String INTERNET_STORE_DIRECTOR = \" данный директор занимается разработкой, продвижением и руководством интернет магазина, в котором должны \" +             \" продаваться товары за цифровой доллар или цифровые акции. Детальные полномочия должны быть данны или через действующие законы или \" +             \" выданы Генеральным исполнительным директором или Советом Директоров. Название Магазина должен определить либо Совет Директоров или Генеральный Исполнительный Директор. \";      String GENERAL_EXECUTIVE_DIRECTOR = \" данный Директор координирует действия остальных высших директоров для реализации стратегического плана или \" +             \" поставленных перед ним задач действующими законами. Все полномочия должны быть ему выданы через действующие законы. \";      String DIRECTOR_OF_THE_DIGITAL_EXCHANGE = \" Данный Директор разработкой, продвижением и руководством интернет биржа. Полномочия должны быть \" +             \" выданы ему или действующими законами, или Советом Директоров или или Генеральным Исполнительным Директором. \";      String DIRECTOR_OF_DIGITAL_BANK = \" Данный Директор руководит интернет банком. Все полномочия должны быть выданы или действующими законами, или Советом директоров \" +             \" или Генеральным Исполнительным Директором. \";      String DIRECTOR_OF_THE_COMMERCIAL_COURT = \" Директор частного коммерческого суда должен обеспечивать руководство частным судом, все полномочия \" +             \" должны быть Выданы или действующими законами или Советом Директоров или Генеральным Исполнительным Директором. \";      String MEDIA_DIRECTOR = \" Данный Директор руководит сми, все полномочия должны быть выданы действующими законами, или Советом Директоров или \" +             \" генеральным исполнительным Директором. \";      String DIRECTOR_OF_THE_DEVELOPMENT_OF_THE_IMPLEMENTATION_OF_CRYPTOCURRENCY_TECHNOLOGIES_OF_THE_INTERNATIONAL_TRADE_UNION_CORPORATION = \"\" +             \" Данный Директор руководит разработкой и внедрением нового кода в данную криптовалюту, все полномочия должны быть выданы только через \" +             \" действующие законы, но также могут быть выданы или Советом Директоров, если действующие законы дали такие полномочия Совету Директоров. \" +             \" Также ни одно изменение кода не должно противоречить действующему уставу или действующим законам, Также полномочия могут быть выданы \" +             \" Генеральным Исполнительным Директором, если генеральному исполнительному директору данные полномочия выданы действующим законами. \";       String EXPLANATION_WHY_MONEY_DEMURAGE_IS_USED_HERE = \" ОБЯСНЕНИЕ ПОЧЕМУ ЗДЕСЬ ИСПОЛЬЗУЕТСЯ  ДЕМЕРЕДЖ ДЕНЕГ..\" +             \" Отрицательная ставка сейчас применяется во множестве стран, данная стимулирует держателей денег, когда цена чрезмерно завышена, \" +             \" насыщать рынок деньгами. Количество добываемых денег за каждый блок составляет 200 цифровых долларов и 200 цифровых акций, \" +             \" также 2% от каждой добычи вознаграждение основателю, что составляет 4 цифровых доллара и 4 цифровых Акций при каждой добыче блока. \" +             \" Здесь используется как Теории сильвио Гезеля, а также школы монетаризма (в измененном виде \" +             \" у сильвио Гезеля, отрицательная ставка составляла 1% в месяц, что просто убило бы экономику, \" +             \" при монетаризме рост денежной массы должен был быть пропорционален росту ВВП, но так как \" +             \" в данной системе не получиться посчитать реальный рост ВВП, я установил фиксированный рост, также если денежный рост \" +             \" будет равен ВВП, есть высокая вероятность Гиперинфляции. Деньги должны быть твердые, чтобы \" +             \" бизнес мог прогнозировать свои долгосрочные вложения и от монетаризма, взята только та часть что \" +             \" денежная масса должна расти линейно, но в целом здесь микс из разных экономических школ, включая Австрийскую \" +             \" экономическую школу.). При отрицательной ставке 0.1% каждые пол года для цифровых \" +             \" долларов и 0.2% для цифровых акций мы избегаем последствий тяжелого экономического кризиса для данной валюты. \" +             \" Такой механизм создает коридор цен, где нижняя граница стоимости данных цифровых валют является общее количество выпущенных цифровых \" +             \" долларов и цифровых акций, а верхняя граница является реальная стоимость. Так как только стоимость становиться выше реальной стоимости, \" +             \" держателям выгодней становиться продавать цифровые доллары и цифровые акции, по завышенным ценам, тем самым насыщая рынок деньгами \" +             \" и создавая коррекцию на рынке. \" +             \"\" +             \" Основным источником монетарных кризисов, является между быстрыми изменениями цен на товары и медленным изменением заработных плат. \" +             \" Пример: Представим что стоимость валюты резко подорожало на 30%, держателям выгодней становиться не инвестировать деньги, так как \" +             \" доходы от удерживания валюты, выше чем теперь уже оплачивать более дорогих сотрудников, из за того деньги перестают \" +             \" инвестироваться, люди не дополучают заработные платы, что приводит к тому, что огромное количество товаров не реализуется, \" +             \" что приводит к тому, часть производителей банкротится и увольняют множество рабочих, что еще больше снижает заработную \" +             \" плату у оставшихся, так как становиться профицитный рынок труда. Что  в свою очередь еще больше вызывает страх у держателей \" +             \" денег инвестировать и данный процесс продолжается до того момента, пока стоимость денег не начинает сокращаться в связи с тем \" +             \" что общее количество производственных цепочек сократилось и также сократились товары. \" +             \" Пример: Представим что у нас произошла инфляция и стоимость денег упала на 40% в течение месяца, стоимость товаров резко возрастает, \" +             \" но заработные платы не выросли, таким образом множество товаров не будут куплены, что приводит к закрытию производственных цепочек, \" +             \" что в свою очередь из за избытка рабочих на рынке труда, снижает заработную плату, что также в свою очередь еще больше сокращает \" +             \" количество проданных товаров. Первый случай Дефляционная спираль возникает из за резкого сокращения денег на рынке, второй \" +             \" случай стагфляция чаще возникает когда на рынок поступает резко избыточное количество денег. \" +             \"\" +             \" Чтобы не возникали такие кризисы не возникали, в данной криптовалюте деньги прирастают в одинаковом предсказуемом количестве. \" +             \" 204 (4 - вознаграждение основателю, 200 - вознаграждение добытчику) \" +             \" цифровых долларов и акций за блок, в сутках около 576 блоков. А отрицательная ставка корректирует стоимость монет каждые пол года. \" +             \" Также запрещено использовать частичное банковское резервирование для данных монет, так как их количество растет линейно, и \" +             \" не сможет покрыть долги возникшие из за частичного банковского резервирования, в связи отсутствия с недостатком \" +             \" наличности, так как при частичном банковском резервировании рост долгов будет намного выше, чем данный протокол будет создавать денег. \" +             \" также если увеличить денежную массу изменив настройки, и сделав рост денежной массы значительно выше, может вызвать гиперинфляцию или \" +             \" даже галопирующую инфляцию. Если нужно будет увеличить рост денежной массы это должно происходить только через внесения поправок, \" +             \" сохраняя процент вознаграждения основателя в двух процентах. И добыча за блок не должна увеличиваться больше 5% в течение \" +             \" двадцати лет, каждое следующее увеличение которое может вноситься должно проходить не менее двадцати лет через поправки, \" +             \" и не более 5% за блок от вознаграждения последнего блока. (Пример: если мы изменили \" +             \" через поправки, то добыча не должна быть выше 210 монет, но каждые следующие будет не больше пяти процентов от последнего. \" +             \" Таким образом следующее увеличение внесенное через поправки составит 220.5 монет. Но Эту поправку внесут только через двадцать \" +             \" лет после первой поправки по изменению добычи) \" +             \"\" +             \" При недостатки денежной массы, если не было изменено количество добываемых монет через поправку, можно добавить несколько \" +             \" дополнительных нулей после запятой, таким образом это просто увеличит ценность монет, без увелечения общей выпущенной денежной массы.\" +             \"\" +             \" Отрицательные ставки не должны быть выше 0.5% годовых и ниже 0.2% годовых. Отрицательные ставки можно изменять только через внесения поправок. \" +             \" \";      String FREEDOM_OF_SPEECH = \" Ни один орган данной корпорации или субъект не должен запрещать свободное исповедание \" +             \" какой-либо религии; или ограничивать свободу слова, совести или печати; \" +             \" или право людей мирно собираться или объединяться друг с другом, или не объединяться друг с другом, и \" +             \" обращаться к руководству Корпорации Международного Торгового Союза и к данной корпорации с ходатайством об удовлетворении жалоб; \" +             \" или нарушать право на плоды своего труда или \" +             \" право на мирную жизнь по своему выбору. Свободы слова и совести включают свободу вносить вклад в \" +             \" политические кампании или кандидатуры на корпоративные должности и должны толковаться как \" +             \" распространяющиеся в равной степени на любые средства коммуникации. \";      String RIGHTS = \" Все члены сети, должны соблюдать Естественные Права Человека и не нарушать их. \" +             \" Также должно соблюдаться презумпция невиновности и каждый участник сети должен иметь права на честное независимое \" +             \" судебное разбирательство. Каждый участник имеет права на адвоката или быть самому себе адвокатом. \" +             \" Корпорация Международный Торговый Союз не должна регулировать стоимость товаров и услуг участников сети, которые \" +             \" продают через данную платформу. Также Корпорация не должна запрещать отдельные бренды на своей площадке, но может \" +             \" запрещать продавать целые группы товаров, которые попадают по характеристикам описанных действующими законами, если \" +             \" этот запрет не нарушает Естественные Права Человека. В качестве источника прав можно брать в качестве прецедента \" +             \" и юриспруденции США и Англии. К числу естественных неотчуждаемых прав человека относят право на жизнь, \" +             \" свободу, безопасность, собственность, физическую и психическую неприкосновенность, достоинство личности, личную и семейную тайну и т. п. \" +             \"\" +             \" Ни один действующий закон не должен интерпретироваться так, чтобы нарушать естественные права человека. \" +             \" Корпоративный верховный суд может использовать прецеденты в качестве судебных решений, если эти решения не противоречат \" +             \" действующему уставу и действующим законам.\" +             \" Корпоративный Верховный Суд может создавать прецеденты ано логично как в Ангии, но применять \" +             \" можно если эти прецеденты не нарушают действующий устав или действующие законы Корпорации Международного Торгового Союза. \";  }","package International_Trade_Union.originalCorporateCharter;  public interface OriginalCHARTER_ENG {     String POWERS_OF_THE_BOARD_OF_DIRECTORS = \"Powers of the Board of Directors.\" +             \" The Board of Directors may approve that they have been appointed to positions from the list of Directors \" +             \"Also by law package names start with ADD_DIRECTOR which are packages which are packages\" +             \" List of new phenomena to be managed by differentiated product lines. Data \" +             \" each line that starts with ADD_DIRECTOR will be added to the list of Directors as a new \" +             \"to be expected.\" +             \"which starts with BUDGET is the budget and can only be decided by the Implementation Board.\" +             \"The current budget can be only one.\" +             \" The council also confirmed the serious plan STRATEGIC_PLAN. Strategic \" +             \"There can only be one plan.\" +             \"The Council is also involved in the practice\"+               \" all members of the corporation), as well as participation in the meeting of amendments to the charter AMENDMENT_TO_THE_CHARTER.\" +                       \"\" +                       \"The Council has the right to exist and collects a commission from sales within the platforms of holding Corporations\" +                       \" Measuring the Trade Union, when calculating the coverage will not exceed twenty percent (20%). \" +                       \"All fees must and are allocated to expenditures that are set in the budget.\"+                       \"Also, income is income from the sale of their goods and services, for this there are Office Directors who are withdrawn\" +                       \"Council for Accounting and Sales of Products of the Industrial Union Corporation\" +                       \"\" ;      //rules for laws     //TODO     String HOW_LAWS_ARE_CHOSEN = \"HOW LAWS ARE CHOSEN\" +             \"No law has retroactive effect. No law should violate the current charter or contradict \" +             \" other laws in force. If there is a conflict between several laws from one set of laws, \" +             \" then the current one is the one that is higher in the index. Example: a package for the sale of alcohol \" +             \"the law under index 3 contradicts the law from index 17, in this case the law under index three will be valid.\" +             \"if the laws contradict from different packages, then the package that received more votes is valid\" +             \" from the Board of Shareholders, if there is parity, then the one that received more votes from the Board of Directors, if here too \" +             \"there is parity, then this dispute must be decided by the Chief Justice, if he also did not determine which of the two packages\" +             \"where the laws contradict each other, the laws of one of the packages are more valid, then the priority becomes \" +             \"the one that began to operate earlier, the countdown is determined precisely from the last moment of entry into force. \" +             \" All ordinary laws are valid if they are voted in this way ONE_VOTE by the Board of Shareholders, the Board of Directors and possibly \" +             \"The Chief Justice. For a law to be valid, it must receive equal to or more than 100 of the remaining votes of the Board of Shareholders,\" +             \" 15 remaining votes of the Board of Directors and one vote of the Chief Justice, but if the Chief Justice does not vote or votes against \" +             \"then it is possible to override the veto of the supreme judge by obtaining 200 of the remainder of the votes of the Board of Shareholders and 30 of the remainder of the votes of the Board of Directors.\" +             \" \" +             \"A law is valid as long as it matches the number of votes as described above. Every time someone loses their office\" +             \"also lost are all his votes for all the laws that he voted.\" +             \"\" +             \" Example code in LawsController current law:\" +             \" //laws that don't get enough votes that can only pass if the supreme judge approves\\n\" +             \" List<CurrentLawVotesEndBalance> notEnoughVotes = current.stream()\\n\" +             \" .filter(t -> !directors.contains(t.getPackageName()))\\n\" +             \" .filter(t->!Seting.AMENDMENT_TO_THE_CHARTER.equals(t.getPackageName()))\\n\" +             \" .filter(t->!directors.isCabinets(t.getPackageName()))\\n\" +             \" .filter(t -> !Seting.ORIGINAL_CHARTER_CURRENT_LAW_PACKAGE_NAME.equals(t.getPackageName()))\\n\" +             \" .filter(t -> t.getVotesBoardOfShareholders() >= Seting.ORIGINAL_LIMIT_MIN_VOTE_BOARD_OF_SHAREHOLDERS)\\n\" +             \" .filter(t -> t.getVotesBoardOfDirectors() >= Seting.ORIGINAL_LIMIT_MIN_VOTE_BOARD_OF_DIRECTORS)\\n\" +             \" .filter(t -> t.getVoteHightJudge() >= Seting.ORIGINAL_LIMIT_MIN_VOTE_HIGHT_JUDGE)\\n\" +             \" .sorted(Comparator.comparing(CurrentLawVotesEndBalance::getVotes).reversed()).collect(Collectors.toList());\\n\" +             \"\\n\" +             \"\\n\" +             \" //laws that have received enough votes and do not require the approval of the supreme judge\\n\" +             \" List<CurrentLawVotesEndBalance> powerfulVotes = current.stream()\\n\" +             \" .filter(t -> !directors.contains(t.getPackageName()))\\n\" +             \" .filter(t-> !Seting.AMENDMENT_TO_THE_CHARTER.equals(t.getPackageName()))\\n\" +             \" .filter(t-> !directors.isCabinets(t.getPackageName()))\\n\" +             \" .filter(t -> !Seting.ORIGINAL_CHARTER_CURRENT_LAW_PACKAGE_NAME.equals(t.getPackageName()))\\n\" +             \" .filter(t -> t.getVotesBoardOfShareholders() >= (Seting.ORIGINAL_LIMIT_MIN_VOTE_BOARD_OF_SHAREHOLDERS * Seting.POWERFUL_VOTE))\\n\" +             \" .filter(t -> t.getVotesBoardOfDirectors() >= (Seting.ORIGINAL_LIMIT_MIN_VOTE_BOARD_OF_DIRECTORS * Seting.POWERFUL_VOTE))\\n\" +             \" .sorted(Comparator.comparing(CurrentLawVotesEndBalance::getVotes).reversed()).collect(Collectors.toList()); \";      String HOW_THE_BOARD_OF_DIRECTORS_IS_ELECTED = \"How the Board of Directors is elected.\" +             \"\" +             \" The board of directors consists of 301 BOARD_OF_DIRECTORS accounts. \" +             \" each member of the network can apply for the position of the board of directors by creating a package of law, where \" +             \" the package name BOARD_OF_DIRECTORS and the sender's account must match the account specified \" +             \" in the first line of the law that is contained in the list of this package \" +             \"The 301 account with the most remainder of the votes gets the position.\" +             \"the cost of filing for the creation of a law (position) is worth five digital dollars (5) as a reward to the earner\" +             \"The voting process is described in VOTE_STOCK\" +             \"\" +             \" Code example: LawController: method currentLaw: \" +             \"code section responsible for the election of the board of directors\" +             \" //minimum number of positive votes for the law to be valid,\\n\" +             \" //positions elected by shares of the board of directors\\n\" +             \" List<CurrentLawVotesEndBalance> electedByStockBoardOfDirectors = current.stream()\\n\" +             \" .filter(t -> directors.isElectedByStocks(t.getPackageName()))\\n\" +             \" .filter(t -> t.getPackageName().equals(NamePOSITION.BOARD_OF_DIRECTORS.toString()))\\n\" +             \" .filter(t -> t.getVotes() >= Seting.ORIGINAL_LIMIT_MIN_VOTE)\\n\" +             \" .sorted(Comparator.comparing(CurrentLawVotesEndBalance::getVotes).reversed())\\n\" +             \" .limit(directors.getDirector(NamePOSITION.BOARD_OF_DIRECTORS.toString()).getCount())\\n\" +             \" .collect(Collectors.toList()); \";      String POWERS_OF_THE_BOARD_OF_SHAREHOLDERS = \" Powers of the Board of Shareholders \" +             \" The Council of Shareholders Participates in the approval of Laws (rules that all members of this corporation must comply with) \" +             \" Also, the Board of Shareholders participates in the approval of amendments to the charter of the Corporation of the International Trade Union AMENDMENT_TO_THE_CHARTER \" +             \" The Board of Shareholders may also participate in voting when electing candidates CORPORATE_COUNCIL_OF_REFEREES and BOARD_OF_DIRECTORS \" +             \" using these rules to vote for VOTE_STOCK candidates. \" +             \"\";      String HOW_SHAREHOLDERS_BOARD_IS_ELECTED = \" HOW THE BOARD OF SHAREHOLDERS IS ELECTED \" +             \" The Board of Shareholders consists of one thousand five hundred accounts (1500) with the largest number of shares, but only those accounts are taken into account \" +             \" from whose activity more than a year has not passed. formula: the current year is one year, and if the account was active in this range, it \" +             \" is taken into account. All accounts are sorted in descending order of the number of digital shares, and 1500 accounts with the largest number of \" +             \" shares. Recalculation occurs every block. \" +             \"\" +             \" An example of a section of code how the Board of Shareholders is elected: \" +             \" class UtilsGovernment method findBoardOfShareholders: \" +             \" //determining the board of shareholders\\n\" +             \" public static List<Account> findBoardOfShareholders(Map<String, Account> balances, List<Block> blocks, int limit) {\\n\" +             \"List<Block> minersHaveMoreStock = null;\\n\" +             \" if (blocks.size() > limit) {\\n\" +             \" minersHaveMoreStock = blocks.subList(blocks.size() - limit, blocks.size());\\n\" +             \" } else {\\n\" +             \"minersHaveMoreStock = blocks;\\n\" +             \"}\\n\" +             \" List<Account> boardAccounts = minersHaveMoreStock.stream().map(\\n\" +             \" t -> new Account(t.getMinerAddress(), 0, 0))\\n\" +             \" .collect(Collectors.toList());\\n\" +             \"\\n\" +             \" for (Block block : minersHaveMoreStock) {\\n\" +             \" for (DtoTransaction dtoTransaction : block.getDtoTransactions()) {\\n\" +             \" boardAccounts.add(new Account(dtoTransaction.getSender(), 0, 0));\\n\" +             \"}\\n\" +             \"\\n\" +             \"}\\n\" +             \"\\n\" +             \"\\n\" +             \" CompareObject compareObject = new CompareObject();\\n\" +             \"\\n\" +             \" List<Account> boardOfShareholders = balances.entrySet().stream()\\n\" +             \" .filter(t -> boardAccounts.contains(t.getValue()))\\n\" +             \" .map(t -> t.getValue()).collect(Collectors.toList());\\n\" +             \"\\n\" +             \"\\n\" +             \"boardOfShareholders = boardOfShareholders\\n\" +             \".stream()\\n\" +             \" .filter(t -> !t.getAccount().startsWith(Seting.NAME_LAW_ADDRESS_START))\\n\" +             \" .filter(t -> t.getDigitalStockBalance() > 0)\\n\" +             \" .sorted(Comparator.comparing(Account::getDigitalStockBalance).reversed())\\n\" +             \" .collect(Collectors.toList());\\n\" +             \"\\n\" +             \"boardOfShareholders = boardOfShareholders\\n\" +             \".stream()\\n\" +             \" .limit(Setting.BOARD_OF_SHAREHOLDERS)\\n\" +             \" .collect(Collectors.toList());\\n\" +             \"\\n\" +             \" return boardOfShareholders;\\n\" +             \"}\";      String VOTE_STOCK = \"How shares vote. \" +             \" all shares held by the account are equal to the same number of votes. \" +             \" every time someone makes a transaction to an account that is the address of the given packet that begins \" +             \" LIBER he votes for this package. Only those votes from which more than four years have not passed are taken into account. \" +             \" if the transaction was made VoteEnum.YES then this account receives votes for according to the formula \" +             \" yesV = number of votes equal to the sender's shares.\" +             \" yesN = how many laws this account voted for with VoteEnum.YES\" +             \" resultYES = yesV / math.pow(yesN, 3). Example: A score voted for three scores that start with LIBER,\" +             \"100 shares in the account means 100 votes. 100 / math.pow(3, 3) = 3.7 means each account gets 3.7 votes.\" +             \"\" +             \" if the transaction was made with VoteEnum.NO \" +             \" then the same formula is used, but now all bills for which he voted against are taken into account \" +             \"Example the same account voted for two scores against, it has the same one hundred shares.\" +             \" resultNO = noV / math.pow(noN, 3) = 100/ math.pow(2,3) = 12.5 means every score he voted for, \" +             \"against will get 12.5 votes against.\" +             \" then each score counts all the votes given to it FOR (VoteEnum.YES) and AGAINST (VoteEnum.NO). \" +             \" then this formula is used remainder = resultYES - resultNO. \" +             \"First, these positions are selected for all accounts that received more than or equal to fourteen thousand\" +             \"four hundred votes of the remainder (14400) remainder >= 14400.\" +             \" Further, all accounts are sorted in descending order by remainder and from there the number of accounts on \" +             \" these positions, as much as it is stipulated in this position. Example: \" +             \" For the Board of Directors, that's the 301 accounts with the most balances. \" +             \" \" +             \"At any time you can change your voice, but only to the opposite, which means if\" +             \" you voted for the candidate YES then you can only change to NO and vice versa. \" +             \"There is no limit to how many times you can change your voice.\" +             \"With every block there is a recalculation of votes, if you lose your shares, your candidates\" +             \"are also losing their votes. This measure is specifically implemented so that elected positions\" +             \"were interested in seeing you prosper.\" +             \"Only CORPORATE_COUNCIL_OF_REFEREES and BOARD_OF_DIRECTORS are elected this way\" +             \" Only the last transaction given for each account counts if you haven't updated your vote, \" +             \"then after four years it is annulled.\";      String CODE_VOTE_STOCK = \" class CurrentLawVotes method: votesLaw \" +             \" public double votesLaw(Map<String, Account> balances,\\n\" +             \" Map<String, Integer> yesAverage, Map<String, Integer> noAverage) {\\n\" +             \"double yes = 0.0;\\n\" +             \"double no = 0.0;\\n\" +             \"\\n\" +             \" //\\n\" +             \" for (String s : YES) {\\n\" +             \"\\n\" +             \"int count = 1;\\n\" +             \"count = yesAverage.get(s) > 0 ? yesAverage.get(s) : 1;\\n\" +             \" yes += balances.get(s).getDigitalStockBalance() / Math.pow(count, Seting.POWERING_FOR_VOTING);\\n\" +             \"\\n\" +             \"}\\n\" +             \" //\\n\" +             \" for (String s : NO) {\\n\" +             \"int count = 1;\\n\" +             \" count = noAverage.get(s) > 0 ? noAverage.get(s) : 1;\\n\" +             \" no += balances.get(s).getDigitalStockBalance() / Math.pow(count, Seting.POWERING_FOR_VOTING);\\n\" +             \"\\n\" +             \"}\\n\" +             \"\\n\" +             \"\\n\" +             \"return yes - no;\\n\" +             \"}\";      String POWERS_OF_DIRECTORS_IN_THE_OFFICE = \" POWERS OF DIRECTORS TO THE OFFICE \" +             \"Office directors are senior directors who are directors of their divisions. \" +             \" The powers of each director must be described by the laws in force. But each director must manage \" +             \" only by his division. Coordination of all directors should be the General Executive Director GENERAL_EXECUTIVE_DIRECTOR. \" +             \" \" +             \" Board of Directors, CORPORATE_COUNCIL_OF_REFEREES, HIGH_JUDGE, Board of Shareholders and GENERAL_EXECUTIVE_DIRECTOR can be either \" +             \"individuals and legal entities, but one account will be counted as one vote. \";       String HOW_OFFICE_DIRECTORS_ARE_CHOSEN = \"HOW OFFICE DIRECTORS ARE CHOSEN\" +             \" All Directors of the office, these are the top directors who manage their divisions, are elected only by the Board of Directors. \" +             \" Each member of the network can apply for the position of supreme director by creating a law with a package name that matches the allowed \" +             \" positions, where the address of the sender of this transaction must match the first line from the list of laws in this package. \" +             \"The cost of the law is five digital dollars as a reward to the earner.\" +             \" the score with the most remaining votes wins the position. \" +             \" The voting mechanism is described by ONE_VOTE. \" +             \"\" +             \" An example of a piece of code how positions are elected class LawsController: method currentLaw: \" +             \"\" +             \" //positions created by the board of directors\\n\" +             \" List<CurrentLawVotesEndBalance> createdByBoardOfDirectors = current.stream()\\n\" +             \" .filter(t->t.getPackageName().startsWith(Seting.ADD_DIRECTOR))\\n\" +             \" .filter(t->t.getVotesBoardOfDirectors() >= Seting.ORIGINAL_LIMIT_MIN_VOTE_BOARD_OF_DIRECTORS)\\n\" +             \" .collect(Collectors.toList());\\n\" +             \" //adding positions created by the board of directors\\n\" +             \" for (CurrentLawVotesEndBalance currentLawVotesEndBalance : createdByBoardOfDirectors) {\\n\" +             \"directors.addAllByBoardOfDirectors(currentLawVotesEndBalance.getLaws());\\n\" +             \"}\\n\" +             \"\\n\" +             \" //positions elected only by the board of directors\\n\" +             \" List<CurrentLawVotesEndBalance> electedByBoardOfDirectors = current.stream()\\n\" +             \" .filter(t -> directors.isElectedByBoardOfDirectors(t.getPackageName()) || directors.isCabinets(t.getPackageName()))\\n\" +             \" .filter(t -> t.getVotesBoardOfDirectors() >= Seting.ORIGINAL_LIMIT_MIN_VOTE_BOARD_OF_DIRECTORS)\\n\" +             \" .sorted(Comparator.comparing(CurrentLawVotesEndBalance::getVotesBoardOfDirectors).reversed())\\n\" +             \" .collect(Collectors.toList());\";      String ONE_VOTE = \"ONE VOTE\" +             \"\" +             \" when these positions are voted counts as one count = one vote. \" +             \" CORPORATE_COUNCIL_OF_REFEREES, BOARD_OF_DIRECTORS, GENERAL_EXECUTIVE_DIRECTOR, HIGH_JUDGE and Board of Shareholders. \" +             \" every score that starts with LIBER counts all votes FOR (VoteEnum.YES) and AGAINST (VoteEnum.NO) for it \" +             \" further subtracted subtracted from FOR - AGAINST = if the balances are above the threshold, then it becomes valid. \" +             \"Votes are recalculated every block. After voting, the vote can only be changed to the opposite.\" +             \" There are no restrictions on the number of times you can change your vote. Only those votes that are given by accounts are taken into account \" +             \"in their position, for example, if the account has ceased to be in the Board of Directors, his vote as a \" +             \" The Board of Directors does not and will not count in the voting. All votes are valid until the accounts \" +             \" those who voted are in their positions. Only those votes from which no more than \" +             \" four years, but each participant can at any time renew his vote. \";      String CODE_VOTE_ONE = \" CODE class CurrentLawVotes: method voteGovernment \" +             \"\" +             \"public int voteGovernment(\\n\" +             \" Map<String, Account> balances,\\n\" +             \"List<String>governments\\n\" +             \"\\n\" +             \" ) {\\n\" +             \"int yes = 0;\\n\" +             \"int no = 0;\\n\" +             \"\\n\" +             \" List<String> addressGovernment = governments;\\n\" +             \" for (String s : YES) {\\n\" +             \" if (addressGovernment.contains(s)) {\\n\" +             \" yes += Seting.VOTE_GOVERNMENT;\\n\" +             \"}\\n\" +             \"\\n\" +             \"}\\n\" +             \" for (String s : NO) {\\n\" +             \" if (addressGovernment.contains(s)) {\\n\" +             \"no += Seting.VOTE_GOVERNMENT;\\n\" +             \"}\\n\" +             \"\\n\" +             \"}\\n\" +             \"\\n\" +             \"\\n\" +             \"return yes - no;\\n\" +             \"\\n\" +             \"}\";      String MECHANISM_FOR_REDUCING_THE_NUMBER_OF_SHARES = \" MECHANISM_FOR_REDUCING_THE_NUMBER_OF_SHARES \" +             \" Every time one account sends a digital share to another account, but uses VoteEnum.NO, the account \" +             \"the recipient's digital shares are reduced by the amount sent by the share sender.\" +             \" Example account A sent 100 VoteEnum.NO digital shares to account B, then account A and account B both lose 100 \" +             \" digital shares. This measure is needed so that there is a mechanism to remove some account from the Board of Shareholders. \" +             \" This mechanism is valid only for digital shares and only if the sender sent with the sign \" +             \"VoteEnum.NO\";      String WHO_HAS_THE_RIGHT_TO_CREATE_LAWS = \"Create Laws in Cryptocurrency International Trade Union Corporations have the right\" +             \" all network members who have at least five digital dollars. \" +             \"To create a law through the mechanism of the International Trade Union Corporation's cryptocurrency\" +             \" Inside this cryptocurrency, Create an object of the Laws class, where packetLawName- is the name of the law package.\" +             \" List<String> laws is a list of laws, String hashLaw is the address of this law package and starts with LIBER.\" +             \" In order for a law to be included in the pool of laws, you need to create a transaction where the recipient is the hashLaw of this law and the reward \" +             \" miner equals five digital dollars (5) of this cryptocurrency. After that, as the law gets into the block, it will be in the pool \" +             \"laws and it will be possible to vote for him.\" +             \" The number of lines in a package of laws can be as many as needed and there are no restrictions. \";      String POWERS_OF_THE_CORPORATE_COUNCIL_OF_JUDGES = \"POWERS OF THE CORPORATE COUNCIL OF JUDGES\" +             \"Approves the Chief Justice.\" +             \" Participates in voting on the implementation of amendments. \" +             \" \" +             \"The judicial power of the Corporation of the International Trade Union belongs\" +             \"to one Supreme Court and such inferior courts as the Corporation International\" +             \"The Merchant Union may issue and establish from time to time.\" +             \"Judges of both the supreme and inferior courts hold their offices in good conduct and\" +             \"They receive remuneration for their services within the stipulated time.\" +             \"Judicial power extends to all cases of law and justice,\" +             \"including those initiated by members to challenge the misappropriation of funds,\" +             \"arising under these Articles, the laws of the International Trade Union Corporation and treaties,\" +             \"prisoners or who will be imprisoned according to their authority.\" +             \"to disputes,\" +             \"in which the International Trade Union will be a party; to a disagreement between two or more members of the network.\" +             \"No trial should be secret, but justice should be administered openly and free of charge, completely and without delay,\" +             \"and every person shall have legal remedy against injury to life, liberty, or property.\" +             \" Supreme Court CORPORATE_COUNCIL_OF_REFEREES and Chief Justice HIGH_JUDGE \";      String HOW_THE_CORPORATE_BOARD_OF_JUDGES_IS_ELECTED = \" HOW THE CORPORATE BOARD OF JUDGES IS ELECTED \" +             \"CORPORATE_COUNCIL_OF_REFEREES\" +             \" consists of 55 accounts. \" +             \" each member of the network can apply for the CORPORATE_COUNCIL_OF_REFEREES position by creating a law package, where \" +             \" the name of the package CORPORATE_COUNCIL_OF_REFEREES and the sender's account must match the account specified \" +             \" in the first line of the law that is contained in the list of this package \" +             \"The 55th score with the most remainder of the votes gets the position.\" +             \"the cost of filing for the creation of a law (position) is worth five digital dollars (5) as a reward to the earner\" +             \" The voting process is described in VOTE_STOCK \" +             \"\" +             \" Code snippet example: class LawsController: method currentLaw: \" +             \" //minimum number of positive votes for the law to be valid,\\n\" +             \" //positions elected by shares CORPORATE_COUNCIL_OF_REFEREES\\n\" +             \" List<CurrentLawVotesEndBalance> electedByStockCorporateCouncilOfReferees = current.stream()\\n\" +             \" .filter(t -> directors.isElectedByStocks(t.getPackageName()))\\n\" +             \" .filter(t -> t.getPackageName().equals(NamePOSITION.CORPORATE_COUNCIL_OF_REFEREES.toString()))\\n\" +             \" .filter(t -> t.getVotes() >= Seting.ORIGINAL_LIMIT_MIN_VOTE)\\n\" +             \" .sorted(Comparator.comparing(CurrentLawVotesEndBalance::getVotes).reversed())\\n\" +             \" .limit(directors.getDirector(NamePOSITION.CORPORATE_COUNCIL_OF_REFEREES.toString()).getCount())\\n\" +             \" .collect(Collectors.toList());\\n\";      String HOW_THE_CHIEF_JUDGE_IS_CHOSEN = \" HOW HIGH_JUDGE IS CHOSEN \" +             \"The Chief Justice is elected by CORPORATE_COUNCIL_OF_REFEREES.\" +             \" Each member of the network can apply for the position of Chief Justice by creating a law with a package name that matches the allowed \" +             \" position, where the address of the sender of this transaction must match the first line from the list of laws in this package. \" +             \"The cost of the law is five digital dollars as a reward to the earner.\" +             \" the score with the most remaining votes wins the position. \" +             \" The voting mechanism is described by ONE_VOTE. \" +             \"\" +             \" Code example as stated by the Chief Justice. class LawsController: method currentLaw. Code snippet \" +             \" //positions elected by the board of corporate chief judges\\n\" +             \" List<CurrentLawVotesEndBalance> electedByCorporateCouncilOfReferees = current.stream()\\n\" +             \" .filter(t -> directors.isElectedBYCorporateCouncilOfReferees(t.getPackageName()))\\n\" +             \" .filter(t -> t.getVotesCorporateCouncilOfReferees() >= Seting.ORIGINAL_LIMIT_MIN_VOTE_CORPORATE_COUNCIL_OF_REFEREES)\\n\" +             \" .sorted(Comparator.comparing(CurrentLawVotesEndBalance::getVotesCorporateCouncilOfReferees)).collect(Collectors.toList()); \";      String POWERS_OF_THE_CHIEF_JUDGE = \"POWERS OF THE CHIP JUDGE.\" +             \"The Chief Justice participates in the approval of laws and in the approval of amendments to the charter, as well as\" +             \" can participate in resolving disputes within network members like CORPORATE_COUNCIL_OF_REFEREES \" +             \" but his vote is higher than that of CORPORATE_COUNCIL_OF_REFEREES. \";      String HOW_IS_THE_PROCESS_OF_AMENDING_THE_CHARTER = \" HOW DOES THE PROCESS FOR AMENDING THE CHARTER \" +             \" to make amendments, you need to create a law with the package name AMENDMENT_TO_THE_CHARTER. \" +             \" Further this law must be voted on by the method described in VOTE_ONE \" +             \" Board of Shareholders and the balance of votes must be equal to or higher than 300 members, \" +             \" the Board of Directors must also vote and the balance of votes must be 60 or more, \" +             \" should also vote corporate chief judges (CORPORATE_COUNCIL_OF_REFEREES) and \" +             \"The remainder of the votes must be equal to or greater than 5.\" +             \"But the amendments should not concern the way in which the rules of existing laws are established, and also\" +             \" election of the Board of Directors, Board of Shareholders, General Executive Director, \" +             \" Council of Corporate Judges and Chief Justice. Amendments may change the code if the rules are preserved \" +             \"election of current positions (including voting rules), laws and money mining (mining digital dollars and digital stocks),\" +             \"No amendment should give any of the above positions more power.\" +             \"Also, the amendments must not infringe on Natural Human Rights.\" +             \" \" +             \" Code example. class LawsController: method currentLaw: code section that approves current amendments\" +             \" //introduction of amendments to the charter\\n\" +             \" List<CurrentLawVotesEndBalance> chapter_amendment = current.stream()\\n\" +             \" .filter(t -> !directors.contains(t.getPackageName()))\\n\" +             \" .filter(t->Seting.AMENDMENT_TO_THE_CHARTER.equals(t.getPackageName()))\\n\" +             \" .filter(t->!directors.isCabinets(t.getPackageName()))\\n\" +             \" .filter(t -> t.getVotesBoardOfShareholders() >= Seting.ORIGINAL_LIMIT_MINT_VOTE_BOARD_OF_SHAREHOLDERS_AMENDMENT)\\n\" +             \" .filter(t -> t.getVotesBoardOfDirectors() >= Seting.ORIGINAL_LIMIT_MIN_VOTE_BOARD_OF_DIRECTORS_AMENDMENT)\\n\" +             \" .filter(t -> t.getVotesCorporateCouncilOfReferees() >= Seting.ORIGINAL_LIMIT_MIN_VOTE_CORPORATE_COUNCIL_OF_REFEREES_AMENDMENT)\\n\" +             \" .sorted(Comparator.comparing(CurrentLawVotesEndBalance::getVotesBoardOfDirectors).reversed()).collect(Collectors.toList());\\n \";      String HOW_THE_BUDGET_IS_APPROVED = \" HOW IS THE BUDGET APPROVED. \" +             \"There can be only one effective budget. Only the Board of Directors approves the budget.\" +             \" To approve the budget, you need to get the method described in VOTE_ONE 15 or more votes. \" +             \"the process itself goes like this: \" +             \" 1. First, all packages of laws are selected where the name of the package matches BUDGET. \" +             \"2. Next, all the packages that received 15 or more votes are selected. \" +             \" 3. Then all these packages are sorted in descending order, with the most votes. \" +             \"4. Then the very first one with the most votes is selected.\" +             \"\" +             \" Budget approving code example. class LawsController: method: currentLaw. \" +             \" //the budget is approved only by the board of directors.\\n\" +             \" List<CurrentLawVotesEndBalance>budjet = current.stream()\\n\" +             \" .filter(t-> !directors.contains(t.getPackageName()))\\n\" +             \" .filter(t->Seting.BUDGET.equals(t.getPackageName()))\\n\" +             \" .filter(t->!directors.isCabinets(t.getPackageName()))\\n\" +             \" .filter(t-> t.getVotesBoardOfDirectors() >= Seting.ORIGINAL_LIMIT_MIN_VOTE_BOARD_OF_DIRECTORS)\\n\" +             \" .sorted(Comparator.comparing(CurrentLawVotesEndBalance::getVotesBoardOfDirectors).reversed())\\n\" +             \".limit(1)\\n\" +             \" .collect(Collectors.toList());\";       String HOW_IS_THE_STRATEGIC = \" AS THE STRATEGIC PLAN IS APPROVED. \" +             \" The strategic plan is approved by the Board of Directors, the strategic plan may be valid \" +             \"only in a single copy. For the Strategic Plan to be valid, a balance of votes is needed\" +             \" Board of Directors 15 or more. Voting method VOTE_ONE. You can cancel at any time \" +             \" The Board of Directors can cancel the Strategic Plan at any time. The Strategic Plan is in effect \" +             \" as long as the number of votes is 15 or more. The Strategic Plan may include a general direction \" +             \"Corporations, and what needs to be implemented.\" +             \"\" +             \"a section of code that shows how the Strategic Plan is being approved.\" +             \" class LawsController: method currentLaw: \" +             \"\\n\" +             \" //the plan is approved only by the chamber Board of Directors\\n\" +             \" List<CurrentLawVotesEndBalance> planFourYears = current.stream()\\n\" +             \" .filter(t->!directors.contains(t.getPackageName()))\\n\" +             \" .filter(t->Seting.STRATEGIC_PLAN.equals(t.getPackageName()))\\n\" +             \" .filter(t->!directors.isCabinets(t.getPackageName()))\\n\" +             \" .filter(t->t.getVotesBoardOfDirectors() >= Seting.ORIGINAL_LIMIT_MIN_VOTE_BOARD_OF_DIRECTORS)\\n\" +             \" .sorted(Comparator.comparing(CurrentLawVotesEndBalance::getVotesBoardOfDirectors).reversed())\\n\" +             \".limit(1)\\n\" +             \" .collect(Collectors.toList());\";      String HOW_NEW_POSITIONS_ARE_ADDED = \" HOW ARE NEW POSITIONS ADDED. \" +             \"in this way, only top management, subordinates of each leader, are added\" +             \" are hired without the use of the blockchain, they can be hired by the director himself, or otherwise as \" +             \" described by applicable laws. Top management is added to the list of class Directors.\" +             \"all newly added positions are valid as long as their laws that create these positions\" +             \" work. Only the Board of Directors can add new positions. \" +             \" Every package of laws that starts with ADD_DIRECTOR is defined as adding a position. \" +             \" the list of laws that are inside this package are positions if the name is in \" +             \" line starts with ADD_DIRECTOR. Example: package name ADD_DIRECTOR_PACKAGE\" +             \" the name of the first third and fourth line ADD_DIRECTOR_FIRST ADD_DIRECTOR_THIRD \" +             \" ADD_DIRECTOR_FOUR this will create three positions for the position. \" +             \" But if the line starts with ADD_DIRECTOR then the job title must be large \" +             \" letters and underscores, also there should be only one position in one line \" +             \" and no more words. Those lines where there is no position added are used to describe \" +             \" permissions of the added positions. \" +             \" In order for new positions to be added to the list, the Board of Directors must vote by the \" +             \"VOTE_ONE 15 or more votes.\" +             \"Once new positions are created, each member of the network will be able to apply for these positions.\" +             \"\" +             \" an example of a piece of code that creates new posts. \" +             \" class LawsController: method currentLaw: \" +             \"\" +             \"\\n\" +             \" //adds laws that create new directorships\\n\" +             \" List<CurrentLawVotesEndBalance> addDirectors = current.stream()\\n\" +             \" .filter(t->t.getPackageName().startsWith(Seting.ADD_DIRECTOR))\\n\" +             \" .filter(t->t.getVotesBoardOfDirectors() >= Seting.ORIGINAL_LIMIT_MIN_VOTE_BOARD_OF_DIRECTORS)\\n\" +             \" .collect(Collectors.toList());\";      String PROPERTY_OF_THE_CORPORATION = \" PROPERTY OF THE CORPORATION. \" +             \"All property owned by the International Trade Union Corporation cannot be sold without a valid law,\" +             \" where the sale process will be described and at what price the property will be sold. The account of the founder, and the account of other participants is not \" +             \"corporate account, the Board of Directors should create a separate account which will be managed as a budget by the current members\" +             \" Board of directors. \";      String INTERNET_STORE_DIRECTOR = \"this director is engaged in the development, promotion and management of an online store in which they must \" +             \" sell goods for a digital dollar or digital shares. Detailed authority must be given either through applicable laws or \" +             \"issued by the CEO or the Board of Directors. The name of the Store must be determined by either the Board of Directors or the CEO.\";      String GENERAL_EXECUTIVE_DIRECTOR = \" this Director coordinates the actions of other senior directors to implement the strategic plan or \" +             \"the tasks assigned to him by the laws in force. All powers must be issued to him through the laws in force.\";      String DIRECTOR_OF_THE_DIGITAL_EXCHANGE = \"This Director is the development, promotion and management of the Internet exchange. The authority must be \" +             \"issued to him either by applicable law or by the Board of Directors or by the Chief Executive Officer.\";      String DIRECTOR_OF_DIGITAL_BANK = \"This Director is in charge of Internet Banking. All powers must be issued either by applicable law or by the Board of Directors\" +             \"or the Chief Executive Officer.\";      String DIRECTOR_OF_THE_COMMERCIAL_COURT = \" The director of a private commercial court must provide leadership to a private court, all powers \" +             \"must be Issued either by applicable law or by the Board of Directors or the Chief Executive Officer.\";      String MEDIA_DIRECTOR = \" This Director directs the media, all powers must be issued by applicable laws, or by the Board of Directors or \" +             \"CEO.\";      String DIRECTOR_OF_THE_DEVELOPMENT_OF_THE_IMPLEMENTATION_OF_CRYPTOCURRENCY_TECHNOLOGIES_OF_THE_INTERNATIONAL_TRADE_UNION_CORPORATION = \"\" +             \" This Director manages the development and implementation of new code in this cryptocurrency, all powers must be issued only through \" +             \" current laws, but may also be issued by either the Board of Directors if the current laws have given such powers to the Board of Directors. \" +             \" Also, no code change should be contrary to the current charter or applicable laws. Also, powers can be issued\" +             \" by the Chief Executive Officer, if such authority is granted to the Chief Executive Officer by applicable law. \";      String EXPLANATION_WHY_MONEY_DEMURAGE_IS_USED_HERE = \" EXPLANATION WHY MONEY DEMURAGE IS USED HERE..\" +             \" Negative rates are now used in many countries, this encourages money holders when the price is excessively high, \" +             \" saturate the market with money. The amount of money mined for each block is 200 digital dollars and 200 digital shares, \" +             \"also 2% of each mining reward to the founder, which is 4 digital dollars and 4 digital Shares for each block mining. \" +             \" Here it is used as the Theories of Silvio Gesell, as well as the school of monetarism (in a modified form \" +             \" with Silvio Gesell, the negative rate was 1% per month, which would just kill the economy, \" +             \"under monetarism, the growth of the money supply should have been proportional to the growth of GDP, but since \" +             \" in this system it is not possible to calculate the real GDP growth, I set a fixed growth, also if the money growth \" +             \" will be equal to GDP, there is a high probability of Hyperinflation. Money must be hard in order to \" +             \" business could predict its long-term investments and from monetarism, only that part was taken that \" +             \"the money supply should grow linearly, but in general there is a mix of different economic schools, including the Austrian one\" +             \" economic school.). With a negative rate of 0.1% every six months for digital \" +             \" dollars and 0.2% for digital stocks, we avoid the consequences of a severe economic crisis for this currency. \" +             \" Such a mechanism creates a price corridor, where the lower limit of the value of these digital currencies is the total number of digital currencies issued \" +             \" dollars and digital stocks, and the upper limit is the real value. As soon as the value becomes higher than the real value, \" +             \" it becomes more profitable for holders to sell digital dollars and digital shares at inflated prices, thereby saturating the market with money \" +             \"and creating a correction in the market.\" +             \"\" +             \"The main source of monetary crises is between rapid changes in commodity prices and slow changes in wages.\" +             \" Example: Imagine that the value of the currency has risen sharply by 30%, it becomes more profitable for holders not to invest money, since \" +             \"revenues from holding currency are higher than what is now paid for more expensive employees, because of this, the money stops\" +             \"to invest, people do not receive wages, which leads to the fact that a huge number of goods are not sold,\" +             \"which leads to the fact that some manufacturers go bankrupt and lay off many workers, which further reduces wages\" +             \"pay the rest, as the labor market becomes surplus. Which in turn causes even more fear among the holders\" +             \"money to invest and this process continues until the moment when the value of money begins to decline due to the fact\" +             \"that the total number of production chains has shrunk and so have the goods.\"+              \" Example: Let's imagine that we had inflation and the value of money fell by 40% within a month, the cost of goods rises sharply, \" +                      \" but wages have not risen, so many goods will not be bought, resulting in the closure of production chains, \" +                      \"which, in turn, due to an excess of workers in the labor market, reduces wages, which also further reduces\" +                      \" the number of goods sold. The first case A deflationary spiral occurs due to a sharp reduction in money in the market, the second \" +                      \"The case of stagflation often occurs when a sharply excess amount of money enters the market. \" +                      \"\" +                      \"So that such crises do not arise, in this cryptocurrency, money grows in the same predictable amount. \" +                      \"204 (4 - reward to the founder, 200 - reward to the earner)\" +                      \" digital dollars and shares per block, there are about 576 blocks per day. And the negative rate adjusts the cost of coins every six months. \" +                      \" It is also forbidden to use fractional reserve banking for these coins, since their number grows linearly, and \" +                      \"will not be able to cover the debts incurred due to fractional reserve banking, due to absence due to a lack of \" +                      \" cash, because with fractional reserve banking, the growth in debt will be much higher than this protocol will create money. \" +                      \" also if you increase the money supply by changing the settings, and making the growth of the money supply much higher, it can cause hyperinflation or \" +                      \"even galloping inflation. If it is necessary to increase the growth of the money supply, this should only happen through amendments, \" +                      \" while keeping the founder's reward percentage at two percent. And the mining per block should not increase more than 5% for \" +                      \"twenty years, each subsequent increase that may be made must pass at least twenty years through amendments,\" +                      \" and no more than 5% per block from the reward of the last block. (Example: if we changed \" +                      \"through the amendments, then the extraction should not be higher than 210 coins, but each subsequent one will be no more than five percent of the last.\" +                      \"Thus, the next increase made through the amendments will be 220.5 coins. But this amendment will be made only after twenty\" +                      \" years after the first correction for production change) \" +                      \"\" +                      \" If the money supply is deficient, if the number of mined coins has not been changed through the amendment, you can add a few \" +                      \"additional zeros after the decimal point, so it will simply increase the value of the coins, without increasing the total money supply.\" +                      \"\" +                      \" Negative rates should not be higher than 0.5% per annum and lower than 0.2% per annum. Negative rates can only be changed through amendments. \" +                      \" \";      String FREEDOM_OF_SPEECH = \"No authority of this corporation or entity shall prohibit free practice\" +             \" any religion; or restrict freedom of speech, conscience, or the press; \" +             \"or the right of people to peacefully assemble or associate with each other, or not associate with each other, and \" +             \" apply to the management of the Corporation of the International Trade Union and to this corporation with a request for satisfaction of complaints; \" +             \" or violate the right to the fruits of one's labor or \" +             \" the right to a peaceful life of one's choice. Freedoms of speech and conscience include the freedom to contribute to \" +             \" political campaigns or nominations for corporate office and shall be interpreted as \" +             \"applying equally to any means of communication. \";      String RIGHTS = \"All members of the network must respect the Natural Human Rights and not violate them.\" +             \" The presumption of innocence must also be respected and each member of the network must have the right to an honest independent \" +             \"litigation. Each participant has the right to a lawyer or to be his own lawyer.\" +             \" International Trade Union Corporation should not regulate the cost of goods and services of network members who \" +             \" sell through this platform. Also, the Corporation should not ban individual brands on its site, but may \" +             \"prohibit the sale of entire groups of goods that fall within the characteristics described by applicable laws, if \" +             \"this prohibition does not violate Natural Human Rights. As a source of rights, you can take it as a precedent\" +             \"and the jurisprudence of the United States and England. Among the natural inalienable human rights include the right to life,\" +             \"freedom, security, property, physical and mental integrity, personal dignity, personal and family secrets, etc. \" +             \"\" +             \"No law in force should be interpreted in such a way as to violate the natural rights of man.\" +             \" The Corporate Supreme Court may use precedents as judgments, as long as those decisions do not contradict \" +             \"the current charter and current laws.\" +             \" The Corporate Supreme Court can create precedents in the same way as in England, but apply \" +             \"You can if these precedents do not violate the current charter or current laws of the Corporation of the International Trade Union.\";   }","package International_Trade_Union.originalCorporateCharter;  public interface OriginalPreamble {     String ARTICLE_0 = \" (По ошибке я добавил в устав черновик, который не был еще доработан, но чтобы с нуля не \" +             \" добывать блоки я добавляю сюда оригинальную конституцию-устав. Данный устав подписан основателем и \" +             \" именно этот устав является действительным) \" +             \" Корпорация Международный Торговый Союз это криптовалютная организация целью которой является создание \" +             \" единой торговой эко-системы, позволяющая людям из разных уголков земли продавать, а также приобретать \" +             \" высококачественные товары и услуги, по самым доступным ценам, при этом соблюдая права человека. \" +             \"\" +             \" Корпорация Международный Торговый Союз использует дивизионную продуктовую организационную структуру. \" +             \" В случае если возникли противоречия в Английской версии и Русской, брать за основу русскую версию \" +             \" Устава, так как перевод был осуществлен из Русской в Английскую версию. \"; }","package International_Trade_Union.originalCorporateCharter;  public interface OriginalPreambleEng {     String ARTICLE_0 = \" (By mistake, I added a draft to the bylaws, which has not yet been finalized, but not from scratch \" +             \"to mine blocks, I add here the original constitution-charter. This charter is signed by the founder and \" +             \"it is this statute that is valid)\" +             \" International Trade Union Corporation is a cryptocurrency organization whose goal is to create \" +             \" a unified trading eco-system that allows people from different parts of the world to sell, as well as acquire \" +             \" high-quality goods and services, at the most affordable prices, while respecting human rights. \" +             \"\" +             \" International Trade Union Corporation uses a divisional product organizational structure. \" +             \"If there are any conflicts between the English version and the Russian version, take the Russian version as a basis\" +             \"Charter, as the translation was carried out from the Russian to the English version. \"; }","package International_Trade_Union.setings;  import International_Trade_Union.about_usDraft.AboutUsDraft; import International_Trade_Union.about_us_engDraft.AboutUsEngDraft; import International_Trade_Union.CorporateCharterEngDraft.CorporateCharter; import International_Trade_Union.governments.Directors; import International_Trade_Union.governments.NamePOSITION; import International_Trade_Union.utils.UtilsUse;  import java.util.Set;  public interface Seting {     // значение используется для вычисления процентов     int HUNDRED_PERCENT = 100;     // значение используется как константа года,     // в данной системе отсутствует високосный год     int YEAR = 360;      Directors directors = new Directors();       //используется для очистки из файла, где хранятся отправленные транзакции,     //чтобы предотвратить добавление повторно уже отправленных транзакций     int DAY_DELETED_SENDED_FILE = 3;        //За какой период последних блоков учитывать для отбора акционеров.     //Акционерами могут быть только с наибольшим количеством баланса     //отправители и майнеры.     int BOARDS_BLOCK = (int) (Seting.COUNT_BLOCK_IN_DAY * YEAR);       //минимальное значение количество положительных голосов, для того чтобы избрать     // Совет Директоров и Совет Корпоративных Верховных Судей,     int ORIGINAL_LIMIT_MIN_VOTE = (int) (200 * Seting.COUNT_BLOCK_IN_DAY * 1 / 8);        //Минимальное значение чтобы Совет Корпоративных Верховных Судей могла избрать Верховного Судью     int ORIGINAL_LIMIT_MIN_VOTE_CORPORATE_COUNCIL_OF_REFEREES = 3;      //Минимальное значение остатка голосов чтобы Совет директоров утверждал бюджет,     //стратегический план, в создании новых должностей и назначении новых должностей,     //и т.д. Также участвовал в утверждении законов, вместе с другими участниками.     int ORIGINAL_LIMIT_MIN_VOTE_BOARD_OF_DIRECTORS = 15;//15;      //Минимальное количество остатка голосов чтобы Совет Акционеров     //утверждал вместе с остальными участниками в утверждении законов.     int ORIGINAL_LIMIT_MIN_VOTE_BOARD_OF_SHAREHOLDERS = 100; //100;      //голос Генерального Исполнительного Директора     int ORIGINAL_LIMIT_MIN_VOTE_GENERAL_EXECUTIVE_DIRECTOR = 1;      //голос Верховного Судьи     int ORIGINAL_LIMIT_MIN_VOTE_HIGHT_JUDGE = 1;      //для преодоления верховного судьи, если Верховный Судья не одобрил закон     //то нужно получить в два раза больше голосов, чтобы преодолеть вето Верховного Судьи     int POWERFUL_VOTE = 2;      //данная мера нужна чтобы если один счет голосует за несколько кандидатов,     //его голос не делился равномерно, а становился значительно сильнее,     //чтобы не допустить монополии, если очень богатый человек захочет должностные лица поставить к власти     //то он не сможет пример: счет X проголосовал ЗА = 2 закона и ПРОТИВ = 3 закона     //100 = voteYES, 100 = voteNO, voteYES / (2^3) = 12.5 , voteNO / (3^3) = 3.7     //таким образом чем больше голосует, тем меньше голосов остается для избрания     //должностных лиц, это защита от сверхбогатых участников Совета Акционеров     int POWERING_FOR_VOTING = 3;       //голос должностных лиц,     int VOTE_GOVERNMENT = 1;     //голос должностных лиц вместо акций учитывается только один     //голос, как будто у них одна акция     double STOCK_VOTE_GOVERNMENT = 1;      //    процент который получает основатель от добычи     Double FOUNDERS_REWARD = 2.0;      //address for send rewards     String BASIS_ADDRESS = \"faErFrDnBhfSfNnj1hYjxydKNH28cRw1PBwDQEXH3QsJ\";     String BASIS_PASSWORD = \"3hupFSQNWwiJuQNc68HiWzPgyNpQA2yy9iiwhytMS7rZyfPddNRwtvExeevhayzN6xL2YmTXN6NCA8jBhV9ge1w8KciHedGUMgZyq2T7rDdvekVNwEgf5pQrELv8VAEvQ4Kb5uviXJFuMyuD1kRAGExrZym5nppyibEVnTC9Uiw8YzUh2JmVT9iUajnVV3wJ5foMs\";      //сложность коррекция каждые n блоков     int DIFFICULTY_ADJUSTMENT_INTERVAL = (int) (Seting.COUNT_BLOCK_IN_DAY / 2);     int DIFFICULTY_ADJUSTMENT_INTERVAL_TEST = 10;      long BLOCK_GENERATION_INTERVAL = Seting.BLOCK_TIME * 1000;// after Seting.BLOCK_TIME     long BLOCK_GENERATION_INTERVAL_TEST = 0 * 1000;       long INTERVAL_TARGET = 600000;     long INTERVAL_TARGET_TEST = 25000;      // плата за обслуживание каждые 6 месяцев.     Double ANNUAL_MAINTENANCE_FREE_DIGITAL_DOLLAR_YEAR = 0.2;     //отрицательная ставка для цифровой акции     double ANNUAL_MAINTENANCE_FREE_DIGITAL_STOCK_YEAR = 0.4;     //каждые сколько месяцев снимать     int HALF_YEAR = 2;      //стоимость создания закона 5     double COST_LAW = 5;     //с чего начинается адрес пакета закона     //сокращенно корпорация     String NAME_LAW_ADDRESS_START = \"LIBER\";      int HASH_COMPLEXITY_GENESIS = 1;      //совет акционеров    int BOARD_OF_SHAREHOLDERS = 1500;      //ПОПРАВКА В УСТАВЕ    //требования к поправкам     String AMENDMENT_TO_THE_CHARTER = \"AMENDMENT_TO_THE_CHARTER\";      //директора созданные Советом директоров     String ADD_DIRECTOR = \"ADD_DIRECTOR\";      //бюджет должен формировать только палата представителей     String BUDGET = \"BUDGET\";      //план также утверждается на четыре года и утверждается только палатой представителей     //каждый план обязан содержать дату начала планирования с какого числа вступает в силу.     //FOUR-YEAR PLAN     String STRATEGIC_PLAN = \"STRATEGIC_PLAN\";       //лимиты для ведения поправок     //палата судей минимум 5 голосов     int ORIGINAL_LIMIT_MIN_VOTE_CORPORATE_COUNCIL_OF_REFEREES_AMENDMENT = 5;// 5;     //палата представителей 20% голосов     int ORIGINAL_LIMIT_MIN_VOTE_BOARD_OF_DIRECTORS_AMENDMENT =            directors.getDirector(NamePOSITION.BOARD_OF_DIRECTORS.toString()).getCount() * 20 / 100;      //Совет акционеров минимум 20% голосов     int ORIGINAL_LIMIT_MINT_VOTE_BOARD_OF_SHAREHOLDERS_AMENDMENT = BOARD_OF_SHAREHOLDERS * 20 / 100;       //    адресс основателя: здесь будет мой адрес. Сейчас заглушка     String ADDRESS_FOUNDER_TEST = \"stExZb8ifLfnFoq4JJuTifpAcscegATH8znhwW26zyTa\";     String ADDRESS_FOUNDER = \"stExZb8ifLfnFoq4JJuTifpAcscegATH8znhwW26zyTa\";      String CORPORATE_CHARTER_DRAFT = International_Trade_Union.CorporateCharterDraft.CorporateCharter.getAllConstitution() + \"\\n\" + CorporateCharter.getAllConstitution() + AboutUsDraft.getAboutUs()             + AboutUsEngDraft.getAboutUs();      //КЛЮЧЕВОЕ НАЗВАНИЕ ПАКЕТА ЧТО ЭТО УСТАВ, ДЕЙСТВУЮЩИЙ УСТАВ ПОДПИСАН ОСНОВАТЕЛЕМ.     String ORIGINAL_CHARTER_CURRENT_LAW_PACKAGE_NAME = \"ORIGINAL_CHARTER_CURRENT_LAW_PACKAGE_NAME\";      //КЛЮЧЕВОЕ НАЗВАНИЕ ДЛЯ КОДА КОТОРЫЙ СОПРОВОЖДАЕТСЯ С УСТАВОМ     String ORIGINAL_CHARTER_CURRENT_ALL_CODE = \"ORIGINAL_CHARTER_CURRENT_ALL_CODE\";      //начальная сумма основателя     Double FOUNDERS_REMUNERATION_DIGITAL_DOLLAR = 30000000.0;     double FOUNDERS_REMNUNERATION_DIGITAL_STOCK = 30000000.0;       // сколько секунд в сутках     int DAY_SECOND = 86400;      //    за сколько секунд добывается каждый блок     int BLOCK_TIME = 150;       //сколько блоков добывается в сутки     double COUNT_BLOCK_IN_DAY = (DAY_SECOND / BLOCK_TIME);      //подсчет голосов для должности в годах, учитываются только те голоса     //которые не позже четырех лет для законов и должностей,     //голоса отданные за законы должны обновляться каждые четыре года     //как и за должности     int POSITION_YEAR_VOTE = (int) Seting.COUNT_BLOCK_IN_DAY * YEAR * 4;     //подсчет голосов для законов в годах     int LAW_YEAR_VOTE = (int) Seting.COUNT_BLOCK_IN_DAY * YEAR * 4;         String ORIGINAL_INDEX_FILE = \".\\\\src\\\\main\\\\resources\\\\index\\\\index.txt\";     String ORIGINAL_BLOCKCHAIN_FILE = \".\\\\src\\\\main\\\\resources\\\\blockchain\\\\\";     String ORIGINAL_BALANCE_FILE = \".\\\\src\\\\main\\\\resources\\\\balance\\\\\";     String ORIGINAL_BOARD_0F_SHAREHOLDERS_FILE = \".\\\\src\\\\main\\\\resources\\\\federalGovernment\\\\federalGovernment.txt\";     String ORIGINAL_ALL_CORPORATION_LAWS_FILE = \".\\\\src\\\\main\\\\resources\\\\federalLaws\\\\\";     String ORIGINAL_ACCOUNT = \".\\\\src\\\\main\\\\resources\\\\minerAccount\\\\minerAccount.txt\";     String ORIGINAL_CORPORATE_VOTE_FILE = \".\\\\src\\\\main\\\\resources\\\\vote\\\\\";      String ORIGINAL_ALL_CORPORATION_LAWS_WITH_BALANCE_FILE = \".\\\\src\\\\main\\\\resources\\\\allLawsWithBalance\\\\\";     String ORGINAL_ALL_TRANSACTION_FILE = \".\\\\src\\\\main\\\\resources\\\\transactions\\\\\";     String ORIGINAL_ALL_SENDED_TRANSACTION_FILE = \".\\\\src\\\\main\\\\resources\\\\sendedTransaction\\\\\";     String ORIGINAL_POOL_URL_ADDRESS_FILE = \".\\\\src\\\\main\\\\resources\\\\poolAddress\\\\\";      //адресса discovery     Set<String> ORIGINAL_ADDRESSES = Set.of(\"http://localhost:8083\");      int SIZE_FILE_LIMIT = 100;      //папки файла для тестирования с сохранениям файла     String TEST_LAST_BLOCK = \".\\\\src\\\\test\\\\java\\\\unitted_states_of_mankind\\\\resourceTestingFileSaved\\\\lastBlock\\\\\";     String INDEX_TEST = \".\\\\src\\\\test\\\\java\\\\unitted_states_of_mankind\\\\resourceTestingFileSaved\\\\index\\\\index.txt\";     String TEST_BLOCKCHAIN_SAVED = \".\\\\src\\\\test\\\\java\\\\unitted_states_of_mankind\\\\resourceTestingFileSaved\\\\network\\\\\";     String TEST_BLOCKCHAIN_BALANCES = \".\\\\src\\\\test\\\\java\\\\unitted_states_of_mankind\\\\resourceTestingFileSaved\\\\balances\\\\\";     String TEST_FEDERAL_GOVERNMENT = \".\\\\src\\\\test\\\\java\\\\unitted_states_of_mankind\\\\resourceTestingFileSaved\\\\federal government\\\\federalGovernment.txt\";     String TEST_FEDERAL_LAWS = \".\\\\src\\\\test\\\\java\\\\unitted_states_of_mankind\\\\resourceTestingFileSaved\\\\laws\\\\\";     String TEST_CURRENT_LAWS = \".\\\\src\\\\test\\\\java\\\\unitted_states_of_mankind\\\\resourceTestingFileSaved\\\\current laws\\\\\";     String TEST_FEDERAL_VOTE = \".\\\\src\\\\test\\\\java\\\\unitted_states_of_mankind\\\\resourceTestingFileSaved\\\\vote\\\\\";     String TEST_ALL_FEDERAL_LAWS_WITH_BALANCE_FILE = \".\\\\src\\\\test\\\\java\\\\unitted_states_of_mankind\\\\resourceTestingFileSaved\\\\allLawsWithBalance\\\\\";      //Временный блокчейн для тестирования     String TEST_LAST_BLOCK_TEMPORARY = \".\\\\src\\\\test\\\\java\\\\unitted_states_of_mankind\\\\resourceTestingFileWithoutSave\\\\lastBlock\\\\\";     String TEST_INDEX_TEMPORARY = \".\\\\src\\\\test\\\\java\\\\unitted_states_of_mankind\\\\resourceTestingFileWithoutSave\\\\index\\\\index.txt\";     String TEST_TEMPORARY_BLOCKCHAIN = \".\\\\src\\\\test\\\\java\\\\unitted_states_of_mankind\\\\resourceTestingFileWithoutSave\\\\temporary blockchain\\\\\";     String TEST_BLOCKCHAIN_BALANCES_TEMPORARY = \".\\\\src\\\\test\\\\java\\\\unitted_states_of_mankind\\\\resourceTestingFileWithoutSave\\\\balances\\\\\";     String TEST_FEDERAL_GOVERNMENT_TEMPORARY = \".\\\\src\\\\test\\\\java\\\\unitted_states_of_mankind\\\\resourceTestingFileWithoutSave\\\\federal government\\\\federalGovernment.txt\";     String TEST_FEDERAL_LAWS_TEMPORARY = \".\\\\src\\\\test\\\\java\\\\unitted_states_of_mankind\\\\resourceTestingFileWithoutSave\\\\laws\\\\\";     String TEST_CURRENT_LAWS_TEMPORARY = \".\\\\src\\\\test\\\\java\\\\unitted_states_of_mankind\\\\resourceTestingFileWithoutSave\\\\current laws\\\\\";     String TEST_FEDERAL_VOTE_TEMPORARY = \".\\\\src\\\\test\\\\java\\\\unitted_states_of_mankind\\\\resourceTestingFileSaved\\\\vote\\\\\";     String TEST_ALL_FEDERAL_LAWS_WITH_BALANCE_TEMPORARY = \".\\\\unitedStates\\\\src\\\\test\\\\java\\\\unitted_states_of_mankind\\\\resourceTestingFileWithoutSave\\\\allLawsWithBalance\\\\\";      String TEST_FILE_WRITE_INFO = \".\\\\src\\\\test\\\\java\\\\unitted_states_of_mankind\\\\blockchainTwentyYearTest\\\\\";     double DIGITAL_DOLLAR_REWARDS_BEFORE = 200.0;     double DIGITAL_STOCK_REWARDS_BEFORE = 200.0;     double DIGITAL_DOLLAR_FOUNDER_REWARDS_BEFORE = Math.round(UtilsUse.countPercents(Seting.DIGITAL_DOLLAR_REWARDS_BEFORE, Seting.FOUNDERS_REWARD));     double DIGITAL_REPUTATION_FOUNDER_REWARDS_BEFORE = Math.round(UtilsUse.countPercents(Seting.DIGITAL_STOCK_REWARDS_BEFORE, Seting.FOUNDERS_REWARD));   }","package International_Trade_Union.sheduled;  import org.springframework.context.annotation.Configuration; import org.springframework.scheduling.annotation.EnableScheduling;  @EnableScheduling @Configuration public class SchedulerConfig { }","package International_Trade_Union.simulation;  import lombok.Data;  @Data public class AccountSimulation {     private String publicKey;     private String privateKey;     private double digitalDollarBalance;     private double digitalReputationBalance;       public AccountSimulation(String publicKey, String privateKey, double digitalDollarBalance, double digitalReputationBalance) {         this.publicKey = publicKey;         this.privateKey = privateKey;         this.digitalDollarBalance = digitalDollarBalance;         this.digitalReputationBalance = digitalReputationBalance;     }      public AccountSimulation(String publicKey, double digitalDollarBalance, double digitalReputationBalance) {         this.publicKey = publicKey;         this.digitalDollarBalance = digitalDollarBalance;         this.digitalReputationBalance = digitalReputationBalance;     }      public AccountSimulation() {     }   }","package International_Trade_Union.simulation;    import International_Trade_Union.model.Account;  import java.util.ArrayList; import java.util.List;  public class AddapterAccountSimulationToAccount {     public static List<Account> getAccounts(List<AccountSimulation> accountSimulations){         List<Account> accounts = new ArrayList<>();          for (AccountSimulation accountSimulation :accountSimulations) {              Account account = new Account(accountSimulation.getPublicKey(), accountSimulation.getDigitalDollarBalance());             accounts.add(account);         }         return accounts;     } }","package International_Trade_Union.simulation;    import International_Trade_Union.model.Keys; import International_Trade_Union.utils.UtilsSecurity; import International_Trade_Union.utils.base.Base; import International_Trade_Union.utils.base.Base58;  import java.security.InvalidAlgorithmParameterException; import java.security.NoSuchAlgorithmException; import java.security.NoSuchProviderException; import java.security.spec.InvalidKeySpecException; import java.util.ArrayList; import java.util.List;  public class GenerateAccountsSimulation {     public static List<AccountSimulation> accountSimulations(int count) throws InvalidAlgorithmParameterException, NoSuchAlgorithmException, NoSuchProviderException, InvalidKeySpecException {         Keys keyPair = null;         List<AccountSimulation> list = new ArrayList<>();         Base base = new Base58();         for (int i = 0; i < count; i++) {             keyPair = UtilsSecurity.generateKeyPair();             String pub =keyPair.getPubkey();             String priv = keyPair.getPrivkey();             AccountSimulation accountSimulation = new AccountSimulation(pub, priv, 0.0, 0.0);             list.add(accountSimulation);         }         return list;      } }","package International_Trade_Union.utils.base;  public interface Base {     String encode(byte[] input);     byte[] decode(String input); }","package International_Trade_Union.utils.base;    /*  * Copyright 2011 Google Inc.  * Copyright 2018 Andreas Schildbach  *  * From https://github.com/bitcoinj/bitcoinj/blob/master/core/src/main/java/org/bitcoinj/core/Base58.java  *  * Licensed under the Apache License, Version 2.0 (the \"License\");  * you may not use this file except in compliance with the License.  * You may obtain a copy of the License at  *  *    http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an \"AS IS\" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */  import java.math.BigInteger; import java.util.Arrays;  /**  * Base58 is a way to encode Bitcoin addresses (or arbitrary data) as alphanumeric strings.  * <p>  * Note that this is not the same base58 as used by Flickr, which you may find referenced around the Internet.  * <p>  * Satoshi explains: why base-58 instead of standard base-64 encoding?  * <ul>  * <li>Don't want 0OIl characters that look the same in some fonts and  *     could be used to create visually identical looking minerAccount numbers.</li>  * <li>A string with non-alphanumeric characters is not as easily accepted as an minerAccount number.</li>  * <li>E-mail usually won't line-break if there's no punctuation to break at.</li>  * <li>Doubleclicking selects the whole number as one word if it's all alphanumeric.</li>  * </ul>  * <p>  * However, note that the encoding/decoding runs in O(n&sup2;) time, so it is not useful for large data.  * <p>  * The basic idea of the encoding is to treat the data bytes as a large number represented using  * base-256 digits, convert the number to be represented using base-58 digits, preserve the exact  * number of leading zeros (which are otherwise lost during the mathematical operations on the  * numbers), and finally represent the resulting base-58 digits as alphanumeric ASCII characters.  */ public class Base58 implements Base {     public static final char[] ALPHABET = \"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz\".toCharArray();     private static final char ENCODED_ZERO = ALPHABET[0];     private static final int[] INDEXES = new int[128];     static {         Arrays.fill(INDEXES, -1);         for (int i = 0; i < ALPHABET.length; i++) {             INDEXES[ALPHABET[i]] = i;         }     }      /**      * Encodes the given bytes as a base58 string (no checksum is appended).      *      * @param input the bytes to encode      * @return the base58-encoded string      */     public String encode(byte[] input) {         if (input.length == 0) {             return \"\";         }         // Count leading zeros.         int zeros = 0;         while (zeros < input.length && input[zeros] == 0) {             ++zeros;         }         // Convert base-256 digits to base-58 digits (plus conversion to ASCII characters)         input = Arrays.copyOf(input, input.length); // since we modify it in-place         char[] encoded = new char[input.length * 2]; // upper bound         int outputStart = encoded.length;         for (int inputStart = zeros; inputStart < input.length; ) {             encoded[--outputStart] = ALPHABET[divmod(input, inputStart, 256, 58)];             if (input[inputStart] == 0) {                 ++inputStart; // optimization - skip leading zeros             }         }         // Preserve exactly as many leading encoded zeros in output as there were leading zeros in input.         while (outputStart < encoded.length && encoded[outputStart] == ENCODED_ZERO) {             ++outputStart;         }         while (--zeros >= 0) {             encoded[--outputStart] = ENCODED_ZERO;         }         // Return encoded string (including encoded leading zeros).         return new String(encoded, outputStart, encoded.length - outputStart);     }      /**      * Decodes the given base58 string into the original data bytes.      *      * @param input the base58-encoded string to decode      * @return the decoded data bytes      */     public byte[] decode(String input) {         if (input.length() == 0) {             return new byte[0];         }         // Convert the base58-encoded ASCII chars to a base58 byte sequence (base58 digits).         byte[] input58 = new byte[input.length()];         for (int i = 0; i < input.length(); ++i) {             char c = input.charAt(i);             int digit = c < 128 ? INDEXES[c] : -1;             if (digit < 0) {                 throw new IllegalStateException(\"InvalidCharacter in base 58\");             }             input58[i] = (byte) digit;         }         // Count leading zeros.         int zeros = 0;         while (zeros < input58.length && input58[zeros] == 0) {             ++zeros;         }         // Convert base-58 digits to base-256 digits.         byte[] decoded = new byte[input.length()];         int outputStart = decoded.length;         for (int inputStart = zeros; inputStart < input58.length; ) {             decoded[--outputStart] = divmod(input58, inputStart, 58, 256);             if (input58[inputStart] == 0) {                 ++inputStart; // optimization - skip leading zeros             }         }         // Ignore extra leading zeroes that were added during the calculation.         while (outputStart < decoded.length && decoded[outputStart] == 0) {             ++outputStart;         }         // Return decoded data (including original number of leading zeros).         return Arrays.copyOfRange(decoded, outputStart - zeros, decoded.length);     }      public  BigInteger decodeToBigInteger(String input) {         return new BigInteger(1, decode(input));     }      /**      * Divides a number, represented as an array of bytes each containing a single digit      * in the specified base, by the given divisor. The given number is modified in-place      * to contain the quotient, and the return value is the remainder.      *      * @param number the number to divide      * @param firstDigit the index within the array of the first non-zero digit      *        (this is used for optimization by skipping the leading zeros)      * @param base the base in which the number's digits are represented (up to 256)      * @param divisor the number to divide by (up to 256)      * @return the remainder of the division operation      */     private byte divmod(byte[] number, int firstDigit, int base, int divisor) {         // this is just long division which accounts for the base of the input digits         int remainder = 0;         for (int i = firstDigit; i < number.length; i++) {             int digit = (int) number[i] & 0xFF;             int temp = remainder * base + digit;             number[i] = (byte) (temp / divisor);             remainder = temp % divisor;         }         return (byte) remainder;     } }","package International_Trade_Union.utils;    import International_Trade_Union.setings.Seting; import International_Trade_Union.model.Account;  import java.io.File; import java.io.IOException; import java.security.InvalidKeyException; import java.security.NoSuchAlgorithmException; import java.security.NoSuchProviderException; import java.security.SignatureException; import java.security.spec.InvalidKeySpecException; import java.util.ArrayList; import java.util.List; import java.util.Map; import java.util.stream.Collectors;  public class SaveBalances {      public static void saveBalances(Map<String, Account> balances, String filename) throws IOException, NoSuchAlgorithmException, SignatureException, InvalidKeySpecException, NoSuchProviderException, InvalidKeyException {         int fileLimit = Seting.SIZE_FILE_LIMIT * 1024 * 1024;          //папка чтобы проверить есть ли         File folder = new File(filename);         List<String> files = new ArrayList<>();         for (File file : folder.listFiles()) {             if(!file.isDirectory()){                 files.add(file.getAbsolutePath());             }         }          int count = 0;         files = files.stream().sorted().collect(Collectors.toList());         String nextFile = \"\";          if (files.size() > 0) {             nextFile = files.get(files.size()-1);              count = Integer.parseInt(nextFile.replaceAll(\"[^\\\\d]\", \"\"));           }          File file = new File(nextFile);          if(file.length() >= fileLimit){             count++;          }          nextFile = filename + count + \".txt\";          List<String> jsons = new ArrayList<>();         for (Map.Entry<String, Account> stringAccountEntry : balances.entrySet()) {             String json = UtilsJson.objToStringJson(stringAccountEntry.getValue());             jsons.add(json);         }  //        String json = UtilsJson.objToStringJson(minerAccount); //        UtilsFileSaveRead.save(json + \"\\n\", nextFile);         UtilsFileSaveRead.saves(jsons, nextFile, true);      }      public static Map<String, Account> readLineObject(String filename ) throws IOException, NoSuchAlgorithmException, InvalidKeySpecException, SignatureException, NoSuchProviderException, InvalidKeyException {         List<Account> accounts = new ArrayList<>();         File folder = new File(filename);         for (final File fileEntry : folder.listFiles()) {             if (fileEntry.isDirectory()) {                 System.out.println(\"is directory \" + fileEntry.getAbsolutePath());             } else {                 List<String> list = UtilsFileSaveRead.reads(fileEntry.getAbsolutePath());                 for (String s : list) {                    Account account = UtilsJson.jsonToAccount(s);                     accounts.add(account);                 }              }         }         Map<String, Account> balances = accounts                 .stream()                 .collect(Collectors.toMap(Account::getAccount, t->t, (v1, v2) -> v1));         return balances;     } }","package International_Trade_Union.utils;    import International_Trade_Union.model.Account; import International_Trade_Union.setings.Seting;  import java.util.ArrayList; import java.util.List;  public class UtilAccounts {  //    поиск аккаунта по адрессу     public static Account serchAccountByAddress(List<Account> accountList, String address){         Account result = null;         for (Account account : accountList) {             if(account.getAccount().equals(address)){                 result = account; //                System.out.println(String.format(\"find minerAccount: %s, address %s\", minerAccount.getAccount(), address));                 return result;             }         }         return result;     } //    возвращает список счетов чья наличность больше n     public static List<Account> allAccountsRemnantUpperLimit(              List<Account> accountList, double bottomLineMoney){         List<Account> accounts = new ArrayList<>();                  for (Account account : accountList) {                      if(account.getDigitalDollarBalance()>bottomLineMoney)                         accounts.add(account);                 }               return accounts;     }  //    подсчитывает общий баланс всех участников     public static double getAllBalance( List<Account> accountList){         double allBalance = 0.0;              for (Account account : accountList) {                 if(!account.getAccount().equals(Seting.BASIS_ADDRESS))                     allBalance+=account.getDigitalDollarBalance();             }           return allBalance;     }     }","package International_Trade_Union.utils;  import International_Trade_Union.entity.DtoTransaction.DtoTransaction; import International_Trade_Union.setings.Seting;  import java.io.File; import java.io.IOException; import java.security.InvalidKeyException; import java.security.NoSuchAlgorithmException; import java.security.NoSuchProviderException; import java.security.SignatureException; import java.security.spec.InvalidKeySpecException; import java.util.ArrayList; import java.util.HashSet; import java.util.List; import java.util.Set; import java.util.stream.Collectors;  public class UtilsAllAddresses {     public static void saveAllAddresses(String adress, String filename) throws IOException, NoSuchAlgorithmException, SignatureException, InvalidKeySpecException, NoSuchProviderException, InvalidKeyException {         int fileLimit = Seting.SIZE_FILE_LIMIT * 1024 * 1024;          //папка чтобы проверить есть ли         File folder = new File(filename);         List<String> files = new ArrayList<>();         for (File file : folder.listFiles()) {             if(!file.isDirectory()){                 files.add(file.getAbsolutePath());             }         }           int count = 0;         files = files.stream().sorted().collect(Collectors.toList());         String nextFile = \"\";          if (files.size() > 0) {             nextFile = files.get(files.size()-1);              count = Integer.parseInt(nextFile.replaceAll(\"[^\\\\d]\", \"\"));           }          File file = new File(nextFile);          if(file.length() >= fileLimit){             count++;          }          nextFile = filename + count + \".txt\";          String json = UtilsJson.objToStringJson(adress);         UtilsFileSaveRead.save(json + \"\\n\", nextFile);      }      public static Set<String> readLineObject(String filename ) throws IOException, NoSuchAlgorithmException, InvalidKeySpecException, SignatureException, NoSuchProviderException, InvalidKeyException {         Set<String> allAddresses = new HashSet<>();         File folder = new File(filename);         for (final File fileEntry : folder.listFiles()) {             if (fileEntry.isDirectory()) {                 System.out.println(\"is directory \" + fileEntry.getAbsolutePath());             } else {                 Set<String> list = UtilsFileSaveRead.readSet(fileEntry.getAbsolutePath())                         .stream().collect(Collectors.toSet());                 for (String s : list) {                     allAddresses.add(s);                 }              }         }          allAddresses = allAddresses                 .stream()                 .collect(Collectors.toSet());           return allAddresses;     }  }","package International_Trade_Union.utils;    import International_Trade_Union.entity.DtoTransaction.DtoTransaction; import International_Trade_Union.entity.blockchain.Blockchain; import International_Trade_Union.entity.blockchain.block.Block; import International_Trade_Union.setings.Seting; import International_Trade_Union.model.Account; import International_Trade_Union.vote.VoteEnum;  import java.io.IOException; import java.security.*; import java.security.spec.InvalidKeySpecException; import java.util.*;   public class UtilsBalance {      //подсчет по штучно баланса     public  static Map<String, Account> calculateBalance(Map<String, Account> balances, Block block) throws IOException, NoSuchAlgorithmException, SignatureException, InvalidKeySpecException, NoSuchProviderException, InvalidKeyException {           double percent = Seting.ANNUAL_MAINTENANCE_FREE_DIGITAL_DOLLAR_YEAR / Seting.HALF_YEAR;         double digitalReputationPercent = Seting.ANNUAL_MAINTENANCE_FREE_DIGITAL_STOCK_YEAR / Seting.HALF_YEAR;             int i = (int) block.getIndex();               for (int j = 0; j < block.getDtoTransactions().size(); j++) {                 int BasisSendCount = 0;                   DtoTransaction transaction = block.getDtoTransactions().get(j);                  if(transaction.getSender().startsWith(Seting.NAME_LAW_ADDRESS_START)){                     System.out.println(\"law balance cannot be sender\");                     continue;                 }                 if (transaction.verify()) {                     if(transaction.getSender().equals(Seting.BASIS_ADDRESS))                         BasisSendCount++;                       Account sender = getBalance(transaction.getSender(), balances);                     Account customer = getBalance(transaction.getCustomer(), balances);                      boolean sendTrue = true;                     if(sender.getAccount().equals(Seting.BASIS_ADDRESS) && BasisSendCount > 2){                         System.out.println(\"Basis address can send only two the base address can send no more than two times per block:\" + Seting.BASIS_ADDRESS);                         continue;                     }                      double minerRewards = Seting.DIGITAL_DOLLAR_REWARDS_BEFORE;                     double digitalReputationForMiner = Seting.DIGITAL_STOCK_REWARDS_BEFORE;                        if(sender.getAccount().equals(Seting.BASIS_ADDRESS) ){                        if(i > 1 && (transaction.getDigitalDollar() > minerRewards || transaction.getDigitalStockBalance() > digitalReputationForMiner )){                            System.out.println(\"rewards cannot be upper than \" + minerRewards);                            continue;                        }                         if(!customer.getAccount().equals(block.getFounderAddress()) && !customer.getAccount().equals(block.getMinerAddress())){                             System.out.println(\"Basis address can send only to founder or miner\");                             continue;                         }                     }                     sendTrue = UtilsBalance.sendMoney(sender, customer, transaction.getDigitalDollar(), transaction.getDigitalStockBalance(), transaction.getBonusForMiner(), transaction.getVoteEnum());                      //если транзация валидная то записать данн иыезменения в баланс                     if(sendTrue){                         balances.put(sender.getAccount(), sender);                         balances.put(customer.getAccount(), customer);                     }                  }              }           if (i != 0 && i / Seting.COUNT_BLOCK_IN_DAY % (Seting.YEAR / Seting.HALF_YEAR) == 0.0) {              for (Map.Entry<String, Account> changeBalance : balances.entrySet()) {                 Account change = changeBalance.getValue();                 change.setDigitalStockBalance(change.getDigitalStockBalance() - UtilsUse.countPercents(change.getDigitalStockBalance(), digitalReputationPercent));                 change.setDigitalDollarBalance(change.getDigitalDollarBalance() - UtilsUse.countPercents(change.getDigitalDollarBalance(), percent));             }         }           return balances;      }     //подсчет целиком баланса     public static Map<String, Account> calculateBalances(List<Block> blocks) throws IOException, NoSuchAlgorithmException, SignatureException, InvalidKeySpecException, NoSuchProviderException, InvalidKeyException {         Map<String, Account> balances = new HashMap<>();         for (Block block :  blocks) {             calculateBalance(balances, block);         }          return balances;      }        public static Account getBalance(String address, Map<String, Account> balances) {         if (balances.containsKey(address)) {             return balances.get(address);         } else {             Account account = new Account(address, 0.0, 0.0);             return account;         }     }       public static Account findAccount(Blockchain blockList, String address) throws IOException, NoSuchAlgorithmException, SignatureException, InvalidKeySpecException, NoSuchProviderException, InvalidKeyException {         Map<String, Account> accountMap = calculateBalances(blockList.getBlockchainList());         Account account = accountMap.get(address);         return account != null? account: new Account(address, 0.0, 0.0);     }      public static boolean sendMoney(Account senderAddress, Account recipientAddress, double digitalDollar, double digitalReputation, double minerRewards) throws NoSuchAlgorithmException, InvalidKeySpecException, IOException, SignatureException, NoSuchProviderException, InvalidKeyException {         return sendMoney(senderAddress, recipientAddress, digitalDollar, digitalReputation, minerRewards, VoteEnum.YES);     }      public static boolean sendMoney(Account senderAddress, Account recipientAddress, double digitalDollar, double digitalReputation, double minerRewards, VoteEnum voteEnum) throws NoSuchAlgorithmException, InvalidKeySpecException, NoSuchProviderException, IOException, SignatureException, InvalidKeyException {         double remnantDigitalDollar = 0.0;         double remnantDigitalReputation = 0.0;         boolean sendTrue = true;         if (senderAddress.getAccount().equals(recipientAddress.getAccount())) {             System.out.println(\"sender %s, recipient %s cannot be equals! Error!\".format(senderAddress.getAccount(), recipientAddress.getAccount()));             sendTrue = false;         }          remnantDigitalDollar = senderAddress.getDigitalDollarBalance();         remnantDigitalReputation = senderAddress.getDigitalStockBalance();          if (!senderAddress.getAccount().equals(Seting.BASIS_ADDRESS)) {             if(remnantDigitalDollar < digitalDollar + minerRewards){                 sendTrue = false;             }             else if(remnantDigitalReputation < digitalReputation){                     System.out.printf(\"sender power %f, les than powerSend:  %f\\n\",                             senderAddress.getDigitalStockBalance(), digitalReputation);                     sendTrue = false;              } else if (recipientAddress.getAccount().equals(Seting.BASIS_ADDRESS)) {                 System.out.println(\"Basis canot to be recipient;\");                 sendTrue = false;             } else {                  senderAddress.setDigitalDollarBalance(senderAddress.getDigitalDollarBalance() - digitalDollar);                 senderAddress.setDigitalStockBalance(senderAddress.getDigitalStockBalance() - digitalReputation);                 recipientAddress.setDigitalDollarBalance(recipientAddress.getDigitalDollarBalance() + digitalDollar);                 //сделано чтобы можно было увеличить или отнять власть                 if (voteEnum.equals(VoteEnum.YES)) {                     recipientAddress.setDigitalStockBalance(recipientAddress.getDigitalStockBalance() + digitalReputation);                 } else if (voteEnum.equals(VoteEnum.NO)) {                     //политика сдерживания.                     recipientAddress.setDigitalStockBalance(recipientAddress.getDigitalStockBalance() - digitalReputation);                 }              }           }  else if (senderAddress.getAccount().equals(Seting.BASIS_ADDRESS)) {              recipientAddress.setDigitalDollarBalance(recipientAddress.getDigitalDollarBalance() + digitalDollar);             recipientAddress.setDigitalStockBalance(recipientAddress.getDigitalStockBalance() + digitalReputation);          }         return sendTrue;     } }","package International_Trade_Union.utils;   import com.fasterxml.jackson.core.JsonProcessingException; import International_Trade_Union.config.BLockchainFactory; import International_Trade_Union.config.BlockchainFactoryEnum; import International_Trade_Union.entity.DtoTransaction.DtoTransaction; import International_Trade_Union.entity.blockchain.Blockchain; import International_Trade_Union.entity.blockchain.block.Block; import International_Trade_Union.setings.Seting;   import java.io.*; import java.security.*; import java.security.spec.InvalidKeySpecException; import java.util.*; import java.util.stream.Collectors;  public class UtilsBlock {      public static void saveBlocks(List<Block> blocks, String filename) throws IOException {         int fileLimit = Seting.SIZE_FILE_LIMIT * 1024 * 1024;          //папка чтобы проверить есть ли         File folder = new File(filename);         List<String> files = new ArrayList<>();         for (File file : folder.listFiles()) {             if(!file.isDirectory()){                 files.add(file.getAbsolutePath());             }         }          int count = 0;         files = files.stream().sorted().collect(Collectors.toList());         String nextFile = \"\";          if (files.size() > 0) {             nextFile = files.get(files.size()-1);              count = Integer.parseInt(nextFile.replaceAll(\"[^\\\\d]\", \"\"));           }          File file = new File(nextFile);          if(file.length() >= fileLimit){             count++;          }          nextFile = filename + count + \".txt\";          List<String> jsons = new ArrayList<>();         for (Block block: blocks) {             String json = UtilsJson.objToStringJson(block);             jsons.add(json);         }  //        String json = UtilsJson.objToStringJson(minerAccount); //        UtilsFileSaveRead.save(json + \"\\n\", nextFile);         UtilsFileSaveRead.saves(jsons, nextFile, true);     }     public static void saveBLock(Block block, String filename) throws IOException, NoSuchAlgorithmException, SignatureException, InvalidKeySpecException, NoSuchProviderException, InvalidKeyException {         int fileLimit = Seting.SIZE_FILE_LIMIT * 1024 * 1024;          //папка чтобы проверить есть ли         File folder = new File(filename);         List<String> files = new ArrayList<>();         for (File file : folder.listFiles()) {             if(!file.isDirectory()){                 files.add(file.getAbsolutePath());             }         }           int count = 0;         files = files.stream().sorted().collect(Collectors.toList());         String nextFile = \"\";          if (files.size() > 0) {             nextFile = files.get(files.size()-1);              count = Integer.parseInt(nextFile.replaceAll(\"[^\\\\d]\", \"\"));           }          File file = new File(nextFile);          if(file.length() >= fileLimit){             count++;          }           nextFile = filename + count + \".txt\";          String json = UtilsJson.objToStringJson(block);         UtilsFileSaveRead.save(json + \"\\n\", nextFile);      }        public static List<Block> read(String nameFile) throws FileNotFoundException, JsonProcessingException {         return  UtilsJson.jsonToListBLock(UtilsFileSaveRead.read(nameFile));     }      public static List<Block> readLineObject(String filename ) throws IOException, NoSuchAlgorithmException, InvalidKeySpecException, SignatureException, NoSuchProviderException, InvalidKeyException {         List<Block> blocks = new ArrayList<>();         File folder = new File(filename);          for (final File fileEntry : folder.listFiles()) {             if (fileEntry.isDirectory()) {                 System.out.println(\"is directory \" + fileEntry.getAbsolutePath());             } else {                List<String> list = UtilsFileSaveRead.reads(fileEntry.getAbsolutePath());                 for (String s : list) {                      Block block = UtilsJson.jsonToBLock(s);                     blocks.add(block);                 }              }         }         blocks = blocks                 .stream()                 .sorted(Comparator.comparing(Block::getIndex))                 .collect(Collectors.toList());          return blocks;     }     public static Blockchain readBLock(String nameFile, long BLOCK_GENERATION_INTERVAL, int DIFFICULTY_ADJUSTMENT_INTERVAL, long INTERVAL_TARGET , String ADDRESS_FOUNDER) throws NoSuchAlgorithmException, InvalidKeySpecException, IOException, SignatureException, NoSuchProviderException, InvalidKeyException {         List<Block> blocks = null;         List<List<Block>> list = new ArrayList<>();          File folder = new File(nameFile);          for (final File fileEntry : folder.listFiles()) {             if (fileEntry.isDirectory()) {                 System.out.println(\"is directory \" + fileEntry.getAbsolutePath());             } else {                 blocks = UtilsJson.jsonToListBLock(UtilsFileSaveRead.read(fileEntry.getAbsolutePath()));                 list.add(blocks);             }         }          // new Blockchain(BLOCK_GENERATION_INTERVAL, DIFFICULTY_ADJUSTMENT_INTERVAL, INTERVAL_TARGET, ADDRESS_FOUNDER);         Blockchain blockchain = BLockchainFactory.getBlockchain(BlockchainFactoryEnum.ORIGINAL);         blockchain.setBlockchainList(new ArrayList<>());          for (List<Block> lists : list) {             for (int i = 0; i < lists.size(); i++) {                 blockchain.addBlock(lists.get(i));             }          }          List<Block> blockList = blockchain.getBlockchainList()                 .stream()                 .sorted(Comparator.comparing(Block::getIndex))                 .collect(Collectors.toList());         blockchain.setBlockchainList(blockList);          return blockchain;     }      public static Blockchain readBLock() throws IOException, NoSuchAlgorithmException, InvalidKeySpecException, SignatureException, NoSuchProviderException, InvalidKeyException {        return readBLock(Seting.TEST_FILE_WRITE_INFO, Seting.BLOCK_GENERATION_INTERVAL,  Seting.DIFFICULTY_ADJUSTMENT_INTERVAL, Seting.INTERVAL_TARGET, Seting.ADDRESS_FOUNDER );     }      public static boolean isValidTimestamp(Block newBlock, Block prevBLock, long timestamp){         return (prevBLock.getTimestamp().getTime() - timestamp <newBlock.getTimestamp().getTime())                 && newBlock.getTimestamp().getTime() < System.currentTimeMillis();     }      //https://lhartikk.github.io/jekyll/update/2017/07/13/chapter2.html     //сайт сложности     //https://lhartikk.github.io/jekyll/update/2017/07/13/chapter2.html     //https://tproger.ru/translations/blockchain-explained/      //new https://guicommits.com/building-blockchain-with-python/     public static int difficulty(List<Block> blocks, long BLOCK_GENERATION_INTERVAL, int  DIFFICULTY_ADJUSTMENT_INTERVAL ){          //секунды как часто создается блоки         int difficulty = 1;         Block latestBlock = blocks.get(blocks.size() -1);         if(latestBlock.getIndex() != 0 && latestBlock.getIndex() % DIFFICULTY_ADJUSTMENT_INTERVAL == 0){             difficulty = getAdjustedDifficulty(latestBlock, blocks, BLOCK_GENERATION_INTERVAL, DIFFICULTY_ADJUSTMENT_INTERVAL);             System.out.println(\"difficulty: change dificulty: \" + difficulty);         }         else {             difficulty =  latestBlock.getHashCompexity();         }         return difficulty == 0? 1: difficulty;     }       private static int getAdjustedDifficulty(Block latestBlock, List<Block> blocks, long BLOCK_GENERATION_INTERVAL, int DIFFICULTY_ADJUSTMENT_INTERVAL){         Block prevAdjustmentBlock = blocks.get(blocks.size() - DIFFICULTY_ADJUSTMENT_INTERVAL);          long timeExpected = BLOCK_GENERATION_INTERVAL * DIFFICULTY_ADJUSTMENT_INTERVAL;         long timeTaken = latestBlock.getTimestamp().getTime() - prevAdjustmentBlock.getTimestamp().getTime();          if(timeTaken < timeExpected / 2){              return prevAdjustmentBlock.getHashCompexity() + 1;         }else if(timeTaken > timeExpected * 2){              return prevAdjustmentBlock.getHashCompexity() - 1;         }else {             return prevAdjustmentBlock.getHashCompexity();         }     }      public static boolean validationOneBlock(             String addressFounder,             Block previusblock,             Block thisBlock,             long blockGenerationInterval,             int difficultyAdjustmentInterval,             List<Block> lastBlock) throws IOException, NoSuchAlgorithmException, SignatureException, InvalidKeySpecException, NoSuchProviderException, InvalidKeyException {          boolean addressFounderReward = false;         boolean addressMinerReward = false;         if(!addressFounder.equals(thisBlock.getFounderAddress())){             System.out.println(\"genesis address not equals block founder: \");             System.out.println(\"genesis address: \" + addressFounder);             System.out.println(\"block address: \" + thisBlock.getFounderAddress());             return false;          }               String actualPrevHash = previusblock.hashForBlockchain();             String recordedPrevHash = thisBlock.getPreviousHash();            boolean validated = true;         int countBasisSendFounder = 0;         int countBasisSendAll = 0;         finished:         for (DtoTransaction transaction : thisBlock.getDtoTransactions()) {             if(transaction.verify() && transaction.getSender().equals(Seting.BASIS_ADDRESS)){                 double minerReward = Seting.DIGITAL_DOLLAR_REWARDS_BEFORE;                 double minerPowerReward = Seting.DIGITAL_STOCK_REWARDS_BEFORE;                    if(transaction.getSender().equals(Seting.BASIS_ADDRESS)&&                         transaction.getCustomer().equals(thisBlock.getMinerAddress()) && transaction.getDigitalDollar() > minerReward                         && thisBlock.getIndex() > 1){                     System.out.println(\"wrong transaction: reward miner wrong digital dollar: \" + minerReward + \" index: \" + thisBlock.getIndex());                     System.out.println(\"sendmoney \" + transaction.getDigitalDollar());                     validated = false;                     break;                 }                 if(transaction.getSender().equals(Seting.BASIS_ADDRESS) &&                         transaction.getCustomer().equals(thisBlock.getMinerAddress()) && transaction.getDigitalStockBalance()                         > minerPowerReward                         && thisBlock.getIndex() > 1){                     System.out.println(\"wrong transaction: reward miner wrong digital stock: \" + minerPowerReward + \" need: \" + transaction.getDigitalStockBalance());                     System.out.println(transaction);                     validated = false;                     break;                 }                   if(transaction.getSender().equals(Seting.BASIS_ADDRESS)                         &&transaction.getCustomer().equals(addressFounder)){                     countBasisSendFounder += 1;                 }                  if(transaction.getSender().equals(Seting.BASIS_ADDRESS)&&!transaction.getCustomer().equals(addressFounder))                 {                     countBasisSendAll +=1;                 }                  if(countBasisSendFounder > 2 && thisBlock.getIndex() > 1){                     System.out.println(\"basis sender send for founder uper one: \" + countBasisSendFounder);                     validated = false;                     break;                 }                  if(countBasisSendAll > 1 && thisBlock.getIndex() > 1){                     System.out.println(\"basis sender send uper two: \" + countBasisSendAll + \" block index: \" + thisBlock.getIndex());                     validated = false;                     break;                 }             }             else if(!transaction.verify()){                 System.out.println(\"wrong transaction: \" + transaction + \" verify: \" + transaction.verify());                 validated = false;                 break finished;             }          }             if(!UtilsUse.hashComplexity(thisBlock.getHashBlock(), thisBlock.getHashCompexity())){                 System.out.println(\"does't start hash with 0\");                 System.out.println(\"this block hash: \" + thisBlock.getHashBlock());                 return false;             }              if(!actualPrevHash.equals(recordedPrevHash)){                 System.out.println(\"Blockchain is invalid, expected: \" + recordedPrevHash + \" actual: \" + actualPrevHash );                 System.out.println(\"index block: \" + thisBlock.getIndex());                 System.out.println(\"wrong chain hash\");                 return false;             }          return validated;     }      public static void deleteFiles(){         UtilsFileSaveRead.deleteAllFiles(Seting.ORIGINAL_BLOCKCHAIN_FILE);          UtilsFileSaveRead.deleteAllFiles(Seting.ORIGINAL_BALANCE_FILE);         UtilsFileSaveRead.deleteAllFiles(Seting.ORIGINAL_ALL_CORPORATION_LAWS_FILE);         UtilsFileSaveRead.deleteAllFiles(Seting.ORIGINAL_ALL_CORPORATION_LAWS_WITH_BALANCE_FILE);     }      public static boolean validation(List<Block> blocks, long BLOCK_GENERATION_INTERVAL, int DIFFICULTY_ADJUSTMENT_INTERVAL ) throws IOException, NoSuchAlgorithmException, SignatureException, InvalidKeySpecException, NoSuchProviderException, InvalidKeyException {         boolean validated = true;         List<Block> temporary = new ArrayList<>();         Block prevBlock  = null;         for (Block block : blocks) {             if(prevBlock == null){                 prevBlock = block;                 temporary.add(block);                 continue;             }              temporary.add(block);              validated = validationOneBlock(block.getFounderAddress(),                     prevBlock,                     block,                     BLOCK_GENERATION_INTERVAL,                     DIFFICULTY_ADJUSTMENT_INTERVAL,                     temporary );             if(validated == false){                  System.out.println(\"ERROR: UtilsBlock: validation: prevBLock.Hash():\" + prevBlock.getHashBlock());                 System.out.println(\"ERROR: UtilsBlock: validation: index:\" + block.getIndex());                 System.out.println(\"ERROR: UtilsBlock: validation: block.Hash():\" + block.getHashBlock());                 System.out.println(\"ERROR: UtilsBlock: validation: BLOCK_GENERATION_INTERVAL:\" + BLOCK_GENERATION_INTERVAL);                 System.out.println(\"ERROR: UtilsBlock: validation: DIFFICULTY_ADJUSTMENT_INTERVAL:\" + DIFFICULTY_ADJUSTMENT_INTERVAL);                 System.out.println(\"ERROR: UtilsBlock: validation: temporary:\" + temporary.size());                 return false;             }             prevBlock = block;         }         return validated;     } }","package International_Trade_Union.utils;  import java.io.*; import java.util.ArrayList; import java.util.HashSet; import java.util.List; import java.util.Set;  public class UtilsFileSaveRead {      public static void save(String object, String fileName) throws IOException {        save(object, fileName, true);     }     public static void save(String object, String fileName, boolean save){         try(BufferedWriter writer = new BufferedWriter(new FileWriter(fileName, save))) {             writer.write(object);             writer.flush();          }catch (IOException e){             e.printStackTrace();         }       }      public static void saves(List<String> objects, String fileName, boolean save){          try(BufferedWriter writer = new BufferedWriter(new FileWriter(fileName, save))) {              for (String s : objects) {                 writer.write(s + \"\\n\");             }             writer.flush();          }catch (IOException e){             e.printStackTrace();         }     }      public static String read(String file) throws FileNotFoundException {         String text = \"\";         File file1 = new File(file);         if(!file1.exists()){             System.out.println(\"file dosn't have\");             return text;         }         try( BufferedReader reader = new BufferedReader(new FileReader(file))){             while (reader.ready()){                 text += reader.readLine();             }         }catch (IOException e){             e.printStackTrace();         }         return text;     }     public static Set<String> readSet(String file){         Set<String> list = new HashSet<>();          try( BufferedReader reader = new BufferedReader(new FileReader(file))){             while (reader.ready()){                 list.add(reader.readLine());             }         }catch (IOException e){             e.printStackTrace();         }         return list;     }     public static List<String> reads(String file){         List<String> list = new ArrayList<>();          try( BufferedReader reader = new BufferedReader(new FileReader(file))){             while (reader.ready()){                 list.add(reader.readLine());             }         }catch (IOException e){             e.printStackTrace();         }         return list;     }         public static void deleteAllFiles(String path){         File folder = new File(path);         for (File file : folder.listFiles()) {             if(!file.isDirectory()){                 file.delete();             }         }     }      public static void deleteFile(String path){         File file = new File(path);         file.delete();     }  }","package International_Trade_Union.utils;  import com.fasterxml.jackson.core.JsonProcessingException; import com.fasterxml.jackson.core.type.TypeReference; import com.fasterxml.jackson.databind.ObjectMapper; import International_Trade_Union.entity.DtoTransaction.DtoTransaction; import International_Trade_Union.entity.EntityChain; import International_Trade_Union.entity.blockchain.block.Block; import International_Trade_Union.model.Account; import International_Trade_Union.vote.CurrentLawVotes; import International_Trade_Union.vote.LawEligibleForParliamentaryApproval; import International_Trade_Union.vote.Laws;   import java.io.IOException; import java.io.StringWriter; import java.util.List; import java.util.Set;  public class UtilsJson {     public static String objToStringJson(Object object) throws IOException {         ObjectMapper mapper = new ObjectMapper();         StringWriter writer = new StringWriter();         mapper.writeValue(writer, object);         return writer.toString();     }      public static Object jsonToListBLock(String json, Class cls) throws JsonProcessingException {         ObjectMapper mapper = new ObjectMapper();         return mapper.readValue(json, cls);     }      public static List<Block> jsonToListBLock(String json) throws JsonProcessingException {         ObjectMapper mapper = new ObjectMapper();         return mapper.readValue(json, new TypeReference<List<Block>>(){});     }     public static List<Account> jsonToListAccounts(String json) throws JsonProcessingException {         ObjectMapper mapper = new ObjectMapper();         return mapper.readValue(json, new TypeReference<List<Account>>(){});     }      public static Set<String> jsonToSetAddresses(String json) throws  JsonProcessingException{         ObjectMapper mapper = new ObjectMapper();         return mapper.readValue(json, new TypeReference<Set<String>>(){});     }     public static Block jsonToBLock(String json) throws JsonProcessingException {         ObjectMapper mapper = new ObjectMapper();         return mapper.readValue(json, Block.class);     }      public static Laws jsonToLaw(String json) throws JsonProcessingException {         ObjectMapper mapper = new ObjectMapper();         return mapper.readValue(json, Laws.class);     }      public static CurrentLawVotes jsonToVote(String json) throws  JsonProcessingException{         ObjectMapper mapper = new ObjectMapper();         return mapper.readValue(json, CurrentLawVotes.class);     }      public static LawEligibleForParliamentaryApproval jsonToCurrentLaw(String json) throws JsonProcessingException {         ObjectMapper mapper = new ObjectMapper();         return mapper.readValue(json, LawEligibleForParliamentaryApproval.class);     }     public static Account jsonToAccount(String json) throws JsonProcessingException {         ObjectMapper mapper = new ObjectMapper();         return mapper.readValue(json, Account.class);     }     public static EntityChain jsonToEntityChain(String json) throws  JsonProcessingException{         ObjectMapper mapper = new ObjectMapper();         return mapper.readValue(json, EntityChain.class);     }      public static DtoTransaction jsonToDtoTransaction(String json) throws  JsonProcessingException{         ObjectMapper mapper = new ObjectMapper();         return mapper.readValue(json, DtoTransaction.class);      }      public static List<DtoTransaction> jsonToDtoTransactionList(String json) throws  JsonProcessingException{         ObjectMapper mapper = new ObjectMapper();         return mapper.readValue(json, new TypeReference<List<DtoTransaction>>(){});     } }","package International_Trade_Union.utils;    import International_Trade_Union.model.Keys; import International_Trade_Union.utils.base.Base; import International_Trade_Union.utils.base.Base58;  import org.bouncycastle.asn1.ASN1ObjectIdentifier; import org.bouncycastle.asn1.x9.ECNamedCurveTable; import org.bouncycastle.asn1.x9.X9ECParameters; import org.bouncycastle.crypto.params.ECNamedDomainParameters; import org.bouncycastle.crypto.params.ECPublicKeyParameters; import org.bouncycastle.jcajce.provider.asymmetric.ec.BCECPublicKey; import org.bouncycastle.jce.provider.BouncyCastleProvider; import org.bouncycastle.jce.spec.ECNamedCurveParameterSpec; import org.bouncycastle.jce.spec.ECPublicKeySpec; import org.bouncycastle.math.ec.ECCurve; import org.bouncycastle.math.ec.ECPoint;  import java.io.IOException; import java.math.BigInteger; import java.nio.charset.StandardCharsets; import java.security.*; import java.security.interfaces.ECPublicKey; import java.security.spec.*;  //https://metamug.com/article/security/sign-verify-digital-signature-ecdsa-java.html //https://stackoverflow.com/questions/8451205/create-privatekey-and-publickey-having-a-byte-array-encoded-in-base-64 public class UtilsSecurity {     private static final String SPEC = \"secp256k1\";     private static final String ALGO_ECDSA = \"ECDSA\";     private static final String PROVIDER = \"BC\";      static {         Security.addProvider(new org.bouncycastle.jce.provider.BouncyCastleProvider());     }     public static Keys generateKeyPair() throws NoSuchAlgorithmException, InvalidAlgorithmParameterException, NoSuchProviderException, InvalidKeySpecException {        Base base = new Base58();         Security.addProvider(new org.bouncycastle.jce.provider.BouncyCastleProvider());         ECGenParameterSpec ecSpec = new ECGenParameterSpec(SPEC);         KeyPairGenerator g = KeyPairGenerator.getInstance(ALGO_ECDSA, PROVIDER);         g.initialize(ecSpec, new SecureRandom());         KeyPair keyPair = g.generateKeyPair();         String pub = base.encode(UtilsSecurity.compressed(keyPair.getPublic().getEncoded()));         String priv = base.encode(keyPair.getPrivate().getEncoded());         Keys keys = new Keys(pub, priv);         return keys;     }      public static PrivateKey privateBytToPrivateKey(byte[] bytes) throws NoSuchAlgorithmException, InvalidKeySpecException, NoSuchProviderException {         EncodedKeySpec privateKeySpec = new PKCS8EncodedKeySpec(bytes);         KeyFactory generator = KeyFactory.getInstance(ALGO_ECDSA, PROVIDER);         return generator.generatePrivate(privateKeySpec);     }      public static PublicKey publicByteToPublicKey(byte[] bytes) throws NoSuchAlgorithmException, InvalidKeySpecException, NoSuchProviderException {         //new X509EncodedKeySpec         EncodedKeySpec publicKeySpec = new X509EncodedKeySpec(bytes);         KeyFactory generator = KeyFactory.getInstance(ALGO_ECDSA, PROVIDER);         return generator.generatePublic(publicKeySpec);     }       public static KeyPair createKeyPairWithPrivkeyPubKey(PrivateKey privateKey, PublicKey publicKey){         return new KeyPair(publicKey, privateKey);     }       public static byte[] sign(PrivateKey privateKey, String hex) throws NoSuchAlgorithmException, NoSuchProviderException, InvalidKeyException, SignatureException, IOException {         Signature signature = Signature.getInstance(ALGO_ECDSA, PROVIDER);         signature.initSign(privateKey);         signature.update(hex.getBytes(StandardCharsets.UTF_8));         byte[] signByte = signature.sign();         return signByte;     }      public static boolean verify(String sha256message, byte[] sign, PublicKey publicKey) throws NoSuchAlgorithmException, NoSuchProviderException, InvalidKeyException, SignatureException {         Signature signature = Signature.getInstance(ALGO_ECDSA, PROVIDER);         signature.initVerify(publicKey);         signature.update(sha256message.getBytes(StandardCharsets.UTF_8));         return signature.verify(sign);     }       public static byte[] compressed(byte[] pub) throws NoSuchAlgorithmException, NoSuchProviderException, InvalidAlgorithmParameterException, InvalidKeySpecException {          // === NOT PART OF THE CODE, JUST GETTING TEST VECTOR ===         PublicKey publicKey = UtilsSecurity.publicByteToPublicKey(pub);          ECPublicKey key = (ECPublicKey) publicKey;         byte[] x = key.getW().getAffineX().toByteArray();         byte[] y = key.getW().getAffineY().toByteArray();          // assumes that x and y are (unsigned) big endian encoded         BigInteger xbi = new BigInteger(1, x);         BigInteger ybi = new BigInteger(1, y);         X9ECParameters x9 = ECNamedCurveTable.getByName(SPEC);         ASN1ObjectIdentifier oid = ECNamedCurveTable.getOID(SPEC);         ECCurve curve = x9.getCurve();         ECPoint point = curve.createPoint(xbi, ybi);         ECNamedDomainParameters dParams = new ECNamedDomainParameters(oid,                 x9.getCurve(), x9.getG(), x9.getN(), x9.getH(), x9.getSeed());         ECPublicKeyParameters pubKey = new ECPublicKeyParameters(point, dParams);         System.out.println(pubKey);          // some additional encoding tricks         byte[] compressed = point.getEncoded(true);         return compressed;     }     public static ECPublicKey decodeKey(byte[] encoded) {          ECNamedCurveParameterSpec params = org.bouncycastle.jce.ECNamedCurveTable.getParameterSpec(SPEC);         org.bouncycastle.jce.spec.ECPublicKeySpec keySpec = new ECPublicKeySpec(params.getCurve().decodePoint(encoded), params);         return new BCECPublicKey(ALGO_ECDSA, keySpec, BouncyCastleProvider.CONFIGURATION);     } }","package International_Trade_Union.utils;  import International_Trade_Union.entity.DtoTransaction.DtoTransaction; import International_Trade_Union.entity.blockchain.block.Block; import International_Trade_Union.setings.Seting;  import java.io.File; import java.io.IOException; import java.security.InvalidKeyException; import java.security.NoSuchAlgorithmException; import java.security.NoSuchProviderException; import java.security.SignatureException; import java.security.spec.InvalidKeySpecException; import java.util.ArrayList; import java.util.Comparator; import java.util.List; import java.util.stream.Collectors;  public class UtilsTransaction {     public static void saveAllTransaction(DtoTransaction dtoTransaction, String filename) throws IOException, NoSuchAlgorithmException, SignatureException, InvalidKeySpecException, NoSuchProviderException, InvalidKeyException {         int fileLimit = Seting.SIZE_FILE_LIMIT * 1024 * 1024;          //папка чтобы проверить есть ли         File folder = new File(filename);         List<String> files = new ArrayList<>();         for (File file : folder.listFiles()) {             if(!file.isDirectory()){                 files.add(file.getAbsolutePath());             }         }           int count = 0;         files = files.stream().sorted().collect(Collectors.toList());         String nextFile = \"\";          if (files.size() > 0) {             nextFile = files.get(files.size()-1);              count = Integer.parseInt(nextFile.replaceAll(\"[^\\\\d]\", \"\"));           }          File file = new File(nextFile);          if(file.length() >= fileLimit){             count++;          }          nextFile = filename + count + \".txt\";          String json = UtilsJson.objToStringJson(dtoTransaction);         UtilsFileSaveRead.save(json + \"\\n\", nextFile);      }      public static List<DtoTransaction> readLineObject(String filename ) throws IOException, NoSuchAlgorithmException, InvalidKeySpecException, SignatureException, NoSuchProviderException, InvalidKeyException {         List<DtoTransaction> dtoTransactions = new ArrayList<>();         File folder = new File(filename);         for (final File fileEntry : folder.listFiles()) {             if (fileEntry.isDirectory()) {                 System.out.println(\"is directory \" + fileEntry.getAbsolutePath());             } else {                 List<String> list = UtilsFileSaveRead.reads(fileEntry.getAbsolutePath());                 for (String s : list) {                      DtoTransaction dtoTransaction = UtilsJson.jsonToDtoTransaction(s);                     dtoTransactions.add(dtoTransaction);                 }              }         }         dtoTransactions = dtoTransactions                 .stream()                 .collect(Collectors.toList());          return dtoTransactions;     }  }","package International_Trade_Union.utils;    import International_Trade_Union.setings.Seting;  import java.io.IOException;  import java.math.BigDecimal; import java.nio.charset.Charset; import java.nio.charset.StandardCharsets; import java.security.MessageDigest; import java.security.NoSuchAlgorithmException; import java.util.HashMap; import java.util.List; import java.util.Random; import java.util.Set; import java.util.concurrent.ConcurrentHashMap; import java.util.function.Function; import java.util.function.Predicate; import java.util.regex.Matcher; import java.util.regex.Pattern;  public class UtilsUse {     private static MessageDigest digest;      static {         try {             digest = MessageDigest.getInstance(\"SHA-256\");         } catch (NoSuchAlgorithmException e) {             e.printStackTrace();         }     } //    одно число от другого в процентах     public static Double percentDifferent(Double first, Double second){         return (first / second - 1) * Seting.HUNDRED_PERCENT;     }      //найти моду     public static int mode(List<Integer> array)     {         HashMap<Integer,Integer> hm = new HashMap<Integer,Integer>();         int max  = 1;         int temp = 0;          for(int i = 0; i < array.size(); i++) {              if (hm.get(array.get(i)) != null) {                  int count = hm.get(array.get(i));                 count++;                 hm.put(array.get(i), count);                  if(count > max) {                     max  = count;                     temp = array.get(i);                 }             }              else                 hm.put(array.get(i),1);         }         return temp;     }      public static BigDecimal percentDifferent(BigDecimal first, BigDecimal second){         return first.divide(second).subtract(new BigDecimal(1)).multiply(new BigDecimal(Seting.HUNDRED_PERCENT));     }      public static byte[] sha256(String text){         return digest.digest(text.getBytes(StandardCharsets.UTF_8));     }     public static String sha256hash(String text){         byte[] bytes = sha256(text);         return bytesToHex(bytes);     }      private static String bytesToHex(byte[] hash) {         StringBuilder hexString = new StringBuilder(2 * hash.length);         for (int i = 0; i < hash.length; i++) {             String hex = Integer.toHexString(0xff & hash[i]);             if(hex.length() == 1) {                 hexString.append('0');             }             hexString.append(hex);         }         return hexString.toString();     }      public static String generateRandomStr() {         byte[] array = new byte[7]; // length is bounded by 7         new Random().nextBytes(array);         String generatedString = new String(array, Charset.forName(\"UTF-8\"));          return generatedString;     }      public static double countPercents(double sum, double percent){         return sum * percent / Seting.HUNDRED_PERCENT;     }     public static BigDecimal countPercents(BigDecimal sum, BigDecimal percent){         return sum.multiply(percent).divide(new BigDecimal(Seting.HUNDRED_PERCENT));     }      public  static double countGrowth(long block, double percent, double money){         long year = (long) (block / Seting.COUNT_BLOCK_IN_DAY / (Seting.YEAR / Seting.HALF_YEAR));         double opeartion1 = 1+ (percent / Seting.HALF_YEAR)/Seting.HUNDRED_PERCENT;         double operation2 = Math.pow(opeartion1, year);         double result = money * operation2;         return result;     }      public static boolean hashComplexity(String literral, int hashComplexity){          String regex = \"^[0]{\" + Integer.toString(hashComplexity) + \"}\";         Pattern pattern = Pattern.compile(regex);         Matcher matcher = pattern.matcher(literral);         return matcher.find();     }      public static String hashComplexityStr(String str, int hashComplexity) throws IOException {         int randomNumberProof = 0;         String hash = \"\";         while (true){             randomNumberProof++;             hash = UtilsUse.sha256hash(UtilsJson.objToStringJson(str + randomNumberProof));             if(UtilsUse.hashComplexity(hash.substring(0, hashComplexity), hashComplexity))             {                 break;             }          }         return hash;     }      //для филтрации в стриме, чтобы получить уникальные обекты по полям     public static <T> Predicate<T> distinctByKey(Function<? super T, ?> keyExtractor) {         Set<Object> seen = ConcurrentHashMap.newKeySet();         return t -> seen.add(keyExtractor.apply(t));     }     //подсчитать количество нулей идущих подряд в hash     public static long hashCount(String hash) {         long count = 0;         for (int i = 0; i < hash.length(); i++) {             if(hash.charAt(i) == '0') count++;             else return count;         }         return count;     }      //подсчитывает долю в процентах одного числа от другого     public static double percentageShare(double first, double allNumber){         return (first/allNumber)*Seting.HUNDRED_PERCENT;     }      //опреледеляет ближайщее число к году     public static long nearestDateToYear(long block){         long period = (long) (Seting.COUNT_BLOCK_IN_DAY * Seting.YEAR);         return block / period * period;     }   }","package International_Trade_Union.utils;  import com.fasterxml.jackson.databind.ObjectMapper; import org.apache.http.NameValuePair; import org.apache.http.client.methods.HttpPost; import org.apache.http.message.BasicNameValuePair; import org.json.JSONException;  import javax.net.ssl.HttpsURLConnection; import java.io.*; import java.net.*; import java.nio.charset.Charset; import java.util.ArrayList; import java.util.Base64; import java.util.List;  public class UtilUrl {     public static String readJsonFromUrl(String url) throws IOException, JSONException {         InputStream is = new URL(url).openStream();         try {             BufferedReader rd = new BufferedReader(new InputStreamReader(is, Charset.forName(\"UTF-8\")));             String jsonText = readAll(rd);             ObjectMapper mapper = new ObjectMapper();             return jsonText;         } finally {             is.close();         }     }      private static String readAll(Reader rd) throws IOException {         StringBuilder sb = new StringBuilder();         int cp;         while ((cp = rd.read()) != -1) {             sb.append((char) cp);         }         return sb.toString();     }      public static String getObject(String jsonObject, String requstStr) throws IOException {         URL url = new URL(requstStr);         HttpURLConnection conn = (HttpURLConnection) url.openConnection(); //        conn.connect();         conn.setReadTimeout(10000);         conn.setConnectTimeout(15000);         conn.setRequestMethod(\"POST\");         conn.setRequestProperty(\"Content-Type\", \"application/json; utf-8\");         conn.setRequestProperty(\"Accept\", \"application/json\");         conn.setDoOutput(true);            try(OutputStream outputStream = conn.getOutputStream()) {             byte[] input = jsonObject.getBytes(\"utf-8\");             outputStream.write(input, 0, input.length);             conn.getResponseCode();         }           conn.connect();         try(BufferedReader br = new BufferedReader(                 new InputStreamReader(conn.getInputStream(), \"utf-8\"))) {             StringBuilder response = new StringBuilder();             String responseLine = null;             while ((responseLine = br.readLine()) != null) {                 response.append(responseLine.trim());             }             return response.toString();          }      }         public static void sendPost(String jsonObject, String requestStr) throws IOException {          URL url = new URL(requestStr);         HttpURLConnection conn = (HttpURLConnection) url.openConnection(); //        conn.connect();         conn.setReadTimeout(10000);         conn.setConnectTimeout(15000);         conn.setRequestMethod(\"POST\");         conn.setRequestProperty(\"Content-Type\", \"application/json; utf-8\");         conn.setRequestProperty(\"Accept\", \"application/json\");         conn.setDoOutput(true);            try(OutputStream outputStream = conn.getOutputStream()) {             byte[] input = jsonObject.getBytes(\"utf-8\");             outputStream.write(input, 0, input.length);             conn.getResponseCode();         }           conn.connect();     }     }","package International_Trade_Union.vote;  import lombok.Data; import International_Trade_Union.model.Account; import International_Trade_Union.setings.Seting; import org.apache.tomcat.util.net.jsse.JSSEUtil;  import java.util.List; import java.util.Map; import java.util.Objects; import java.util.Set; import java.util.stream.Collectors;  @Data public class CurrentLawVotes {     private String addressLaw;     private Set<String> YES;     private Set<String> NO;       public CurrentLawVotes() {     }      public CurrentLawVotes(String addressLaw, Set<String> YES, Set<String> NO) {         this.addressLaw = addressLaw;         this.YES = YES;         this.NO = NO;     }      //подсчет голосов для палат     public int voteGovernment(             Map<String, Account> balances,             List<String> governments      ) {         int yes = 0;         int no = 0;          List<String> addressGovernment = governments;         for (String s : YES) {             if (addressGovernment.contains(s)) {                 yes += Seting.VOTE_GOVERNMENT;             }          }         for (String s : NO) {             if (addressGovernment.contains(s)) {                 no += Seting.VOTE_GOVERNMENT;             }          }           return yes - no;      }      //для избрания должностных лиц     public double votesLaw(Map<String, Account> balances,                            Map<String, Integer> yesAverage, Map<String, Integer> noAverage) {         double yes = 0.0;         double no = 0.0;           //         for (String s : YES) {              int count = 1;             count = yesAverage.get(s) > 0 ? yesAverage.get(s) : 1;             yes += balances.get(s).getDigitalStockBalance() / Math.pow(count, Seting.POWERING_FOR_VOTING);          }         //         for (String s : NO) {             int count = 1;             count = noAverage.get(s) > 0 ? noAverage.get(s) : 1;             no += balances.get(s).getDigitalStockBalance() / Math.pow(count, Seting.POWERING_FOR_VOTING);          }           return yes - no;     }      //для избрания должностных лиц     public double votes(Map<String, Account> balances,                         Map<String, Integer> yesAverage, Map<String, Integer> noAverage) {         double yes = 0.0;         double no = 0.0;         for (String s : YES) {             int count = 1;             count = yesAverage.get(s) > 0 ? yesAverage.get(s) : 1;             yes += balances.get(s).getDigitalStockBalance() / count;          }         for (String s : NO) {             int count = 1;             count = noAverage.get(s) > 0 ? noAverage.get(s) : 1;             no += balances.get(s).getDigitalStockBalance() / count;          }           return yes - no;     }      @Override     public boolean equals(Object o) {         if (this == o) return true;         if (!(o instanceof CurrentLawVotes)) return false;         CurrentLawVotes that = (CurrentLawVotes) o;         return getAddressLaw().equals(that.getAddressLaw());     }      @Override     public int hashCode() {         return Objects.hash(getAddressLaw());     } }","package International_Trade_Union.vote;  import lombok.Data;  import java.util.List; import java.util.Objects;  @Data public class CurrentLawVotesEndBalance {     private String addressLaw;     private double votes;     //CORPORATE_COUNCIL_OF_REFEREES     private int votesCorporateCouncilOfReferees;      //BOARD_OF_DIRECTORS     private int votesBoardOfDirectors;     private int votesBoardOfShareholders;      //GENERAL_EXECUTIVE_DIRECTOR     private int voteGeneralExecutiveDirector;     private int voteHightJudge;      private int founderVote;     private String packageName;     private List<String> laws;      public CurrentLawVotesEndBalance() {     }      public CurrentLawVotesEndBalance             (String addressLaw,              String packageName,              double votes,              int votesCorporateCouncilOfReferees,              int votesBoardOfDirectors,              int votesBoardOfShareholders,              int voteGeneralExecutiveDirector,              int voteHightJudge,                     int founderVote,              List<String> laws) {         this.addressLaw = addressLaw;         this.packageName = packageName;         this.votesCorporateCouncilOfReferees = votesCorporateCouncilOfReferees;         this.votesBoardOfShareholders = votesBoardOfShareholders;         this.votesBoardOfDirectors = votesBoardOfDirectors;         this.voteGeneralExecutiveDirector = voteGeneralExecutiveDirector;         this.voteHightJudge = voteHightJudge;         this.founderVote = founderVote;          this.votes = votes;         this.laws = laws;      }      @Override     public boolean equals(Object o) {         if (this == o) return true;         if (!(o instanceof CurrentLawVotesEndBalance)) return false;         CurrentLawVotesEndBalance that = (CurrentLawVotesEndBalance) o;         return getAddressLaw().equals(that.getAddressLaw());     }      @Override     public int hashCode() {         return Objects.hash(getAddressLaw());     } }","package International_Trade_Union.vote;   import lombok.Data; import International_Trade_Union.model.Account;  import java.util.Objects;  @Data public class LawEligibleForParliamentaryApproval {     public LawEligibleForParliamentaryApproval(Account account, Laws laws) {         this.account = account;         this.laws = laws;         this.name = account.getAccount();     }      public LawEligibleForParliamentaryApproval() {     }      private String name;     private Account account;     private Laws laws;      @Override     public boolean equals(Object o) {         if (this == o) return true;         if (!(o instanceof LawEligibleForParliamentaryApproval)) return false;         LawEligibleForParliamentaryApproval that = (LawEligibleForParliamentaryApproval) o;         return Objects.equals(getName(), that.getName()) && Objects.equals(getAccount(), that.getAccount()) && Objects.equals(getLaws(), that.getLaws());     }      @Override     public int hashCode() {         return Objects.hash(getName(), getAccount(), getLaws());     } }","package International_Trade_Union.vote;   import lombok.Data; import International_Trade_Union.setings.Seting; import International_Trade_Union.utils.UtilsJson; import International_Trade_Union.utils.UtilsUse;  import java.io.IOException; import java.util.List; import java.util.Objects;  @Data public class Laws {     //название пакета закона     String packetLawName;     List<String> laws;     String hashLaw;      public Laws() {     }      public Laws(String packetLawName, List<String> laws) throws IOException {         this.packetLawName = packetLawName;         this.laws = laws;         this.hashLaw = Seting.NAME_LAW_ADDRESS_START + UtilsUse.sha256hash(UtilsJson.objToStringJson(this));     }      @Override     public boolean equals(Object o) {         if (this == o) return true;         if (!(o instanceof Laws)) return false;         Laws laws = (Laws) o;         return getHashLaw().equals(laws.getHashLaw());     }      @Override     public int hashCode() {         return Objects.hash(getHashLaw());     } }","package International_Trade_Union.vote;  import International_Trade_Union.entity.DtoTransaction.DtoTransaction; import International_Trade_Union.entity.blockchain.Blockchain; import International_Trade_Union.entity.blockchain.block.Block; import International_Trade_Union.governments.Director; import International_Trade_Union.governments.Directors; import International_Trade_Union.governments.UtilsGovernment; import International_Trade_Union.model.Account; import International_Trade_Union.model.FIndPositonHelperData; import International_Trade_Union.setings.Seting;  import java.io.IOException; import java.security.InvalidKeyException; import java.security.NoSuchAlgorithmException; import java.security.NoSuchProviderException; import java.security.SignatureException; import java.security.spec.InvalidKeySpecException; import java.util.*; import java.util.stream.Collectors;  public class UtilsCurrentLaw {     //подсчет по штучно баланса     public static Map<String, CurrentLawVotes> calculateVote(Map<String, CurrentLawVotes> votes, List<Account> governments, Block block) throws IOException, NoSuchAlgorithmException, SignatureException, InvalidKeySpecException, NoSuchProviderException, InvalidKeyException {          for (int j = 0; j < block.getDtoTransactions().size(); j++) {             DtoTransaction transaction = block.getDtoTransactions().get(j);              if (transaction.getSender().startsWith(Seting.NAME_LAW_ADDRESS_START)) {                 System.out.println(\"law balance cannot be sender\");                 continue;             }             if (transaction.verify() && transaction.getCustomer().startsWith(Seting.NAME_LAW_ADDRESS_START)) {                 for (Account account : governments) {                     //основатель не может участвовать в голосовании                     //!block.getFounderAddress().equals(transaction.getSender())                     if (transaction.getSender().equals(account.getAccount())) {                         CurrentLawVotes currentLawVotes = votes.get(transaction.getCustomer());                          if (currentLawVotes == null) {                             currentLawVotes = new CurrentLawVotes();                             currentLawVotes.setAddressLaw(transaction.getCustomer());                             currentLawVotes.setYES(new HashSet<>());                             currentLawVotes.setNO(new HashSet<>());                              votes.put(transaction.getCustomer(), currentLawVotes);                         }                          if (transaction.getVoteEnum().equals(VoteEnum.YES)) {                              currentLawVotes.getYES().add(transaction.getSender());                             currentLawVotes.getNO().remove(transaction.getSender());                          } else if (transaction.getVoteEnum().equals(VoteEnum.NO)) {                             currentLawVotes.getNO().add(transaction.getSender());                             currentLawVotes.getYES().remove(transaction.getSender());                         }                     }                 }              }          }           return votes;      }      //подсчет целиком баланса     public static Map<String, CurrentLawVotes> calculateVotes(List<Account> governments, List<Block> blocks) throws IOException, NoSuchAlgorithmException, SignatureException, InvalidKeySpecException, NoSuchProviderException, InvalidKeyException {         Map<String, CurrentLawVotes> votes = new HashMap<>();         for (Block block : blocks) {             calculateVote(votes, governments, block);         }          return votes;      }      //возвращаяет усредненное количество голосов,     //суть проста если есть один акаунт и он имеет 100 акций     //и проголосовал за один закон то все сто акций будут для этого закона как сто голосов     //если за два закона то 100/2 то есть если он на протяжении трех лет проголосовал     //за n законов, то его голоса делятся на n.     public static Map<String, Integer> calculateAverageVotesYes(Map<String, CurrentLawVotes> votesMap) {         Map<String, Integer> voteAverage = new HashMap<>();         for (Map.Entry<String, CurrentLawVotes> current : votesMap.entrySet()) {             for (String yesVoteAddress : current.getValue().getYES()) {                 if (voteAverage.containsKey(yesVoteAddress)) {                     int count = voteAverage.get(yesVoteAddress);                     voteAverage.put(yesVoteAddress, count + 1);                 } else {                     int count = 1;                     voteAverage.put(yesVoteAddress, count);                 }             }          }         return voteAverage;     }      //подсчитывает голоса No     public static Map<String, Integer> calculateAverageVotesNo(Map<String, CurrentLawVotes> votesMap) {         Map<String, Integer> voteAverage = new HashMap<>();         for (Map.Entry<String, CurrentLawVotes> current : votesMap.entrySet()) {             for (String yesVoteAddress : current.getValue().getNO()) {                 if (voteAverage.containsKey(yesVoteAddress)) {                     int count = voteAverage.get(yesVoteAddress);                     voteAverage.put(yesVoteAddress, count + 1);                 } else {                     int count = 1;                     voteAverage.put(yesVoteAddress, count);                 }             }          }         return voteAverage;     }        //возвращает списки позиций     public static Map<Director, List<String>> findPositions(              Map<String, Account> balances,             Blockchain blockchain,             List<LawEligibleForParliamentaryApproval> allGovernment,             List<Account> BoardOfShareholders,             Map<Director, FIndPositonHelperData> fIndPositonHelperData      ) throws IOException, NoSuchAlgorithmException, InvalidKeySpecException, SignatureException, NoSuchProviderException, InvalidKeyException {         //список должностей         Directors directors = new Directors();         Map<Director, List<LawEligibleForParliamentaryApproval>> positionsListMap = new HashMap<>();         //добавление всех должностей         for (Director higherSpecialPositions : directors.getDirectors()) {             positionsListMap.put(higherSpecialPositions, UtilsLaws.getPossions(allGovernment, higherSpecialPositions));         }         //список законов с голосами         Map<Director, List<CurrentLawVotesEndBalance>> curentLawVotesEndBalance = new HashMap<>();         for (Map.Entry<Director, List<LawEligibleForParliamentaryApproval>> corp : positionsListMap.entrySet()) {             //убрать повторяющиеся должности из списка.             corp.setValue(corp.getValue().stream() //                    .filter(t-> finalBoardOfShareholders.contains(new Account(t.getLaws().getLaws().get(0), 0, 0)))                     .distinct().collect(Collectors.toList()));              //получить баланс и голоса для действующих законов             curentLawVotesEndBalance.put(corp.getKey(), UtilsGovernment.filters(corp.getValue(), balances, BoardOfShareholders,                     blockchain.getBlockchainList(), Seting.POSITION_YEAR_VOTE));             List<CurrentLawVotesEndBalance> temporary;             if (fIndPositonHelperData.get(corp.getKey()).isElectedWithStock()) {                   //отобрать голоса выше лимита                 curentLawVotesEndBalance.put(corp.getKey(), curentLawVotesEndBalance.get(corp.getKey()));                 List<CurrentLawVotesEndBalance> electedByStock =                         curentLawVotesEndBalance.get(corp.getKey())                                 .stream()                                 .filter(t->directors.isElectedByStocks(t.getPackageName()))                                 .filter(t -> t.getVotes() >= Seting.ORIGINAL_LIMIT_MIN_VOTE)                                 .sorted(Comparator.comparing(CurrentLawVotesEndBalance::getVotes).reversed())                                 .limit(corp.getKey().getCount())                                 .collect(Collectors.toList());                  System.out.println(\"UtilsCurrentLaw: findPostion: \");                 System.out.println(\"*******************************\");                 electedByStock.stream().forEach(System.out::println);                 System.out.println(\"*******************************\");                  //отобрать то количество которое соответсвтвует данной должности                 temporary = electedByStock;              } else {                  curentLawVotesEndBalance.put(corp.getKey(), curentLawVotesEndBalance.get(corp.getKey()));                 //отобрать то количество которое соответсвтвует данной должности                 //избираемые премьер министром                 if(fIndPositonHelperData.get(corp.getKey()).isElectedWithPrimeMinister()){                     //отобрать голоса выше лимита                     curentLawVotesEndBalance.put(corp.getKey(), curentLawVotesEndBalance.get(corp.getKey()));                     List<CurrentLawVotesEndBalance> electedByPrimeMinister =                             curentLawVotesEndBalance.get(corp.getKey())                                     .stream()                                     .filter(t->directors.isElectedCEO(t.getPackageName()))                                     .filter(t -> t.getVoteGeneralExecutiveDirector() >= Seting.ORIGINAL_LIMIT_MIN_VOTE_GENERAL_EXECUTIVE_DIRECTOR)                                     .sorted(Comparator.comparing(CurrentLawVotesEndBalance::getVoteGeneralExecutiveDirector).reversed())                                     .collect(Collectors.toList());                       //отобрать то количество которое соответсвтвует данной должности                     temporary = electedByPrimeMinister;                 }                 //избираемые палатой представителей                 else if(fIndPositonHelperData.get(corp.getKey()).isElectedWithHousOfRepresentativies()){                     //отобрать голоса выше лимита                     curentLawVotesEndBalance.put(corp.getKey(), curentLawVotesEndBalance.get(corp.getKey()));                     List<CurrentLawVotesEndBalance> electedByHouseOfRepresentatives =                             curentLawVotesEndBalance.get(corp.getKey())                                     .stream()                                     .filter(t->directors.isElectedByBoardOfDirectors(t.getPackageName()))                                     .filter(t -> t.getVotesBoardOfDirectors() >= Seting.ORIGINAL_LIMIT_MIN_VOTE_BOARD_OF_DIRECTORS)                                     .sorted(Comparator.comparing(CurrentLawVotesEndBalance::getVotesBoardOfDirectors).reversed())                                     .collect(Collectors.toList());                       //отобрать то количество которое соответсвтвует данной должности                     temporary = electedByHouseOfRepresentatives;                    }                 //избираемые палатаой верховных судей                 else if(fIndPositonHelperData.get(corp.getKey()).isElectedWithChamberOfHightJudjes()){                     //отобрать голоса выше лимита                     curentLawVotesEndBalance.put(corp.getKey(), curentLawVotesEndBalance.get(corp.getKey()));                     List<CurrentLawVotesEndBalance> electedByChamberOfSupremeJudges =                             curentLawVotesEndBalance.get(corp.getKey())                                     .stream()                                     .filter(t->directors.isElectedBYCorporateCouncilOfReferees(t.getPackageName()))                                     .filter(t -> t.getVotesCorporateCouncilOfReferees() >= Seting.ORIGINAL_LIMIT_MIN_VOTE_CORPORATE_COUNCIL_OF_REFEREES)                                     .sorted(Comparator.comparing(CurrentLawVotesEndBalance::getVotesCorporateCouncilOfReferees).reversed())                                     .collect(Collectors.toList());                       //отобрать то количество которое соответсвтвует данной должности                     temporary = electedByChamberOfSupremeJudges;                  }                 else {                     temporary = curentLawVotesEndBalance.get(corp.getKey()).stream()                              .collect(Collectors.toList());                 }              }              temporary = temporary.stream().distinct().collect(Collectors.toList());              curentLawVotesEndBalance.put(corp.getKey(), temporary);         }           List<LawEligibleForParliamentaryApproval> lawEligibleForParliamentaryApprovals =                 UtilsLaws.readLineCurrentLaws(Seting.ORIGINAL_ALL_CORPORATION_LAWS_WITH_BALANCE_FILE);           Map<Director, List<String>> currentPossitions = new HashMap<>();         for (Map.Entry<Director, FIndPositonHelperData> fIndPositonHelperData1 : fIndPositonHelperData.entrySet()) {             List<CurrentLawVotesEndBalance> position = curentLawVotesEndBalance.get(fIndPositonHelperData1.getKey());             //список адресов на данную позицию, пример члена палаты представителей             List<String> currntAddress = new ArrayList<>();             for (CurrentLawVotesEndBalance address : position) {                 for (LawEligibleForParliamentaryApproval lawEligibleForParliamentaryApproval : lawEligibleForParliamentaryApprovals) {                       if (lawEligibleForParliamentaryApproval.getLaws().getHashLaw().equals(address.getAddressLaw())) {                          currntAddress.add(lawEligibleForParliamentaryApproval.getLaws().getLaws().get(0));                      }                 }              }             currentPossitions.put(fIndPositonHelperData1.getKey(), currntAddress);          }           return currentPossitions;     }      //найти членов палаты представителей     //возвращает список позиций     public static List<String> findPosition(             Map<String, Account> balances,             Blockchain blockchain,             List<LawEligibleForParliamentaryApproval> allGovernment,             List<Account> BoardOfShareholders,             Directors positions,             boolean withLimit      ) throws IOException, NoSuchAlgorithmException, InvalidKeySpecException, SignatureException, NoSuchProviderException, InvalidKeyException {         //список должностей          Map<Director, List<LawEligibleForParliamentaryApproval>> positionsListMap = new HashMap<>();         //добавление всех должностей         for (Director higherSpecialPositions : positions.getDirectors()) {             positionsListMap.put(higherSpecialPositions, UtilsLaws.getPossions(allGovernment, higherSpecialPositions));         }         //список законов с голосами         Map<Director, List<CurrentLawVotesEndBalance>> curentLawVotesEndBalance = new HashMap<>();         for (Map.Entry<Director, List<LawEligibleForParliamentaryApproval>> corp : positionsListMap.entrySet()) {             //убрать повторяющиеся должности из списка.             corp.setValue(corp.getValue().stream() //                    .filter(t-> finalBoardOfShareholders.contains(new Account(t.getLaws().getLaws().get(0), 0, 0)))                     .distinct().collect(Collectors.toList()));              //получить баланс и голоса для действующих законов             curentLawVotesEndBalance.put(corp.getKey(), UtilsGovernment.filters(corp.getValue(), balances, BoardOfShareholders,                     blockchain.getBlockchainList(), Seting.POSITION_YEAR_VOTE));             List<CurrentLawVotesEndBalance> temporary;             if (withLimit) {                 //отобрать голоса выше лимита                 curentLawVotesEndBalance.put(corp.getKey(), curentLawVotesEndBalance.get(corp.getKey())                         .stream().filter(t -> t.getVotes() >= Seting.ORIGINAL_LIMIT_MIN_VOTE)                         .collect(Collectors.toList()));                  //отобрать то количество которое соответсвтвует данной должности                 temporary = curentLawVotesEndBalance.get(corp.getKey()).stream()                         .filter(t -> !t.getPackageName().equals(corp.getKey()))                         .sorted(Comparator.comparing(CurrentLawVotesEndBalance::getVotes).reversed())                         .limit(corp.getKey().getCount()).collect(Collectors.toList());             } else {                 //отобрать то количество которое соответсвтвует данной должности                 temporary = curentLawVotesEndBalance.get(corp.getKey()).stream()                         .filter(t -> !t.getPackageName().equals(corp.getKey()))                         .sorted(Comparator.comparing(CurrentLawVotesEndBalance::getVotes).reversed())                         .collect(Collectors.toList());             }               curentLawVotesEndBalance.put(corp.getKey(), temporary);         }           List<LawEligibleForParliamentaryApproval> lawEligibleForParliamentaryApprovals =                 UtilsLaws.readLineCurrentLaws(Seting.ORIGINAL_ALL_CORPORATION_LAWS_WITH_BALANCE_FILE);          //список адресов на данную позицию, пример члена палаты представителей         List<String> currntAddress = new ArrayList<>();          List<CurrentLawVotesEndBalance> position = curentLawVotesEndBalance.get(positions);          for (CurrentLawVotesEndBalance address : position) {             for (LawEligibleForParliamentaryApproval lawEligibleForParliamentaryApproval : lawEligibleForParliamentaryApprovals) {                   if (lawEligibleForParliamentaryApproval.getLaws().getHashLaw().equals(address.getAddressLaw())) {                      currntAddress.add(lawEligibleForParliamentaryApproval.getLaws().getLaws().get(0));                  }             }         }           return currntAddress;     } }","package International_Trade_Union.vote;  import International_Trade_Union.governments.Director; import International_Trade_Union.governments.Directors; import com.fasterxml.jackson.core.JsonProcessingException; import International_Trade_Union.entity.DtoTransaction.DtoTransaction; import International_Trade_Union.entity.blockchain.block.Block; import International_Trade_Union.setings.Seting; import International_Trade_Union.model.Account; import International_Trade_Union.utils.UtilsFileSaveRead; import International_Trade_Union.utils.UtilsJson; import International_Trade_Union.utils.UtilsUse;   import java.io.File; import java.io.IOException; import java.security.InvalidKeyException; import java.security.NoSuchAlgorithmException; import java.security.NoSuchProviderException; import java.security.SignatureException; import java.security.spec.InvalidKeySpecException; import java.util.*; import java.util.stream.Collectors;  public class UtilsLaws {     public static void saveLaws(List<Laws> laws, String filename) throws IOException {         int fileLimit = Seting.SIZE_FILE_LIMIT * 1024 * 1024;          //папка чтобы проверить есть ли         File folder = new File(filename);         List<String> files = new ArrayList<>();         for (File file : folder.listFiles()) {             if(!file.isDirectory()){                 files.add(file.getAbsolutePath());             }         }          int count = 0;         files = files.stream().sorted().collect(Collectors.toList());         String nextFile = \"\";          if (files.size() > 0) {             nextFile = files.get(files.size()-1);              count = Integer.parseInt(nextFile.replaceAll(\"[^\\\\d]\", \"\"));           }          File file = new File(nextFile);          if(file.length() >= fileLimit){             count++;          }          nextFile = filename + count + \".txt\";          List<String> jsons = new ArrayList<>();         for (Laws laws1: laws) {             String json = UtilsJson.objToStringJson(laws1);             jsons.add(json);         }  //        String json = UtilsJson.objToStringJson(minerAccount); //        UtilsFileSaveRead.save(json + \"\\n\", nextFile);         UtilsFileSaveRead.saves(jsons, nextFile, true);     }     public static void saveLaw(Laws laws, String filename) throws IOException, NoSuchAlgorithmException, SignatureException, InvalidKeySpecException, NoSuchProviderException, InvalidKeyException {         int fileLimit = Seting.SIZE_FILE_LIMIT * 1024 * 1024;          //папка чтобы проверить есть ли         File folder = new File(filename);         List<String> files = new ArrayList<>();         for (File file : folder.listFiles()) {             if (!file.isDirectory()) {                 files.add(file.getAbsolutePath());             }         }          int count = 0;         files = files.stream().sorted().collect(Collectors.toList());         String nextFile = \"\";          if (files.size() > 0) {             nextFile = files.get(files.size() - 1);              count = Integer.parseInt(nextFile.replaceAll(\"[^\\\\d]\", \"\"));           }          File file = new File(nextFile);          if (file.length() >= fileLimit) {             count++;          }          nextFile = filename + count + \".txt\";          String json = UtilsJson.objToStringJson(laws);         UtilsFileSaveRead.save(json + \"\\n\", nextFile);      }      public static void saveCurrentsLaws(List<LawEligibleForParliamentaryApproval> lawEligibleForParliamentaryApprovals, String filename) throws IOException {         int fileLimit = Seting.SIZE_FILE_LIMIT * 1024 * 1024;          //папка чтобы проверить есть ли         File folder = new File(filename);         List<String> files = new ArrayList<>();         for (File file : folder.listFiles()) {             if(!file.isDirectory()){                 files.add(file.getAbsolutePath());             }         }          int count = 0;         files = files.stream().sorted().collect(Collectors.toList());         String nextFile = \"\";          if (files.size() > 0) {             nextFile = files.get(files.size()-1);              count = Integer.parseInt(nextFile.replaceAll(\"[^\\\\d]\", \"\"));           }          File file = new File(nextFile);          if(file.length() >= fileLimit){             count++;          }          nextFile = filename + count + \".txt\";          List<String> jsons = new ArrayList<>();         for (LawEligibleForParliamentaryApproval lawEligibleForParliamentaryApproval : lawEligibleForParliamentaryApprovals) {             String json = UtilsJson.objToStringJson(lawEligibleForParliamentaryApproval);             jsons.add(json);         }  //        String json = UtilsJson.objToStringJson(minerAccount); //        UtilsFileSaveRead.save(json + \"\\n\", nextFile);         UtilsFileSaveRead.saves(jsons, nextFile, true);     }     public static void saveCurrentLaw(LawEligibleForParliamentaryApproval lawEligibleForParliamentaryApproval, String filename) throws IOException, NoSuchAlgorithmException, SignatureException, InvalidKeySpecException, NoSuchProviderException, InvalidKeyException {         int fileLimit = Seting.SIZE_FILE_LIMIT * 1024 * 1024;          //папка чтобы проверить есть ли         File folder = new File(filename);         List<String> files = new ArrayList<>();         for (File file : folder.listFiles()) {             if (!file.isDirectory()) {                 files.add(file.getAbsolutePath());             }         }          int count = 0;         files = files.stream().sorted().collect(Collectors.toList());         String nextFile = \"\";          if (files.size() > 0) {             nextFile = files.get(files.size() - 1);              count = Integer.parseInt(nextFile.replaceAll(\"[^\\\\d]\", \"\"));           }          File file = new File(nextFile);          if (file.length() >= fileLimit) {             count++;          }          nextFile = filename + count + \".txt\";          String json = UtilsJson.objToStringJson(lawEligibleForParliamentaryApproval);         UtilsFileSaveRead.save(json + \"\\n\", nextFile);      }      public static List<Laws> readLineLaws(String filename) throws IOException, NoSuchAlgorithmException, InvalidKeySpecException, SignatureException, NoSuchProviderException, InvalidKeyException {         List<Laws> laws = new ArrayList<>();         File folder = new File(filename);         for (final File fileEntry : folder.listFiles()) {             if (fileEntry.isDirectory()) {                 System.out.println(\"is directory \" + fileEntry.getAbsolutePath());             } else {                 List<String> list = UtilsFileSaveRead.reads(fileEntry.getAbsolutePath());                 for (String s : list) {                      Laws laws1 = UtilsJson.jsonToLaw(s);                     laws.add(laws1);                 }              }         }         laws = laws                 .stream()                 .sorted(Comparator.comparing(Laws::getPacketLawName))                 .collect(Collectors.toList());          return laws;     }      public static List<LawEligibleForParliamentaryApproval> readLineCurrentLaws(String filename) throws JsonProcessingException {         List<LawEligibleForParliamentaryApproval> laws = new ArrayList<>();         File folder = new File(filename);         for (final File fileEntry : folder.listFiles()) {             if (fileEntry.isDirectory()) {                 System.out.println(\"is directory \" + fileEntry.getAbsolutePath());             } else {                 List<String> list = UtilsFileSaveRead.reads(fileEntry.getAbsolutePath());                 for (String s : list) {                      LawEligibleForParliamentaryApproval laws1 = UtilsJson.jsonToCurrentLaw(s);                     laws.add(laws1);                 }              }         }          return laws;     }       //возвращает все счета законов     public static List<Account> allPackegeLaws(Map<String, Account> balances) {         List<Account> laws = new ArrayList<>();         laws = balances.entrySet()                 .stream()                 .map(t -> t.getValue())                 .filter(t -> t.getAccount().startsWith(Seting.NAME_LAW_ADDRESS_START))                 .collect(Collectors.toList());         return laws;     }      //возвращает пакет законов и их счета     public static Map<String, Laws> getPackageLaws(List<Block> blocks) throws IOException, NoSuchAlgorithmException, SignatureException, InvalidKeySpecException, NoSuchProviderException, InvalidKeyException {         Map<String, Laws> laws = new HashMap<>();         for (Block block : blocks) {             for (DtoTransaction dtoTransaction : block.getDtoTransactions()) {                 if (dtoTransaction.verify()) {                     if (dtoTransaction.getCustomer().startsWith(Seting.NAME_LAW_ADDRESS_START) && dtoTransaction.getBonusForMiner() >= Seting.COST_LAW) {                         if(dtoTransaction.getLaws() != null && !laws.containsKey(dtoTransaction.getCustomer())){                             laws.put(dtoTransaction.getCustomer(), dtoTransaction.getLaws());                         }                      }                 }             }          }         return laws;     }      //проверяет валидность закона     public static boolean isValidHashLaw(Laws laws) throws IOException {         String hash = laws.getHashLaw();         String hashLaw = Seting.NAME_LAW_ADDRESS_START + UtilsUse.sha256hash(UtilsJson.objToStringJson(laws));         System.out.println(\"UtilsLaw: isValidHashLaw: \" + hash.equals(hashLaw));         System.out.println(\"hash: \" + hash);         System.out.println(\"hashLaw: \" + hashLaw);         return hash.equals(hashLaw);     }        public static List<Account> allPackageLaws(List<Account> accounts){         List<Account> currentLaws = accounts.stream()                 .filter(t -> t.getAccount().startsWith(Seting.NAME_LAW_ADDRESS_START))                 .collect(Collectors.toList());         return currentLaws;     }      //возвращяет список всех законов, как действующих, так и не действующих, если закон новый то автоматически сохраняет его     public static Map<String, Laws> getLaws(List<Block> blocks, String fileLaws) throws IOException, NoSuchAlgorithmException, InvalidKeySpecException, SignatureException, NoSuchProviderException, InvalidKeyException {         List<Laws> lawsForSave = new ArrayList<>();         Map<String, Laws> lawsMap = new HashMap<>();         File file = new File(fileLaws);         List<Laws> lawsList = new ArrayList<>();         if (file.exists()) {             lawsList = readLineLaws(fileLaws);         }         lawsMap = getPackageLaws(blocks);          for (Map.Entry<String, Laws> map : lawsMap.entrySet()) {             if (!lawsList.contains(map.getValue())) {                 if( map.getValue() != null &&                         map.getValue().packetLawName != null&&                         map.getValue().getLaws() != null                         && !map.getValue().getHashLaw().isEmpty()                         && (map.getValue().getLaws().size() > 0)){                          lawsForSave.add(map.getValue());                 }              }          }         saveLaws(lawsForSave, fileLaws);         return lawsMap;     }     public static List<LawEligibleForParliamentaryApproval> getCurrentLaws(Map<String, Laws> lawsMap, Map<String, Account> balances, String fileCurrentLaws) throws IOException, NoSuchAlgorithmException, SignatureException, InvalidKeySpecException, NoSuchProviderException, InvalidKeyException {         List<Account> lawsBalances = allPackegeLaws(balances);           List<LawEligibleForParliamentaryApproval> lawEligibleForParliamentaryApprovals = new ArrayList<>();         LawEligibleForParliamentaryApproval lawEligibleForParliamentaryApproval = null;         File file = new File(fileCurrentLaws);         if (file.exists()) {             lawEligibleForParliamentaryApprovals = readLineCurrentLaws(fileCurrentLaws);         }          for (LawEligibleForParliamentaryApproval eligibleForParliamentaryApproval : lawEligibleForParliamentaryApprovals) {             if(lawsBalances.contains(eligibleForParliamentaryApproval.getAccount())){                 eligibleForParliamentaryApproval.getAccount().                         setDigitalStockBalance(balances.get(eligibleForParliamentaryApproval.getAccount().getAccount()).getDigitalStockBalance());                 eligibleForParliamentaryApproval.getAccount().                         setDigitalDollarBalance(balances.get(eligibleForParliamentaryApproval.getAccount().getAccount()).getDigitalDollarBalance());             }          }           List<LawEligibleForParliamentaryApproval> temporary = new ArrayList<>();         for (Account account : lawsBalances) {             lawEligibleForParliamentaryApproval = new LawEligibleForParliamentaryApproval(account, lawsMap.get(account.getAccount()));             temporary.add(lawEligibleForParliamentaryApproval);         }           lawEligibleForParliamentaryApprovals.addAll(temporary);           lawEligibleForParliamentaryApprovals = lawEligibleForParliamentaryApprovals.stream()                 .filter(t->Objects.nonNull(t.getLaws()))                 .filter(t->Objects.nonNull(t.getAccount()))                 .filter(t->Objects.nonNull(t.getLaws().getHashLaw()))                 .filter(t->Objects.nonNull(t.getLaws().getLaws()))                 .filter(t->Objects.nonNull(t.getName()))                 .filter(t->Objects.nonNull(t.getLaws().getPacketLawName()))                 .filter(t->t != null).                 filter(UtilsUse.distinctByKey(LawEligibleForParliamentaryApproval::getName)).collect(Collectors.toList());          return lawEligibleForParliamentaryApprovals;      }         //отбирает позицию вакансий     public static List<LawEligibleForParliamentaryApproval> getPossions(List<LawEligibleForParliamentaryApproval> lawEligibleForParliamentaryApprovals, Director higherSpecialPositions){          List<LawEligibleForParliamentaryApproval> temporary = new ArrayList<>();         temporary = lawEligibleForParliamentaryApprovals.stream()                 .filter(t->Objects.nonNull(t))                 .filter(t->Objects.nonNull(t.getLaws()))                 .filter(t->Objects.nonNull(t.getLaws().getLaws()))                 .filter(t->Objects.nonNull(t.getLaws().getPacketLawName()))                 .filter(t->Objects.nonNull(t.getName()))                 .filter(t->Objects.nonNull(t.getLaws().getHashLaw()))                 .sorted((f1, f2) -> Double.compare(f2.getAccount().getDigitalStockBalance(), f1.getAccount().getDigitalStockBalance()))                 .filter(t-> t.getLaws().getPacketLawName().equals(higherSpecialPositions.getName()))                 .limit(higherSpecialPositions.getCount())                 .collect(Collectors.toList());         return temporary;      }       //удаляет из списка не лигитимные должности     public static List<LawEligibleForParliamentaryApproval> deletePossions(List<LawEligibleForParliamentaryApproval> lawEligibleForParliamentaryApprovals, List<LawEligibleForParliamentaryApproval> forDeleted, Directors higherSpecialPositions){         List<LawEligibleForParliamentaryApproval> temporary = new ArrayList<>();         for (LawEligibleForParliamentaryApproval lawEligibleForParliamentaryApproval : forDeleted) {             if(lawEligibleForParliamentaryApproval != null &&                     lawEligibleForParliamentaryApproval.getLaws() != null &&                     lawEligibleForParliamentaryApproval.getLaws().getPacketLawName() != null &&                     lawEligibleForParliamentaryApproval.getLaws().getHashLaw() != null &&                     lawEligibleForParliamentaryApproval.getLaws().getHashLaw() != null &&                     lawEligibleForParliamentaryApproval.getLaws().getPacketLawName().equals(higherSpecialPositions.getNames())){                 if(lawEligibleForParliamentaryApprovals.contains(lawEligibleForParliamentaryApproval)){                     temporary.add(lawEligibleForParliamentaryApproval);                 }else {                     continue;                 }             }             temporary.add(lawEligibleForParliamentaryApproval);         }         return temporary;     }   }","package International_Trade_Union.vote;  public enum VoteEnum {     YES,     NO }","package International_Trade_Union;  import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; import org.springframework.scheduling.annotation.EnableScheduling;  @SpringBootApplication public class UnitedStatesApplication { \tpublic static void main(String[] args) { \t\tSpringApplication.run(UnitedStatesApplication.class, args); \t}  }","<div th:fragment=\"footer\">     <footer class=\"text-muted py-5\">         <div class=\"container\">             <p class=\"float-end mb-1\">                 <a href=\"#\"><font style=\"vertical-align: inherit;\"><font style=\"vertical-align: inherit;\">Back to the top</font></font></a>             </p>             <p class=\"mb-1\"><font style=\"vertical-align: inherit;\"><font style=\"vertical-align: inherit;\">Пример альбома: © Bootstrap, но, пожалуйста, загрузите и настройте его под себя!</font></font></p>             <p class=\"mb-0\"><font style=\"vertical-align: inherit;\"><font style=\"vertical-align: inherit;\">Новичок в Bootstrap? </font></font><a href=\"/\"><font style=\"vertical-align: inherit;\"><font style=\"vertical-align: inherit;\">Посетите домашнюю страницу</font></font></a><font style=\"vertical-align: inherit;\"><font style=\"vertical-align: inherit;\"> или прочитайте наше </font></font><a href=\"/docs/5.2/getting-started/introduction/\"><font style=\"vertical-align: inherit;\"><font style=\"vertical-align: inherit;\">руководство по началу</font></font></a><font style=\"vertical-align: inherit;\"><font style=\"vertical-align: inherit;\"> работы .</font></font></p>         </div>     </footer> </div>","<div th:fragment=\"header\">     <div class=\"d-flex flex-column flex-md-row align-items-center pb-3 mb-4 border-bottom\">         <a href=\"/\" class=\"d-flex align-items-center text-dark text-decoration-none\">             <svg xmlns=\"http://www.w3.org/2000/svg\" width=\"40\" height=\"32\" class=\"me-2\" viewBox=\"0 0 118 94\" role=\"img\"><title>Bootstrap</title><path fill-rule=\"evenodd\" clip-rule=\"evenodd\" d=\"M24.509 0c-6.733 0-11.715 5.893-11.492 12.284.214 6.14-.064 14.092-2.066 20.577C8.943 39.365 5.547 43.485 0 44.014v5.972c5.547.529 8.943 4.649 10.951 11.153 2.002 6.485 2.28 14.437 2.066 20.577C12.794 88.106 17.776 94 24.51 94H93.5c6.733 0 11.714-5.893 11.491-12.284-.214-6.14.064-14.092 2.066-20.577 2.009-6.504 5.396-10.624 10.943-11.153v-5.972c-5.547-.529-8.934-4.649-10.943-11.153-2.002-6.484-2.28-14.437-2.066-20.577C105.214 5.894 100.233 0 93.5 0H24.508zM80 57.863C80 66.663 73.436 72 62.543 72H44a2 2 0 01-2-2V24a2 2 0 012-2h18.437c9.083 0 15.044 4.92 15.044 12.474 0 5.302-4.01 10.049-9.119 10.88v.277C75.317 46.394 80 51.21 80 57.863zM60.521 28.34H49.948v14.934h8.905c6.884 0 10.68-2.772 10.68-7.727 0-4.643-3.264-7.207-9.012-7.207zM49.948 49.2v16.458H60.91c7.167 0 10.964-2.876 10.964-8.281 0-5.406-3.903-8.178-11.425-8.178H49.948z\" fill=\"currentColor\"></path></svg>             <span class=\"fs-4\"><font style=\"vertical-align: inherit;\"><font style=\"vertical-align: inherit;\">Corporation International Trade Union.</font></font></span>         </a>          <nav class=\"d-inline-flex mt-2 mt-md-0 ms-md-auto\">             <a class=\"me-3 py-2 text-dark text-decoration-none\" href=\"/board-of-shareholders\"><font style=\"vertical-align: inherit;\"><font style=\"vertical-align: inherit;\">board of shareholders</font></font></a>             <a class=\"me-3 py-2 text-dark text-decoration-none\" href=\"/governments\"><font style=\"vertical-align: inherit;\"><font style=\"vertical-align: inherit;\">management</font></font></a>             <a class=\"me-3 py-2 text-dark text-decoration-none\" href=\"/all-laws\"><font style=\"vertical-align: inherit;\"><font style=\"vertical-align: inherit;\">All created laws</font></font></a>             <a class=\"me-3 py-2 text-dark text-decoration-none\" href=\"/current-laws\"><font style=\"vertical-align: inherit;\"><font style=\"vertical-align: inherit;\">current-law</font></font></a>             <a class=\"me-3 py-2 text-dark text-decoration-none\" href=\"/create-account\"><font style=\"vertical-align: inherit;\"><font style=\"vertical-align: inherit;\">Create account</font></font></a>             <a class=\"me-3 py-2 text-dark text-decoration-none\" href=\"/create-law\"><font style=\"vertical-align: inherit;\"><font style=\"vertical-align: inherit;\">Create law</font></font></a>             <a class=\"me-3 py-2 text-dark text-decoration-none\" href=\"/create-position\"><font style=\"vertical-align: inherit;\"><font style=\"vertical-align: inherit;\">Create Position</font></font></a>             <a class=\"me-3 py-2 text-dark text-decoration-none\" href=\"/corporate-charter\"><font style=\"vertical-align: inherit;\"><font style=\"vertical-align: inherit;\">Сorporate-charter</font></font></a>             <a class=\"me-3 py-2 text-dark text-decoration-none\" href=\"/about\"><font style=\"vertical-align: inherit;\"><font style=\"vertical-align: inherit;\">about us</font></font></a>         </nav>     </div> </div>","<!DOCTYPE HTML> <html xmlns:th=\"http://www.thymeleaf.org\"> <head>     <title>About us</title>     <meta http-equiv=\"Content-Type\" content=\"text/html\" charset=\"UTF-8\"/>     <link rel=\"stylesheet\" href=\"https://cdn.jsdelivr.net/npm/bootstrap@5.2.2/dist/css/bootstrap.min.css\"> </head> <body> <header th:insert=\"blocks/header :: header \"></header>  <div class=\"container mt-5\"> <h1 th:text=\"${title}\"></h1>     <h1 th:text=\"${eng}\"></h1>     <h1 th:text=\"${rus}\"></h1> </div> <footer th:insert=\"blocks/footer :: footer\"></footer>  </body> </html>","<!DOCTYPE HTML> <html xmlns:th=\"http://www.thymeleaf.org\"> <head>     <title th:text=\"${title}\"/>     <meta http-equiv=\"Content-Type\" content=\"text/html\" charset=\"UTF-8\"/>     <link rel=\"stylesheet\" href=\"https://cdn.jsdelivr.net/npm/bootstrap@5.2.2/dist/css/bootstrap.min.css\"> </head> <body> <header th:insert=\"blocks/header :: header \"></header>  <div class=\"container mt-5\">     <h3 th:text=\"${title}\"/>     <div th:each=\"el : ${allLaws}\" class=\"alert alert-info mt-2\">         <h4 th:text=\"'address package law: '+${el.addressLaw}\"/>         <p th:text=\"'votes: '+${#numbers.formatDecimal(el.votes, 1, 'COMMA', 16, 'POINT')}\"/>         <p th:text=\"'votesCorporateCouncilOfReferees: '+${el.votesCorporateCouncilOfReferees}\"/>         <p th:text=\"'votesBoardOfDirectors: '+${el.votesBoardOfDirectors}\"/>         <p th:text=\"'votesBoardOfShareholders: '+${el.votesBoardOfShareholders}\"/>         <p th:text=\"'voteGeneralExecutiveDirector: '+${el.voteGeneralExecutiveDirector}\"/>         <p th:text=\"'voteHightJudge: '+${el.voteHightJudge}\"/>         <p th:text=\"'founderVote: '+${el.founderVote}\"/>         <p th:text=\"'package law name: '+${el.packageName}\"/>         <a th:href=\"'/detail-laws-current/' + ${el.addressLaw}\" class=\"btn btn-warning\">Details</a>     </div>  </div> <footer th:insert=\"blocks/footer :: footer\"></footer>  </body> </html>","<!DOCTYPE HTML> <html xmlns:th=\"http://www.thymeleaf.org\"> <head>   <title th:text=\"${title}\"/>   <meta http-equiv=\"Content-Type\" content=\"text/html\" charset=\"UTF-8\"/>   <link rel=\"stylesheet\" href=\"https://cdn.jsdelivr.net/npm/bootstrap@5.2.2/dist/css/bootstrap.min.css\"> </head> <body> <header th:insert=\"blocks/header :: header \"></header>  <div class=\"container mt-5\">   <h3 th:text=\"${title}\"/>    <div th:each=\"el : ${boardOfShareholders}\" class=\"alert alert-info mt-2\">     <h4 th:text=\"'address: '+${el.account}\"/>     <p th:text=\"'digital dollar: '+${#numbers.formatDecimal(el.digitalDollarBalance, 1, 'COMMA', 16, 'POINT')}\"/>     <p th:text=\"'digital digitalStockBalance: '+${#numbers.formatDecimal(el.digitalStockBalance, 1, 'COMMA', 16, 'POINT')}\"/>    </div>  </div> <footer th:insert=\"blocks/footer :: footer\"></footer>  </body> </html>","<!DOCTYPE HTML> <html xmlns:th=\"http://www.thymeleaf.org\"> <head>     <title th:text=\"${title}\"/>     <meta http-equiv=\"Content-Type\" content=\"text/html\" charset=\"UTF-8\"/>     <link rel=\"stylesheet\" href=\"https://cdn.jsdelivr.net/npm/bootstrap@5.2.2/dist/css/bootstrap.min.css\"> </head> <body> <header th:insert=\"blocks/header :: header \"></header>  <div class=\"container mt-5\">     <h3 th:text=\"${title}\"/>      <div th:each=\"el : ${eng}\" class=\"alert alert-info mt-2\">         <h4 th:text=\"' '+${el}\"/>     </div>      <div th:each=\"el : ${rus}\" class=\"alert alert-info mt-2\">         <h4 th:text=\"' '+${el}\"/>     </div>    </div> <footer th:insert=\"blocks/footer :: footer\"></footer>  </body> </html>","<!DOCTYPE HTML> <html xmlns:th=\"http://www.thymeleaf.org\"> <head>     <title th:text=\"${title}\"/>      <meta http-equiv=\"Content-Type\" content=\"text/html\" charset=\"UTF-8\"/>     <link rel=\"stylesheet\" href=\"https://cdn.jsdelivr.net/npm/bootstrap@5.2.2/dist/css/bootstrap.min.css\"> </head> <body> <header th:insert=\"blocks/header :: header \"></header>  <div class=\"container mt-5\">     <h3 th:text=\"${title}\"/>     <h3>         copy the address and password and save it in a secure place, also set as the miner's address in the text file minerAccount.txt this address will be set during mining.</h3>      <div class=\"alert alert-info mt-2\">         <h4 th:text=\"'new address: ' + ${login}\"  class=\"form-control\"/><br>         <textarea th:text=\"'pasword: ' + ${password}\" class=\"form-control\" rows=\"12\"></textarea><br>          <form action=\"/create-account\" method=\"post\">         <button type=\"submit\" class=\"btn btn-success\">generate new account</button><br>         </form>      </div>   </div> <footer th:insert=\"blocks/footer :: footer\"></footer>  </body> </html>","<!DOCTYPE HTML> <html xmlns:th=\"http://www.thymeleaf.org\"> <head>   <title th:text=\"${title}\"/>   <meta http-equiv=\"Content-Type\" content=\"text/html\" charset=\"UTF-8\"/>   <link rel=\"stylesheet\" href=\"type/css\" th:href=\"style.css\">   <link rel=\"stylesheet\" href=\"https://cdn.jsdelivr.net/npm/bootstrap@5.2.2/dist/css/bootstrap.min.css\"> </head> <body>  <header th:insert=\"blocks/header :: header \"></header> <div class=\"container mt 5\">   <h1 th:text=\"${title}\"></h1> </div> <h3>The cost of creating the law is five digital dollars, the details are described in the charter.</h3>     <form action=\"/create-law\" method=\"post\">     <input type=\"text\" name=\"sender\" placeholder=\"input address sender\" class=\"form-control\"><br>      <input type=\"text\" name=\"reward\" placeholder=\"send reward for miner\" class=\"form-control\"><br>     <input type=\"text\" name=\"nameLaw\" placeholder=\"input name packege law\" class=\"form-control\"><br>     <textarea name=\"password\" placeholder=\"input password\" th:rows=\"8\" th:cols=\"120\"></textarea><br>     <button type=\"submit\" class=\"btn btn-success\" name=\"action\" value=\"/send\">Send Law</button><br>     <input type=\"text\" name=\"laws\" placeholder=\"input law\" class=\"form-control\"><br>     <input type=\"text\" name=\"laws\" placeholder=\"input law\" class=\"form-control\"><br>     <input type=\"text\" name=\"laws\" placeholder=\"input law\" class=\"form-control\"><br>     <input type=\"text\" name=\"laws\" placeholder=\"input law\" class=\"form-control\"><br>     <input type=\"text\" name=\"laws\" placeholder=\"input law\" class=\"form-control\"><br>     <input type=\"text\" name=\"laws\" placeholder=\"input law\" class=\"form-control\"><br>     <input type=\"text\" name=\"laws\" placeholder=\"input law\" class=\"form-control\"><br>     <input type=\"text\" name=\"laws\" placeholder=\"input law\" class=\"form-control\"><br>     <input type=\"text\" name=\"laws\" placeholder=\"input law\" class=\"form-control\"><br>     <input type=\"text\" name=\"laws\" placeholder=\"input law\" class=\"form-control\"><br>     <input type=\"text\" name=\"laws\" placeholder=\"input law\" class=\"form-control\"><br>     <input type=\"text\" name=\"laws\" placeholder=\"input law\" class=\"form-control\"><br>     <input type=\"text\" name=\"laws\" placeholder=\"input law\" class=\"form-control\"><br>     <input type=\"text\" name=\"laws\" placeholder=\"input law\" class=\"form-control\"><br>     <input type=\"text\" name=\"laws\" placeholder=\"input law\" class=\"form-control\"><br>     <input type=\"text\" name=\"laws\" placeholder=\"input law\" class=\"form-control\"><br>     <input type=\"text\" name=\"laws\" placeholder=\"input law\" class=\"form-control\"><br>     <input type=\"text\" name=\"laws\" placeholder=\"input law\" class=\"form-control\"><br>     <input type=\"text\" name=\"laws\" placeholder=\"input law\" class=\"form-control\"><br>     <input type=\"text\" name=\"laws\" placeholder=\"input law\" class=\"form-control\"><br>     <input type=\"text\" name=\"laws\" placeholder=\"input law\" class=\"form-control\"><br>     <input type=\"text\" name=\"laws\" placeholder=\"input law\" class=\"form-control\"><br>     <input type=\"text\" name=\"laws\" placeholder=\"input law\" class=\"form-control\"><br>     <input type=\"text\" name=\"laws\" placeholder=\"input law\" class=\"form-control\"><br>     <input type=\"text\" name=\"laws\" placeholder=\"input law\" class=\"form-control\"><br>     <input type=\"text\" name=\"laws\" placeholder=\"input law\" class=\"form-control\"><br>     <input type=\"text\" name=\"laws\" placeholder=\"input law\" class=\"form-control\"><br>     <input type=\"text\" name=\"laws\" placeholder=\"input law\" class=\"form-control\"><br>     <input type=\"text\" name=\"laws\" placeholder=\"input law\" class=\"form-control\"><br>     <input type=\"text\" name=\"laws\" placeholder=\"input law\" class=\"form-control\"><br>     <input type=\"text\" name=\"laws\" placeholder=\"input law\" class=\"form-control\"><br>     <input type=\"text\" name=\"laws\" placeholder=\"input law\" class=\"form-control\"><br>     <input type=\"text\" name=\"laws\" placeholder=\"input law\" class=\"form-control\"><br>     <input type=\"text\" name=\"laws\" placeholder=\"input law\" class=\"form-control\"><br>     <input type=\"text\" name=\"laws\" placeholder=\"input law\" class=\"form-control\"><br>     <input type=\"text\" name=\"laws\" placeholder=\"input law\" class=\"form-control\"><br>     <input type=\"text\" name=\"laws\" placeholder=\"input law\" class=\"form-control\"><br>     <input type=\"text\" name=\"laws\" placeholder=\"input law\" class=\"form-control\"><br>     <input type=\"text\" name=\"laws\" placeholder=\"input law\" class=\"form-control\"><br>     <input type=\"text\" name=\"laws\" placeholder=\"input law\" class=\"form-control\"><br>     <input type=\"text\" name=\"laws\" placeholder=\"input law\" class=\"form-control\"><br>     <input type=\"text\" name=\"laws\" placeholder=\"input law\" class=\"form-control\"><br>     <input type=\"text\" name=\"laws\" placeholder=\"input law\" class=\"form-control\"><br>     <input type=\"text\" name=\"laws\" placeholder=\"input law\" class=\"form-control\"><br>     <input type=\"text\" name=\"laws\" placeholder=\"input law\" class=\"form-control\"><br>     <input type=\"text\" name=\"laws\" placeholder=\"input law\" class=\"form-control\"><br>     <input type=\"text\" name=\"laws\" placeholder=\"input law\" class=\"form-control\"><br>     <input type=\"text\" name=\"laws\" placeholder=\"input law\" class=\"form-control\"><br>     <input type=\"text\" name=\"laws\" placeholder=\"input law\" class=\"form-control\"><br>     <input type=\"text\" name=\"laws\" placeholder=\"input law\" class=\"form-control\"><br>     <input type=\"text\" name=\"laws\" placeholder=\"input law\" class=\"form-control\"><br>     <input type=\"text\" name=\"laws\" placeholder=\"input law\" class=\"form-control\"><br>     <input type=\"text\" name=\"laws\" placeholder=\"input law\" class=\"form-control\"><br>     <input type=\"text\" name=\"laws\" placeholder=\"input law\" class=\"form-control\"><br>     <input type=\"text\" name=\"laws\" placeholder=\"input law\" class=\"form-control\"><br>     <input type=\"text\" name=\"laws\" placeholder=\"input law\" class=\"form-control\"><br>     <input type=\"text\" name=\"laws\" placeholder=\"input law\" class=\"form-control\"><br>     <input type=\"text\" name=\"laws\" placeholder=\"input law\" class=\"form-control\"><br>     <input type=\"text\" name=\"laws\" placeholder=\"input law\" class=\"form-control\"><br>     <input type=\"text\" name=\"laws\" placeholder=\"input law\" class=\"form-control\"><br>     <input type=\"text\" name=\"laws\" placeholder=\"input law\" class=\"form-control\"><br>     <input type=\"text\" name=\"laws\" placeholder=\"input law\" class=\"form-control\"><br>     <input type=\"text\" name=\"laws\" placeholder=\"input law\" class=\"form-control\"><br>     <input type=\"text\" name=\"laws\" placeholder=\"input law\" class=\"form-control\"><br>     <input type=\"text\" name=\"laws\" placeholder=\"input law\" class=\"form-control\"><br>     <input type=\"text\" name=\"laws\" placeholder=\"input law\" class=\"form-control\"><br>     <input type=\"text\" name=\"laws\" placeholder=\"input law\" class=\"form-control\"><br>     <input type=\"text\" name=\"laws\" placeholder=\"input law\" class=\"form-control\"><br>     <input type=\"text\" name=\"laws\" placeholder=\"input law\" class=\"form-control\"><br>     <input type=\"text\" name=\"laws\" placeholder=\"input law\" class=\"form-control\"><br>     <input type=\"text\" name=\"laws\" placeholder=\"input law\" class=\"form-control\"><br>     <input type=\"text\" name=\"laws\" placeholder=\"input law\" class=\"form-control\"><br>     <input type=\"text\" name=\"laws\" placeholder=\"input law\" class=\"form-control\"><br>     <input type=\"text\" name=\"laws\" placeholder=\"input law\" class=\"form-control\"><br>     <input type=\"text\" name=\"laws\" placeholder=\"input law\" class=\"form-control\"><br>     <input type=\"text\" name=\"laws\" placeholder=\"input law\" class=\"form-control\"><br>     <input type=\"text\" name=\"laws\" placeholder=\"input law\" class=\"form-control\"><br>     <input type=\"text\" name=\"laws\" placeholder=\"input law\" class=\"form-control\"><br>     <input type=\"text\" name=\"laws\" placeholder=\"input law\" class=\"form-control\"><br>     <input type=\"text\" name=\"laws\" placeholder=\"input law\" class=\"form-control\"><br>     <input type=\"text\" name=\"laws\" placeholder=\"input law\" class=\"form-control\"><br>     <input type=\"text\" name=\"laws\" placeholder=\"input law\" class=\"form-control\"><br>     <input type=\"text\" name=\"laws\" placeholder=\"input law\" class=\"form-control\"><br>     <input type=\"text\" name=\"laws\" placeholder=\"input law\" class=\"form-control\"><br>     <input type=\"text\" name=\"laws\" placeholder=\"input law\" class=\"form-control\"><br>     <input type=\"text\" name=\"laws\" placeholder=\"input law\" class=\"form-control\"><br>     <input type=\"text\" name=\"laws\" placeholder=\"input law\" class=\"form-control\"><br>     <input type=\"text\" name=\"laws\" placeholder=\"input law\" class=\"form-control\"><br>     <input type=\"text\" name=\"laws\" placeholder=\"input law\" class=\"form-control\"><br>     <input type=\"text\" name=\"laws\" placeholder=\"input law\" class=\"form-control\"><br>     <input type=\"text\" name=\"laws\" placeholder=\"input law\" class=\"form-control\"><br>     <input type=\"text\" name=\"laws\" placeholder=\"input law\" class=\"form-control\"><br>     <input type=\"text\" name=\"laws\" placeholder=\"input law\" class=\"form-control\"><br>     <input type=\"text\" name=\"laws\" placeholder=\"input law\" class=\"form-control\"><br>     <input type=\"text\" name=\"laws\" placeholder=\"input law\" class=\"form-control\"><br>     <input type=\"text\" name=\"laws\" placeholder=\"input law\" class=\"form-control\"><br>     <input type=\"text\" name=\"laws\" placeholder=\"input law\" class=\"form-control\"><br>     <input type=\"text\" name=\"laws\" placeholder=\"input law\" class=\"form-control\"><br>     <input type=\"text\" name=\"laws\" placeholder=\"input law\" class=\"form-control\"><br>     <input type=\"text\" name=\"laws\" placeholder=\"input law\" class=\"form-control\"><br>     <input type=\"text\" name=\"laws\" placeholder=\"input law\" class=\"form-control\"><br>     <input type=\"text\" name=\"laws\" placeholder=\"input law\" class=\"form-control\"><br>     <input type=\"text\" name=\"laws\" placeholder=\"input law\" class=\"form-control\"><br>     <input type=\"text\" name=\"laws\" placeholder=\"input law\" class=\"form-control\"><br>     <input type=\"text\" name=\"laws\" placeholder=\"input law\" class=\"form-control\"><br>     <input type=\"text\" name=\"laws\" placeholder=\"input law\" class=\"form-control\"><br>     <input type=\"text\" name=\"laws\" placeholder=\"input law\" class=\"form-control\"><br>     <input type=\"text\" name=\"laws\" placeholder=\"input law\" class=\"form-control\"><br>     <input type=\"text\" name=\"laws\" placeholder=\"input law\" class=\"form-control\"><br>     <input type=\"text\" name=\"laws\" placeholder=\"input law\" class=\"form-control\"><br>     <input type=\"text\" name=\"laws\" placeholder=\"input law\" class=\"form-control\"><br>     <input type=\"text\" name=\"laws\" placeholder=\"input law\" class=\"form-control\"><br>     <input type=\"text\" name=\"laws\" placeholder=\"input law\" class=\"form-control\"><br>     <input type=\"text\" name=\"laws\" placeholder=\"input law\" class=\"form-control\"><br>     <input type=\"text\" name=\"laws\" placeholder=\"input law\" class=\"form-control\"><br>     <input type=\"text\" name=\"laws\" placeholder=\"input law\" class=\"form-control\"><br>     <input type=\"text\" name=\"laws\" placeholder=\"input law\" class=\"form-control\"><br>     <input type=\"text\" name=\"laws\" placeholder=\"input law\" class=\"form-control\"><br>     <input type=\"text\" name=\"laws\" placeholder=\"input law\" class=\"form-control\"><br>     <input type=\"text\" name=\"laws\" placeholder=\"input law\" class=\"form-control\"><br>     <input type=\"text\" name=\"laws\" placeholder=\"input law\" class=\"form-control\"><br>     <input type=\"text\" name=\"laws\" placeholder=\"input law\" class=\"form-control\"><br>     <input type=\"text\" name=\"laws\" placeholder=\"input law\" class=\"form-control\"><br>     <input type=\"text\" name=\"laws\" placeholder=\"input law\" class=\"form-control\"><br>     <input type=\"text\" name=\"laws\" placeholder=\"input law\" class=\"form-control\"><br>     <input type=\"text\" name=\"laws\" placeholder=\"input law\" class=\"form-control\"><br>     <input type=\"text\" name=\"laws\" placeholder=\"input law\" class=\"form-control\"><br>     <input type=\"text\" name=\"laws\" placeholder=\"input law\" class=\"form-control\"><br>     <input type=\"text\" name=\"laws\" placeholder=\"input law\" class=\"form-control\"><br>     <input type=\"text\" name=\"laws\" placeholder=\"input law\" class=\"form-control\"><br>     <input type=\"text\" name=\"laws\" placeholder=\"input law\" class=\"form-control\"><br>     <input type=\"text\" name=\"laws\" placeholder=\"input law\" class=\"form-control\"><br>     <input type=\"text\" name=\"laws\" placeholder=\"input law\" class=\"form-control\"><br>     <input type=\"text\" name=\"laws\" placeholder=\"input law\" class=\"form-control\"><br>     <input type=\"text\" name=\"laws\" placeholder=\"input law\" class=\"form-control\"><br>     <input type=\"text\" name=\"laws\" placeholder=\"input law\" class=\"form-control\"><br>     <input type=\"text\" name=\"laws\" placeholder=\"input law\" class=\"form-control\"><br>     <input type=\"text\" name=\"laws\" placeholder=\"input law\" class=\"form-control\"><br>     <input type=\"text\" name=\"laws\" placeholder=\"input law\" class=\"form-control\"><br>     <input type=\"text\" name=\"laws\" placeholder=\"input law\" class=\"form-control\"><br>     <input type=\"text\" name=\"laws\" placeholder=\"input law\" class=\"form-control\"><br>     <input type=\"text\" name=\"laws\" placeholder=\"input law\" class=\"form-control\"><br>     <input type=\"text\" name=\"laws\" placeholder=\"input law\" class=\"form-control\"><br>     <input type=\"text\" name=\"laws\" placeholder=\"input law\" class=\"form-control\"><br>     <input type=\"text\" name=\"laws\" placeholder=\"input law\" class=\"form-control\"><br>     <input type=\"text\" name=\"laws\" placeholder=\"input law\" class=\"form-control\"><br>     <input type=\"text\" name=\"laws\" placeholder=\"input law\" class=\"form-control\"><br>     <input type=\"text\" name=\"laws\" placeholder=\"input law\" class=\"form-control\"><br>     <input type=\"text\" name=\"laws\" placeholder=\"input law\" class=\"form-control\"><br>     <input type=\"text\" name=\"laws\" placeholder=\"input law\" class=\"form-control\"><br>     <input type=\"text\" name=\"laws\" placeholder=\"input law\" class=\"form-control\"><br>     <input type=\"text\" name=\"laws\" placeholder=\"input law\" class=\"form-control\"><br>     <input type=\"text\" name=\"laws\" placeholder=\"input law\" class=\"form-control\"><br>     <input type=\"text\" name=\"laws\" placeholder=\"input law\" class=\"form-control\"><br>     <input type=\"text\" name=\"laws\" placeholder=\"input law\" class=\"form-control\"><br>     <input type=\"text\" name=\"laws\" placeholder=\"input law\" class=\"form-control\"><br>     <input type=\"text\" name=\"laws\" placeholder=\"input law\" class=\"form-control\"><br>     <input type=\"text\" name=\"laws\" placeholder=\"input law\" class=\"form-control\"><br>     <input type=\"text\" name=\"laws\" placeholder=\"input law\" class=\"form-control\"><br>     <input type=\"text\" name=\"laws\" placeholder=\"input law\" class=\"form-control\"><br>     <input type=\"text\" name=\"laws\" placeholder=\"input law\" class=\"form-control\"><br>     <input type=\"text\" name=\"laws\" placeholder=\"input law\" class=\"form-control\"><br>     <input type=\"text\" name=\"laws\" placeholder=\"input law\" class=\"form-control\"><br>     <input type=\"text\" name=\"laws\" placeholder=\"input law\" class=\"form-control\"><br>     <input type=\"text\" name=\"laws\" placeholder=\"input law\" class=\"form-control\"><br>     <input type=\"text\" name=\"laws\" placeholder=\"input law\" class=\"form-control\"><br>     <input type=\"text\" name=\"laws\" placeholder=\"input law\" class=\"form-control\"><br>     <input type=\"text\" name=\"laws\" placeholder=\"input law\" class=\"form-control\"><br>     <input type=\"text\" name=\"laws\" placeholder=\"input law\" class=\"form-control\"><br>     <input type=\"text\" name=\"laws\" placeholder=\"input law\" class=\"form-control\"><br>     <input type=\"text\" name=\"laws\" placeholder=\"input law\" class=\"form-control\"><br>     <input type=\"text\" name=\"laws\" placeholder=\"input law\" class=\"form-control\"><br>     <input type=\"text\" name=\"laws\" placeholder=\"input law\" class=\"form-control\"><br>     <input type=\"text\" name=\"laws\" placeholder=\"input law\" class=\"form-control\"><br>     <input type=\"text\" name=\"laws\" placeholder=\"input law\" class=\"form-control\"><br>     <input type=\"text\" name=\"laws\" placeholder=\"input law\" class=\"form-control\"><br>     <input type=\"text\" name=\"laws\" placeholder=\"input law\" class=\"form-control\"><br>     <input type=\"text\" name=\"laws\" placeholder=\"input law\" class=\"form-control\"><br>     <input type=\"text\" name=\"laws\" placeholder=\"input law\" class=\"form-control\"><br>     <input type=\"text\" name=\"laws\" placeholder=\"input law\" class=\"form-control\"><br>        </form>   </div>   <footer th:insert=\"blocks/footer :: footer\"></footer> </body> </html>","<!DOCTYPE HTML> <html xmlns:th=\"http://www.thymeleaf.org\"> <head>     <title th:text=\"${title}\"/>     <meta http-equiv=\"Content-Type\" content=\"text/html\" charset=\"UTF-8\"/>     <link rel=\"stylesheet\" href=\"type/css\" th:href=\"style.css\">     <link rel=\"stylesheet\" href=\"https://cdn.jsdelivr.net/npm/bootstrap@5.2.2/dist/css/bootstrap.min.css\"> </head> <body>  <header th:insert=\"blocks/header :: header \"></header> <div class=\"container mt 5\">     <h1 th:text=\"${title}\"></h1> </div> <h3>the cost of creating the law is 5 digital dollars as a reward to the miner</h3>   <form action=\"/create-law\" method=\"post\">     <input type=\"text\" name=\"sender\" placeholder=\"input address sender\" class=\"form-control\"><br>      <input type=\"text\" name=\"reward\" placeholder=\"send reward for miner\" class=\"form-control\"><br>     <select  name=\"nameLaw\" class=\"form-control\">         <option  th:each=\"position: ${positions}\"         th:value=\"${position}\" th:text=\"${position}\"></option>     </select><br>     <textarea name=\"password\" placeholder=\"input password\" th:rows=\"8\" th:cols=\"120\"></textarea><br>     <button type=\"submit\" class=\"btn btn-success\" name=\"action\" value=\"/send\">Send Law</button><br>     <input type=\"text\" name=\"laws\" placeholder=\"input address sender\" class=\"form-control\"><br>     <input type=\"text\" name=\"laws\" placeholder=\"you can enter contact details or personal details, (If you want)\" class=\"form-control\"><br>    </form>   </div>   <footer th:insert=\"blocks/footer :: footer\"></footer> </body> </html>","<!DOCTYPE HTML> <html xmlns:th=\"http://www.thymeleaf.org\"> <head>     <title th:text=\"${title}\"/>     <meta http-equiv=\"Content-Type\" content=\"text/html\" charset=\"UTF-8\"/>     <link rel=\"stylesheet\" href=\"https://cdn.jsdelivr.net/npm/bootstrap@5.2.2/dist/css/bootstrap.min.css\"> </head> <body> <header th:insert=\"blocks/header :: header \"></header>  <div class=\"container mt-5\">     <h3 th:text=\"${title}\"/>       <div th:each=\"el : ${currentLaw}\" class=\"alert alert-info mt-2\">         <h4 th:text=\"'address package law: '+${el.addressLaw}\"/>         <p th:text=\"'votes: '+${#numbers.formatDecimal(el.votes, 1, 'COMMA', 16, 'POINT')}\"/>         <p th:text=\"'votesCorporateCouncilOfReferees: '+${el.votesCorporateCouncilOfReferees}\"/>         <p th:text=\"'votesBoardOfDirectors: '+${el.votesBoardOfDirectors}\"/>         <p th:text=\"'votesBoardOfShareholders: '+${el.votesBoardOfShareholders}\"/>         <p th:text=\"'voteGeneralExecutiveDirector: '+${el.voteGeneralExecutiveDirector}\"/>         <p th:text=\"'voteHightJudge: '+${el.voteHightJudge}\"/>         <p th:text=\"'founderVote: '+${el.founderVote}\"/>         <p th:text=\"'package law name: '+${el.packageName}\"/>          <a th:href=\"'/detail-laws-current/' + ${el.addressLaw}\" class=\"btn btn-warning\">Details</a>     </div>  </div> <footer th:insert=\"blocks/footer :: footer\"></footer>  </body> </html>","<html xmlns:th=\"http://www.thymeleaf.org\"> <head>     <title>About us</title>     <meta http-equiv=\"Content-Type\" content=\"text/html\" charset=\"UTF-8\"/>     <link rel=\"stylesheet\" href=\"https://cdn.jsdelivr.net/npm/bootstrap@5.2.2/dist/css/bootstrap.min.css\"> </head> <body> <header th:insert=\"blocks/header :: header \"></header>  <div class=\"container mt-5\">     <h1 th:text=\"${title}\"></h1>     <div th:each=\"el : ${laws}\">         <h5 th:text=\"${el}\"/>     </div> </div> <footer th:insert=\"blocks/footer :: footer\"></footer>  </body> </html>","<!DOCTYPE HTML> <html xmlns:th=\"http://www.thymeleaf.org\"> <head>     <title th:text=\"${title}\"/>     <meta http-equiv=\"Content-Type\" content=\"text/html\" charset=\"UTF-8\"/>     <link rel=\"stylesheet\" href=\"https://cdn.jsdelivr.net/npm/bootstrap@5.2.2/dist/css/bootstrap.min.css\"> </head> <body> <header th:insert=\"blocks/header :: header \"></header> <div class=\"container mt-5\">     <h3 th:text=\"${title}\"/> </div> <div class=\"container mt-5\">      <div th:each=\"instance :${show}\">         <h4 th:text=\"${instance.key}\"/>         <div th:each=\"el : ${instance.value}\" class=\"alert alert-info mt-2\">             <h4 th:text=\"'address law: '+${el.addressLaw}\"/>             <p th:text=\"'package law name: '+${el.packageName}\"/>             <p th:text=\"'votes: '+${#numbers.formatDecimal(el.votes, 1, 'COMMA', 16, 'POINT')}\"/>             <p th:text=\"'votesCorporateCouncilOfReferees: '+${el.votesCorporateCouncilOfReferees}\"/>             <p th:text=\"'votesBoardOfDirectors: '+${el.votesBoardOfDirectors}\"/>             <p th:text=\"'votesBoardOfShareholders: '+${el.votesBoardOfShareholders}\"/>             <p th:text=\"'voteGeneralExecutiveDirector: '+${el.voteGeneralExecutiveDirector}\"/>             <p th:text=\"'voteHightJudge: '+${el.voteHightJudge}\"/>             <p th:text=\"'founderVote: '+${el.founderVote}\"/>              <a th:href=\"'/detail-laws-current/' + ${el.addressLaw}\" class=\"btn btn-warning\">Details</a>         </div>     </div>    </div> <footer th:insert=\"blocks/footer :: footer\"></footer>  </body> </html>","<!DOCTYPE HTML> <html xmlns:th=\"http://www.thymeleaf.org\"> <head>     <title th:text=\"${title}\"/>     <meta http-equiv=\"Content-Type\" content=\"text/html\" charset=\"UTF-8\"/>     <link rel=\"stylesheet\" href=\"https://cdn.jsdelivr.net/npm/bootstrap@5.2.2/dist/css/bootstrap.min.css\"> </head> <body>  <header th:insert=\"blocks/header :: header \"></header> <div class=\"container mt 5\">     <h1 th:text=\"${title}\"></h1> </div>  <div  class=\"alert alert-info mt-2\">     <h4 th:text=\"'miner address: '+${account.account}\"/>     <p th:text=\"'digital dollar: '+${#numbers.formatDecimal(account.digitalDollarBalance, 1, 'COMMA', 16, 'POINT')}\"/>     <p th:text=\"'digital digitalStockBalance: '+${#numbers.formatDecimal(account.digitalStockBalance, 1, 'COMMA', 16, 'POINT')}\"/>  </div>  <div class=\"container mt-5 mb-5\">     <form action=\"/\" method=\"post\">         <input type=\"text\" name=\"sender\" placeholder=\"input address sender\" class=\"form-control\"><br>         <input type=\"text\" name=\"recipient\" placeholder=\"input address recipient\" class=\"form-control\"><br>         <input type=\"text\" name=\"dollar\" placeholder=\"input digital dollar to send\" class=\"form-control\"><br>         <input type=\"text\" name=\"stock\" placeholder=\"input digital stock to send\" class=\"form-control\"><br>         <input type=\"text\" name=\"reward\" placeholder=\"send reward for miner\" class=\"form-control\"><br>          <h5>if your vote is YES, then the recipient's reputation is increased by the transferred amount of reputation, if NO, then the recipient's amount is reduced by the same amount that you sent, but does not affect the digital dollar</h5>         <select  name=\"vote\" class=\"form-control\">             <option value=\"YES\" >YES</option>             <option value=\"NO\">NO</option>         </select><br>          <textarea name=\"password\" placeholder=\"input password\" th:rows=\"8\" th:cols=\"120\"></textarea><br>         <button type=\"submit\" class=\"btn btn-success\">Send money</button><br>     </form>      <form action=\"/mine\" method=\"get\">         <button type=\"submit\" class=\"btn btn-success\">Mining block</button><br>     </form>      <form action=\"/nodes/register\" method=\"post\">         <input type=\"text\" name=\"urlAddrress\" placeholder=\"add url address)\" class=\"form-control\"><br>         <button type=\"submit\" class=\"btn btn-success\">register urlth</button><br>     </form>      <form action=\"/setMinner\" method=\"post\">         <input type=\"text\" name=\"setMinner\" placeholder=\"change miner address)\" class=\"form-control\"><br>         <button type=\"submit\" class=\"btn btn-success\">change miner address</button><br>     </form> </div>   <footer th:insert=\"blocks/footer :: footer\"></footer> </body> </html>"," <!DOCTYPE HTML> <html xmlns:th=\"http://www.thymeleaf.org\"> <head>     <title th:text=\"'test: '+${title}\"/>     <meta http-equiv=\"Content-Type\" content=\"text/html\" charset=\"UTF-8\"/>     <link rel=\"stylesheet\" href=\"https://cdn.jsdelivr.net/npm/bootstrap@5.2.2/dist/css/bootstrap.min.css\"> </head> <body> <header th:insert=\"blocks/header :: header \"></header> <div class=\"container mt-5\">     <div  class=\"alert alert-info mt-2\">         <h4 th:text=\"'adress sender: '+${sender}\"/>         <h3 th:text=\"'address recipient: '+${recipient}\"/>         <h3 th:text=\"'dollar: '+${dollar}\"/>         <h3 th:text=\"'stock: '+${stock}\"/>         <h3 th:text=\"'reward: '+${reward}\"/>         <h3 th:text=\"'vote: '+${vote}\"/>         <h3 th:text=\"'sending: '+${sending}\"/>      </div> </div>  <footer th:insert=\"blocks/footer :: footer\"></footer>  </body> </html>","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","",""],"hashLaw":"LIBER18f89b0194e9109e7c0bbf2f2d952359af4c9c52b366b4d87197fe512a3d2114"}}
{"name":"LIBER520a7cedd27ecc7e8d23e590acc93637e26936f4702e02feca622f5d5f0b8006","account":{"account":"LIBER520a7cedd27ecc7e8d23e590acc93637e26936f4702e02feca622f5d5f0b8006","digitalDollarBalance":0.0,"digitalStockBalance":0.0},"laws":{"packetLawName":"ORIGINAL_CHARTER_CURRENT_LAW_PACKAGE_NAME","laws":["# HOW THE LAWS ARE CHOSEN.  ## Approval of the law _____  ## CHARTER No law is retroactive. No law shall violate the existing statute or be inconsistent with other applicable laws. If there is a contradiction between several laws from one set of laws, then the current one is the one that is higher in the index in the list. Example: alcohol sales package the law under index 3 contradicts the law from index 17, in this case the law under index three will be valid, because he is higher in status. In the event of a conflict between several laws in force, the Judiciary shall give priority to those laws which were adopted earlier, but should be taken into account precisely from the last date of adoption of the law. The law is in force as long as it satisfies the conditions for the adoption of the law and as soon as the condition violated, the law loses its force until the law is re-adopted. In the voting of all laws, only the votes given in the last four years are taken into account. All laws are divided into several groups. 1. Ordinary laws 2. Strategic Plan 3. Budget 4. Appointed by the Legislature 6. Laws that create new positions. These positions are approved only by the Legislative Power. 7. Amendments to the Charter 8. The charter itself  ### REGULAR LAWS To establish ordinary laws, 1. The name of the package of law should not match the highlighted keywords. 2. The law must receive more than 1 vote according to the scoring system described by [VOTE_STOCK](../charterEng/VOTE_STOCK.md) 3. Must receive 10 or more votes of the Board of Directors according to the scoring system described in [ONE_VOTE](../charterEng/ONE_VOTE.md) 4. Must receive 10 or more votes of the Board of Shareholders according to the scoring system described in [ONE_VOTE](../charterEng/ONE_VOTE.md) 5. Must receive 10% of votes from factions according to the counting system described in [VOTE_FRACTION](../charterEng/VOTE_FRACTION.md).  ![asserting customary laws](../screenshots/law-classic.png) Sample code in LawsController current law: ````       //laws must be approved by everyone.          List<CurrentLawVotesEndBalance> notEnoughVotes = current.stream()                  .filter(t -> !directors.contains(t.getPackageName()))                  .filter(t->!Seting.AMENDMENT_TO_THE_CHARTER.equals(t.getPackageName()))                  .filter(t->!directors.isCabinets(t.getPackageName()))                  .filter(t -> !Seting.ORIGINAL_CHARTER_CURRENT_LAW_PACKAGE_NAME.equals(t.getPackageName()))                  .filter(t->!Seting.ORIGINAL_CHARTER_CURRENT_ALL_CODE.equals(t.getPackageName()))                  .filter(t -> t.getVotesBoardOfShareholders() >= Seting.ORIGINAL_LIMIT_MIN_VOTE_BOARD_OF_SHAREHOLDERS                  && t.getVotesBoardOfDirectors() >= Seting.ORIGINAL_LIMIT_MIN_VOTE_BOARD_OF_DIRECTORS                  && t.getVotes() >= Seting.ALL_STOCK_VOTE                  && t.getFractionVote() >= Seting.ORIGINAL_LIMIT_MIN_VOTE_FRACTIONS)                  .sorted(Comparator.comparing(CurrentLawVotesEndBalance::getVotes).reversed()).collect(Collectors.toList());      ````  ### STRATEGIC PLAN. The strategic plan is the general plan for the entire network and is approved in the same way as an ordinary law, but there are some differences from ordinary laws. 1. The strategic plan package should be called STRATEGIC_PLAN 2. All plans that have been approved are sorted from highest to lowest by the number of votes,    received from the Board of Directors. 3. After Sorting, only one PLAN with the highest number of votes received from the Board of Directors is selected.  ```` //the plan is approved by everyone          List<CurrentLawVotesEndBalance> planFourYears = current.stream()                  .filter(t->!directors.contains(t.getPackageName()))                  .filter(t->Seting.STRATEGIC_PLAN.equals(t.getPackageName()))                  .filter(t->!directors.isCabinets(t.getPackageName()))                  .filter(t->t.getVotesBoardOfDirectors() >= Seting.ORIGINAL_LIMIT_MIN_VOTE_BOARD_OF_DIRECTORS                          && t.getVotesBoardOfShareholders() >= Seting.ORIGINAL_LIMIT_MIN_VOTE_BOARD_OF_SHAREHOLDERS                          && t.getFractionVote() >= Seting.ORIGINAL_LIMIT_MIN_VOTE_FRACTIONS                          && t.getVotes() >= Seting.ALL_STOCK_VOTE)                  .sorted(Comparator.comparing(CurrentLawVotesEndBalance::getVotesBoardOfDirectors).reversed())                  .limit(1)                  .collect(Collectors.toList()); ````  ### BUDGET The budget is the overall cost for the system and is approved similarly to the Strategic Plan, but the name of the package should be BUDGET and it is also in a single copy.  ````   //budget approved by everyone          List<CurrentLawVotesEndBalance> budjet = current.stream()                  .filter(t-> !directors.contains(t.getPackageName()))                  .filter(t->Seting.BUDGET.equals(t.getPackageName()))                  .filter(t->!directors.isCabinets(t.getPackageName()))                  .filter(t->                          t.getVotesBoardOfDirectors() >= Seting.ORIGINAL_LIMIT_MIN_VOTE_BOARD_OF_DIRECTORS                          && t.getVotesBoardOfShareholders() >= Seting.ORIGINAL_LIMIT_MIN_VOTE_BOARD_OF_SHAREHOLDERS                          && t.getFractionVote() >= Seting.ORIGINAL_LIMIT_MIN_VOTE_FRACTIONS                          && t.getVotes() >= Seting.ALL_STOCK_VOTE)                  .sorted(Comparator.comparing(CurrentLawVotesEndBalance::getVotesBoardOfDirectors).reversed())                  .limit(1)                  .collect(Collectors.toList()); ````  ### POSTS THAT ARE APPOINTED ONLY BY THE LEGISLATIVE AUTHORITY There are positions that are appointed only by the Legislature and such positions include General Executive Director. This position is similar to the Prime Minister and is Executive Power in this system. Each such position can be limited to the number that is defined in this system. for this position. Example: There is only one CEO position. Elected in the same way as ***strategic plan*** and ***budget***. But the number is determined for each position separately. ````    //positions elected only by all participants          List<CurrentLawVotesEndBalance> electedByBoardOfDirectors = current.stream()                  .filter(t -> directors.isElectedByBoardOfDirectors(t.getPackageName()) || directors.isCabinets(t.getPackageName()))                  .filter(t -> t.getVotesBoardOfDirectors() >= Seting.ORIGINAL_LIMIT_MIN_VOTE_BOARD_OF_DIRECTORS                  && t.getVotesBoardOfShareholders() >= Seting.ORIGINAL_LIMIT_MIN_VOTE_BOARD_OF_SHAREHOLDERS                  && t.getFractionVote() >= Seting.ORIGINAL_LIMIT_MIN_VOTE_FRACTIONS                  && t.getVotes() >= Seting.ALL_STOCK_VOTE)                  .sorted(Comparator.comparing(CurrentLawVotesEndBalance::getVotesBoardOfDirectors).reversed())                  .collect(Collectors.toList());                                     //group by list          Map<String, List<CurrentLawVotesEndBalance>> group = electedByBoardOfDirectors.stream()                  .collect(Collectors.groupingBy(CurrentLawVotesEndBalance::getPackageName));           Map<Director, List<CurrentLawVotesEndBalance>> original_group = new HashMap<>();           // leave the amount that is described in this post          for (Map.Entry<String, List<CurrentLawVotesEndBalance>> stringListEntry : group.entrySet()) {              List<CurrentLawVotesEndBalance> temporary = stringListEntry.getValue();              temporary = temporary.stream()                      .sorted(Comparator.comparing(CurrentLawVotesEndBalance::getVotesBoardOfDirectors))                      .limit(directors.getDirector(stringListEntry.getKey()).getCount())                      .collect(Collectors.toList());              original_group.put(directors.getDirector(stringListEntry.getKey()), temporary);          } ````  There are also positions that are created with the help of laws, these positions are also approved by the Legislative power. For each such position, there is only one seat for each title. The name of such packages starts with ADD_DIRECTOR_. With the obligatory underscore.  ### CHARTER AMENDMENTS To amend the charter, the law package must be named AMENDMENT_TO_THE_CHARTER. For an amendment to be valid 1. It is necessary that 20% or more of the votes received from the Council of Shareholders by the counting system [ONE_VOTE](../charterEng/ONE_VOTE.md). 2. Need to get 20% or more votes from the Board of Directors by the [ONE_VOTE](../charterEng/ONE_VOTE.md) counting system . 3. Need to get 5 or more votes from the Legislative Branch of the Corporate Chief Justices. 4. Need to get 10% or more of votes from factions by counting system [VOTE_FRACTION](../charterEng/VOTE_FRACTION.md).  ![Charter amendments](../screenshots/amendment-chapter.png) ````     //introduction of amendments to the charter          List<CurrentLawVotesEndBalance> chapter_amendment = current.stream()                  .filter(t -> !directors.contains(t.getPackageName()))                  .filter(t-> Seting.AMENDMENT_TO_THE_CHARTER.equals(t.getPackageName()))                  .filter(t->!directors.isCabinets(t.getPackageName()))                  .filter(t -> t.getVotesBoardOfShareholders() >= Seting.ORIGINAL_LIMIT_MINT_VOTE_BOARD_OF_SHAREHOLDERS_AMENDMENT                  && t.getVotesBoardOfDirectors() >= Seting.ORIGINAL_LIMIT_MIN_VOTE_BOARD_OF_DIRECTORS_AMENDMENT                  && t.getVotesCorporateCouncilOfReferees() >= Seting.ORIGINAL_LIMIT_MIN_VOTE_CORPORATE_COUNCIL_OF_REFEREES_AMENDMENT                  && t.getFractionVote() >= Seting.ORIGINAL_LIMIT_MIN_VOTE_FRACTIONS)                  .sorted(Comparator.comparing(CurrentLawVotesEndBalance::getVotesBoardOfDirectors).reversed()).collect(Collectors.toList());  ````  ### SAM CHARTER. The first charter is approved by the founder and it is valid, the vote of the founder for approval The charter never has an expiration date. The charter package name starts with CHARTER_ORIGINAL and the name refone CHARTER_ORIGINAL_CODE. These two packages are a holistic charter, but in the first place, the source code must not contradict the principles described in CHARTER_ORIGINAL. ```` // the charter is always valid, it is signed by the founder          List<CurrentLawVotesEndBalance> CHARTER_ORIGINAL = current.stream()                  .filter(t -> !directors.contains(t.getPackageName()) && Seting.ORIGINAL_CHARTER_CURRENT_LAW_PACKAGE_NAME.equals(t.getPackageName()))                  .filter(t->!directors.isCabinets(t.getPackageName()))                  .filter(t->t.getFounderVote()>=1)                  .sorted(Comparator.comparing(CurrentLawVotesEndBalance::getVotes).reversed())                  .limit(1)                  .collect(Collectors.toList());           // SOURCE CODE CREATED BY THE FOUNDER          List<CurrentLawVotesEndBalance> CHARTER_ORIGINAL_CODE = current.stream()                  .filter(t -> !directors.contains(t.getPackageName()) && Seting.ORIGINAL_CHARTER_CURRENT_ALL_CODE.equals(t.getPackageName()))                  .filter(t->!directors.isCabinets(t.getPackageName()))                  .filter(t->t.getFounderVote()>=1)                  .sorted(Comparator.comparing(CurrentLawVotesEndBalance::getVotes).reversed())                  .limit(1)                  .collect(Collectors.toList()); ```` [Return to main page](../documentationEng/documentationEng.md)","# VOTE_STOCK (How shares are voted.)  How shares are voted. All shares held by the account are equal to the same number of votes. Every time someone makes a transaction to the account, is the packet address that starts with LIBER he votes on this package. Only those votes from which no more than four years have passed are taken into account. If the transaction was made ***VoteEnum.YES,*** then this account receives votes ***for***, formula yesV = number of votes equal to the sender's shares. yesN = how many laws this account voted for with VoteEnum.YES resultYES = yesV / yesN). Example: an account voted for three accounts that start with LIBER, 100 shares, 100 votes. 100 / 3 = 33.3 means each account will receive 33.3 votes.  If the transaction was made with VoteEnum.NO, then the same formula is used, but now all bills for which he voted against are taken into account example the same account voted for two accounts against, it has the same one hundred shares. resultNO = noV / noN = 50 = 50 means every bill he voted for, against will receive 50 votes against. Further, each score that starts with LIBER counts and sums up all the votes given to it ***FOR*** (VoteEnum.YES) and ***NO*** (VoteEnum.NO). Then this formula is used remainder = resultYES - resultNO. It is this result that is displayed as votes cast. At any time you can change your voice, but only to the opposite, which means if If you voted for a YES candidate then you can only change to NO and back. The number of times you can change your voice is not limited. With each block there is a recalculation of votes, if you lose your shares, your candidates also lose their votes. This measure is specifically implemented so that elected positions were interested in the fact that those who vote for them prospered and did not lose their shares. Only CORPORATE_COUNCIL_OF_REFEREES and BOARD_OF_DIRECTORS are elected this way Only the last transaction given for each account counts, unless you have updated your vote, then after four years it will be cancelled. 100,000 votes are needed to approve the law  ______  ```` //code is in class class CurrentLawVotes method: votesLaw public double votesLaw(Map<String, Account> balances,       Map<String, Integer> yesAverage, Map<String, Integer> noAverage) {          double yes = 0.0;          double no = 0.0;                                for (String s : YES) {               int count = 1;            count = yesAverage.get(s) > 0 ? yesAverage.get(s) : 1;            yes += balances.get(s).getDigitalStockBalance() / count;          }                   for (String s : NO) {             int count = 1;              count = noAverage.get(s) > 0 ? noAverage.get(s) : 1;             no += balances.get(s).getDigitalStockBalance() / count);           }            return yes - no;     }  ````  [back to home](../documentationEng/documentationEng.md)","# ONE_VOTE (One Voice)  When these positions are voted count as one score = one vote (CORPORATE_COUNCIL_OF_REFEREES-Council of Corporate Judges, BOARD_OF_DIRECTORS-Board of Directors, GENERAL_EXECUTIVE_DIRECTOR-General Executive Director, HIGH_JUDGE - Supreme Judge and Board of Shareholders). Each score that starts with LIBER counts all votes FOR (VoteEnum.YES) and AGAINST (VoteEnum.NO) for it further deducted from FOR - AGAINST = if the balances are above the threshold, then it becomes the current law. But if a position is elected, then after that it is sorted from largest to smallest and the largest number that is described for this position is selected. Recalculation of votes occurs every block.  After voting, the vote can only be changed to the opposite one. There is no limit on the number of times you can change your vote. Only those votes that are given by accounts are taken into account in office, for example, if the account ceases to be on the Board of Directors, his vote as The Board of Directors does not, and will not, count in voting. All votes are valid until the bills voters are in their positions. Only those votes from which no more than four years, but each participant may at any time renew their vote.  ______  CODE class CurrentLawVotes: method voteGovernment  ```` public int voteGovernment(              Map<String, Account> balances,              List<String> governments) {         int yes = 0;          int no = 0;          List<String> addressGovernment = governments;        for (String s : YES) {              if (addressGovernment.contains(s)) {                  yes += Seting.VOTE_GOVERNMENT;             }           }          for (String s : NO) {            if (addressGovernment.contains(s)) {                  no += Seting.VOTE_GOVERNMENT;             }          }         return yes - no;     }  ````  [back to home](../documentationEng/documentationEng.md)","#VOTE_FRACTION This voting system is used only for factions. First, 100 factions are selected that have become legitimate. Then all the votes given to 100 selected factions are summed up. After that, the share of each fraction from the total amount is determined. votes cast for this faction. The number of votes of each faction is equal to its percentage shares. Thus, if a faction has 23% of the votes of all votes, out of 100 factions, then her vote is equal to 23%.  Then every time a faction votes for laws, that start with LIBER (VoteEnum.YES) or (VoteEnum.NO). This law counts all the votes given *** for *** and *** against ***, after which it is subtracted from *** for *** - *** against ***. This result is displayed as a percentage.  ````   //faction vote      public double voteFractions(Map<String, Double> fractions){          double yes = 0;          double no = 0;          double sum = fractions.entrySet().stream()                  .map(t->t.getValue())                  .collect(Collectors.toList())                  .stream().reduce(0.0, Double::sum);           for (String s : YES) {              if (fractions.containsKey(s)) {                  yes += (fractions.get(s)/sum) * Seting.HUNDRED_PERCENT;              }           }          for (String s : NO) {              if (fractions.containsKey(s)) {                  no += (fractions.get(s)/sum) * Seting.HUNDRED_PERCENT;              }           }          return yes - no;       }  ````  [Return to main page](../documentationEng/documentationEng.md)","# Penalty mechanism  You make a transaction in which you lose this amount of shares, but and the account to which the penalty is directed loses such an amount of shares.  Valid for digital dollars only. ![Lead fine](../screenshots/lead_a_fine_eng.png) ______  ## MECHANISM_FOR_REDUCING_THE_NUMBER_OF_SHARES MECHANISM FOR REDUCING THE NUMBER OF SHARES. Entering penalties. Every time one account sends a digital share to another account but uses VoteEnum.NO, the account recipient's digital shares are reduced by the amount sent by the share sender. Example account A sent to account B 100 digital shares with VoteEnum.NO, then account A and account B both lose 100 digital shares. This measure is needed so that there is a mechanism to dismiss the Board of Shareholders and also allows you to lower your votes destructive accounts, since the number of votes is equal to the number of shares in the Election of the Board of Directors and when electing CORPORATE_COUNCIL_OF_REFEREES. This mechanism only works on digital shares and only if the sender has made a transaction with VoteEnum.NO.  [exit to home](../documentationEng/documentationEng.md)","# WHO_HAS_THE_RIGHT_TO_CREATE_LAWS Who has the right to create laws  String WHO_HAS_THE_RIGHT_TO_CREATE_LAWS = Who has the right to make laws. Create Laws in Cryptocurrency International Trade Union Corporations Have the Rights all network members who have at least five digital dollars. To create law through the International Trade Union Corporation's cryptocurrency mechanism It is necessary to create an object of the Laws class inside this cryptocurrency, where packetLawName is the name of the law package. List<String> laws - is a list of laws, String hashLaw - is the address of this package of laws and starts with LIBER. For a law to be included in the pool of laws, you need to create a transaction where the recipient is the hashLaw of this law and the reward miner is equal to five digital dollars (5) of this cryptocurrency. After that, as the law gets into the block, it will be in the pool laws and it will be possible to vote for it. The number of lines in a package of laws can be as many as needed and there are no restrictions.  [Exit to home](../documentationEng/documentationEng.md)","# POWERS_OF_THE_CORPORATE_COUNCIL_OF_JUDGES Judicial Power. Approves the Chief Justice. Participates in the voting on the introduction of amendments.  The judicial power of the International Trade Union Corporation is vested in one Supreme Court and such inferior courts as the Corporation International The Merchant Union may issue and establish from time to time. Judges of both the supreme and inferior courts hold their offices, with good conduct and in due time receive remuneration for their services. Remuneration must be given from the budget established by laws. Judicial power extends to all cases of law and justice, including those initiated by members to challenge the misappropriation of funds, arising under these Articles, the laws of the International Trade Union Corporation and treaties, imprisoned or to be imprisoned according to their authority. to controversy, in which the International Trade Union will be party to a dispute between two or more members of the network. No judgment shall be secret, but justice shall be administered openly and free of charge, completely and without delay, and every person shall have legal protection against injury to life, liberty, or property. Supreme Court CORPORATE_COUNCIL_OF_REFEREES and Chief Justice HIGH_JUDGE.  ## How the Corporate Council of Judges is elected. The Corporate Council of Judges consists of 55 accounts and is elected by the Network Members, with the scoring system described in VOTE_STOCK, similar to Board of Directors and Factions. The 55 accounts that received the most votes are selected. ![stock votes](../screenshots/stock_vote.png) ```` //minimum value for the number of positive votes for the law to be valid,          //positions elected by shares CORPORATE_COUNCIL_OF_REFEREES          List<CurrentLawVotesEndBalance> electedByStockCorporateCouncilOfReferees = current.stream()                  .filter(t -> directors.isElectedByStocks(t.getPackageName()))                  .filter(t -> t.getPackageName().equals(NamePOSITION.CORPORATE_COUNCIL_OF_REFEREES.toString()))                  .filter(t -> t.getVotes() >= Seting.ORIGINAL_LIMIT_MIN_VOTE)                  .sorted(Comparator.comparing(CurrentLawVotesEndBalance::getVotes).reversed())                  .limit(directors.getDirector(NamePOSITION.CORPORATE_COUNCIL_OF_REFEREES.toString()).getCount())                  .collect(Collectors.toList()); ````  Each score of such a judge is equal to one vote, similar to [ONE_VOTE](../charterEng/ONE_VOTE.md)  [Exit to home](../documentationEng/documentationEng.md)","# String HOW_THE_CHIEF_JUDGE_IS_CHOSEN HOW HIGH_JUDGE IS CHOSEN. The Chief Justice is elected by CORPORATE_COUNCIL_OF_REFEREES. Each member of the network can apply for the position of Chief Justice by creating a law called package that matches HIGH_JUDGE position, where the address of the sender of this transaction must match the first line from the list of laws of this package. The cost of the law is five digital dollars as a reward to the earner. The account with the most remaining votes receives the position. The voting mechanism is described in [ONE_VOTE](../charterEng/ONE_VOTE.md). Elects the Chief Justice, Corporate Council of Judges. (CORPORATE_COUNCIL_OF_REFEREES) Sample code as stated by the supreme judge. Class LawsController: method currentLaw. Code section  ````        //positions elected by the board of corporate chief judges        List<CurrentLawVotesEndBalance> electedByCorporateCouncilOfReferees = current.stream()                 .filter(t -> directors.isElectedBYCorporateCouncilOfReferees(t.getPackageName()))                 .filter(t -> t.getVotesCorporateCouncilOfReferees() >= Seting.ORIGINAL_LIMIT_MIN_VOTE_CORPORATE_COUNCIL_OF_REFEREES)                 .sorted(Comparator.comparing(CurrentLawVotesEndBalance::getVotesCorporateCouncilOfReferees)).collect(Collectors.toList()); ````  ## Powers of Chief Justice Chief Justice can participate in resolving disputes within network members, like CORPORATE_COUNCIL_OF_REFEREES, but his vote is higher than that of CORPORATE_COUNCIL_OF_REFEREES.  [Exit to home](../documentationEng/documentationEng.md)","# PROPERTY_OF_THE_CORPORATION PROPERTY OF THE CORPORATION. All property owned by the International Trade Union Corporation, cannot be sold without a valid law, where the sale process will be described and at what price the property will be sold. The founder's account, and the accounts of other members are not corporate account, the Board of Directors must create a separate account which will be budgeted and managed only by members of the current members of the Board of Directors.  [Exit to home](../documentationEng/documentationEng.md)","# GENERAL_EXECUTIVE_DIRECTOR General Executive Director This Director coordinates the actions of the other senior directors to implement the strategic plan or the tasks assigned to it by the laws in force. All powers must be given to him through existing laws. This is the highest position elected by the Corporation and is essentially the analogue of the prime minister.  ## How the CEO is elected This director is elected by the Legislature 1. The Board of Directors must give more than 10 or more votes using the [ONE_VOTE](../charterEng/ONE_VOTE.md) method 2. The Board of Shareholders must give more than 10 or more votes using the [ONE_VOTE](../charterEng/ONE_VOTE.md) method 3. Fractions must give 10% or more votes using the [VOTE_FRACTION](../charterEng/VOTE_FRACTION.md) method 4. Network participants must give more than one vote using the [VOTE_STOCK](../charterEng/VOTE_STOCK.md) method 5. Next comes the sorting from highest to lowest received votes from the Board of Directors and 6. One account with the most votes from the Board of Directors is selected  ````   //positions elected only by all participants          List<CurrentLawVotesEndBalance> electedByBoardOfDirectors = current.stream()                  .filter(t -> directors.isElectedByBoardOfDirectors(t.getPackageName()) || directors.isCabinets(t.getPackageName()))                  .filter(t -> t.getVotesBoardOfDirectors() >= Seting.ORIGINAL_LIMIT_MIN_VOTE_BOARD_OF_DIRECTORS                  && t.getVotesBoardOfShareholders() >= Seting.ORIGINAL_LIMIT_MIN_VOTE_BOARD_OF_SHAREHOLDERS                  && t.getFractionVote() >= Seting.ORIGINAL_LIMIT_MIN_VOTE_FRACTIONS                  && t.getVotes() >= Seting.ALL_STOCK_VOTE)                  .sorted(Comparator.comparing(CurrentLawVotesEndBalance::getVotesBoardOfDirectors).reversed())                  .collect(Collectors.toList());                                    //group by list          Map<String, List<CurrentLawVotesEndBalance>> group = electedByBoardOfDirectors.stream()                  .collect(Collectors.groupingBy(CurrentLawVotesEndBalance::getPackageName));           Map<Director, List<CurrentLawVotesEndBalance>> original_group = new HashMap<>();           // leave the amount that is described in this post          for (Map.Entry<String, List<CurrentLawVotesEndBalance>> stringListEntry : group.entrySet()) {              List<CurrentLawVotesEndBalance> temporary = stringListEntry.getValue();              temporary = temporary.stream()                      .sorted(Comparator.comparing(CurrentLawVotesEndBalance::getVotesBoardOfDirectors))                      .limit(directors.getDirector(stringListEntry.getKey()).getCount())                      .collect(Collectors.toList());              original_group.put(directors.getDirector(stringListEntry.getKey()), temporary);          }  ````  ````   public static List<CurrentLawVotesEndBalance> filtersVotes(              List<LawEligibleForParliamentaryApproval> approvalList,              Map<String, Account> balances,              List<Account> BoardOfShareholders,              List<Block> blocks,              int limitBlocks      ) throws IOException, NoSuchAlgorithmException, SignatureException, InvalidKeySpecException, NoSuchProviderException, InvalidKeyException {          //acting laws whose votes are greater than ORIGINAL_LIMIT_MIN_VOTE          List<CurrentLawVotesEndBalance> current = new ArrayList<>();          Map<String, CurrentLawVotes> votesMap = null;          List<Account> accounts = balances.entrySet().stream().map(t -> t.getValue()).collect(Collectors.toList());          if (blocks.size() > limitBlocks) {              votesMap = UtilsCurrentLaw.calculateVotes(accounts, blocks.subList(blocks.size() - limitBlocks, blocks.size()));          } else {              votesMap = UtilsCurrentLaw.calculateVotes(accounts, blocks);          }           //calculate the average number of times he voted for          Map<String, Integer> yesAverage = UtilsCurrentLaw.calculateAverageVotesYes(votesMap);          //calculate the average number of times he downvoted          Map<String, Integer> noAverage = UtilsCurrentLaw.calculateAverageVotesNo(votesMap);            //count the votes for the normal laws and laws of positions          for (LawEligibleForParliamentaryApproval lawEligibleForParliamentaryApproval : approvalList) {              if (votesMap.containsKey(lawEligibleForParliamentaryApproval.getLaws().getHashLaw())) {                  String address = lawEligibleForParliamentaryApproval.getLaws().getHashLaw();                  String packageName = lawEligibleForParliamentaryApproval.getLaws().getPacketLawName();                  List<String> laws = lawEligibleForParliamentaryApproval.getLaws().getLaws();                  double vote = 0;                  int supremeVotes = 0;                  int boafdOfShareholderVotes = 0;                  int houseOfRepresentativiesVotes = 0;                  int primeMinisterVotes = 0;                  int-highhtJudgesVotes = 0;                  int founderVote = 0;                  double fraction = 0;                   //count special votes for laws                  vote = votesMap.get(lawEligibleForParliamentaryApproval.getLaws().getHashLaw()).votesLaw(balances, yesAverage, noAverage);                  List<String> boardOfShareholdersAddress = BoardOfShareholders.stream().map(t -> t.getAccount()).collect(Collectors.toList());                  boafdOfShareholderVotes = votesMap.get(lawEligibleForParliamentaryApproval.getLaws().getHashLaw()).voteGovernment(balances, boardOfShareholdersAddress);                   List<String> founder = List.of(Seting.ADDRESS_FOUNDER);                  founderVote = votesMap.get(lawEligibleForParliamentaryApproval.getLaws().getHashLaw()).voteGovernment(balances, founder);                  CurrentLawVotesEndBalance currentLawVotesEndBalance = new CurrentLawVotesEndBalance(                          address,                          packagename,                          vote,                          supremeVotes,                          houseOfRepresentativesVotes,                          boafdOfShareholderVotes,                          primeMinisterVotes,                          hightJudgesVotes,                          founderVote,                          fraction,                          laws);                  current.add(currentLawVotesEndBalance);               }          }           List<String> houseOfRepresentativies = new ArrayList<>();          List<String> chamberOfSumpremeJudges = new ArrayList<>();          Map<String, Double> fractions = new HashMap<>();           for (CurrentLawVotesEndBalance currentLawVotesEndBalance: current) {              if(currentLawVotesEndBalance.getPackageName().equals(NamePOSITION.BOARD_OF_DIRECTORS.toString())){                  if(currentLawVotesEndBalance.getVotes() >= Seting.ORIGINAL_LIMIT_MIN_VOTE){                      houseOfRepresentativies.add(currentLawVotesEndBalance.getLaws().get(0));                  }               }              if(currentLawVotesEndBalance.getPackageName().equals(NamePOSITION.CORPORATE_COUNCIL_OF_REFEREES.toString())){                  if(currentLawVotesEndBalance.getVotes() >= Seting.ORIGINAL_LIMIT_MIN_VOTE){                      chamberOfSumpremeJudges.add(currentLawVotesEndBalance.getLaws().get(0));                  }               }                if(currentLawVotesEndBalance.getPackageName().equals(NamePOSITION.FRACTION.toString())){                  if(currentLawVotesEndBalance.getVotes() >= Seting.ORIGINAL_LIMIT_MIN_VOTE){                      fractions.put(currentLawVotesEndBalance.getLaws().get(0), currentLawVotesEndBalance.getVotes());                  }              }           }             for (CurrentLawVotesEndBalance currentLawVotesEndBalance : current) {              if(votesMap.containsKey(currentLawVotesEndBalance.getAddressLaw())){                    double vote = votesMap.get(currentLawVotesEndBalance.getAddressLaw()).votesLaw(balances, yesAverage, noAverage);                  int supremeVotes = votesMap.get(currentLawVotesEndBalance.getAddressLaw()).voteGovernment(balances, chamberOfSumpremeJudges);                  int houseOfRepresentativiesVotes = votesMap.get(currentLawVotesEndBalance.getAddressLaw()).voteGovernment(balances, houseOfRepresentativies);                  double fractionsVotes = votesMap.get(currentLawVotesEndBalance.getAddressLaw()).voteFractions(fractions);                   currentLawVotesEndBalance.setVotes(vote);                  currentLawVotesEndBalance.setVotesBoardOfDirectors(houseOfRepresentativiesVotes);                  currentLawVotesEndBalance.setVotesCorporateCouncilOfReferees(supremeVotes);                  currentLawVotesEndBalance.setFractionVote(fractionsVotes);              }           }           //examines the CEO          List<String> primeMinister = new ArrayList<>();          List<String> hightJudge = new ArrayList<>();          for (CurrentLawVotesEndBalance currentLawVotesEndBalance : current) {              if(currentLawVotesEndBalance.getPackageName().equals(NamePOSITION.GENERAL_EXECUTIVE_DIRECTOR.toString())){                  if(currentLawVotesEndBalance.getVotesBoardOfDirectors() >= Seting.ORIGINAL_LIMIT_MIN_VOTE_BOARD_OF_DIRECTORS                  && currentLawVotesEndBalance.getFractionVote() >= Seting.ORIGINAL_LIMIT_MIN_VOTE_FRACTIONS                  && currentLawVotesEndBalance.getVotesBoardOfShareholders() >= Seting.ORIGINAL_LIMIT_MIN_VOTE_BOARD_OF_SHAREHOLDERS                  && currentLawVotesEndBalance.getVotes() >= Seting.ALL_STOCK_VOTE){                      primeMinister.add(currentLawVotesEndBalance.getLaws().get(0));                  }              }               if(currentLawVotesEndBalance.getPackageName().equals(NamePOSITION.HIGH_JUDGE.toString())){                  if(currentLawVotesEndBalance.getVotesCorporateCouncilOfReferees() >= Seting.ORIGINAL_LIMIT_MIN_VOTE_CORPORATE_COUNCIL_OF_REFEREES){                      hightJudge.add(currentLawVotesEndBalance.getLaws().get(0));                  }              }          }          for (CurrentLawVotesEndBalance currentLawVotesEndBalance : current) {              if(votesMap.containsKey(currentLawVotesEndBalance.getAddressLaw())){                  int primeMinisterVotes = votesMap.get(currentLawVotesEndBalance.getAddressLaw()).voteGovernment(balances, primeMinister);                  int hightJudgeVotes = votesMap.get(currentLawVotesEndBalance.getAddressLaw()).voteGovernment(balances, hightJudge);                   currentLawVotesEndBalance.setVoteGeneralExecutiveDirector(primeMinisterVotes);                  currentLawVotesEndBalance.setVoteHightJudge(hightJudgeVotes);              }           }            return current;       }  ````  [Exit to home](../documentationEng/documentationEng.md)","# EXPLANATION WHY MONEY DEMURAGE IS USED HERE The negative rate is now applied in many countries, this measure stimulates money holders when the price is excessively high, saturate the market with money. The amount of money mined for each block is 200 digital dollars and 200 digital shares, also 2% of each mining reward to the founder, which is 4 digital dollars and 4 digital Shares for each block mining. Here it is used as the Theories of Silvio Gesell, as well as the school of monetarism in a modified form.  With Silvio Gezel, the negative rate was 1% per month, which would just kill the economy, under monetarism, the growth of the money supply had to be proportional to the growth of GDP, but since in this system fails to calculate the real GDP growth, I set a fixed growth, also if the monetary growth will equal GDP, there is a high probability of Hyperinflation, since GDP does not always reflect real economic growth. Money must be solid so that a business can predict its long-term investments and from monetarism, only the part that the money supply should grow linearly, but in general there is a mix of different economic schools, including the Austrian School of Economics.  With a negative rate of 0.1% every six months for digital dollars and 0.2% for digital stocks, we avoid the consequences of a severe economic crisis for this currency.  Such a mechanism creates a price corridor where the lower limit of the value of these digital currencies is the total number of issued digital currencies. dollars and digital stocks, and the upper limit is the real value. Since as soon as the value becomes higher than the real value, it becomes more profitable for holders to sell digital dollars and digital shares at inflated prices, thereby saturating the market with money and creating a correction in the market.  The main source of monetary crises is rapid changes in commodity prices and slow changes in wages. Example: Imagine that the value of the currency has risen sharply by 30%, it becomes more profitable for holders not to invest money, since income from holding currency, higher than now pay more expensive employees, because of the fact that the money stops invest. People do not receive wages, which leads to the fact that a huge number of goods are not sold, and this leads to the fact that some manufacturers go bankrupt and lay off many workers, which further reduces wages. wages from the rest, as the labor market becomes surplus.  Which, in turn, causes even more fear among money holders to invest, and this process continues until the moment when until the value of money starts to decline due to the fact that the total number of production chains has decreased and goods have also decreased. \" Example: Let's imagine that we had inflation and the value of money fell by 40% within a month, the cost of goods increases sharply, but wages have not risen, so a lot of goods will not be bought, which leads to the closure of production chains, which, in turn, due to an excess of workers in the labor market, reduces wages, which also further reduces the number of goods sold. The first case A deflationary spiral occurs due to a sharp reduction in money in the market, the second stagflation occurs more often when a sharply excess amount of money enters the market. And these two phenomena are two sides of the same coin, in one case we get a deflationary spiral in the other stagflation.  To avoid such crises, in this cryptocurrency, money grows in the same predictable amount. 204 (4 - founder reward, 200 - earner reward) digital dollars and shares per block, about 576 blocks per day. A negative rate adjusts the value of coins every six months. It is also forbidden to use fractional reserve banking for these coins, as their number grows linearly, and will not be able to cover the debts incurred due to fractional reserve banking, due to lack of cash, since with fractional reserve banking, the increase in debt will be much higher than this protocol will create money.  Also, if you increase the money supply by changing the settings, and making the money supply increase much higher, it can cause hyperinflation or even galloping inflation. If it is necessary to increase the growth of the money supply, this should only happen through amendments, keeping the founder's remuneration percentage at two percent. And mining per block should not increase more than 5% for ten years, each subsequent increase that may be made must pass at least ten years through amendments, and no more than 5% per block from the reward of the last block. (Example: if we change through amendments, then the extraction should not be higher than 210 coins, but each following will be no more than five percent of the last. Thus, the next increase introduced by without amendment will be 220.5 coins. But this amendment will be introduced only in ten years after the first production adjustment)  With a lack of money supply, if the number of mined coins has not been changed through an amendment, you can add a few additional zeros after the decimal point, so it will simply increase the value of the coins, without increasing the total money supply.  Negative rates should not be higher than 0.5% per annum and lower than 0.2% per annum. Negative rates can only be changed through amendments.  [Exit to home](../documentationEng/documentationEng.md)","# FREEDOM_OF_SPEECH The right to free speech No body of this corporation or entity shall prohibit free practice any religion; or restrict freedom of speech, conscience or the press or the right of people to peacefully assemble or associate with one another, or not associate with one another, and apply to the management of the Corporation of the International Trade Union and to this corporation with a petition for satisfaction of complaints; + or violate the right to the fruits of one's labor or the right to a peaceful life of their choice. Freedoms of speech and conscience include the freedom to contribute to political campaigns or nominations for corporate office and shall be construed as extending equally to any means of communication.  [Exit to home](../documentationEng/documentationEng.md)","# RIGHTS Natural Rights All members of the network must respect the Natural Human Rights and not violate them. \"The presumption of innocence must also be respected and every member of the network must have the right to a fair and independent trial. Each participant has the right to a lawyer or to be his own lawyer.  The International Trade Union Corporation shall not regulate the cost of goods and services of network members that sell through this platform. Also, the Corporation should not ban individual brands on its site, but may prohibit the sale of entire groups of goods that fall within the characteristics described by applicable laws, if this prohibition does not violate Natural Human Rights. As a source of rights, you can take as a precedent Countries recognized as democratic countries.  A detailed list is at the United Nations (UN)  The right to live Right to liberty and security of person Right to privacy The right to determine and indicate one's nationality The right to use one's native language The right to freedom of movement and choice of place of stay and residence Right to freedom of conscience  Freedom of thought and speech Freedom of Information The right to form public associations The right to hold public events The right to participate in the management of the affairs of the Corporation of the International Trade Union The right to appeal to the bodies of the Corporation of the International Trade Union and local governments.   [Exit to home](../documentationEng/documentationEng.md)","#LEGISLATURE. Power consists of 4 groups in this system. 1. Board of Shareholders 2. Board of Directors 3. Fractions 4. Independent members of the network.  All participants must participate in the vote for the law adopted by the system to be valid. For all votes, only votes cast in the last four years count. All members may hold multiple positions from different groups, but may not hold more than one position in the same category. Example: One account can be both ***Member of the Network*** and ***Member of the Board of Directors*** and ***Member of the Board of Shareholders***, but one account cannot hold multiple seats on the Board of Directors or in the Board of Shareholders.  It is this part of the vote that is taken into account when electing the Board of Directors and Fractions. ![stock_vote](../screenshots/stock_vote.png) ## Board of Shareholders The Board of Shareholders is automatically appointed by the system. The Board of Shareholders consists of 1500 accounts with the largest number of shares, but only those accounts are selected that have either been mining in the last year, either sent digital dollars or digital shares, or participated in voting. A member of one Board of Shareholders has one vote. One score equals one vote. The voting system described in [ONE_VOTE](../charterEng/ONE_VOTE.md) is used  ````    //determining the board of shareholders      public static List<Account> findBoardOfShareholders(Map<String, Account> balances, List<Block> blocks, int limit) {          List<Block> minersHaveMoreStock = null;          if (blocks.size() > limit) {              minersHaveMoreStock = blocks.subList(blocks.size() - limit, blocks.size());          } else {              minersHaveMoreStock = blocks;          }          List<Account> boardAccounts = minersHaveMoreStock.stream().map(                          t -> new Account(t.getMinerAddress(), 0, 0))                  .collect(Collectors.toList());           for (Block block : minersHaveMoreStock) {              for (DtoTransaction dtoTransaction : block.getDtoTransactions()) {                  boardAccounts.add(new Account(dtoTransaction.getSender(), 0, 0));              }           } ````  ## Board of Directors The Board of Directors is elected by the members of the network. The Board of Directors consists of 301 accounts that received the most votes according to the system described in [VOTE_STOCK](../charterEng/VOTE_STOCK.md). Each score is equal to one vote, described in [ONE_VOTE](../charterEng/ONE_VOTE.md).  ````   //minimum value for the number of positive votes for the law to be valid,          //positions elected by shares of the board of directors          List<CurrentLawVotesEndBalance> electedByStockBoardOfDirectors = current.stream()                  .filter(t -> directors.isElectedByStocks(t.getPackageName()))                  .filter(t -> t.getPackageName().equals(NamePOSITION.BOARD_OF_DIRECTORS.toString()))                  .filter(t -> t.getVotes() >= Seting.ORIGINAL_LIMIT_MIN_VOTE)                  .sorted(Comparator.comparing(CurrentLawVotesEndBalance::getVotes).reversed())                  .limit(directors.getDirector(NamePOSITION.BOARD_OF_DIRECTORS.toString()).getCount())                  .collect(Collectors.toList()); ````  ### How to apply for a board position First you need to go to the tab in ***apply for a position*** Select BOARD_OF_DIRECTORS and fill in all the lines with the required data. ![apply_board_of_directors](../screenshots/apply_board_or_directors.png)  ## Fractions. The factions are elected by the members of the network. There are only 100 revenge for factions. One hundred with the most votes received by the system described in [VOTE_STOCK](../charterEng/VOTE_STOCK.md) becomes a faction. The vote of each faction is equal to the share which she received relatively 99 other factions. Each faction has a vote described in [VOTE_FRACTION](../charterEng/VOTE_FRACTION.md).  ```` //select factions          List<CurrentLawVotesEndBalance> electedFraction = current.stream()                  .filter(t -> directors.isElectedByStocks(t.getPackageName()))                  .filter(t -> t.getPackageName().equals(NamePOSITION.FRACTION.toString()))                  .filter(t -> t.getVotes() >= Seting.ORIGINAL_LIMIT_MIN_VOTE)                  .sorted(Comparator.comparing(CurrentLawVotesEndBalance::getVotes).reversed())                  .limit(directors.getDirector(NamePOSITION.FRACTION.toString()).getCount())                  .collect(Collectors.toList()); ````  ### How to create a new faction To create a faction, you need to follow the same procedure as for submitting to the board of directors. ![apply_fraction](../screenshots/apply_fraction.png)   ## Independent Network Members. All network members who have shares and are not included in the first three categories listed above, are ***independent members of the network***. The votes of each such participant are equal to to the number of shares at the moment and is described in detail in [VOTE_STOCK](../charterEng/VOTE_STOCK.md).   [Exit to home](../documentationEng/documentationEng.md)","На русском-russian","# КАК ИЗБИРАЮТСЯ ЗАКОНЫ.   ## Утверждение закона _____  ## УСТАВ Ни один закон не имеет обратной силы. Ни один закон не должен нарушать действующий устав или противоречит  другим действующим законам. Если есть противотечение между несколькими законами из одного пакета законов,  то действующим является тот который в списке находится выше по индексу. Пример: пакет по продаже алкоголя  закон под индексом 3 противоречит закону из индекса 17, в данном случае закон под индексом три будет действующим,  так как он более высокая по статусу.  В случае противоречия нескольких действующих Законов Судебная Власть должна отдавать приоритет, тем законам, которые были приняты ранее, но учитывать должны именно с последней даты принятия закона. Закон является Действующим, пока удовлетворяет условиям принятия закона и как только условие  нарушено, закон теряет свою силу, до повторного принятия закона. В голосовании всех законов, учитываются только голоса отданные за последние четыре года. Все законы делятся на несколько групп. 1. Обычные законы 2. Стратегический План 3. Бюджет 4. Назначаемые должности Законодательной властью 6. Законы, которые создают новые должности. Данные должности утверждаются только Законодательной Властью. 7. Поправки в Устав 8. Сам устав  ### ОБЫЧНЫЕ ЗАКОНЫ Чтобы утвердить обычные законы,  1. название пакета закона не должно совпадать с выделенными ключевыми словами. 2. Закон должен получить больше 1 голоса по системе подсчета описанной [VOTE_STOCK](../charter/VOTE_STOCK.md) 3. Должен получить 10 или больше голосов Совета Директоров по системе подсчета описанной в [ONE_VOTE](../charter/ONE_VOTE.md) 4. Должен получить 10 или больше голосов Совета Акционеров по системе подсчета описанной в [ONE_VOTE](../charter/ONE_VOTE.md) 5. Должен получить 10% голосов от фракций по системе подсчета описанной в [VOTE_FRACTION](../charter/VOTE_FRACTION.md).  ![утверждение обычных законов](../screenshots/law-classic.png) Пример кода в LawsController current law: ````      //законы должны быть одобрены всеми.         List<CurrentLawVotesEndBalance> notEnoughVotes = current.stream()                 .filter(t -> !directors.contains(t.getPackageName()))                 .filter(t->!Seting.AMENDMENT_TO_THE_CHARTER.equals(t.getPackageName()))                 .filter(t->!directors.isCabinets(t.getPackageName()))                 .filter(t -> !Seting.ORIGINAL_CHARTER_CURRENT_LAW_PACKAGE_NAME.equals(t.getPackageName()))                 .filter(t->!Seting.ORIGINAL_CHARTER_CURRENT_ALL_CODE.equals(t.getPackageName()))                 .filter(t -> t.getVotesBoardOfShareholders() >= Seting.ORIGINAL_LIMIT_MIN_VOTE_BOARD_OF_SHAREHOLDERS                 && t.getVotesBoardOfDirectors() >= Seting.ORIGINAL_LIMIT_MIN_VOTE_BOARD_OF_DIRECTORS                 && t.getVotes() >= Seting.ALL_STOCK_VOTE                 && t.getFractionVote() >= Seting.ORIGINAL_LIMIT_MIN_VOTE_FRACTIONS)                 .sorted(Comparator.comparing(CurrentLawVotesEndBalance::getVotes).reversed()).collect(Collectors.toList());      ````  ### СТРАТЕГИЧЕСКИЙ ПЛАН. Стратегический план является общим планом для всей сети и утверждается аналогично обычному закону, но есть некоторые отличия от обычных законов. 1. Пакет стратегического плана должен называться STRATEGIC_PLAN 2. Все планы которые прошли одобрение, сортируется от наибольшего к наименьшему по количеству голосов, полученных от Совета Директоров. 3. После Сортировки отбираются только один ПЛАН с наибольшим количеством голосов полученных от Совета Директоров.  ```` //план утверждается всеми         List<CurrentLawVotesEndBalance> planFourYears = current.stream()                 .filter(t->!directors.contains(t.getPackageName()))                 .filter(t->Seting.STRATEGIC_PLAN.equals(t.getPackageName()))                 .filter(t->!directors.isCabinets(t.getPackageName()))                 .filter(t->t.getVotesBoardOfDirectors() >= Seting.ORIGINAL_LIMIT_MIN_VOTE_BOARD_OF_DIRECTORS                         && t.getVotesBoardOfShareholders() >= Seting.ORIGINAL_LIMIT_MIN_VOTE_BOARD_OF_SHAREHOLDERS                         && t.getFractionVote() >= Seting.ORIGINAL_LIMIT_MIN_VOTE_FRACTIONS                         && t.getVotes() >= Seting.ALL_STOCK_VOTE)                 .sorted(Comparator.comparing(CurrentLawVotesEndBalance::getVotesBoardOfDirectors).reversed())                 .limit(1)                 .collect(Collectors.toList()); ````  ### БЮДЖЕТ Бюджет является общими расходами для системы и утверждается аналогично Стратегическому Плану, но название пакета Должно быть BUDGET и он тоже в единственном экземпляре.  ````  //бюджет утверждается всеми         List<CurrentLawVotesEndBalance> budjet = current.stream()                 .filter(t-> !directors.contains(t.getPackageName()))                 .filter(t->Seting.BUDGET.equals(t.getPackageName()))                 .filter(t->!directors.isCabinets(t.getPackageName()))                 .filter(t->                         t.getVotesBoardOfDirectors() >= Seting.ORIGINAL_LIMIT_MIN_VOTE_BOARD_OF_DIRECTORS                         && t.getVotesBoardOfShareholders() >= Seting.ORIGINAL_LIMIT_MIN_VOTE_BOARD_OF_SHAREHOLDERS                         && t.getFractionVote() >= Seting.ORIGINAL_LIMIT_MIN_VOTE_FRACTIONS                         && t.getVotes() >= Seting.ALL_STOCK_VOTE)                 .sorted(Comparator.comparing(CurrentLawVotesEndBalance::getVotesBoardOfDirectors).reversed())                 .limit(1)                 .collect(Collectors.toList()); ````  ### ДОЛЖНОСТИ КОТОРЫЕ НАЗНАЧАЮТСЯ ТОЛЬКО ЗАКОНОДАТЕЛЬНОЙ ВЛАСТЬЮ Есть должности которые назначаются только Законодательной властью и таким должностям относиться Генеральный Исполнительный Директор. Данная должность аналогична премьер-министру и является Исполнительной Властью в данной системе. Каждая такая должность может быть ограничена количеством, которое определено в данной системе для данной должности. Пример: Генеральный Исполнительный Директор есть только одно место. Избирается аналогично как ***стратегический план*** и ***бюджет***. Но количество определяется для каждой должности отдельно. ````   //позиции избираемые только всеми участниками         List<CurrentLawVotesEndBalance> electedByBoardOfDirectors = current.stream()                 .filter(t -> directors.isElectedByBoardOfDirectors(t.getPackageName()) || directors.isCabinets(t.getPackageName()))                 .filter(t -> t.getVotesBoardOfDirectors() >= Seting.ORIGINAL_LIMIT_MIN_VOTE_BOARD_OF_DIRECTORS                 && t.getVotesBoardOfShareholders() >= Seting.ORIGINAL_LIMIT_MIN_VOTE_BOARD_OF_SHAREHOLDERS                 && t.getFractionVote() >= Seting.ORIGINAL_LIMIT_MIN_VOTE_FRACTIONS                 && t.getVotes() >= Seting.ALL_STOCK_VOTE)                 .sorted(Comparator.comparing(CurrentLawVotesEndBalance::getVotesBoardOfDirectors).reversed())                 .collect(Collectors.toList());                                    //групируем по списку         Map<String, List<CurrentLawVotesEndBalance>> group = electedByBoardOfDirectors.stream()                 .collect(Collectors.groupingBy(CurrentLawVotesEndBalance::getPackageName));          Map<Director, List<CurrentLawVotesEndBalance>> original_group = new HashMap<>();          //оставляем то количество которое описано в данной должности         for (Map.Entry<String, List<CurrentLawVotesEndBalance>> stringListEntry : group.entrySet()) {             List<CurrentLawVotesEndBalance> temporary = stringListEntry.getValue();             temporary = temporary.stream()                     .sorted(Comparator.comparing(CurrentLawVotesEndBalance::getVotesBoardOfDirectors))                     .limit(directors.getDirector(stringListEntry.getKey()).getCount())                     .collect(Collectors.toList());             original_group.put(directors.getDirector(stringListEntry.getKey()), temporary);         } ````  Также есть должности которые создаются с помощью законов, данные должности утверждаются тоже Законодательной властью. Для каждой такой должности только одно место, для каждого названия.  Название таких пакетов начинается с ADD_DIRECTOR_. С обязательным нижним подчеркиванием.  ### ПОПРАВКИ В УСТАВ Чтобы внести поправки в устав, нужно чтобы пакет закона должен называться AMENDMENT_TO_THE_CHARTER. Для того чтобы поправка считалась действующей 1. Нужно чтобы 20% или больше голосов получила от Совета Акционеров системой подсчета [ONE_VOTE](../charter/ONE_VOTE.md). 2. Нужно, чтобы получить 20% или больше голосов от Совета Директоров системой подсчета [ONE_VOTE](../charter/ONE_VOTE.md). 3. Нужно, чтобы получить 5 или больше голосов от Законодательной Власти Корпоративных Верховных Судей. 4. Нужно, чтобы получить 10% или больше голосов от фракций системой подсчета [VOTE_FRACTION](../charter/VOTE_FRACTION.md).  ![поправки в устав](../screenshots/amendment-chapter.png) ````    //внедрение поправок в устав         List<CurrentLawVotesEndBalance> chapter_amendment = current.stream()                 .filter(t -> !directors.contains(t.getPackageName()))                 .filter(t-> Seting.AMENDMENT_TO_THE_CHARTER.equals(t.getPackageName()))                 .filter(t->!directors.isCabinets(t.getPackageName()))                 .filter(t -> t.getVotesBoardOfShareholders() >= Seting.ORIGINAL_LIMIT_MINT_VOTE_BOARD_OF_SHAREHOLDERS_AMENDMENT                 && t.getVotesBoardOfDirectors() >= Seting.ORIGINAL_LIMIT_MIN_VOTE_BOARD_OF_DIRECTORS_AMENDMENT                 && t.getVotesCorporateCouncilOfReferees() >= Seting.ORIGINAL_LIMIT_MIN_VOTE_CORPORATE_COUNCIL_OF_REFEREES_AMENDMENT                 && t.getFractionVote() >= Seting.ORIGINAL_LIMIT_MIN_VOTE_FRACTIONS)                 .sorted(Comparator.comparing(CurrentLawVotesEndBalance::getVotesBoardOfDirectors).reversed()).collect(Collectors.toList());  ````  ### САМ УСТАВ. Первый устав утверждается основателем и он является действующим, голос основателя для утверждения устава никогда не имеет срока годности. Название пакета устава начинается с CHARTER_ORIGINAL и название исходного кода CHARTER_ORIGINAL_CODE. Эти два пакета и являются целостным уставом, но в первую очередь, исходный код не должен противоречить принципам описанным в CHARTER_ORIGINAL. ```` //устав всегда действующий он подписан основателем         List<CurrentLawVotesEndBalance> CHARTER_ORIGINAL = current.stream()                 .filter(t -> !directors.contains(t.getPackageName()) && Seting.ORIGINAL_CHARTER_CURRENT_LAW_PACKAGE_NAME.equals(t.getPackageName()))                 .filter(t->!directors.isCabinets(t.getPackageName()))                 .filter(t->t.getFounderVote()>=1)                 .sorted(Comparator.comparing(CurrentLawVotesEndBalance::getVotes).reversed())                 .limit(1)                 .collect(Collectors.toList());          //ИСХОДНЫЙ КОД СОЗДАННЫЙ ОСНОВАТЕЛЕМ         List<CurrentLawVotesEndBalance> CHARTER_ORIGINAL_CODE = current.stream()                 .filter(t -> !directors.contains(t.getPackageName()) && Seting.ORIGINAL_CHARTER_CURRENT_ALL_CODE.equals(t.getPackageName()))                 .filter(t->!directors.isCabinets(t.getPackageName()))                 .filter(t->t.getFounderVote()>=1)                 .sorted(Comparator.comparing(CurrentLawVotesEndBalance::getVotes).reversed())                 .limit(1)                 .collect(Collectors.toList()); ```` [Возврат на главную](../documentation/documentationRus.md)","# VOTE_STOCK (Как с помощью акций происходит голосование.)  Как с помощью акций происходит голосование.  Все акции которым счет владеет, приравниваются такому же количеству голосов.  Каждый раз когда кто-то делает транзакцию на счет, является адресом пакета который начинается с  LIBER он голосует по данному пакету. Учитываются только те голоса, с которых не прошло больше четырех лет.  Если транзакция была совершена ***VoteEnum.YES,*** то данный счет получает голоса ***за***, формуле  yesV = количество голосов равные количеству акций отправителя. yesN = за сколько законов данный счет проголосовал с VoteEnum.YES resultYES = yesV / yesN). Пример: счет проголосовал за три счета, которые начинаются с LIBER, на счету сто акций, значит сто голосов. 100 / 3 = 33.3 значит каждый счет получит по 33.3 голоса.   Если транзакция была совершена с VoteEnum.NO,  то используется такая же формула, но учитываются теперь все счета за которые он проголосовал против  пример тот же счет проголосовал за два счёта против, у него те же сто акций.  resultNO = noV / noN = 50 = 50 значит каждый счет за который он проголосовал,  против получит 50 голосов против.  Дальше каждый счет который начитается с LIBER подсчитывает и суммирует все отданные ему голоса ***ЗА*** (VoteEnum.YES) и ***ПРОТИВ*** (VoteEnum.NO).  Потом используется данная формула remainder = resultYES - resultNO.  Именно этот результат и отображается как отданные голоса. В любой момент можно изменить свой голос, но только на противоположный, что значит если  вы проголосовали за кандидата YES то вы можете изменить только на NO и обратно.  Количество раз сколько вы можете изменить свой голос не ограничено. С каждым блоком происходит перерасчет голосов, если вы теряете свои акции, ваши кандидаты  также теряют свои голоса. Данная мера специально так реализовано чтобы избираемые должности  были заинтересованы в том чтобы те кто голосует за них, процветал и не теряли свои акции.  Таким способом избираются Только CORPORATE_COUNCIL_OF_REFEREES и BOARD_OF_DIRECTORS Учитывается только последняя транзакция отданная за каждый счет, если вы не обновляли свой голос,  то по прошествии четырех лет он аннулируется. Для Утверждения Закона нужно 100 тысяч голосов  ______  ```` //код находится в классе class CurrentLawVotes method: votesLaw  public double votesLaw(Map<String, Account> balances,      Map<String, Integer> yesAverage, Map<String, Integer> noAverage) {         double yes = 0.0;         double no = 0.0;                               for (String s : YES) {              int count = 1;           count = yesAverage.get(s) > 0 ? yesAverage.get(s) : 1;           yes += balances.get(s).getDigitalStockBalance() / count;         }                  for (String s : NO) {            int count = 1;             count = noAverage.get(s) > 0 ? noAverage.get(s) : 1;            no += balances.get(s).getDigitalStockBalance() / count);          }           return yes - no;    }   ````  [возврат на главную](../documentation/documentationRus.md)","# ONE_VOTE (Один Голос)  Когда голосуют данные должности, учитывается как один счет = один голос   (CORPORATE_COUNCIL_OF_REFEREES-Совет Корпоративных Судей,  BOARD_OF_DIRECTORS-Совет Директоров, GENERAL_EXECUTIVE_DIRECTOR-Генеральный Исполнительный Директор, HIGH_JUDGE-Верховный Судья и Совет Акционеров).  Каждый счет который начинается с LIBER, учитывает все голоса ЗА (VoteEnum.YES) и ПРОТИВ (VoteEnum.NO) за него  дальше отнимается от ЗА - ПРОТИВ = если остатков выше порога, то он становиться действующим законом. Но если избирается должности,  то после сортируется от наибольшего к наименьшим и отбираются то количество наибольших, которое описано для данной должности.  Перерасчет голосов происходит каждый блок.   После голосования голос можно поменять только на противоположный.  Ограничений на количество сколько раз можно поменять свой голос нет. Учитываются только те голоса которые даны счетами  находящимися в своей должности, к примеру если счет перестал быть в Совете Директор, его голос как в качестве  Совета Директоров не учитывается, и не будет учитываться в голосовании. Все голоса действуют, пока счета  проголосовавшие находятся в своих должностях. Учитываются также только те голоса, от которых прошло не более  четырех лет, но каждый участник, может в любой момент времени обновить свой голос.   ______  КОД class CurrentLawVotes: method voteGovernment  ```` public int voteGovernment(             Map<String, Account> balances,             List<String> governments) {        int yes = 0;         int no = 0;         List<String> addressGovernment = governments;       for (String s : YES) {             if (addressGovernment.contains(s)) {                 yes += Seting.VOTE_GOVERNMENT;            }          }         for (String s : NO) {           if (addressGovernment.contains(s)) {                 no += Seting.VOTE_GOVERNMENT;            }         }        return yes - no;    }   ````  [возврат на главную](../documentation/documentationRus.md)","# VOTE_FRACTION  Данная система голосования используется только для фракций. Сначала отбираются 100 фракций, которые стали легитимными. Дальше суммируется все голоса отданные 100 отобранным фракциям. После чего определяется доля каждой фракции от общих количество  голосов отданных за данную фракцию. Количество голосов каждой фракции приравниваются ее доли в процентах. Таким образом если фракция имеет 23% голосов от всех голосов, из 100 фракций, то ее голос приравнивается к 23%.  Дальше каждый раз когда фракция голосует за законы, которые начинаются с LIBER (VoteEnum.YES) или (VoteEnum.NO). У данного закона подсчитываются все голоса отданные ***за*** и ***против***, после чего отнимается от ***за*** - ***против***. Именно этот результат отображается в процентах.  ````  //голос фракции     public double voteFractions(Map<String, Double> fractions){         double yes = 0;         double no = 0;         double sum = fractions.entrySet().stream()                 .map(t->t.getValue())                 .collect(Collectors.toList())                 .stream().reduce(0.0, Double::sum);          for (String s : YES) {             if (fractions.containsKey(s)) {                 yes += (fractions.get(s)/sum) * Seting.HUNDRED_PERCENT;             }          }         for (String s : NO) {             if (fractions.containsKey(s)) {                 no += (fractions.get(s)/sum) * Seting.HUNDRED_PERCENT;             }          }         return yes - no;      }  ````  [Возврат на главную](../documentation/documentationRus.md)","# Механизм штрафов  Вы совершаете транзакцию, при которой, вы теряете данную сумму акций, но  и счет на который направлен штраф теряет такую сумму акций.  Действует только на цифровые доллары. ![Вести штраф](../screenshots/lead_a_fine.png) ______  ## MECHANISM_FOR_REDUCING_THE_NUMBER_OF_SHARES  МЕХАНИЗМ СНИЖЕНИЯ КОЛИЧЕСТВА АКЦИЙ. Ввод штрафов.  Каждый раз когда один счет отправляет на другой счет цифровую акцию, но использует VoteEnum.NO, счет  цифровых акций получателя снижается на то количество которое отправил отправитель акций.  Пример счет А отправил на счет Б 100 цифровых акций с VoteEnum.NO, тогда счет А и счет Б оба теряют 100  цифровых акций. Данная мера нужна чтобы был механизм снять с должности Совета акционеров и также позволяет снижать голоса  деструктивных счетов, так как количество голосов, равно количеству акций, при Избрании Совета Директоров и  при избрании CORPORATE_COUNCIL_OF_REFEREES.  Данный механизм действует только на цифровые акции и только в том случае, что отправитель совершил транзакцию с VoteEnum.NO.  [выход на главную](../documentation/documentationRus.md)","# WHO_HAS_THE_RIGHT_TO_CREATE_LAWS Кто имеет права создавать законы  String WHO_HAS_THE_RIGHT_TO_CREATE_LAWS = Кто имеет Права создавать законы. Создавать законы в криптовалюте Корпорации Международный Торговый Союз имеют права  все участники сети, которые имеют минимум пять цифровых долларов.  Для создания закона через механизм криптовалюты Корпорации Международного торгового Союза  Нужно внутри данной криптовалюты Создать объект класса Laws, где packetLawName - является названием пакета законов.  List<String> laws - является списком законов, String hashLaw - является адресом данного пакета законов и начинается с LIBER.  Чтобы Закон попал в пул законов нужно создать транзакцию где получателем являться hashLaw данного закона и вознаграждение  майнера равно пять цифровых доллара (5)  данной криптовалюты. После этого как закон попадет в блок, он окажется в пуле  законов и за него можно будет голосовать.  Количество строк в пакете законов может быть столько, сколько понадобиться и нет никаких ограничений.  [Выход на главную](../documentation/documentationRus.md)","# POWERS_OF_THE_CORPORATE_COUNCIL_OF_JUDGES  Судебная Власть.  Утверждает Верховного судью. Участвует в голосовании внедрения поправок.   Судебная власть Корпорации Международного Торгового Союза принадлежит  одному Верховному суду и таким нижестоящим судам, которые Корпорация Международный  Торговый Союз может время от времени издавать и учреждать.  Судьи как верховных, так и нижестоящих судов занимают свои должности, при хорошем поведении и  в установленные сроки получают за свои услуги вознаграждение.  Вознаграждение должно даваться с бюджета, установленными законами. Судебная власть распространяется на все дела по закону и справедливости,  в том числе инициированные членами для оспаривания незаконного расходования средств,  возникающего в соответствии с настоящем Уставом, законами Корпорации Международного Торгового Союза и договорами,  заключенными или которые будут заключены в соответствии с их авторитетом.  К спорам,  в которых Международный Торговый Союз будут стороной к разногласиям между двумя или более участников сети.  Ни один суд не должен быть тайным, но правосудие должно вершиться открыто и бесплатно, полностью и безотлагательно,  и каждый человек должен иметь правовую защиту от вреда, причиненного жизни, свободе или имуществу.  Верховный Суд CORPORATE_COUNCIL_OF_REFEREES и верховный судья HIGH_JUDGE.  ## Как избирается Корпоративный Совет Судей. Корпоративный Совет судей состоит из 55 счетов и избирается Участниками сети, с системой подсчета описанной в VOTE_STOCK, аналогично Совету Директоров и Фракциям. Отбираются 55 счетов, которые получили наибольшее количество голосов. ![голоса акциями](../screenshots/stock_vote.png) ```` //минимальное значение количество положительных голосов для того чтобы закон действовал,         //позиции избираемые акциями CORPORATE_COUNCIL_OF_REFEREES         List<CurrentLawVotesEndBalance> electedByStockCorporateCouncilOfReferees = current.stream()                 .filter(t -> directors.isElectedByStocks(t.getPackageName()))                 .filter(t -> t.getPackageName().equals(NamePOSITION.CORPORATE_COUNCIL_OF_REFEREES.toString()))                 .filter(t -> t.getVotes() >= Seting.ORIGINAL_LIMIT_MIN_VOTE)                 .sorted(Comparator.comparing(CurrentLawVotesEndBalance::getVotes).reversed())                 .limit(directors.getDirector(NamePOSITION.CORPORATE_COUNCIL_OF_REFEREES.toString()).getCount())                 .collect(Collectors.toList()); ````  Каждый счет такого судьи приравнивается одному голосу аналогично [ONE_VOTE](../charter/ONE_VOTE.md)  [Выход на главную](../documentation/documentationRus.md)","#  String HOW_THE_CHIEF_JUDGE_IS_CHOSEN КАК ИЗБИРАЕТСЯ ВЕРХОВНЫЙ СУДЬЯ HIGH_JUDGE. Верховный Судья избирается CORPORATE_COUNCIL_OF_REFEREES.  Каждый участник сети может подать на должность Верховного Судьи, создав закон, с названием  пакета который совпадает с HIGH_JUDGE  должностью, где адрес отправителя данной транзакции должен совпадать с первой строкой из списка законов данного пакета.  Стоимость закона пять цифровых долларов в качестве вознаграждения добытчику.   Счет с наибольшим количеством голосов остатка получает данную должность.  Механизм голосования описан [ONE_VOTE](../charter/ONE_VOTE.md).  Избирает Верховного Судью, Корпоративный Совет Судей. (CORPORATE_COUNCIL_OF_REFEREES)  Пример кода как утверждается верховный судья. Class LawsController: method currentLaw. Участок кода   ````       //позиции избираемые советом корпоративных верховных судей       List<CurrentLawVotesEndBalance> electedByCorporateCouncilOfReferees = current.stream()                .filter(t -> directors.isElectedBYCorporateCouncilOfReferees(t.getPackageName()))                .filter(t -> t.getVotesCorporateCouncilOfReferees() >= Seting.ORIGINAL_LIMIT_MIN_VOTE_CORPORATE_COUNCIL_OF_REFEREES)                .sorted(Comparator.comparing(CurrentLawVotesEndBalance::getVotesCorporateCouncilOfReferees)).collect(Collectors.toList());  ````  ## Полномочия верховного судьи Верховный судья может участвовать в решении споров внутри членов сети, как и CORPORATE_COUNCIL_OF_REFEREES, но его голос выше чем голос CORPORATE_COUNCIL_OF_REFEREES.  [Выход на главную](../documentation/documentationRus.md)","# PROPERTY_OF_THE_CORPORATION СОБСТВЕННОСТЬ КОРПОРАЦИИ. Вся собственность которая принадлежит Корпорации Международного Торгового Союза, не может быть продана без действующего закона,  где будет описан процесс продажи и по какой стоимости будет продана собственность. Счет основателя, и счета других участников не является  счетом корпорации, Совет Директоров должен создать отдельный счет который будет бюджетом и управляться только членами действующих членов Совета Директоров.  [Выход на главную](../documentation/documentationRus.md)","# GENERAL_EXECUTIVE_DIRECTOR Генеральный Исполнительный Директор Данный Директор координирует действия остальных высших директоров для реализации стратегического плана или  поставленных перед ним задач действующими законами.  Все полномочия должны быть ему выданы через действующие законы.  Это самая высокая должность избираемая Корпорацией и является по своей сути аналогом премьер-министра.  ## Как избирается Генеральный Исполнительный Директор Данный директор избирается Законодательной властью 1. Совет Директоров должен дать больше 10 или больше голосов методом [ONE_VOTE](../charter/ONE_VOTE.md) 2. Совет Акционеров должен дать больше 10 или больше голосов методом [ONE_VOTE](../charter/ONE_VOTE.md) 3. Фракции должны дать 10% или больше голосов методом [VOTE_FRACTION](../charter/VOTE_FRACTION.md) 4. Участники сети должны дать больше одного голоса методом [VOTE_STOCK](../charter/VOTE_STOCK.md) 5. Дальше происходит сортировка от наибольшего к наименьшему полученых голосов от Совета Директоров и 6. Отбирается один счет с наибольшим количеством голосов от Совета Директоров  ````  //позиции избираемые только всеми участниками         List<CurrentLawVotesEndBalance> electedByBoardOfDirectors = current.stream()                 .filter(t -> directors.isElectedByBoardOfDirectors(t.getPackageName()) || directors.isCabinets(t.getPackageName()))                 .filter(t -> t.getVotesBoardOfDirectors() >= Seting.ORIGINAL_LIMIT_MIN_VOTE_BOARD_OF_DIRECTORS                 && t.getVotesBoardOfShareholders() >= Seting.ORIGINAL_LIMIT_MIN_VOTE_BOARD_OF_SHAREHOLDERS                 && t.getFractionVote() >= Seting.ORIGINAL_LIMIT_MIN_VOTE_FRACTIONS                 && t.getVotes() >= Seting.ALL_STOCK_VOTE)                 .sorted(Comparator.comparing(CurrentLawVotesEndBalance::getVotesBoardOfDirectors).reversed())                 .collect(Collectors.toList());                                   //групируем по списку         Map<String, List<CurrentLawVotesEndBalance>> group = electedByBoardOfDirectors.stream()                 .collect(Collectors.groupingBy(CurrentLawVotesEndBalance::getPackageName));          Map<Director, List<CurrentLawVotesEndBalance>> original_group = new HashMap<>();          //оставляем то количество которое описано в данной должности         for (Map.Entry<String, List<CurrentLawVotesEndBalance>> stringListEntry : group.entrySet()) {             List<CurrentLawVotesEndBalance> temporary = stringListEntry.getValue();             temporary = temporary.stream()                     .sorted(Comparator.comparing(CurrentLawVotesEndBalance::getVotesBoardOfDirectors))                     .limit(directors.getDirector(stringListEntry.getKey()).getCount())                     .collect(Collectors.toList());             original_group.put(directors.getDirector(stringListEntry.getKey()), temporary);         }  ````  ````  public static List<CurrentLawVotesEndBalance> filtersVotes(             List<LawEligibleForParliamentaryApproval> approvalList,             Map<String, Account> balances,             List<Account> BoardOfShareholders,             List<Block> blocks,             int limitBlocks     ) throws IOException, NoSuchAlgorithmException, SignatureException, InvalidKeySpecException, NoSuchProviderException, InvalidKeyException {         //действующие законы чьи голоса больше ORIGINAL_LIMIT_MIN_VOTE         List<CurrentLawVotesEndBalance> current = new ArrayList<>();         Map<String, CurrentLawVotes> votesMap = null;         List<Account> accounts = balances.entrySet().stream().map(t -> t.getValue()).collect(Collectors.toList());         if (blocks.size() > limitBlocks) {             votesMap = UtilsCurrentLaw.calculateVotes(accounts, blocks.subList(blocks.size() - limitBlocks, blocks.size()));         } else {             votesMap = UtilsCurrentLaw.calculateVotes(accounts, blocks);         }          //подсчитать средннее количество раз сколько он проголосовал за         Map<String, Integer> yesAverage = UtilsCurrentLaw.calculateAverageVotesYes(votesMap);         //подсчитать среднее количество раз сколько он проголосовал против         Map<String, Integer> noAverage = UtilsCurrentLaw.calculateAverageVotesNo(votesMap);           //подсчитываем голоса для для обычных законов и законов позиций         for (LawEligibleForParliamentaryApproval lawEligibleForParliamentaryApproval : approvalList) {             if (votesMap.containsKey(lawEligibleForParliamentaryApproval.getLaws().getHashLaw())) {                 String address = lawEligibleForParliamentaryApproval.getLaws().getHashLaw();                 String packageName = lawEligibleForParliamentaryApproval.getLaws().getPacketLawName();                 List<String> laws = lawEligibleForParliamentaryApproval.getLaws().getLaws();                 double vote = 0;                 int supremeVotes = 0;                 int boafdOfShareholderVotes = 0;                 int houseOfRepresentativiesVotes = 0;                 int primeMinisterVotes = 0;                 int hightJudgesVotes = 0;                 int founderVote = 0;                 double fraction = 0;                  //для законов подсчитываем специальные голоса                 vote = votesMap.get(lawEligibleForParliamentaryApproval.getLaws().getHashLaw()).votesLaw(balances, yesAverage, noAverage);                 List<String> boardOfShareholdersAddress = BoardOfShareholders.stream().map(t -> t.getAccount()).collect(Collectors.toList());                 boafdOfShareholderVotes = votesMap.get(lawEligibleForParliamentaryApproval.getLaws().getHashLaw()).voteGovernment(balances, boardOfShareholdersAddress);                  List<String> founder = List.of(Seting.ADDRESS_FOUNDER);                 founderVote = votesMap.get(lawEligibleForParliamentaryApproval.getLaws().getHashLaw()).voteGovernment(balances, founder);                 CurrentLawVotesEndBalance currentLawVotesEndBalance = new CurrentLawVotesEndBalance(                         address,                         packageName,                         vote,                         supremeVotes,                         houseOfRepresentativiesVotes,                         boafdOfShareholderVotes,                         primeMinisterVotes,                         hightJudgesVotes,                         founderVote,                         fraction,                         laws);                 current.add(currentLawVotesEndBalance);              }         }          List<String> houseOfRepresentativies = new ArrayList<>();         List<String> chamberOfSumpremeJudges = new ArrayList<>();         Map<String, Double> fractions = new HashMap<>();          for (CurrentLawVotesEndBalance currentLawVotesEndBalance: current) {             if(currentLawVotesEndBalance.getPackageName().equals(NamePOSITION.BOARD_OF_DIRECTORS.toString())){                 if(currentLawVotesEndBalance.getVotes() >= Seting.ORIGINAL_LIMIT_MIN_VOTE){                     houseOfRepresentativies.add(currentLawVotesEndBalance.getLaws().get(0));                 }              }             if(currentLawVotesEndBalance.getPackageName().equals(NamePOSITION.CORPORATE_COUNCIL_OF_REFEREES.toString())){                 if(currentLawVotesEndBalance.getVotes() >= Seting.ORIGINAL_LIMIT_MIN_VOTE){                     chamberOfSumpremeJudges.add(currentLawVotesEndBalance.getLaws().get(0));                 }              }               if(currentLawVotesEndBalance.getPackageName().equals(NamePOSITION.FRACTION.toString())){                 if(currentLawVotesEndBalance.getVotes() >= Seting.ORIGINAL_LIMIT_MIN_VOTE){                     fractions.put(currentLawVotesEndBalance.getLaws().get(0), currentLawVotesEndBalance.getVotes());                 }             }          }            for (CurrentLawVotesEndBalance currentLawVotesEndBalance : current) {             if(votesMap.containsKey(currentLawVotesEndBalance.getAddressLaw())){                   double vote = votesMap.get(currentLawVotesEndBalance.getAddressLaw()).votesLaw(balances, yesAverage, noAverage);                 int supremeVotes  = votesMap.get(currentLawVotesEndBalance.getAddressLaw()).voteGovernment(balances, chamberOfSumpremeJudges);                 int houseOfRepresentativiesVotes = votesMap.get(currentLawVotesEndBalance.getAddressLaw()).voteGovernment(balances, houseOfRepresentativies);                 double fractionsVotes = votesMap.get(currentLawVotesEndBalance.getAddressLaw()).voteFractions(fractions);                  currentLawVotesEndBalance.setVotes(vote);                 currentLawVotesEndBalance.setVotesBoardOfDirectors(houseOfRepresentativiesVotes);                 currentLawVotesEndBalance.setVotesCorporateCouncilOfReferees(supremeVotes);                 currentLawVotesEndBalance.setFractionVote(fractionsVotes);             }          }          //изирается Генеральный исполнительный директор         List<String> primeMinister = new ArrayList<>();         List<String> hightJudge = new ArrayList<>();         for (CurrentLawVotesEndBalance currentLawVotesEndBalance : current) {             if(currentLawVotesEndBalance.getPackageName().equals(NamePOSITION.GENERAL_EXECUTIVE_DIRECTOR.toString())){                 if(currentLawVotesEndBalance.getVotesBoardOfDirectors() >= Seting.ORIGINAL_LIMIT_MIN_VOTE_BOARD_OF_DIRECTORS                 && currentLawVotesEndBalance.getFractionVote() >= Seting.ORIGINAL_LIMIT_MIN_VOTE_FRACTIONS                 && currentLawVotesEndBalance.getVotesBoardOfShareholders() >= Seting.ORIGINAL_LIMIT_MIN_VOTE_BOARD_OF_SHAREHOLDERS                 && currentLawVotesEndBalance.getVotes() >= Seting.ALL_STOCK_VOTE){                     primeMinister.add(currentLawVotesEndBalance.getLaws().get(0));                 }             }              if(currentLawVotesEndBalance.getPackageName().equals(NamePOSITION.HIGH_JUDGE.toString())){                 if(currentLawVotesEndBalance.getVotesCorporateCouncilOfReferees() >= Seting.ORIGINAL_LIMIT_MIN_VOTE_CORPORATE_COUNCIL_OF_REFEREES){                     hightJudge.add(currentLawVotesEndBalance.getLaws().get(0));                 }             }         }         for (CurrentLawVotesEndBalance currentLawVotesEndBalance : current) {             if(votesMap.containsKey(currentLawVotesEndBalance.getAddressLaw())){                 int primeMinisterVotes = votesMap.get(currentLawVotesEndBalance.getAddressLaw()).voteGovernment(balances, primeMinister);                 int hightJudgeVotes = votesMap.get(currentLawVotesEndBalance.getAddressLaw()).voteGovernment(balances, hightJudge);                  currentLawVotesEndBalance.setVoteGeneralExecutiveDirector(primeMinisterVotes);                 currentLawVotesEndBalance.setVoteHightJudge(hightJudgeVotes);             }          }           return current;      }  ````  [Выход на главную](../documentation/documentationRus.md)","# ОБЯСНЕНИЕ ПОЧЕМУ ЗДЕСЬ ИСПОЛЬЗУЕТСЯ  ДЕМЕРЕДЖ ДЕНЕГ Отрицательная ставка сейчас применяется во множестве стран, данная мера стимулирует держателей денег, когда цена чрезмерно завышена,  насыщать рынок деньгами.  Количество добываемых денег за каждый блок составляет 200 цифровых долларов и 200 цифровых акций,  также 2% от каждой добычи вознаграждение основателю, что составляет 4 цифровых доллара и 4 цифровых Акций при каждой добыче блока.  Здесь используется как Теории Сильвио Гезеля, а также школы монетаризма в измененном виде.  У Сильвио Гезеля, отрицательная ставка составляла 1% в месяц, что просто убило бы экономику, при монетаризме рост, денежной массы должен был быть пропорционален росту ВВП, но так как в данной системе не получиться посчитать реальный рост ВВП, я установил фиксированный рост, также если денежный рост  будет равен ВВП, есть высокая вероятность Гиперинфляции, так как ВВП не всегда отражает реальный экономический рост.  Деньги должны быть твердые, чтобы бизнес мог прогнозировать свои долгосрочные вложения и от монетаризма, взята только та часть что  денежная масса должна расти линейно, но в целом здесь микс из разных экономических школ, включая Австрийскую экономическую школу.   При отрицательной ставке 0.1% каждые пол года для цифровых долларов и 0.2% для цифровых акций мы избегаем последствий тяжелого экономического кризиса для данной валюты.   Такой механизм создает коридор цен, где нижняя граница стоимости данных цифровых валют является общее количество выпущенных цифровых  долларов и цифровых акций, а верхняя граница является реальная стоимость. Так как только стоимость становиться выше реальной стоимости,  держателям выгодней становиться продавать цифровые доллары и цифровые акции, по завышенным ценам, тем самым насыщая рынок деньгами  и создавая коррекцию на рынке.   Основным источником монетарных кризисов, является быстрыми изменениями цен на товары и медленным изменением заработных плат.  Пример: Представим что стоимость валюты резко подорожало на 30%, держателям выгодней становиться не инвестировать деньги, так как  доходы от удерживания валюты, выше чем теперь уже оплачивать более дорогих сотрудников, из-за того деньги перестают  инвестироваться. Люди не дополучают заработные платы, что приводит к тому, что огромное количество товаров не реализуется,  и это приводит к тому, часть производителей банкротится и увольняют множество рабочих, что еще больше снижает заработную  плату у оставшихся, так как становиться профицитный рынок труда.   Что в свою очередь еще больше вызывает страх у держателей денег инвестировать и данный процесс продолжается до того момента,  пока стоимость денег не начинает сокращаться в связи с тем что общее количество производственных цепочек сократилось и также сократились товары.              \" Пример: Представим что у нас произошла инфляция и стоимость денег упала на 40% в течение месяца, стоимость товаров резко возрастает,  но заработные платы не выросли, таким образом множество товаров не будут куплены, что приводит к закрытию производственных цепочек,  что в свою очередь из-за избытка рабочих на рынке труда, снижает заработную плату, что также в свою очередь еще больше сокращает  количество проданных товаров. Первый случай Дефляционная спираль возникает из-за резкого сокращения денег на рынке, второй  случай стагфляция чаще возникает когда на рынок поступает резко избыточное количество денег.  И это оба явления две стороны одной медали, в одном случае мы получаем дефляционную спираль в другом стагфляцию.              Чтобы не возникали такие кризисы, в данной криптовалюте деньги прирастают в одинаковом предсказуемом количестве.  204 (4 - вознаграждение основателю, 200 - вознаграждение добытчику)  цифровых долларов и акций за блок, в сутках около 576 блоков. А отрицательная ставка корректирует стоимость монет каждые пол года.  Также запрещено использовать частичное банковское резервирование для данных монет, так как их количество растет линейно, и  не сможет покрыть долги возникшие из-за частичного банковского резервирования, в связи отсутствия с недостатком  наличности, так как при частичном банковском резервировании рост долгов будет намного выше, чем данный протокол будет создавать денег.   Также если увеличить денежную массу изменив настройки, и сделав прирост денежной массы значительно выше, может вызвать гиперинфляцию или  даже галопирующую инфляцию. Если нужно будет увеличить прирост денежной массы это должно происходить только через внесения поправок,  сохраняя процент вознаграждения основателя в двух процентах. И добыча за блок не должна увеличиваться больше 5% в течение  десяти лет, каждое следующее увеличение которое может вноситься должно проходить не менее десяти лет через поправки,  и не более 5% за блок от вознаграждения последнего блока. (Пример: если мы изменили  через поправки, то добыча не должна быть выше 210 монет, но каждые следующие будет не больше пяти процентов от последнего.  Таким образом следующее увеличение внесенное через поправки составит 220.5 монет. Но Эту поправку внесут только через десять лет после первой поправки по изменению добычи)   При недостатке денежной массы, если не было изменено количество добываемых монет через поправку, можно добавить несколько  дополнительных нулей после запятой, таким образом это просто увеличит ценность монет, без увелечения общей выпущенной денежной массы.  Отрицательные ставки не должны быть выше 0.5% годовых и ниже 0.2% годовых. Отрицательные ставки можно изменять только через внесения поправок.   [Выход на главную](../documentation/documentationRus.md)","# FREEDOM_OF_SPEECH Право свободы слова  Ни один орган данной корпорации или субъект не должен запрещать свободное исповедание  какой-либо религии; или ограничивать свободу слова, совести или печати или право людей мирно собираться или объединяться друг с другом, или не объединяться друг с другом, и  обращаться к руководству Корпорации Международного Торгового Союза и к данной корпорации с ходатайством об удовлетворении жалоб; \" + или нарушать право на плоды своего труда или  право на мирную жизнь по своему выбору.  Свободы слова и совести включают свободу вносить вклад в  политические кампании или кандидатуры на корпоративные должности и должны толковаться как  распространяющиеся в равной степени на любые средства коммуникации.  [Выход на главную](../documentation/documentationRus.md)","# RIGHTS Естественные Права Все члены сети, должны соблюдать Естественные Права Человека и не нарушать их.  \"Также должно соблюдаться презумпция невиновности и каждый участник сети должен иметь права на честное независимое  судебное разбирательство.  Каждый участник имеет права на адвоката или быть самому себе адвокатом.   Корпорация Международный Торговый Союз не должна регулировать стоимость товаров и услуг участников сети, которые  продают через данную платформу.  Также Корпорация не должна запрещать отдельные бренды на своей площадке, но может  запрещать продавать целые группы товаров, которые попадают по характеристикам описанных действующими законами, если  этот запрет не нарушает Естественные Права Человека. В качестве источника прав можно брать  в качестве прецедента Страны признанные демократическими странами.    Детальный список есть в Организации Объединенных Наций (ООН)  Право на жизнь Право на свободу и личную неприкосновенность Право на неприкосновенность частной жизни Право определять и указывать свою национальную принадлежность Право на пользование родным языком Право на свободу передвижения и выбора места пребывания и жительства Право на свободу совести  Свобода мысли и слова Свобода информации Право на создание общественных объединений Право на проведение публичных мероприятий Право на участие в управлении делами Корпорации Международного Торгового Союза Право на обращение в органы Корпорации Международного Торгового Союза и органы местного самоуправления.   [Выход на главную](../documentation/documentationRus.md)","#ЗАКОНОДАТЕЛЬНАЯ ВЛАСТЬ. Власть состоит из 4 групп в данной системе. 1. Совет Акционеров 2. Совет Директоров 3. Фракции  4. Независимые участники сети.  Все участники должны участвовать в голосовании чтобы был действителен закон принятый системой. Для всех голосов учитываются только голоса отданные за последние четыре года. Все участники могут занимать несколько должностей из разных групп, но не могут занимать в одной категории должностей несколько мест. Пример: Один счет может быть как ***Независимым участником сети*** и ***Членом Совета Директоров*** и ***Членом Совета Акционеров***, но один счет не сможет занять несколько мест в Совете Директоров или в Совете Акционеров.  Именно данная часть голоса учитывается при избрании Совета Директоров и Фракций. ![stock_vote](../screenshots/stock_vote.png) ## Совет Акционеров Совет Акционеров назначается системой автоматически. Совет Акционеров состоит из 1500 счетов с наибольшим количеством акций, но отбираются только те счета, которые за последний год либо занимались добычей, либо отправляли цифровые доллары или цифровые акции, или участвовали в голосовании. Член одного Совета акционеров имеет один голос. Один счет равен одному голосу.  Используется система голосования описанная в [ONE_VOTE](../charter/ONE_VOTE.md)  ````   //определение совета акционеров     public static List<Account> findBoardOfShareholders(Map<String, Account> balances, List<Block> blocks, int limit) {         List<Block> minersHaveMoreStock = null;         if (blocks.size() > limit) {             minersHaveMoreStock = blocks.subList(blocks.size() - limit, blocks.size());         } else {             minersHaveMoreStock = blocks;         }         List<Account> boardAccounts = minersHaveMoreStock.stream().map(                         t -> new Account(t.getMinerAddress(), 0, 0))                 .collect(Collectors.toList());          for (Block block : minersHaveMoreStock) {             for (DtoTransaction dtoTransaction : block.getDtoTransactions()) {                 boardAccounts.add(new Account(dtoTransaction.getSender(), 0, 0));             }          } ````  ## Совет Директоров  Совет директоров избирается участниками сети. Совет Директоров состоит из 301 счетов которые получили наибольшее количество голосов по системе описанной в [VOTE_STOCK](../charter/VOTE_STOCK.md). Каждый счет приравнивается одному голосу, описанному в [ONE_VOTE](../charter/ONE_VOTE.md).  ````  //минимальное значение количество положительных голосов для того чтобы закон действовал,         //позиции избираемые акциями совета директоров         List<CurrentLawVotesEndBalance> electedByStockBoardOfDirectors = current.stream()                 .filter(t -> directors.isElectedByStocks(t.getPackageName()))                 .filter(t -> t.getPackageName().equals(NamePOSITION.BOARD_OF_DIRECTORS.toString()))                 .filter(t -> t.getVotes() >= Seting.ORIGINAL_LIMIT_MIN_VOTE)                 .sorted(Comparator.comparing(CurrentLawVotesEndBalance::getVotes).reversed())                 .limit(directors.getDirector(NamePOSITION.BOARD_OF_DIRECTORS.toString()).getCount())                 .collect(Collectors.toList()); ````  ### Как подать на должность совета директоров Сначала нужно зайти во вкладку в ***apply for a position*** Выбрать BOARD_OF_DIRECTORS и заполнить все строки нужными данными. ![apply_board_of_directors](../screenshots/apply_board_or_directors.png)  ## Фракции. Фракции избираются участниками сети.  Есть только 100 месть для фракций. Сто с наибольшим количеством голосов полученных по системе описанной в [VOTE_STOCK](../charter/VOTE_STOCK.md) становиться фракцией. Голос каждой фракции приравнивается доли которую она получила относительно 99 других фракций. Каждая фракция имеет голос описанный в [VOTE_FRACTION](../charter/VOTE_FRACTION.md).  ```` //избранные фракции         List<CurrentLawVotesEndBalance> electedFraction = current.stream()                 .filter(t -> directors.isElectedByStocks(t.getPackageName()))                 .filter(t -> t.getPackageName().equals(NamePOSITION.FRACTION.toString()))                 .filter(t -> t.getVotes() >= Seting.ORIGINAL_LIMIT_MIN_VOTE)                 .sorted(Comparator.comparing(CurrentLawVotesEndBalance::getVotes).reversed())                 .limit(directors.getDirector(NamePOSITION.FRACTION.toString()).getCount())                 .collect(Collectors.toList()); ````  ### Как создать новую фракцию Для создания фракции нужно проделать ту же процедуру действий, что и для подачи на совет директоров. ![apply_fraction](../screenshots/apply_fraction.png)   ##  Независимые Участники сети. Все участники сети которые имеют акции и не входят в первые три выше перечисленные категории, являются ***независимыми участниками сети***. Голоса каждого такого участника приравнивается к количеству акций на данный момент и детально описано в [VOTE_STOCK](../charter/VOTE_STOCK.md).   [Выход на главную](../documentation/documentationRus.md)","","","","","","","","","","",""],"hashLaw":"LIBER520a7cedd27ecc7e8d23e590acc93637e26936f4702e02feca622f5d5f0b8006"}}
{"name":"LIBERdcef42ee1882e08e599887b744a88220de839f42246fd89c2caba7c924c9a6cb","account":{"account":"LIBERdcef42ee1882e08e599887b744a88220de839f42246fd89c2caba7c924c9a6cb","digitalDollarBalance":0.0,"digitalStockBalance":0.0},"laws":{"packetLawName":"FRACTION","laws":["stExZb8ifLfnFoq4JJuTifpAcscegATH8znhwW26zyTa","PROSPERITY FACTION the prosperity faction was created by the founder and puts the spread of this system in the world and the prosperity of the participants in this system in the first place. mercurygermes@gmail.com"],"hashLaw":"LIBERdcef42ee1882e08e599887b744a88220de839f42246fd89c2caba7c924c9a6cb"}}
